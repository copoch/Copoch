/******/ (function(modules) { // webpackBootstrap
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/ 	var parentHotUpdateCallback = this["webpackHotUpdate"];
/******/ 	this["webpackHotUpdate"] = 
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/ 	
/******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.type = "text/javascript";
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		head.appendChild(script);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadManifest(requestTimeout) { // eslint-disable-line no-unused-vars
/******/ 		requestTimeout = requestTimeout || 10000;
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if(typeof XMLHttpRequest === "undefined")
/******/ 				return reject(new Error("No browser support"));
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = requestTimeout;
/******/ 				request.send(null);
/******/ 			} catch(err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if(request.readyState !== 4) return;
/******/ 				if(request.status === 0) {
/******/ 					// timeout
/******/ 					reject(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 				} else if(request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if(request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch(e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/
/******/ 	
/******/ 	
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "5d41d685ceecc5a50b3d"; // eslint-disable-line no-unused-vars
/******/ 	var hotRequestTimeout = 10000;
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = []; // eslint-disable-line no-unused-vars
/******/ 	
/******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if(me.children.indexOf(request) < 0)
/******/ 					me.children.push(request);
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name) && name !== "e") {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if(hotStatus === "ready")
/******/ 				hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/ 	
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if(hotStatus === "prepare") {
/******/ 					if(!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/ 	
/******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/ 	
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else
/******/ 					hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/ 	
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/ 	
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/ 	
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/ 	
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/ 	
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = (+id) + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/ 	
/******/ 	function hotCheck(apply) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/ 	
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 0;
/******/ 			{ // eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/ 	
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		if(!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if(!deferred) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
/******/ 			// avoid triggering uncaught exception warning in Chrome.
/******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
/******/ 			Promise.resolve().then(function() {
/******/ 				return hotApply(hotApplyOnUpdate);
/******/ 			}).then(
/******/ 				function(result) {
/******/ 					deferred.resolve(result);
/******/ 				},
/******/ 				function(err) {
/******/ 					deferred.reject(err);
/******/ 				}
/******/ 			);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotApply(options) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/ 	
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/ 	
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/ 	
/******/ 			var queue = outdatedModules.slice().map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while(queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if(module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(!parent) continue;
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 	
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/ 	
/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 	
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn("[HMR] unexpected require(" + result.moduleId + ") to disposed module");
/******/ 		};
/******/ 	
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				var result;
/******/ 				if(hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if(result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch(result.type) {
/******/ 					case "self-declined":
/******/ 						if(options.onDeclined)
/******/ 							options.onDeclined(result);
/******/ 						if(!options.ignoreDeclined)
/******/ 							abortError = new Error("Aborted because of self decline: " + result.moduleId + chainInfo);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if(options.onDeclined)
/******/ 							options.onDeclined(result);
/******/ 						if(!options.ignoreDeclined)
/******/ 							abortError = new Error("Aborted because of declined dependency: " + result.moduleId + " in " + result.parentId + chainInfo);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if(options.onUnaccepted)
/******/ 							options.onUnaccepted(result);
/******/ 						if(!options.ignoreUnaccepted)
/******/ 							abortError = new Error("Aborted because " + moduleId + " is not accepted" + chainInfo);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if(options.onAccepted)
/******/ 							options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if(options.onDisposed)
/******/ 							options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if(abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if(doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for(moduleId in result.outdatedDependencies) {
/******/ 						if(Object.prototype.hasOwnProperty.call(result.outdatedDependencies, moduleId)) {
/******/ 							if(!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(outdatedDependencies[moduleId], result.outdatedDependencies[moduleId]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if(doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/ 	
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if(hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/ 	
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if(!module) continue;
/******/ 	
/******/ 			var data = {};
/******/ 	
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/ 	
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/ 	
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/ 	
/******/ 			// when disposing there is no need to call dispose handler
/******/ 			delete outdatedDependencies[moduleId];
/******/ 	
/******/ 			// remove "parents" references from all children
/******/ 			for(j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				if(module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for(j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if(idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/ 	
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/ 	
/******/ 		// insert new code
/******/ 		for(moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				if(module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					var callbacks = [];
/******/ 					for(i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 						dependency = moduleOutdatedDependencies[i];
/******/ 						cb = module.hot._acceptedDependencies[dependency];
/******/ 						if(cb) {
/******/ 							if(callbacks.indexOf(cb) >= 0) continue;
/******/ 							callbacks.push(cb);
/******/ 						}
/******/ 					}
/******/ 					for(i = 0; i < callbacks.length; i++) {
/******/ 						cb = callbacks[i];
/******/ 						try {
/******/ 							cb(moduleOutdatedDependencies);
/******/ 						} catch(err) {
/******/ 							if(options.onErrored) {
/******/ 								options.onErrored({
/******/ 									type: "accept-errored",
/******/ 									moduleId: moduleId,
/******/ 									dependencyId: moduleOutdatedDependencies[i],
/******/ 									error: err
/******/ 								});
/******/ 							}
/******/ 							if(!options.ignoreErrored) {
/******/ 								if(!error)
/******/ 									error = err;
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Load self accepted modules
/******/ 		for(i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err2) {
/******/ 						if(options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								orginalError: err
/******/ 							});
/******/ 						}
/******/ 						if(!options.ignoreErrored) {
/******/ 							if(!error)
/******/ 								error = err2;
/******/ 						}
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if(options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if(!options.ignoreErrored) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/ 	
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/static/";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(224)(__webpack_require__.s = 224);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(5);
var core = __webpack_require__(31);
var hide = __webpack_require__(19);
var redefine = __webpack_require__(20);
var ctx = __webpack_require__(28);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1; // forced
$export.G = 2; // global
$export.S = 4; // static
$export.P = 8; // proto
$export.B = 16; // bind
$export.W = 32; // wrap
$export.U = 64; // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var emptyFunction = __webpack_require__(26);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(8);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self
// eslint-disable-next-line no-new-func
: Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */


/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

function reactProdInvariant(code) {
  var argCount = arguments.length - 1;

  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

  for (var argIdx = 0; argIdx < argCount; argIdx++) {
    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
  }

  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

  var error = new Error(message);
  error.name = 'Invariant Violation';
  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

  throw error;
}

module.exports = reactProdInvariant;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var store = __webpack_require__(74)('wks');
var uid = __webpack_require__(46);
var Symbol = __webpack_require__(5).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(6)(function () {
  return Object.defineProperty({}, 'a', { get: function () {
      return 7;
    } }).a != 7;
});

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(4);
var IE8_DOM_DEFINE = __webpack_require__(148);
var toPrimitive = __webpack_require__(32);
var dP = Object.defineProperty;

exports.f = __webpack_require__(11) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) {/* empty */}
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 7.1.15 ToLength
var toInteger = __webpack_require__(34);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(7);

var DOMProperty = __webpack_require__(44);
var ReactDOMComponentFlags = __webpack_require__(189);

var invariant = __webpack_require__(2);

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var Flags = ReactDOMComponentFlags;

var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);

/**
 * Check if a given node should be cached.
 */
function shouldPrecacheNode(node, nodeID) {
  return node.nodeType === 1 && node.getAttribute(ATTR_NAME) === String(nodeID) || node.nodeType === 8 && node.nodeValue === ' react-text: ' + nodeID + ' ' || node.nodeType === 8 && node.nodeValue === ' react-empty: ' + nodeID + ' ';
}

/**
 * Drill down (through composites and empty components) until we get a host or
 * host text component.
 *
 * This is pretty polymorphic but unavoidable with the current structure we have
 * for `_renderedChildren`.
 */
function getRenderedHostOrTextFromComponent(component) {
  var rendered;
  while (rendered = component._renderedComponent) {
    component = rendered;
  }
  return component;
}

/**
 * Populate `_hostNode` on the rendered host/text component with the given
 * DOM node. The passed `inst` can be a composite.
 */
function precacheNode(inst, node) {
  var hostInst = getRenderedHostOrTextFromComponent(inst);
  hostInst._hostNode = node;
  node[internalInstanceKey] = hostInst;
}

function uncacheNode(inst) {
  var node = inst._hostNode;
  if (node) {
    delete node[internalInstanceKey];
    inst._hostNode = null;
  }
}

/**
 * Populate `_hostNode` on each child of `inst`, assuming that the children
 * match up with the DOM (element) children of `node`.
 *
 * We cache entire levels at once to avoid an n^2 problem where we access the
 * children of a node sequentially and have to walk from the start to our target
 * node every time.
 *
 * Since we update `_renderedChildren` and the actual DOM at (slightly)
 * different times, we could race here and see a newer `_renderedChildren` than
 * the DOM nodes we see. To avoid this, ReactMultiChild calls
 * `prepareToManageChildren` before we change `_renderedChildren`, at which
 * time the container's child nodes are always cached (until it unmounts).
 */
function precacheChildNodes(inst, node) {
  if (inst._flags & Flags.hasCachedChildNodes) {
    return;
  }
  var children = inst._renderedChildren;
  var childNode = node.firstChild;
  outer: for (var name in children) {
    if (!children.hasOwnProperty(name)) {
      continue;
    }
    var childInst = children[name];
    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
    if (childID === 0) {
      // We're currently unmounting this child in ReactMultiChild; skip it.
      continue;
    }
    // We assume the child nodes are in the same order as the child instances.
    for (; childNode !== null; childNode = childNode.nextSibling) {
      if (shouldPrecacheNode(childNode, childID)) {
        precacheNode(childInst, childNode);
        continue outer;
      }
    }
    // We reached the end of the DOM children without finding an ID match.
     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
  }
  inst._flags |= Flags.hasCachedChildNodes;
}

/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */
function getClosestInstanceFromNode(node) {
  if (node[internalInstanceKey]) {
    return node[internalInstanceKey];
  }

  // Walk up the tree until we find an ancestor whose instance we have cached.
  var parents = [];
  while (!node[internalInstanceKey]) {
    parents.push(node);
    if (node.parentNode) {
      node = node.parentNode;
    } else {
      // Top of the tree. This node must not be part of a React tree (or is
      // unmounted, potentially).
      return null;
    }
  }

  var closest;
  var inst;
  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
    closest = inst;
    if (parents.length) {
      precacheChildNodes(inst, node);
    }
  }

  return closest;
}

/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */
function getInstanceFromNode(node) {
  var inst = getClosestInstanceFromNode(node);
  if (inst != null && inst._hostNode === node) {
    return inst;
  } else {
    return null;
  }
}

/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */
function getNodeFromInstance(inst) {
  // Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.
  !(inst._hostNode !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;

  if (inst._hostNode) {
    return inst._hostNode;
  }

  // Walk up the tree until we find an ancestor whose DOM node we have cached.
  var parents = [];
  while (!inst._hostNode) {
    parents.push(inst);
    !inst._hostParent ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
    inst = inst._hostParent;
  }

  // Now parents contains each ancestor that does *not* have a cached native
  // node, and `inst` is the deepest ancestor that does.
  for (; parents.length; inst = parents.pop()) {
    precacheChildNodes(inst, inst._hostNode);
  }

  return inst._hostNode;
}

var ReactDOMComponentTree = {
  getClosestInstanceFromNode: getClosestInstanceFromNode,
  getInstanceFromNode: getInstanceFromNode,
  getNodeFromInstance: getNodeFromInstance,
  precacheChildNodes: precacheChildNodes,
  precacheNode: precacheNode,
  uncacheNode: uncacheNode
};

module.exports = ReactDOMComponentTree;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 7.1.13 ToObject(argument)
var defined = __webpack_require__(33);
module.exports = function (it) {
  return Object(defined(it));
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var dP = __webpack_require__(12);
var createDesc = __webpack_require__(45);
module.exports = __webpack_require__(11) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(5);
var hide = __webpack_require__(19);
var has = __webpack_require__(18);
var SRC = __webpack_require__(46)('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(31).inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
  // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var fails = __webpack_require__(6);
var defined = __webpack_require__(33);
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(63);

var ReactCurrentOwner = __webpack_require__(37);

var invariant = __webpack_require__(2);
var warning = __webpack_require__(3);

function isNative(fn) {
  // Based on isNative() from Lodash
  var funcToString = Function.prototype.toString;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var reIsNative = RegExp('^' + funcToString
  // Take an example native function source for comparison
  .call(hasOwnProperty
  // Strip regex characters so we can use it for regex
  ).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&'
  // Remove hasOwnProperty from the template to make it generic
  ).replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  try {
    var source = funcToString.call(fn);
    return reIsNative.test(source);
  } catch (err) {
    return false;
  }
}

var canUseCollections =
// Array.from
typeof Array.from === 'function' &&
// Map
typeof Map === 'function' && isNative(Map) &&
// Map.prototype.keys
Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
// Set
typeof Set === 'function' && isNative(Set) &&
// Set.prototype.keys
Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);

var setItem;
var getItem;
var removeItem;
var getItemIDs;
var addRoot;
var removeRoot;
var getRootIDs;

if (canUseCollections) {
  var itemMap = new Map();
  var rootIDSet = new Set();

  setItem = function (id, item) {
    itemMap.set(id, item);
  };
  getItem = function (id) {
    return itemMap.get(id);
  };
  removeItem = function (id) {
    itemMap['delete'](id);
  };
  getItemIDs = function () {
    return Array.from(itemMap.keys());
  };

  addRoot = function (id) {
    rootIDSet.add(id);
  };
  removeRoot = function (id) {
    rootIDSet['delete'](id);
  };
  getRootIDs = function () {
    return Array.from(rootIDSet.keys());
  };
} else {
  var itemByKey = {};
  var rootByKey = {};

  // Use non-numeric keys to prevent V8 performance issues:
  // https://github.com/facebook/react/pull/7232
  var getKeyFromID = function (id) {
    return '.' + id;
  };
  var getIDFromKey = function (key) {
    return parseInt(key.substr(1), 10);
  };

  setItem = function (id, item) {
    var key = getKeyFromID(id);
    itemByKey[key] = item;
  };
  getItem = function (id) {
    var key = getKeyFromID(id);
    return itemByKey[key];
  };
  removeItem = function (id) {
    var key = getKeyFromID(id);
    delete itemByKey[key];
  };
  getItemIDs = function () {
    return Object.keys(itemByKey).map(getIDFromKey);
  };

  addRoot = function (id) {
    var key = getKeyFromID(id);
    rootByKey[key] = true;
  };
  removeRoot = function (id) {
    var key = getKeyFromID(id);
    delete rootByKey[key];
  };
  getRootIDs = function () {
    return Object.keys(rootByKey).map(getIDFromKey);
  };
}

var unmountedIDs = [];

function purgeDeep(id) {
  var item = getItem(id);
  if (item) {
    var childIDs = item.childIDs;

    removeItem(id);
    childIDs.forEach(purgeDeep);
  }
}

function describeComponentFrame(name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
}

function getDisplayName(element) {
  if (element == null) {
    return '#empty';
  } else if (typeof element === 'string' || typeof element === 'number') {
    return '#text';
  } else if (typeof element.type === 'string') {
    return element.type;
  } else {
    return element.type.displayName || element.type.name || 'Unknown';
  }
}

function describeID(id) {
  var name = ReactComponentTreeHook.getDisplayName(id);
  var element = ReactComponentTreeHook.getElement(id);
  var ownerID = ReactComponentTreeHook.getOwnerID(id);
  var ownerName;
  if (ownerID) {
    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
  }
  process.env.NODE_ENV !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
  return describeComponentFrame(name, element && element._source, ownerName);
}

var ReactComponentTreeHook = {
  onSetChildren: function (id, nextChildIDs) {
    var item = getItem(id);
    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
    item.childIDs = nextChildIDs;

    for (var i = 0; i < nextChildIDs.length; i++) {
      var nextChildID = nextChildIDs[i];
      var nextChild = getItem(nextChildID);
      !nextChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
      !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
      !nextChild.isMounted ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
      if (nextChild.parentID == null) {
        nextChild.parentID = id;
        // TODO: This shouldn't be necessary but mounting a new root during in
        // componentWillMount currently causes not-yet-mounted components to
        // be purged from our tree data so their parent id is missing.
      }
      !(nextChild.parentID === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
    }
  },
  onBeforeMountComponent: function (id, element, parentID) {
    var item = {
      element: element,
      parentID: parentID,
      text: null,
      childIDs: [],
      isMounted: false,
      updateCount: 0
    };
    setItem(id, item);
  },
  onBeforeUpdateComponent: function (id, element) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.element = element;
  },
  onMountComponent: function (id) {
    var item = getItem(id);
    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
    item.isMounted = true;
    var isRoot = item.parentID === 0;
    if (isRoot) {
      addRoot(id);
    }
  },
  onUpdateComponent: function (id) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.updateCount++;
  },
  onUnmountComponent: function (id) {
    var item = getItem(id);
    if (item) {
      // We need to check if it exists.
      // `item` might not exist if it is inside an error boundary, and a sibling
      // error boundary child threw while mounting. Then this instance never
      // got a chance to mount, but it still gets an unmounting event during
      // the error boundary cleanup.
      item.isMounted = false;
      var isRoot = item.parentID === 0;
      if (isRoot) {
        removeRoot(id);
      }
    }
    unmountedIDs.push(id);
  },
  purgeUnmountedComponents: function () {
    if (ReactComponentTreeHook._preventPurging) {
      // Should only be used for testing.
      return;
    }

    for (var i = 0; i < unmountedIDs.length; i++) {
      var id = unmountedIDs[i];
      purgeDeep(id);
    }
    unmountedIDs.length = 0;
  },
  isMounted: function (id) {
    var item = getItem(id);
    return item ? item.isMounted : false;
  },
  getCurrentStackAddendum: function (topElement) {
    var info = '';
    if (topElement) {
      var name = getDisplayName(topElement);
      var owner = topElement._owner;
      info += describeComponentFrame(name, topElement._source, owner && owner.getName());
    }

    var currentOwner = ReactCurrentOwner.current;
    var id = currentOwner && currentOwner._debugID;

    info += ReactComponentTreeHook.getStackAddendumByID(id);
    return info;
  },
  getStackAddendumByID: function (id) {
    var info = '';
    while (id) {
      info += describeID(id);
      id = ReactComponentTreeHook.getParentID(id);
    }
    return info;
  },
  getChildIDs: function (id) {
    var item = getItem(id);
    return item ? item.childIDs : [];
  },
  getDisplayName: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (!element) {
      return null;
    }
    return getDisplayName(element);
  },
  getElement: function (id) {
    var item = getItem(id);
    return item ? item.element : null;
  },
  getOwnerID: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (!element || !element._owner) {
      return null;
    }
    return element._owner._debugID;
  },
  getParentID: function (id) {
    var item = getItem(id);
    return item ? item.parentID : null;
  },
  getSource: function (id) {
    var item = getItem(id);
    var element = item ? item.element : null;
    var source = element != null ? element._source : null;
    return source;
  },
  getText: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (typeof element === 'string') {
      return element;
    } else if (typeof element === 'number') {
      return '' + element;
    } else {
      return null;
    }
  },
  getUpdateCount: function (id) {
    var item = getItem(id);
    return item ? item.updateCount : 0;
  },

  getRootIDs: getRootIDs,
  getRegisteredIDs: getItemIDs,

  pushNonStandardWarningStack: function (isCreatingElement, currentSource) {
    if (typeof console.reactStack !== 'function') {
      return;
    }

    var stack = [];
    var currentOwner = ReactCurrentOwner.current;
    var id = currentOwner && currentOwner._debugID;

    try {
      if (isCreatingElement) {
        stack.push({
          name: id ? ReactComponentTreeHook.getDisplayName(id) : null,
          fileName: currentSource ? currentSource.fileName : null,
          lineNumber: currentSource ? currentSource.lineNumber : null
        });
      }

      while (id) {
        var element = ReactComponentTreeHook.getElement(id);
        var parentID = ReactComponentTreeHook.getParentID(id);
        var ownerID = ReactComponentTreeHook.getOwnerID(id);
        var ownerName = ownerID ? ReactComponentTreeHook.getDisplayName(ownerID) : null;
        var source = element && element._source;
        stack.push({
          name: ownerName,
          fileName: source ? source.fileName : null,
          lineNumber: source ? source.lineNumber : null
        });
        id = parentID;
      }
    } catch (err) {
      // Internal state is messed up.
      // Stop building the stack (it's just a nice to have).
    }

    console.reactStack(stack);
  },
  popNonStandardWarningStack: function () {
    if (typeof console.reactStackEnd !== 'function') {
      return;
    }
    console.reactStackEnd();
  }
};

module.exports = ReactComponentTreeHook;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(66);
var defined = __webpack_require__(33);
module.exports = function (it) {
  return IObject(defined(it));
};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var pIE = __webpack_require__(67);
var createDesc = __webpack_require__(45);
var toIObject = __webpack_require__(23);
var toPrimitive = __webpack_require__(32);
var has = __webpack_require__(18);
var IE8_DOM_DEFINE = __webpack_require__(148);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(11) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) {/* empty */}
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(18);
var toObject = __webpack_require__(15);
var IE_PROTO = __webpack_require__(100)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }return O instanceof Object ? ObjectProto : null;
};

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



// Trust the developer to only use ReactInstrumentation with a __DEV__ check

var debugTool = null;

if (process.env.NODE_ENV !== 'production') {
  var ReactDebugTool = __webpack_require__(462);
  debugTool = ReactDebugTool;
}

module.exports = { debugTool: debugTool };
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// optional / simple context binding
var aFunction = __webpack_require__(17);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };
    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };
    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }
  return function () /* ...args */{
    return fn.apply(that, arguments);
  };
};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fails = __webpack_require__(6);

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () {/* empty */}, 1) : method.call(null);
  });
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var core = module.exports = { version: '2.5.1' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(8);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(0);
var core = __webpack_require__(31);
var fails = __webpack_require__(6);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () {
    fn(1);
  }), 'Object', exp);
};

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(28);
var IObject = __webpack_require__(66);
var toObject = __webpack_require__(15);
var toLength = __webpack_require__(13);
var asc = __webpack_require__(117);
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (; length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res; // map
        else if (res) switch (TYPE) {
            case 3:
              return true; // some
            case 5:
              return val; // find
            case 6:
              return index; // findIndex
            case 2:
              result.push(val); // filter
          } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */

var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

module.exports = ReactCurrentOwner;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(7),
    _assign = __webpack_require__(10);

var CallbackQueue = __webpack_require__(193);
var PooledClass = __webpack_require__(57);
var ReactFeatureFlags = __webpack_require__(194);
var ReactReconciler = __webpack_require__(64);
var Transaction = __webpack_require__(92);

var invariant = __webpack_require__(2);

var dirtyComponents = [];
var updateBatchNumber = 0;
var asapCallbackQueue = CallbackQueue.getPooled();
var asapEnqueued = false;

var batchingStrategy = null;

function ensureInjected() {
  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
}

var NESTED_UPDATES = {
  initialize: function () {
    this.dirtyComponentsLength = dirtyComponents.length;
  },
  close: function () {
    if (this.dirtyComponentsLength !== dirtyComponents.length) {
      // Additional updates were enqueued by componentDidUpdate handlers or
      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
      // these new updates so that if A's componentDidUpdate calls setState on
      // B, B will update before the callback A's updater provided when calling
      // setState.
      dirtyComponents.splice(0, this.dirtyComponentsLength);
      flushBatchedUpdates();
    } else {
      dirtyComponents.length = 0;
    }
  }
};

var UPDATE_QUEUEING = {
  initialize: function () {
    this.callbackQueue.reset();
  },
  close: function () {
    this.callbackQueue.notifyAll();
  }
};

var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

function ReactUpdatesFlushTransaction() {
  this.reinitializeTransaction();
  this.dirtyComponentsLength = null;
  this.callbackQueue = CallbackQueue.getPooled();
  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
  /* useCreateElement */true);
}

_assign(ReactUpdatesFlushTransaction.prototype, Transaction, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  destructor: function () {
    this.dirtyComponentsLength = null;
    CallbackQueue.release(this.callbackQueue);
    this.callbackQueue = null;
    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
    this.reconcileTransaction = null;
  },

  perform: function (method, scope, a) {
    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
    // with this transaction's wrappers around it.
    return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
  }
});

PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

function batchedUpdates(callback, a, b, c, d, e) {
  ensureInjected();
  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
}

/**
 * Array comparator for ReactComponents by mount ordering.
 *
 * @param {ReactComponent} c1 first component you're comparing
 * @param {ReactComponent} c2 second component you're comparing
 * @return {number} Return value usable by Array.prototype.sort().
 */
function mountOrderComparator(c1, c2) {
  return c1._mountOrder - c2._mountOrder;
}

function runBatchedUpdates(transaction) {
  var len = transaction.dirtyComponentsLength;
  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;

  // Since reconciling a component higher in the owner hierarchy usually (not
  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
  // them before their children by sorting the array.
  dirtyComponents.sort(mountOrderComparator);

  // Any updates enqueued while reconciling must be performed after this entire
  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
  // C, B could update twice in a single batch if C's render enqueues an update
  // to B (since B would have already updated, we should skip it, and the only
  // way we can know to do so is by checking the batch counter).
  updateBatchNumber++;

  for (var i = 0; i < len; i++) {
    // If a component is unmounted before pending changes apply, it will still
    // be here, but we assume that it has cleared its _pendingCallbacks and
    // that performUpdateIfNecessary is a noop.
    var component = dirtyComponents[i];

    // If performUpdateIfNecessary happens to enqueue any new updates, we
    // shouldn't execute the callbacks until the next render happens, so
    // stash the callbacks first
    var callbacks = component._pendingCallbacks;
    component._pendingCallbacks = null;

    var markerName;
    if (ReactFeatureFlags.logTopLevelRenders) {
      var namedComponent = component;
      // Duck type TopLevelWrapper. This is probably always true.
      if (component._currentElement.type.isReactTopLevelWrapper) {
        namedComponent = component._renderedComponent;
      }
      markerName = 'React update: ' + namedComponent.getName();
      console.time(markerName);
    }

    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);

    if (markerName) {
      console.timeEnd(markerName);
    }

    if (callbacks) {
      for (var j = 0; j < callbacks.length; j++) {
        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
      }
    }
  }
}

var flushBatchedUpdates = function () {
  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
  // array and perform any updates enqueued by mount-ready handlers (i.e.,
  // componentDidUpdate) but we need to check here too in order to catch
  // updates enqueued by setState callbacks and asap calls.
  while (dirtyComponents.length || asapEnqueued) {
    if (dirtyComponents.length) {
      var transaction = ReactUpdatesFlushTransaction.getPooled();
      transaction.perform(runBatchedUpdates, null, transaction);
      ReactUpdatesFlushTransaction.release(transaction);
    }

    if (asapEnqueued) {
      asapEnqueued = false;
      var queue = asapCallbackQueue;
      asapCallbackQueue = CallbackQueue.getPooled();
      queue.notifyAll();
      CallbackQueue.release(queue);
    }
  }
};

/**
 * Mark a component as needing a rerender, adding an optional callback to a
 * list of functions which will be executed once the rerender occurs.
 */
function enqueueUpdate(component) {
  ensureInjected();

  // Various parts of our code (such as ReactCompositeComponent's
  // _renderValidatedComponent) assume that calls to render aren't nested;
  // verify that that's the case. (This is called by each top-level update
  // function, like setState, forceUpdate, etc.; creation and
  // destruction of top-level components is guarded in ReactMount.)

  if (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component);
    return;
  }

  dirtyComponents.push(component);
  if (component._updateBatchNumber == null) {
    component._updateBatchNumber = updateBatchNumber + 1;
  }
}

/**
 * Enqueue a callback to be run at the end of the current batching cycle. Throws
 * if no updates are currently being performed.
 */
function asap(callback, context) {
  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
  asapCallbackQueue.enqueue(callback, context);
  asapEnqueued = true;
}

var ReactUpdatesInjection = {
  injectReconcileTransaction: function (ReconcileTransaction) {
    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
  },

  injectBatchingStrategy: function (_batchingStrategy) {
    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
    batchingStrategy = _batchingStrategy;
  }
};

var ReactUpdates = {
  /**
   * React references `ReactReconcileTransaction` using this property in order
   * to allow dependency injection.
   *
   * @internal
   */
  ReactReconcileTransaction: null,

  batchedUpdates: batchedUpdates,
  enqueueUpdate: enqueueUpdate,
  flushBatchedUpdates: flushBatchedUpdates,
  injection: ReactUpdatesInjection,
  asap: asap
};

module.exports = ReactUpdates;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (__webpack_require__(11)) {
  var LIBRARY = __webpack_require__(47);
  var global = __webpack_require__(5);
  var fails = __webpack_require__(6);
  var $export = __webpack_require__(0);
  var $typed = __webpack_require__(84);
  var $buffer = __webpack_require__(123);
  var ctx = __webpack_require__(28);
  var anInstance = __webpack_require__(53);
  var propertyDesc = __webpack_require__(45);
  var hide = __webpack_require__(19);
  var redefineAll = __webpack_require__(55);
  var toInteger = __webpack_require__(34);
  var toLength = __webpack_require__(13);
  var toIndex = __webpack_require__(174);
  var toAbsoluteIndex = __webpack_require__(49);
  var toPrimitive = __webpack_require__(32);
  var has = __webpack_require__(18);
  var classof = __webpack_require__(68);
  var isObject = __webpack_require__(8);
  var toObject = __webpack_require__(15);
  var isArrayIter = __webpack_require__(114);
  var create = __webpack_require__(50);
  var getPrototypeOf = __webpack_require__(25);
  var gOPN = __webpack_require__(51).f;
  var getIterFn = __webpack_require__(116);
  var uid = __webpack_require__(46);
  var wks = __webpack_require__(9);
  var createArrayMethod = __webpack_require__(36);
  var createArrayIncludes = __webpack_require__(75);
  var speciesConstructor = __webpack_require__(82);
  var ArrayIterators = __webpack_require__(119);
  var Iterators = __webpack_require__(60);
  var $iterDetect = __webpack_require__(79);
  var setSpecies = __webpack_require__(52);
  var arrayFill = __webpack_require__(118);
  var arrayCopyWithin = __webpack_require__(164);
  var $DP = __webpack_require__(12);
  var $GOPD = __webpack_require__(24);
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    }return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () {
        return this._d[internal];
      } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      }O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of() /* ...items */{
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () {
    arrayToLocaleString.call(new Uint8Array(1));
  });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) {
      // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) {
      // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) {
      // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) {
      // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) {
      // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      }return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin));
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target) && target[TYPED_ARRAY] && typeof key != 'symbol' && key in target && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set')
    // TODO: add validation descriptor w/o calling accessors
    && !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable)) {
      target[key] = desc.value;
      return target;
    }return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () {
    arrayToString.call({});
  })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () {/* noop */},
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () {
      return this[TYPED_ARRAY];
    }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () {
          return NAME;
        }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () {
      Base.of.call(TypedArray, 1);
    }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () {/* empty */};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Map = __webpack_require__(169);
var $export = __webpack_require__(0);
var shared = __webpack_require__(74)('metadata');
var store = shared.store || (shared.store = new (__webpack_require__(172))());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);
  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  }return keyMetadata;
};
var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) {
    keys.push(key);
  });
  return keys;
};
var toMetaKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function (O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(10);

var PooledClass = __webpack_require__(57);

var emptyFunction = __webpack_require__(26);
var warning = __webpack_require__(3);

var didWarnForAddedNewProperty = false;
var isProxySupported = typeof Proxy === 'function';

var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: null,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */
function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
  if (process.env.NODE_ENV !== 'production') {
    // these have a getter/setter for warnings
    delete this.nativeEvent;
    delete this.preventDefault;
    delete this.stopPropagation;
  }

  this.dispatchConfig = dispatchConfig;
  this._targetInst = targetInst;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    if (process.env.NODE_ENV !== 'production') {
      delete this[propName]; // this has a getter/setter for warnings
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      if (propName === 'target') {
        this.target = nativeEventTarget;
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
  return this;
}

_assign(SyntheticEvent.prototype, {
  preventDefault: function () {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.preventDefault) {
      event.preventDefault();
      // eslint-disable-next-line valid-typeof
    } else if (typeof event.returnValue !== 'unknown') {
      event.returnValue = false;
    }
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  },

  stopPropagation: function () {
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.stopPropagation) {
      event.stopPropagation();
      // eslint-disable-next-line valid-typeof
    } else if (typeof event.cancelBubble !== 'unknown') {
      // The ChangeEventPlugin registers a "propertychange" event for
      // IE. This event does not support bubbling or cancelling, and
      // any references to cancelBubble throw "Member not found".  A
      // typeof check of "unknown" circumvents this issue (and is also
      // IE specific).
      event.cancelBubble = true;
    }

    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function () {
    this.isPersistent = emptyFunction.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function () {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      if (process.env.NODE_ENV !== 'production') {
        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
      } else {
        this[propName] = null;
      }
    }
    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
      this[shouldBeReleasedProperties[i]] = null;
    }
    if (process.env.NODE_ENV !== 'production') {
      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
    }
  }
});

SyntheticEvent.Interface = EventInterface;

if (process.env.NODE_ENV !== 'production') {
  if (isProxySupported) {
    /*eslint-disable no-func-assign */
    SyntheticEvent = new Proxy(SyntheticEvent, {
      construct: function (target, args) {
        return this.apply(target, Object.create(target.prototype), args);
      },
      apply: function (constructor, that, args) {
        return new Proxy(constructor.apply(that, args), {
          set: function (target, prop, value) {
            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
              process.env.NODE_ENV !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), "This synthetic event is reused for performance reasons. If you're " + "seeing this, you're adding a new property in the synthetic event object. " + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
              didWarnForAddedNewProperty = true;
            }
            target[prop] = value;
            return true;
          }
        });
      }
    });
    /*eslint-enable no-func-assign */
  }
}
/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
};

PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);

module.exports = SyntheticEvent;

/**
  * Helper to nullify syntheticEvent instance properties when destructing
  *
  * @param {object} SyntheticEvent
  * @param {String} propName
  * @return {object} defineProperty object
  */
function getPooledWarningPropertyDefinition(propName, getVal) {
  var isFunction = typeof getVal === 'function';
  return {
    configurable: true,
    set: set,
    get: get
  };

  function set(val) {
    var action = isFunction ? 'setting the method' : 'setting the property';
    warn(action, 'This is effectively a no-op');
    return val;
  }

  function get() {
    var action = isFunction ? 'accessing the method' : 'accessing the property';
    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
    warn(action, result);
    return getVal;
  }

  function warn(action, result) {
    var warningCondition = false;
    process.env.NODE_ENV !== 'production' ? warning(warningCondition, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
  }
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var META = __webpack_require__(46)('meta');
var isObject = __webpack_require__(8);
var has = __webpack_require__(18);
var setDesc = __webpack_require__(12).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(6)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
      i: 'O' + ++id, // object ID
      w: {} // weak collections IDs
    } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
    // return object ID
  }return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
    // return hash weak collections IDs
  }return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(9)('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(19)(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(7);

var invariant = __webpack_require__(2);

function checkMask(value, bitmask) {
  return (value & bitmask) === bitmask;
}

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_PROPERTY: 0x1,
  HAS_BOOLEAN_VALUE: 0x4,
  HAS_NUMERIC_VALUE: 0x8,
  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * isCustomAttribute: function that given an attribute name will return true
   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
   * attributes where it's impossible to enumerate all of the possible
   * attribute names,
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function (domPropertyConfig) {
    var Injection = DOMPropertyInjection;
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    if (domPropertyConfig.isCustomAttribute) {
      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
    }

    for (var propName in Properties) {
      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;

      var lowerCased = propName.toLowerCase();
      var propConfig = Properties[propName];

      var propertyInfo = {
        attributeName: lowerCased,
        attributeNamespace: null,
        propertyName: propName,
        mutationMethod: null,

        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
      };
      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;

      if (process.env.NODE_ENV !== 'production') {
        DOMProperty.getPossibleStandardName[lowerCased] = propName;
      }

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];
        propertyInfo.attributeName = attributeName;
        if (process.env.NODE_ENV !== 'production') {
          DOMProperty.getPossibleStandardName[attributeName] = propName;
        }
      }

      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
      }

      if (DOMPropertyNames.hasOwnProperty(propName)) {
        propertyInfo.propertyName = DOMPropertyNames[propName];
      }

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        propertyInfo.mutationMethod = DOMMutationMethods[propName];
      }

      DOMProperty.properties[propName] = propertyInfo;
    }
  }
};

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
/* eslint-enable max-len */

/**
 * DOMProperty exports lookup objects that can be used like functions:
 *
 *   > DOMProperty.isValid['id']
 *   true
 *   > DOMProperty.isValid['foobar']
 *   undefined
 *
 * Although this may be confusing, it performs better in general.
 *
 * @see http://jsperf.com/key-exists
 * @see http://jsperf.com/key-missing
 */
var DOMProperty = {
  ID_ATTRIBUTE_NAME: 'data-reactid',
  ROOT_ATTRIBUTE_NAME: 'data-reactroot',

  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',

  /**
   * Map from property "standard name" to an object with info about how to set
   * the property in the DOM. Each object contains:
   *
   * attributeName:
   *   Used when rendering markup or with `*Attribute()`.
   * attributeNamespace
   * propertyName:
   *   Used on DOM node instances. (This includes properties that mutate due to
   *   external factors.)
   * mutationMethod:
   *   If non-null, used instead of the property or `setAttribute()` after
   *   initial render.
   * mustUseProperty:
   *   Whether the property must be accessed and mutated as an object property.
   * hasBooleanValue:
   *   Whether the property should be removed when set to a falsey value.
   * hasNumericValue:
   *   Whether the property must be numeric or parse as a numeric and should be
   *   removed when set to a falsey value.
   * hasPositiveNumericValue:
   *   Whether the property must be positive numeric or parse as a positive
   *   numeric and should be removed when set to a falsey value.
   * hasOverloadedBooleanValue:
   *   Whether the property can be used as a flag as well as with a value.
   *   Removed when strictly equal to false; present without a value when
   *   strictly equal to true; present with a value otherwise.
   */
  properties: {},

  /**
   * Mapping from lowercase property names to the properly cased version, used
   * to warn in the case of missing properties. Available only in __DEV__.
   *
   * autofocus is predefined, because adding it to the property whitelist
   * causes unintended side effects.
   *
   * @type {Object}
   */
  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? { autofocus: 'autoFocus' } : null,

  /**
   * All of the isCustomAttribute() functions that have been injected.
   */
  _isCustomAttributeFunctions: [],

  /**
   * Checks whether a property name is a custom attribute.
   * @method
   */
  isCustomAttribute: function (attributeName) {
    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
      if (isCustomAttributeFn(attributeName)) {
        return true;
      }
    }
    return false;
  },

  injection: DOMPropertyInjection
};

module.exports = DOMProperty;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = false;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(150);
var enumBugKeys = __webpack_require__(101);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__(34);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(4);
var dPs = __webpack_require__(151);
var enumBugKeys = __webpack_require__(101);
var IE_PROTO = __webpack_require__(100)('IE_PROTO');
var Empty = function () {/* empty */};
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(98)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(102).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(150);
var hiddenKeys = __webpack_require__(101).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(5);
var dP = __webpack_require__(12);
var DESCRIPTORS = __webpack_require__(11);
var SPECIES = __webpack_require__(9)('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () {
      return this;
    }
  });
};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
    throw TypeError(name + ': incorrect invocation!');
  }return it;
};

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ctx = __webpack_require__(28);
var call = __webpack_require__(162);
var isArrayIter = __webpack_require__(114);
var anObject = __webpack_require__(4);
var toLength = __webpack_require__(13);
var getIterFn = __webpack_require__(116);
var BREAK = {};
var RETURN = {};
var _exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () {
    return iterable;
  } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
_exports.BREAK = BREAK;
_exports.RETURN = RETURN;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var redefine = __webpack_require__(20);
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(10);

var ReactCurrentOwner = __webpack_require__(37);

var warning = __webpack_require__(3);
var canDefineProperty = __webpack_require__(89);
var hasOwnProperty = Object.prototype.hasOwnProperty;

var REACT_ELEMENT_TYPE = __webpack_require__(184);

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

var specialPropKeyWarningShown, specialPropRefWarningShown;

function hasValidRef(config) {
  if (process.env.NODE_ENV !== 'production') {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.ref !== undefined;
}

function hasValidKey(config) {
  if (process.env.NODE_ENV !== 'production') {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  if (process.env.NODE_ENV !== 'production') {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    if (canDefineProperty) {
      Object.defineProperty(element._store, 'validated', {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      });
      // self and source are DEV only properties.
      Object.defineProperty(element, '_self', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: self
      });
      // Two elements created in two different places should be considered
      // equal for testing purposes and therefore we hide it from enumeration.
      Object.defineProperty(element, '_source', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: source
      });
    } else {
      element._store.validated = false;
      element._self = self;
      element._source = source;
    }
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
 */
ReactElement.createElement = function (type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    if (process.env.NODE_ENV !== 'production') {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  if (process.env.NODE_ENV !== 'production') {
    if (key || ref) {
      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
        if (key) {
          defineKeyPropWarningGetter(props, displayName);
        }
        if (ref) {
          defineRefPropWarningGetter(props, displayName);
        }
      }
    }
  }
  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
};

/**
 * Return a function that produces ReactElements of a given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
 */
ReactElement.createFactory = function (type) {
  var factory = ReactElement.createElement.bind(null, type);
  // Expose the type on the factory and the prototype so that it can be
  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
  // This should not be named `constructor` since this may not be the function
  // that created the element, and it may not even be a constructor.
  // Legacy hook TODO: Warn if this is accessed
  factory.type = type;
  return factory;
};

ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
};

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
 */
ReactElement.cloneElement = function (element, config, children) {
  var propName;

  // Original props are copied
  var props = _assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    // Remaining properties override existing props
    var defaultProps;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
};

/**
 * Verifies the object is a ReactElement.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
ReactElement.isValidElement = function (object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
};

module.exports = ReactElement;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(7);

var invariant = __webpack_require__(2);

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function (a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function (a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fourArgumentPooler = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances.
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function (CopyConstructor, pooler) {
  // Casting as any so that flow ignores the actual implementation and trusts
  // it to match the type we declared
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fourArgumentPooler: fourArgumentPooler
};

module.exports = PooledClass;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var def = __webpack_require__(12).f;
var has = __webpack_require__(18);
var TAG = __webpack_require__(9)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var defined = __webpack_require__(33);
var fails = __webpack_require__(6);
var spaces = __webpack_require__(104);
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {};

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(8);
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(10);

var ReactBaseClasses = __webpack_require__(182);
var ReactChildren = __webpack_require__(437);
var ReactDOMFactories = __webpack_require__(441);
var ReactElement = __webpack_require__(56);
var ReactPropTypes = __webpack_require__(445);
var ReactVersion = __webpack_require__(447);

var createReactClass = __webpack_require__(448);
var onlyChild = __webpack_require__(450);

var createElement = ReactElement.createElement;
var createFactory = ReactElement.createFactory;
var cloneElement = ReactElement.cloneElement;

if (process.env.NODE_ENV !== 'production') {
  var lowPriorityWarning = __webpack_require__(124);
  var canDefineProperty = __webpack_require__(89);
  var ReactElementValidator = __webpack_require__(186);
  var didWarnPropTypesDeprecated = false;
  createElement = ReactElementValidator.createElement;
  createFactory = ReactElementValidator.createFactory;
  cloneElement = ReactElementValidator.cloneElement;
}

var __spread = _assign;
var createMixin = function (mixin) {
  return mixin;
};

if (process.env.NODE_ENV !== 'production') {
  var warnedForSpread = false;
  var warnedForCreateMixin = false;
  __spread = function () {
    lowPriorityWarning(warnedForSpread, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.');
    warnedForSpread = true;
    return _assign.apply(null, arguments);
  };

  createMixin = function (mixin) {
    lowPriorityWarning(warnedForCreateMixin, 'React.createMixin is deprecated and should not be used. ' + 'In React v16.0, it will be removed. ' + 'You can use this mixin directly instead. ' + 'See https://fb.me/createmixin-was-never-implemented for more info.');
    warnedForCreateMixin = true;
    return mixin;
  };
}

var React = {
  // Modern

  Children: {
    map: ReactChildren.map,
    forEach: ReactChildren.forEach,
    count: ReactChildren.count,
    toArray: ReactChildren.toArray,
    only: onlyChild
  },

  Component: ReactBaseClasses.Component,
  PureComponent: ReactBaseClasses.PureComponent,

  createElement: createElement,
  cloneElement: cloneElement,
  isValidElement: ReactElement.isValidElement,

  // Classic

  PropTypes: ReactPropTypes,
  createClass: createReactClass,
  createFactory: createFactory,
  createMixin: createMixin,

  // This looks DOM specific but these are actually isomorphic helpers
  // since they are just generating DOM strings.
  DOM: ReactDOMFactories,

  version: ReactVersion,

  // Deprecated hook for JSX spread, don't use this for anything.
  __spread: __spread
};

if (process.env.NODE_ENV !== 'production') {
  var warnedForCreateClass = false;
  if (canDefineProperty) {
    Object.defineProperty(React, 'PropTypes', {
      get: function () {
        lowPriorityWarning(didWarnPropTypesDeprecated, 'Accessing PropTypes via the main React package is deprecated,' + ' and will be removed in  React v16.0.' + ' Use the latest available v15.* prop-types package from npm instead.' + ' For info on usage, compatibility, migration and more, see ' + 'https://fb.me/prop-types-docs');
        didWarnPropTypesDeprecated = true;
        return ReactPropTypes;
      }
    });

    Object.defineProperty(React, 'createClass', {
      get: function () {
        lowPriorityWarning(warnedForCreateClass, 'Accessing createClass via the main React package is deprecated,' + ' and will be removed in React v16.0.' + " Use a plain JavaScript class instead. If you're not yet " + 'ready to migrate, create-react-class v15.* is available ' + 'on npm as a temporary, drop-in replacement. ' + 'For more info see https://fb.me/react-create-class');
        warnedForCreateClass = true;
        return createReactClass;
      }
    });
  }

  // React.DOM factories are deprecated. Wrap these methods so that
  // invocations of the React.DOM namespace and alert users to switch
  // to the `react-dom-factories` package.
  React.DOM = {};
  var warnedForFactories = false;
  Object.keys(ReactDOMFactories).forEach(function (factory) {
    React.DOM[factory] = function () {
      if (!warnedForFactories) {
        lowPriorityWarning(false, 'Accessing factories like React.DOM.%s has been deprecated ' + 'and will be removed in v16.0+. Use the ' + 'react-dom-factories package instead. ' + ' Version 1.0 provides a drop-in replacement.' + ' For more info, see https://fb.me/react-dom-factories', factory);
        warnedForFactories = true;
      }
      return ReactDOMFactories[factory].apply(ReactDOMFactories, arguments);
    };
  });
}

module.exports = React;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */


/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

function reactProdInvariant(code) {
  var argCount = arguments.length - 1;

  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

  for (var argIdx = 0; argIdx < argCount; argIdx++) {
    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
  }

  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

  var error = new Error(message);
  error.name = 'Invariant Violation';
  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

  throw error;
}

module.exports = reactProdInvariant;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactRef = __webpack_require__(460);
var ReactInstrumentation = __webpack_require__(27);

var warning = __webpack_require__(3);

/**
 * Helper to call ReactRef.attachRefs with this composite component, split out
 * to avoid allocations in the transaction mount-ready queue.
 */
function attachRefs() {
  ReactRef.attachRefs(this, this._currentElement);
}

var ReactReconciler = {
  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?object} the containing host component instance
   * @param {?object} info about the host container
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID) // 0 in production and for roots
  {
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
      }
    }
    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
      }
    }
    return markup;
  },

  /**
   * Returns a value that can be passed to
   * ReactComponentEnvironment.replaceNodeWithMarkup.
   */
  getHostNode: function (internalInstance) {
    return internalInstance.getHostNode();
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function (internalInstance, safely) {
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
      }
    }
    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
    internalInstance.unmountComponent(safely);
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
      }
    }
  },

  /**
   * Update a component using a new element.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @internal
   */
  receiveComponent: function (internalInstance, nextElement, transaction, context) {
    var prevElement = internalInstance._currentElement;

    if (nextElement === prevElement && context === internalInstance._context) {
      // Since elements are immutable after the owner is rendered,
      // we can do a cheap identity compare here to determine if this is a
      // superfluous reconcile. It's possible for state to be mutable but such
      // change should trigger an update of the owner which would recreate
      // the element. We explicitly check for the existence of an owner since
      // it's possible for an element created outside a composite to be
      // deeply mutated and reused.

      // TODO: Bailing out early is just a perf optimization right?
      // TODO: Removing the return statement should affect correctness?
      return;
    }

    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
      }
    }

    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

    if (refsChanged) {
      ReactRef.detachRefs(internalInstance, prevElement);
    }

    internalInstance.receiveComponent(nextElement, transaction, context);

    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }

    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
      }
    }
  },

  /**
   * Flush any dirty changes in a component.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {
    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
      // The component's enqueued batch number should always be the current
      // batch or the following one.
      process.env.NODE_ENV !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
      return;
    }
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
      }
    }
    internalInstance.performUpdateIfNecessary(transaction);
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
      }
    }
  }
};

module.exports = ReactReconciler;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMNamespaces = __webpack_require__(132);
var setInnerHTML = __webpack_require__(94);

var createMicrosoftUnsafeLocalFunction = __webpack_require__(133);
var setTextContent = __webpack_require__(198);

var ELEMENT_NODE_TYPE = 1;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

/**
 * In IE (8-11) and Edge, appending nodes with no children is dramatically
 * faster than appending a full subtree, so we essentially queue up the
 * .appendChild calls here and apply them so each node is added to its parent
 * before any children are added.
 *
 * In other browsers, doing so is slower or neutral compared to the other order
 * (in Firefox, twice as slow) so we only do this inversion in IE.
 *
 * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
 */
var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);

function insertTreeChildren(tree) {
  if (!enableLazy) {
    return;
  }
  var node = tree.node;
  var children = tree.children;
  if (children.length) {
    for (var i = 0; i < children.length; i++) {
      insertTreeBefore(node, children[i], null);
    }
  } else if (tree.html != null) {
    setInnerHTML(node, tree.html);
  } else if (tree.text != null) {
    setTextContent(node, tree.text);
  }
}

var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
  // DocumentFragments aren't actually part of the DOM after insertion so
  // appending children won't update the DOM. We need to ensure the fragment
  // is properly populated first, breaking out of our lazy approach for just
  // this level. Also, some <object> plugins (like Flash Player) will read
  // <param> nodes immediately upon insertion into the DOM, so <object>
  // must also be populated prior to insertion into the DOM.
  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
    insertTreeChildren(tree);
    parentNode.insertBefore(tree.node, referenceNode);
  } else {
    parentNode.insertBefore(tree.node, referenceNode);
    insertTreeChildren(tree);
  }
});

function replaceChildWithTree(oldNode, newTree) {
  oldNode.parentNode.replaceChild(newTree.node, oldNode);
  insertTreeChildren(newTree);
}

function queueChild(parentTree, childTree) {
  if (enableLazy) {
    parentTree.children.push(childTree);
  } else {
    parentTree.node.appendChild(childTree.node);
  }
}

function queueHTML(tree, html) {
  if (enableLazy) {
    tree.html = html;
  } else {
    setInnerHTML(tree.node, html);
  }
}

function queueText(tree, text) {
  if (enableLazy) {
    tree.text = text;
  } else {
    setTextContent(tree.node, text);
  }
}

function toString() {
  return this.node.nodeName;
}

function DOMLazyTree(node) {
  return {
    node: node,
    children: [],
    html: null,
    text: null,
    toString: toString
  };
}

DOMLazyTree.insertTreeBefore = insertTreeBefore;
DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
DOMLazyTree.queueChild = queueChild;
DOMLazyTree.queueHTML = queueHTML;
DOMLazyTree.queueText = queueText;

module.exports = DOMLazyTree;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(29);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.f = {}.propertyIsEnumerable;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(29);
var TAG = __webpack_require__(9)('toStringTag');
// ES3 wrong here
var ARG = cof(function () {
  return arguments;
}()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) {/* empty */}
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
  // @@toStringTag case
  : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
  // builtinTag case
  : ARG ? cof(O)
  // ES3 arguments fallback
  : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var EventPluginHub = __webpack_require__(70);
var EventPluginUtils = __webpack_require__(126);

var accumulateInto = __webpack_require__(190);
var forEachAccumulated = __webpack_require__(191);
var warning = __webpack_require__(3);

var getListener = EventPluginHub.getListener;

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(inst, event, propagationPhase) {
  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(inst, registrationName);
}

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(inst, phase, event) {
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
  }
  var listener = listenerAtPhase(inst, event, phase);
  if (listener) {
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */
function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    var targetInst = event._targetInst;
    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(inst, ignoredDirection, event) {
  if (event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(inst, registrationName);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event._targetInst, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateTwoPhaseDispatchesSkipTarget(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}

function accumulateEnterLeaveDispatches(leave, enter, from, to) {
  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
}

function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}

/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing event a
 * single one.
 *
 * @constructor EventPropagators
 */
var EventPropagators = {
  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
  accumulateDirectDispatches: accumulateDirectDispatches,
  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
};

module.exports = EventPropagators;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(7);

var EventPluginRegistry = __webpack_require__(91);
var EventPluginUtils = __webpack_require__(126);
var ReactErrorUtils = __webpack_require__(127);

var accumulateInto = __webpack_require__(190);
var forEachAccumulated = __webpack_require__(191);
var invariant = __webpack_require__(2);

/**
 * Internal store for event listeners
 */
var listenerBank = {};

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
  return executeDispatchesAndRelease(e, false);
};

var getDictionaryKey = function (inst) {
  // Prevents V8 performance issue:
  // https://github.com/facebook/react/pull/7232
  return '.' + inst._rootNodeID;
};

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

function shouldPreventMouseEvent(name, type, props) {
  switch (name) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
      return !!(props.disabled && isInteractive(type));
    default:
      return false;
  }
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */
var EventPluginHub = {
  /**
   * Methods for injecting dependencies.
   */
  injection: {
    /**
     * @param {array} InjectedEventPluginOrder
     * @public
     */
    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

    /**
     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
     */
    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
  },

  /**
   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.
   *
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {function} listener The callback to store.
   */
  putListener: function (inst, registrationName, listener) {
    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener) : void 0;

    var key = getDictionaryKey(inst);
    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
    bankForRegistrationName[key] = listener;

    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.didPutListener) {
      PluginModule.didPutListener(inst, registrationName, listener);
    }
  },

  /**
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @return {?function} The stored callback.
   */
  getListener: function (inst, registrationName) {
    // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
    // live here; needs to be moved to a better place soon
    var bankForRegistrationName = listenerBank[registrationName];
    if (shouldPreventMouseEvent(registrationName, inst._currentElement.type, inst._currentElement.props)) {
      return null;
    }
    var key = getDictionaryKey(inst);
    return bankForRegistrationName && bankForRegistrationName[key];
  },

  /**
   * Deletes a listener from the registration bank.
   *
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   */
  deleteListener: function (inst, registrationName) {
    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.willDeleteListener) {
      PluginModule.willDeleteListener(inst, registrationName);
    }

    var bankForRegistrationName = listenerBank[registrationName];
    // TODO: This should never be null -- when is it?
    if (bankForRegistrationName) {
      var key = getDictionaryKey(inst);
      delete bankForRegistrationName[key];
    }
  },

  /**
   * Deletes all listeners for the DOM element with the supplied ID.
   *
   * @param {object} inst The instance, which is the source of events.
   */
  deleteAllListeners: function (inst) {
    var key = getDictionaryKey(inst);
    for (var registrationName in listenerBank) {
      if (!listenerBank.hasOwnProperty(registrationName)) {
        continue;
      }

      if (!listenerBank[registrationName][key]) {
        continue;
      }

      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
      if (PluginModule && PluginModule.willDeleteListener) {
        PluginModule.willDeleteListener(inst, registrationName);
      }

      delete listenerBank[registrationName][key];
    }
  },

  /**
   * Allows registered plugins an opportunity to extract events from top-level
   * native browser events.
   *
   * @return {*} An accumulation of synthetic events.
   * @internal
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var events;
    var plugins = EventPluginRegistry.plugins;
    for (var i = 0; i < plugins.length; i++) {
      // Not every plugin in the ordering may be loaded at runtime.
      var possiblePlugin = plugins[i];
      if (possiblePlugin) {
        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
        if (extractedEvents) {
          events = accumulateInto(events, extractedEvents);
        }
      }
    }
    return events;
  },

  /**
   * Enqueues a synthetic event that should be dispatched when
   * `processEventQueue` is invoked.
   *
   * @param {*} events An accumulation of synthetic events.
   * @internal
   */
  enqueueEvents: function (events) {
    if (events) {
      eventQueue = accumulateInto(eventQueue, events);
    }
  },

  /**
   * Dispatches all synthetic events on the event queue.
   *
   * @internal
   */
  processEventQueue: function (simulated) {
    // Set `eventQueue` to null before processing it so that we can tell if more
    // events get enqueued while processing.
    var processingEventQueue = eventQueue;
    eventQueue = null;
    if (simulated) {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
    } else {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
    }
    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
    // This would be a good time to rethrow if any of the event handlers threw.
    ReactErrorUtils.rethrowCaughtError();
  },

  /**
   * These are needed for tests only. Do not use!
   */
  __purge: function () {
    listenerBank = {};
  },

  __getListenerBank: function () {
    return listenerBank;
  }
};

module.exports = EventPluginHub;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticEvent = __webpack_require__(41);

var getEventTarget = __webpack_require__(128);

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: function (event) {
    if (event.view) {
      return event.view;
    }

    var target = getEventTarget(event);
    if (target.window === target) {
      // target is a window object
      return target;
    }

    var doc = target.ownerDocument;
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    if (doc) {
      return doc.defaultView || doc.parentWindow;
    } else {
      return window;
    }
  },
  detail: function (event) {
    return event.detail || 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

module.exports = SyntheticUIEvent;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 */

// TODO: Replace this with ES6: var ReactInstanceMap = new Map();

var ReactInstanceMap = {
  /**
   * This API should be called `delete` but we'd have to make sure to always
   * transform these to strings for IE support. When this transform is fully
   * supported we can rename it.
   */
  remove: function (key) {
    key._reactInternalInstance = undefined;
  },

  get: function (key) {
    return key._reactInternalInstance;
  },

  has: function (key) {
    return key._reactInternalInstance !== undefined;
  },

  set: function (key, value) {
    key._reactInternalInstance = value;
  }
};

module.exports = ReactInstanceMap;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(5);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(23);
var toLength = __webpack_require__(13);
var toAbsoluteIndex = __webpack_require__(49);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    }return !IS_INCLUDES && -1;
  };
};

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.f = Object.getOwnPropertySymbols;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 7.2.2 IsArray(argument)
var cof = __webpack_require__(29);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(8);
var cof = __webpack_require__(29);
var MATCH = __webpack_require__(9)('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ITERATOR = __webpack_require__(9)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () {
    SAFE_CLOSING = true;
  };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () {
    throw 2;
  });
} catch (e) {/* empty */}

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () {
      return { done: safe = true };
    };
    arr[ITERATOR] = function () {
      return iter;
    };
    exec(arr);
  } catch (e) {/* empty */}
  return safe;
};

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.2.5.3 get RegExp.prototype.flags

var anObject = __webpack_require__(4);
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hide = __webpack_require__(19);
var redefine = __webpack_require__(20);
var fails = __webpack_require__(6);
var defined = __webpack_require__(33);
var wks = __webpack_require__(9);

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var fns = exec(defined, SYMBOL, ''[KEY]);
  var strfn = fns[0];
  var rxfn = fns[1];
  if (fails(function () {
    var O = {};
    O[SYMBOL] = function () {
      return 7;
    };
    return ''[KEY](O) != 7;
  })) {
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
    // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
    ? function (string, arg) {
      return rxfn.call(string, this, arg);
    }
    // 21.2.5.6 RegExp.prototype[@@match](string)
    // 21.2.5.9 RegExp.prototype[@@search](string)
    : function (string) {
      return rxfn.call(string, this);
    });
  }
};

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(4);
var aFunction = __webpack_require__(17);
var SPECIES = __webpack_require__(9)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(5);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(20);
var redefineAll = __webpack_require__(55);
var meta = __webpack_require__(42);
var forOf = __webpack_require__(54);
var anInstance = __webpack_require__(53);
var isObject = __webpack_require__(8);
var fails = __webpack_require__(6);
var $iterDetect = __webpack_require__(79);
var setToStringTag = __webpack_require__(58);
var inheritIfRequired = __webpack_require__(105);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY, KEY == 'delete' ? function (a) {
      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'has' ? function has(a) {
      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'get' ? function get(a) {
      return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'add' ? function add(a) {
      fn.call(this, a === 0 ? 0 : a);return this;
    } : function set(a, b) {
      fn.call(this, a === 0 ? 0 : a, b);return this;
    });
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () {
      instance.has(1);
    });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) {
      new C(iter);
    }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(5);
var hide = __webpack_require__(19);
var uid = __webpack_require__(46);
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Forced replacement prototype accessors methods

module.exports = __webpack_require__(47) || !__webpack_require__(6)(function () {
  var K = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, K, function () {/* empty */});
  delete __webpack_require__(5)[K];
});

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/

var $export = __webpack_require__(0);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
      var length = arguments.length;
      var A = Array(length);
      while (length--) A[length] = arguments[length];
      return new this(A);
    } });
};

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/

var $export = __webpack_require__(0);
var aFunction = __webpack_require__(17);
var ctx = __webpack_require__(28);
var forOf = __webpack_require__(54);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
      var mapFn = arguments[1];
      var mapping, A, n, cb;
      aFunction(this);
      mapping = mapFn !== undefined;
      if (mapping) aFunction(mapFn);
      if (source == undefined) return new this();
      A = [];
      if (mapping) {
        n = 0;
        cb = ctx(mapFn, arguments[2], 2);
        forOf(source, false, function (nextItem) {
          A.push(cb(nextItem, n++));
        });
      } else {
        forOf(source, false, A.push, A);
      }
      return new this(A);
    } });
};

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(62);

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var canDefineProperty = false;
if (process.env.NODE_ENV !== 'production') {
  try {
    // $FlowFixMe https://github.com/facebook/flow/issues/285
    Object.defineProperty({}, 'x', { get: function () {} });
    canDefineProperty = true;
  } catch (x) {
    // IE will fail on defineProperty
  }
}

module.exports = canDefineProperty;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(7);

var invariant = __webpack_require__(2);

/**
 * Injectable ordering of event plugins.
 */
var eventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!eventPluginOrder) {
    // Wait until an `eventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var pluginModule = namesToPlugins[pluginName];
    var pluginIndex = eventPluginOrder.indexOf(pluginName);
    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
    if (EventPluginRegistry.plugins[pluginIndex]) {
      continue;
    }
    !pluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
    EventPluginRegistry.plugins[pluginIndex] = pluginModule;
    var publishedEvents = pluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events and
 * can be used with `EventPluginHub.putListener` to register listeners.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, pluginModule, eventName) {
  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
  EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;
  EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;

  if (process.env.NODE_ENV !== 'production') {
    var lowerCasedName = registrationName.toLowerCase();
    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;

    if (registrationName === 'onDoubleClick') {
      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
    }
  }
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */
var EventPluginRegistry = {
  /**
   * Ordered list of injected plugins.
   */
  plugins: [],

  /**
   * Mapping from event name to dispatch config
   */
  eventNameDispatchConfigs: {},

  /**
   * Mapping from registration name to plugin module
   */
  registrationNameModules: {},

  /**
   * Mapping from registration name to event name
   */
  registrationNameDependencies: {},

  /**
   * Mapping from lowercase registration names to the properly cased version,
   * used to warn in the case of missing event handlers. Available
   * only in __DEV__.
   * @type {Object}
   */
  possibleRegistrationNames: process.env.NODE_ENV !== 'production' ? {} : null,
  // Trust the developer to only use possibleRegistrationNames in __DEV__

  /**
   * Injects an ordering of plugins (by plugin name). This allows the ordering
   * to be decoupled from injection of the actual plugins so that ordering is
   * always deterministic regardless of packaging, on-the-fly injection, etc.
   *
   * @param {array} InjectedEventPluginOrder
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginOrder}
   */
  injectEventPluginOrder: function (injectedEventPluginOrder) {
    !!eventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
    // Clone the ordering so it cannot be dynamically mutated.
    eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
    recomputePluginOrdering();
  },

  /**
   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
   * in the ordering injected by `injectEventPluginOrder`.
   *
   * Plugins can be injected as part of page initialization or on-the-fly.
   *
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginsByName}
   */
  injectEventPluginsByName: function (injectedNamesToPlugins) {
    var isOrderingDirty = false;
    for (var pluginName in injectedNamesToPlugins) {
      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
        continue;
      }
      var pluginModule = injectedNamesToPlugins[pluginName];
      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
        namesToPlugins[pluginName] = pluginModule;
        isOrderingDirty = true;
      }
    }
    if (isOrderingDirty) {
      recomputePluginOrdering();
    }
  },

  /**
   * Looks up the plugin for the supplied event.
   *
   * @param {object} event A synthetic event.
   * @return {?object} The plugin that created the supplied event.
   * @internal
   */
  getPluginModuleForEvent: function (event) {
    var dispatchConfig = event.dispatchConfig;
    if (dispatchConfig.registrationName) {
      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
    }
    if (dispatchConfig.phasedRegistrationNames !== undefined) {
      // pulling phasedRegistrationNames out of dispatchConfig helps Flow see
      // that it is not undefined.
      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

      for (var phase in phasedRegistrationNames) {
        if (!phasedRegistrationNames.hasOwnProperty(phase)) {
          continue;
        }
        var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];
        if (pluginModule) {
          return pluginModule;
        }
      }
    }
    return null;
  },

  /**
   * Exposed for unit testing.
   * @private
   */
  _resetEventPlugins: function () {
    eventPluginOrder = null;
    for (var pluginName in namesToPlugins) {
      if (namesToPlugins.hasOwnProperty(pluginName)) {
        delete namesToPlugins[pluginName];
      }
    }
    EventPluginRegistry.plugins.length = 0;

    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
    for (var eventName in eventNameDispatchConfigs) {
      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
        delete eventNameDispatchConfigs[eventName];
      }
    }

    var registrationNameModules = EventPluginRegistry.registrationNameModules;
    for (var registrationName in registrationNameModules) {
      if (registrationNameModules.hasOwnProperty(registrationName)) {
        delete registrationNameModules[registrationName];
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
      for (var lowerCasedName in possibleRegistrationNames) {
        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
          delete possibleRegistrationNames[lowerCasedName];
        }
      }
    }
  }
};

module.exports = EventPluginRegistry;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(7);

var invariant = __webpack_require__(2);

var OBSERVED_ERROR = {};

/**
 * `Transaction` creates a black box that is able to wrap any method such that
 * certain invariants are maintained before and after the method is invoked
 * (Even if an exception is thrown while invoking the wrapped method). Whoever
 * instantiates a transaction can provide enforcers of the invariants at
 * creation time. The `Transaction` class itself will supply one additional
 * automatic invariant for you - the invariant that any transaction instance
 * should not be run while it is already being run. You would typically create a
 * single instance of a `Transaction` for reuse multiple times, that potentially
 * is used to wrap several different methods. Wrappers are extremely simple -
 * they only require implementing two methods.
 *
 * <pre>
 *                       wrappers (injected at creation time)
 *                                      +        +
 *                                      |        |
 *                    +-----------------|--------|--------------+
 *                    |                 v        |              |
 *                    |      +---------------+   |              |
 *                    |   +--|    wrapper1   |---|----+         |
 *                    |   |  +---------------+   v    |         |
 *                    |   |          +-------------+  |         |
 *                    |   |     +----|   wrapper2  |--------+   |
 *                    |   |     |    +-------------+  |     |   |
 *                    |   |     |                     |     |   |
 *                    |   v     v                     v     v   | wrapper
 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | +---+ +---+   +---------+   +---+ +---+ |
 *                    |  initialize                    close    |
 *                    +-----------------------------------------+
 * </pre>
 *
 * Use cases:
 * - Preserving the input selection ranges before/after reconciliation.
 *   Restoring selection even in the event of an unexpected error.
 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
 *   while guaranteeing that afterwards, the event system is reactivated.
 * - Flushing a queue of collected DOM mutations to the main UI thread after a
 *   reconciliation takes place in a worker thread.
 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
 *   content.
 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
 * - (Future use case): Layout calculations before and after DOM updates.
 *
 * Transactional plugin API:
 * - A module that has an `initialize` method that returns any precomputation.
 * - and a `close` method that accepts the precomputation. `close` is invoked
 *   when the wrapped process is completed, or has failed.
 *
 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
 * that implement `initialize` and `close`.
 * @return {Transaction} Single transaction for reuse in thread.
 *
 * @class Transaction
 */
var TransactionImpl = {
  /**
   * Sets up this instance so that it is prepared for collecting metrics. Does
   * so such that this setup method may be used on an instance that is already
   * initialized, in a way that does not consume additional memory upon reuse.
   * That can be useful if you decide to make your subclass of this mixin a
   * "PooledClass".
   */
  reinitializeTransaction: function () {
    this.transactionWrappers = this.getTransactionWrappers();
    if (this.wrapperInitData) {
      this.wrapperInitData.length = 0;
    } else {
      this.wrapperInitData = [];
    }
    this._isInTransaction = false;
  },

  _isInTransaction: false,

  /**
   * @abstract
   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
   */
  getTransactionWrappers: null,

  isInTransaction: function () {
    return !!this._isInTransaction;
  },

  /* eslint-disable space-before-function-paren */

  /**
   * Executes the function within a safety window. Use this for the top level
   * methods that result in large amounts of computation/mutations that would
   * need to be safety checked. The optional arguments helps prevent the need
   * to bind in many cases.
   *
   * @param {function} method Member of scope to call.
   * @param {Object} scope Scope to invoke from.
   * @param {Object?=} a Argument to pass to the method.
   * @param {Object?=} b Argument to pass to the method.
   * @param {Object?=} c Argument to pass to the method.
   * @param {Object?=} d Argument to pass to the method.
   * @param {Object?=} e Argument to pass to the method.
   * @param {Object?=} f Argument to pass to the method.
   *
   * @return {*} Return value from `method`.
   */
  perform: function (method, scope, a, b, c, d, e, f) {
    /* eslint-enable space-before-function-paren */
    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
    var errorThrown;
    var ret;
    try {
      this._isInTransaction = true;
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it's still set to true in the finally block, it means
      // one of these calls threw.
      errorThrown = true;
      this.initializeAll(0);
      ret = method.call(scope, a, b, c, d, e, f);
      errorThrown = false;
    } finally {
      try {
        if (errorThrown) {
          // If `method` throws, prefer to show that stack trace over any thrown
          // by invoking `closeAll`.
          try {
            this.closeAll(0);
          } catch (err) {}
        } else {
          // Since `method` didn't throw, we don't want to silence the exception
          // here.
          this.closeAll(0);
        }
      } finally {
        this._isInTransaction = false;
      }
    }
    return ret;
  },

  initializeAll: function (startIndex) {
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      try {
        // Catching errors makes debugging more difficult, so we start with the
        // OBSERVED_ERROR state before overwriting it with the real return value
        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
        // block, it means wrapper.initialize threw.
        this.wrapperInitData[i] = OBSERVED_ERROR;
        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
      } finally {
        if (this.wrapperInitData[i] === OBSERVED_ERROR) {
          // The initializer for wrapper i threw an error; initialize the
          // remaining wrappers but silence any exceptions from them to ensure
          // that the first error is the one to bubble up.
          try {
            this.initializeAll(i + 1);
          } catch (err) {}
        }
      }
    }
  },

  /**
   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
   * them the respective return values of `this.transactionWrappers.init[i]`
   * (`close`rs that correspond to initializers that failed will not be
   * invoked).
   */
  closeAll: function (startIndex) {
    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      var initData = this.wrapperInitData[i];
      var errorThrown;
      try {
        // Catching errors makes debugging more difficult, so we start with
        // errorThrown set to true before setting it to false after calling
        // close -- if it's still set to true in the finally block, it means
        // wrapper.close threw.
        errorThrown = true;
        if (initData !== OBSERVED_ERROR && wrapper.close) {
          wrapper.close.call(this, initData);
        }
        errorThrown = false;
      } finally {
        if (errorThrown) {
          // The closer for wrapper i threw an error; close the remaining
          // wrappers but silence any exceptions from them to ensure that the
          // first error is the one to bubble up.
          try {
            this.closeAll(i + 1);
          } catch (e) {}
        }
      }
    }
    this.wrapperInitData.length = 0;
  }
};

module.exports = TransactionImpl;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticUIEvent = __webpack_require__(71);
var ViewportMetrics = __webpack_require__(197);

var getEventModifierState = __webpack_require__(130);

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: function (event) {
    // Webkit, Firefox, IE9+
    // which:  1 2 3
    // button: 0 1 2 (standard)
    var button = event.button;
    if ('which' in event) {
      return button;
    }
    // IE<9
    // which:  undefined
    // button: 0 0 0
    // button: 1 4 2 (onmouseup)
    return button === 2 ? 2 : button === 4 ? 1 : 0;
  },
  buttons: null,
  relatedTarget: function (event) {
    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
  },
  // "Proprietary" Interface.
  pageX: function (event) {
    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
  },
  pageY: function (event) {
    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

module.exports = SyntheticMouseEvent;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ExecutionEnvironment = __webpack_require__(16);
var DOMNamespaces = __webpack_require__(132);

var WHITESPACE_TEST = /^[ \r\n\t\f]/;
var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

var createMicrosoftUnsafeLocalFunction = __webpack_require__(133);

// SVG temp container for IE lacking innerHTML
var reusableSVGContainer;

/**
 * Set the innerHTML property of a node, ensuring that whitespace is preserved
 * even in IE8.
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
  // IE does not have innerHTML for SVG nodes, so instead we inject the
  // new markup in a temp node and then move the child nodes across into
  // the target node
  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
    var svgNode = reusableSVGContainer.firstChild;
    while (svgNode.firstChild) {
      node.appendChild(svgNode.firstChild);
    }
  } else {
    node.innerHTML = html;
  }
});

if (ExecutionEnvironment.canUseDOM) {
  // IE8: When updating a just created node with innerHTML only leading
  // whitespace is removed. When updating an existing node with innerHTML
  // whitespace in root TextNodes is also collapsed.
  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

  // Feature detection; only IE8 is known to behave improperly like this.
  var testElement = document.createElement('div');
  testElement.innerHTML = ' ';
  if (testElement.innerHTML === '') {
    setInnerHTML = function (node, html) {
      // Magic theory: IE8 supposedly differentiates between added and updated
      // nodes when processing innerHTML, innerHTML on updated nodes suffers
      // from worse whitespace behavior. Re-adding a node like this triggers
      // the initial and more favorable whitespace behavior.
      // TODO: What to do on a detached node?
      if (node.parentNode) {
        node.parentNode.replaceChild(node, node);
      }

      // We also implement a workaround for non-visible tags disappearing into
      // thin air on IE8, this only happens if there is no visible text
      // in-front of the non-visible tags. Piggyback on the whitespace fix
      // and simply check if any non-visible tags appear in the source.
      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
        // Recover leading whitespace by temporarily prepending any character.
        // \uFEFF has the potential advantage of being zero-width/invisible.
        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
        // in hopes that this is preserved even if "\uFEFF" is transformed to
        // the actual Unicode character (by Babel, for example).
        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
        node.innerHTML = String.fromCharCode(0xfeff) + html;

        // deleteData leaves an empty `TextNode` which offsets the index of all
        // children. Definitely want to avoid this.
        var textNode = node.firstChild;
        if (textNode.data.length === 1) {
          node.removeChild(textNode);
        } else {
          textNode.deleteData(0, 1);
        }
      } else {
        node.innerHTML = html;
      }
    };
  }
  testElement = null;
}

module.exports = setInnerHTML;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * Based on the escape-html library, which is used under the MIT License below:
 *
 * Copyright (c) 2012-2013 TJ Holowaychuk
 * Copyright (c) 2015 Andreas Lubbe
 * Copyright (c) 2015 Tiancheng "Timothy" Gu
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */



// code copied and modified from escape-html
/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        // "
        escape = '&quot;';
        break;
      case 38:
        // &
        escape = '&amp;';
        break;
      case 39:
        // '
        escape = '&#x27;'; // modified from escape-html; used to be '&#39'
        break;
      case 60:
        // <
        escape = '&lt;';
        break;
      case 62:
        // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
// end code copied and modified from escape-html

/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function escapeTextContentForBrowser(text) {
  if (typeof text === 'boolean' || typeof text === 'number') {
    // this shortcircuit helps perf for types that we know will never have
    // special characters, especially given that this function is used often
    // for numeric dom ids.
    return '' + text;
  }
  return escapeHtml(text);
}

module.exports = escapeTextContentForBrowser;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(10);

var EventPluginRegistry = __webpack_require__(91);
var ReactEventEmitterMixin = __webpack_require__(486);
var ViewportMetrics = __webpack_require__(197);

var getVendorPrefixedEventName = __webpack_require__(487);
var isEventSupported = __webpack_require__(129);

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactEventListener, which is injected and can therefore support pluggable
 *    event sources. This is the only work that occurs in the main thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var hasEventPageXY;
var alreadyListeningTo = {};
var isMonitoringScrollValue = false;
var reactTopListenersCounter = 0;

// For events like 'submit' which don't consistently bubble (which we trap at a
// lower node than `document`), binding at `document` would cause duplicate
// events so we don't include them here
var topEventMapping = {
  topAbort: 'abort',
  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
  topBlur: 'blur',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topChange: 'change',
  topClick: 'click',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topScroll: 'scroll',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topSelectionChange: 'selectionchange',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTextInput: 'textInput',
  topTimeUpdate: 'timeupdate',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting',
  topWheel: 'wheel'
};

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
 * example:
 *
 *   EventPluginHub.putListener('myID', 'onClick', myFunction);
 *
 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
 *
 * @internal
 */
var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {
  /**
   * Injectable event backend
   */
  ReactEventListener: null,

  injection: {
    /**
     * @param {object} ReactEventListener
     */
    injectReactEventListener: function (ReactEventListener) {
      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
    }
  },

  /**
   * Sets whether or not any created callbacks should be enabled.
   *
   * @param {boolean} enabled True if callbacks should be enabled.
   */
  setEnabled: function (enabled) {
    if (ReactBrowserEventEmitter.ReactEventListener) {
      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
    }
  },

  /**
   * @return {boolean} True if callbacks are enabled.
   */
  isEnabled: function () {
    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
  },

  /**
   * We listen for bubbled touch events on the document object.
   *
   * Firefox v8.01 (and possibly others) exhibited strange behavior when
   * mounting `onmousemove` events at some node that was not the document
   * element. The symptoms were that if your mouse is not moving over something
   * contained within that mount point (for example on the background) the
   * top-level listeners for `onmousemove` won't be called. However, if you
   * register the `mousemove` on the document object, then it will of course
   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
   * top-level listeners to the document object only, at least for these
   * movement types of events and possibly all events.
   *
   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
   *
   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
   * they bubble to document.
   *
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {object} contentDocumentHandle Document which owns the container
   */
  listenTo: function (registrationName, contentDocumentHandle) {
    var mountAt = contentDocumentHandle;
    var isListening = getListeningForDocument(mountAt);
    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

    for (var i = 0; i < dependencies.length; i++) {
      var dependency = dependencies[i];
      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
        if (dependency === 'topWheel') {
          if (isEventSupported('wheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'wheel', mountAt);
          } else if (isEventSupported('mousewheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
          } else {
            // Firefox needs to capture a different mouse scroll event.
            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
          }
        } else if (dependency === 'topScroll') {
          if (isEventSupported('scroll', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topScroll', 'scroll', mountAt);
          } else {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
          }
        } else if (dependency === 'topFocus' || dependency === 'topBlur') {
          if (isEventSupported('focus', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topBlur', 'blur', mountAt);
          } else if (isEventSupported('focusin')) {
            // IE has `focusin` and `focusout` events which bubble.
            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topFocus', 'focusin', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topBlur', 'focusout', mountAt);
          }

          // to make sure blur and focus event listeners are only attached once
          isListening.topBlur = true;
          isListening.topFocus = true;
        } else if (topEventMapping.hasOwnProperty(dependency)) {
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
        }

        isListening[dependency] = true;
      }
    }
  },

  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
  },

  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
  },

  /**
   * Protect against document.createEvent() returning null
   * Some popup blocker extensions appear to do this:
   * https://github.com/facebook/react/issues/6887
   */
  supportsEventPageXY: function () {
    if (!document.createEvent) {
      return false;
    }
    var ev = document.createEvent('MouseEvent');
    return ev != null && 'pageX' in ev;
  },

  /**
   * Listens to window scroll and resize events. We cache scroll values so that
   * application code can access them without triggering reflows.
   *
   * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
   * pageX/pageY isn't supported (legacy browsers).
   *
   * NOTE: Scroll events do not bubble.
   *
   * @see http://www.quirksmode.org/dom/events/scroll.html
   */
  ensureScrollValueMonitoring: function () {
    if (hasEventPageXY === undefined) {
      hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
    }
    if (!hasEventPageXY && !isMonitoringScrollValue) {
      var refresh = ViewportMetrics.refreshScrollValues;
      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
      isMonitoringScrollValue = true;
    }
  }
});

module.exports = ReactBrowserEventEmitter;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;

var _createStore = __webpack_require__(217);

var _createStore2 = _interopRequireDefault(_createStore);

var _combineReducers = __webpack_require__(556);

var _combineReducers2 = _interopRequireDefault(_combineReducers);

var _bindActionCreators = __webpack_require__(557);

var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);

var _applyMiddleware = __webpack_require__(558);

var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);

var _compose = __webpack_require__(220);

var _compose2 = _interopRequireDefault(_compose);

var _warning = __webpack_require__(219);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
* This is a dummy function to check if the function name has been altered by minification.
* If the function has been minified and NODE_ENV !== 'production', warn the user.
*/
function isCrushed() {}

if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  (0, _warning2.default)('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
}

exports.createStore = _createStore2.default;
exports.combineReducers = _combineReducers2.default;
exports.bindActionCreators = _bindActionCreators2.default;
exports.applyMiddleware = _applyMiddleware2.default;
exports.compose = _compose2.default;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(8);
var document = __webpack_require__(5).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(5);
var core = __webpack_require__(31);
var LIBRARY = __webpack_require__(47);
var wksExt = __webpack_require__(149);
var defineProperty = __webpack_require__(12).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var shared = __webpack_require__(74)('keys');
var uid = __webpack_require__(46);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// IE 8- don't enum bug keys
module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var document = __webpack_require__(5).document;
module.exports = document && document.documentElement;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(8);
var anObject = __webpack_require__(4);
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
  function (test, buggy, set) {
    try {
      set = __webpack_require__(28)(Function.call, __webpack_require__(24).f(Object.prototype, '__proto__').set, 2);
      set(test, []);
      buggy = !(test instanceof Array);
    } catch (e) {
      buggy = true;
    }
    return function setPrototypeOf(O, proto) {
      check(O, proto);
      if (buggy) O.__proto__ = proto;else set(O, proto);
      return O;
    };
  }({}, false) : undefined),
  check: check
};

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(8);
var setPrototypeOf = __webpack_require__(103).set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  }return that;
};

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__(34);
var defined = __webpack_require__(33);

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (; n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = !$expm1
// Old FF bug
|| $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
// Tor Browser bug
|| $expm1(-2e-17) != -2e-17 ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__(34);
var defined = __webpack_require__(33);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__(47);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(20);
var hide = __webpack_require__(19);
var has = __webpack_require__(18);
var Iterators = __webpack_require__(60);
var $iterCreate = __webpack_require__(111);
var setToStringTag = __webpack_require__(58);
var getPrototypeOf = __webpack_require__(25);
var ITERATOR = __webpack_require__(9)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () {
  return this;
};

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS:
        return function keys() {
          return new Constructor(this, kind);
        };
      case VALUES:
        return function values() {
          return new Constructor(this, kind);
        };
    }return function entries() {
      return new Constructor(this, kind);
    };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() {
      return $native.call(this);
    };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var create = __webpack_require__(50);
var descriptor = __webpack_require__(45);
var setToStringTag = __webpack_require__(58);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(19)(IteratorPrototype, __webpack_require__(9)('iterator'), function () {
  return this;
});

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(78);
var defined = __webpack_require__(33);

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var MATCH = __webpack_require__(9)('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) {/* empty */}
  }return true;
};

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// check on default Array iterator
var Iterators = __webpack_require__(60);
var ITERATOR = __webpack_require__(9)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $defineProperty = __webpack_require__(12);
var createDesc = __webpack_require__(45);

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));else object[index] = value;
};

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var classof = __webpack_require__(68);
var ITERATOR = __webpack_require__(9)('iterator');
var Iterators = __webpack_require__(60);
module.exports = __webpack_require__(31).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
};

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(327);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)


var toObject = __webpack_require__(15);
var toAbsoluteIndex = __webpack_require__(49);
var toLength = __webpack_require__(13);
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var addToUnscopables = __webpack_require__(43);
var step = __webpack_require__(165);
var Iterators = __webpack_require__(60);
var toIObject = __webpack_require__(23);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(110)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0; // next index
  this._k = kind; // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ctx = __webpack_require__(28);
var invoke = __webpack_require__(155);
var html = __webpack_require__(102);
var cel = __webpack_require__(98);
var global = __webpack_require__(5);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(29)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
    // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
    // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
    // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
    // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
    // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(5);
var macrotask = __webpack_require__(120).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(29)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();else last = undefined;
        throw e;
      }
    }last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
    // browsers with MutationObserver
  } else if (Observer) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
    // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    var promise = Promise.resolve();
    notify = function () {
      promise.then(flush);
    };
    // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    }last = task;
  };
};

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)

var aFunction = __webpack_require__(17);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(5);
var DESCRIPTORS = __webpack_require__(11);
var LIBRARY = __webpack_require__(47);
var $typed = __webpack_require__(84);
var hide = __webpack_require__(19);
var redefineAll = __webpack_require__(55);
var fails = __webpack_require__(6);
var anInstance = __webpack_require__(53);
var toInteger = __webpack_require__(34);
var toLength = __webpack_require__(13);
var toIndex = __webpack_require__(174);
var gOPN = __webpack_require__(51).f;
var dP = __webpack_require__(12).f;
var arrayFill = __webpack_require__(118);
var setToStringTag = __webpack_require__(58);
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  }return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () {
      return this[internal];
    } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = lowPriorityWarning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(7);

var ReactErrorUtils = __webpack_require__(127);

var invariant = __webpack_require__(2);
var warning = __webpack_require__(3);

/**
 * Injected dependencies:
 */

/**
 * - `ComponentTree`: [required] Module that can convert between React instances
 *   and actual node references.
 */
var ComponentTree;
var TreeTraversal;
var injection = {
  injectComponentTree: function (Injected) {
    ComponentTree = Injected;
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
    }
  },
  injectTreeTraversal: function (Injected) {
    TreeTraversal = Injected;
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
    }
  }
};

function isEndish(topLevelType) {
  return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';
}

function isMoveish(topLevelType) {
  return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';
}
function isStartish(topLevelType) {
  return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';
}

var validateEventDispatches;
if (process.env.NODE_ENV !== 'production') {
  validateEventDispatches = function (event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchInstances = event._dispatchInstances;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

    var instancesIsArr = Array.isArray(dispatchInstances);
    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

    process.env.NODE_ENV !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
  };
}

/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */
function executeDispatch(event, simulated, listener, inst) {
  var type = event.type || 'unknown-event';
  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
  if (simulated) {
    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
  } else {
    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
  }
  event.currentTarget = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
    }
  } else if (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
  }
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches, but stops
 * at the first dispatch execution returning true, and returns that id.
 *
 * @return {?string} id of the first dispatch execution who's listener returns
 * true, or null if no listener returned true.
 */
function executeDispatchesInOrderStopAtTrueImpl(event) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      if (dispatchListeners[i](event, dispatchInstances[i])) {
        return dispatchInstances[i];
      }
    }
  } else if (dispatchListeners) {
    if (dispatchListeners(event, dispatchInstances)) {
      return dispatchInstances;
    }
  }
  return null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */
function executeDispatchesInOrderStopAtTrue(event) {
  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
  event._dispatchInstances = null;
  event._dispatchListeners = null;
  return ret;
}

/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 */
function executeDirectDispatch(event) {
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  var dispatchListener = event._dispatchListeners;
  var dispatchInstance = event._dispatchInstances;
  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
  var res = dispatchListener ? dispatchListener(event) : null;
  event.currentTarget = null;
  event._dispatchListeners = null;
  event._dispatchInstances = null;
  return res;
}

/**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 */
function hasDispatches(event) {
  return !!event._dispatchListeners;
}

/**
 * General utilities that are useful in creating custom Event Plugins.
 */
var EventPluginUtils = {
  isEndish: isEndish,
  isMoveish: isMoveish,
  isStartish: isStartish,

  executeDirectDispatch: executeDirectDispatch,
  executeDispatchesInOrder: executeDispatchesInOrder,
  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
  hasDispatches: hasDispatches,

  getInstanceFromNode: function (node) {
    return ComponentTree.getInstanceFromNode(node);
  },
  getNodeFromInstance: function (node) {
    return ComponentTree.getNodeFromInstance(node);
  },
  isAncestor: function (a, b) {
    return TreeTraversal.isAncestor(a, b);
  },
  getLowestCommonAncestor: function (a, b) {
    return TreeTraversal.getLowestCommonAncestor(a, b);
  },
  getParentInstance: function (inst) {
    return TreeTraversal.getParentInstance(inst);
  },
  traverseTwoPhase: function (target, fn, arg) {
    return TreeTraversal.traverseTwoPhase(target, fn, arg);
  },
  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
  },

  injection: injection
};

module.exports = EventPluginUtils;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var caughtError = null;

/**
 * Call a function while guarding against errors that happens within it.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} a First argument
 * @param {*} b Second argument
 */
function invokeGuardedCallback(name, func, a) {
  try {
    func(a);
  } catch (x) {
    if (caughtError === null) {
      caughtError = x;
    }
  }
}

var ReactErrorUtils = {
  invokeGuardedCallback: invokeGuardedCallback,

  /**
   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
   * handler are sure to be rethrown by rethrowCaughtError.
   */
  invokeGuardedCallbackWithCatch: invokeGuardedCallback,

  /**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */
  rethrowCaughtError: function () {
    if (caughtError) {
      var error = caughtError;
      caughtError = null;
      throw error;
    }
  }
};

if (process.env.NODE_ENV !== 'production') {
  /**
   * To help development we can get better devtools integration by simulating a
   * real browser event.
   */
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');
    ReactErrorUtils.invokeGuardedCallback = function (name, func, a) {
      var boundFunc = func.bind(null, a);
      var evtType = 'react-' + name;
      fakeNode.addEventListener(evtType, boundFunc, false);
      var evt = document.createEvent('Event');
      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);
      fakeNode.removeEventListener(evtType, boundFunc, false);
    };
  }
}

module.exports = ReactErrorUtils;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */

function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;

  // Normalize SVG <use> element events #4963
  if (target.correspondingUseElement) {
    target = target.correspondingUseElement;
  }

  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === 3 ? target.parentNode : target;
}

module.exports = getEventTarget;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ExecutionEnvironment = __webpack_require__(16);

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature &&
  // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

module.exports = isEventSupported;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  Alt: 'altKey',
  Control: 'ctrlKey',
  Meta: 'metaKey',
  Shift: 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

module.exports = getEventModifierState;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMLazyTree = __webpack_require__(65);
var Danger = __webpack_require__(471);
var ReactDOMComponentTree = __webpack_require__(14);
var ReactInstrumentation = __webpack_require__(27);

var createMicrosoftUnsafeLocalFunction = __webpack_require__(133);
var setInnerHTML = __webpack_require__(94);
var setTextContent = __webpack_require__(198);

function getNodeAfter(parentNode, node) {
  // Special case for text components, which return [open, close] comments
  // from getHostNode.
  if (Array.isArray(node)) {
    node = node[1];
  }
  return node ? node.nextSibling : parentNode.firstChild;
}

/**
 * Inserts `childNode` as a child of `parentNode` at the `index`.
 *
 * @param {DOMElement} parentNode Parent node in which to insert.
 * @param {DOMElement} childNode Child node to insert.
 * @param {number} index Index at which to insert the child.
 * @internal
 */
var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
  // We rely exclusively on `insertBefore(node, null)` instead of also using
  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
  // we are careful to use `null`.)
  parentNode.insertBefore(childNode, referenceNode);
});

function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
}

function moveChild(parentNode, childNode, referenceNode) {
  if (Array.isArray(childNode)) {
    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
  } else {
    insertChildAt(parentNode, childNode, referenceNode);
  }
}

function removeChild(parentNode, childNode) {
  if (Array.isArray(childNode)) {
    var closingComment = childNode[1];
    childNode = childNode[0];
    removeDelimitedText(parentNode, childNode, closingComment);
    parentNode.removeChild(closingComment);
  }
  parentNode.removeChild(childNode);
}

function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
  var node = openingComment;
  while (true) {
    var nextNode = node.nextSibling;
    insertChildAt(parentNode, node, referenceNode);
    if (node === closingComment) {
      break;
    }
    node = nextNode;
  }
}

function removeDelimitedText(parentNode, startNode, closingComment) {
  while (true) {
    var node = startNode.nextSibling;
    if (node === closingComment) {
      // The closing comment is removed by ReactMultiChild.
      break;
    } else {
      parentNode.removeChild(node);
    }
  }
}

function replaceDelimitedText(openingComment, closingComment, stringText) {
  var parentNode = openingComment.parentNode;
  var nodeAfterComment = openingComment.nextSibling;
  if (nodeAfterComment === closingComment) {
    // There are no text nodes between the opening and closing comments; insert
    // a new one if stringText isn't empty.
    if (stringText) {
      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
    }
  } else {
    if (stringText) {
      // Set the text content of the first node after the opening comment, and
      // remove all following nodes up until the closing comment.
      setTextContent(nodeAfterComment, stringText);
      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
    } else {
      removeDelimitedText(parentNode, openingComment, closingComment);
    }
  }

  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID,
      type: 'replace text',
      payload: stringText
    });
  }
}

var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
if (process.env.NODE_ENV !== 'production') {
  dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
    if (prevInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: prevInstance._debugID,
        type: 'replace with',
        payload: markup.toString()
      });
    } else {
      var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
      if (nextInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onHostOperation({
          instanceID: nextInstance._debugID,
          type: 'mount',
          payload: markup.toString()
        });
      }
    }
  };
}

/**
 * Operations for updating with DOM children.
 */
var DOMChildrenOperations = {
  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,

  replaceDelimitedText: replaceDelimitedText,

  /**
   * Updates a component's children by processing a series of updates. The
   * update configurations are each expected to have a `parentNode` property.
   *
   * @param {array<object>} updates List of update configurations.
   * @internal
   */
  processUpdates: function (parentNode, updates) {
    if (process.env.NODE_ENV !== 'production') {
      var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
    }

    for (var k = 0; k < updates.length; k++) {
      var update = updates[k];
      switch (update.type) {
        case 'INSERT_MARKUP':
          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
          if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'insert child',
              payload: {
                toIndex: update.toIndex,
                content: update.content.toString()
              }
            });
          }
          break;
        case 'MOVE_EXISTING':
          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
          if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'move child',
              payload: { fromIndex: update.fromIndex, toIndex: update.toIndex }
            });
          }
          break;
        case 'SET_MARKUP':
          setInnerHTML(parentNode, update.content);
          if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'replace children',
              payload: update.content.toString()
            });
          }
          break;
        case 'TEXT_CONTENT':
          setTextContent(parentNode, update.content);
          if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'replace text',
              payload: update.content.toString()
            });
          }
          break;
        case 'REMOVE_NODE':
          removeChild(parentNode, update.fromNode);
          if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'remove child',
              payload: { fromIndex: update.fromIndex }
            });
          }
          break;
      }
    }
  }
};

module.exports = DOMChildrenOperations;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMNamespaces = {
  html: 'http://www.w3.org/1999/xhtml',
  mathml: 'http://www.w3.org/1998/Math/MathML',
  svg: 'http://www.w3.org/2000/svg'
};

module.exports = DOMNamespaces;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/* globals MSApp */



/**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */

var createMicrosoftUnsafeLocalFunction = function (func) {
  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
    return function (arg0, arg1, arg2, arg3) {
      MSApp.execUnsafeLocalFunction(function () {
        return func(arg0, arg1, arg2, arg3);
      });
    };
  } else {
    return func;
  }
};

module.exports = createMicrosoftUnsafeLocalFunction;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(7);

var ReactPropTypesSecret = __webpack_require__(202);
var propTypesFactory = __webpack_require__(187);

var React = __webpack_require__(62);
var PropTypes = propTypesFactory(React.isValidElement);

var invariant = __webpack_require__(2);
var warning = __webpack_require__(3);

var hasReadOnlyValue = {
  button: true,
  checkbox: true,
  image: true,
  hidden: true,
  radio: true,
  reset: true,
  submit: true
};

function _assertSingleLink(inputProps) {
  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
}
function _assertValueLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
}

function _assertCheckedLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
}

var propTypes = {
  value: function (props, propName, componentName) {
    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  checked: function (props, propName, componentName) {
    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  onChange: PropTypes.func
};

var loggedTypeFailures = {};
function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Provide a linked `value` attribute for controlled forms. You should not use
 * this outside of the ReactDOM controlled form components.
 */
var LinkedValueUtils = {
  checkPropTypes: function (tagName, props, owner) {
    for (var propName in propTypes) {
      if (propTypes.hasOwnProperty(propName)) {
        var error = propTypes[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret);
      }
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var addendum = getDeclarationErrorAddendum(owner);
        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
      }
    }
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current value of the input either from value prop or link.
   */
  getValue: function (inputProps) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.value;
    }
    return inputProps.value;
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current checked status of the input either from checked prop
   *             or link.
   */
  getChecked: function (inputProps) {
    if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.value;
    }
    return inputProps.checked;
  },

  /**
   * @param {object} inputProps Props for form component
   * @param {SyntheticEvent} event change event to handle
   */
  executeOnChange: function (inputProps, event) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.requestChange(event.target.value);
    } else if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.requestChange(event.target.checked);
    } else if (inputProps.onChange) {
      return inputProps.onChange.call(undefined, event);
    }
  }
};

module.exports = LinkedValueUtils;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(7);

var invariant = __webpack_require__(2);

var injected = false;

var ReactComponentEnvironment = {
  /**
   * Optionally injectable hook for swapping out mount images in the middle of
   * the tree.
   */
  replaceNodeWithMarkup: null,

  /**
   * Optionally injectable hook for processing a queue of child updates. Will
   * later move into MultiChildComponents.
   */
  processChildrenUpdates: null,

  injection: {
    injectEnvironment: function (environment) {
      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
      ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
      injected = true;
    }
  }
};

module.exports = ReactComponentEnvironment;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */



var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Given a `prevElement` and `nextElement`, determines if the existing
 * instance should be updated as opposed to being destroyed or replaced by a new
 * instance. Both arguments are elements. This ensures that this logic can
 * operate on stateless trees without any backing instance.
 *
 * @param {?object} prevElement
 * @param {?object} nextElement
 * @return {boolean} True if the existing instance should be updated.
 * @protected
 */

function shouldUpdateReactComponent(prevElement, nextElement) {
  var prevEmpty = prevElement === null || prevElement === false;
  var nextEmpty = nextElement === null || nextElement === false;
  if (prevEmpty || nextEmpty) {
    return prevEmpty === nextEmpty;
  }

  var prevType = typeof prevElement;
  var nextType = typeof nextElement;
  if (prevType === 'string' || prevType === 'number') {
    return nextType === 'string' || nextType === 'number';
  } else {
    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
  }
}

module.exports = shouldUpdateReactComponent;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * Unescape and unwrap key for human-readable display
 *
 * @param {string} key to unescape.
 * @return {string} the unescaped key.
 */
function unescape(key) {
  var unescapeRegex = /(=0|=2)/g;
  var unescaperLookup = {
    '=0': '=',
    '=2': ':'
  };
  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

  return ('' + keySubstring).replace(unescapeRegex, function (match) {
    return unescaperLookup[match];
  });
}

var KeyEscapeUtils = {
  escape: escape,
  unescape: unescape
};

module.exports = KeyEscapeUtils;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(7);

var ReactCurrentOwner = __webpack_require__(37);
var ReactInstanceMap = __webpack_require__(72);
var ReactInstrumentation = __webpack_require__(27);
var ReactUpdates = __webpack_require__(38);

var invariant = __webpack_require__(2);
var warning = __webpack_require__(3);

function enqueueUpdate(internalInstance) {
  ReactUpdates.enqueueUpdate(internalInstance);
}

function formatUnexpectedArgument(arg) {
  var type = typeof arg;
  if (type !== 'object') {
    return type;
  }
  var displayName = arg.constructor && arg.constructor.name || type;
  var keys = Object.keys(arg);
  if (keys.length > 0 && keys.length < 20) {
    return displayName + ' (keys: ' + keys.join(', ') + ')';
  }
  return displayName;
}

function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
  var internalInstance = ReactInstanceMap.get(publicInstance);
  if (!internalInstance) {
    if (process.env.NODE_ENV !== 'production') {
      var ctor = publicInstance.constructor;
      // Only warn when we have a callerName. Otherwise we should be silent.
      // We're probably calling from enqueueCallback. We don't want to warn
      // there because we already warned for the corresponding lifecycle method.
      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
    }
    return null;
  }

  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + "within `render` or another component's constructor). Render methods " + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
  }

  return internalInstance;
}

/**
 * ReactUpdateQueue allows for state updates to be scheduled into a later
 * reconciliation step.
 */
var ReactUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    if (process.env.NODE_ENV !== 'production') {
      var owner = ReactCurrentOwner.current;
      if (owner !== null) {
        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
        owner._warnedAboutRefsInRender = true;
      }
    }
    var internalInstance = ReactInstanceMap.get(publicInstance);
    if (internalInstance) {
      // During componentWillMount and render this will still be null but after
      // that will always render to something. At least for now. So we can use
      // this hack.
      return !!internalInstance._renderedComponent;
    } else {
      return false;
    }
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @param {string} callerName Name of the calling function in the public API.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback, callerName) {
    ReactUpdateQueue.validateCallback(callback, callerName);
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

    // Previously we would throw an error if we didn't have an internal
    // instance. Since we want to make it a no-op instead, we mirror the same
    // behavior we have in other enqueue* methods.
    // We also need to ignore callbacks in componentWillMount. See
    // enqueueUpdates.
    if (!internalInstance) {
      return null;
    }

    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    // TODO: The callback here is ignored when setState is called from
    // componentWillMount. Either fix it or disallow doing so completely in
    // favor of getInitialState. Alternatively, we can disallow
    // componentWillMount during server-side rendering.
    enqueueUpdate(internalInstance);
  },

  enqueueCallbackInternal: function (internalInstance, callback) {
    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    enqueueUpdate(internalInstance);
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingForceUpdate = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingStateQueue = [completeState];
    internalInstance._pendingReplaceState = true;

    // Future-proof 15.5
    if (callback !== undefined && callback !== null) {
      ReactUpdateQueue.validateCallback(callback, 'replaceState');
      if (internalInstance._pendingCallbacks) {
        internalInstance._pendingCallbacks.push(callback);
      } else {
        internalInstance._pendingCallbacks = [callback];
      }
    }

    enqueueUpdate(internalInstance);
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    if (process.env.NODE_ENV !== 'production') {
      ReactInstrumentation.debugTool.onSetState();
      process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
    }

    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

    if (!internalInstance) {
      return;
    }

    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
    queue.push(partialState);

    enqueueUpdate(internalInstance);
  },

  enqueueElementInternal: function (internalInstance, nextElement, nextContext) {
    internalInstance._pendingElement = nextElement;
    // TODO: introduce _pendingContext instead of setting it directly.
    internalInstance._context = nextContext;
    enqueueUpdate(internalInstance);
  },

  validateCallback: function (callback, callerName) {
    !(!callback || typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
  }
};

module.exports = ReactUpdateQueue;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(10);

var emptyFunction = __webpack_require__(26);
var warning = __webpack_require__(3);

var validateDOMNesting = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.

  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
  var buttonScopeTags = inScopeTags.concat(['button']);

  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

  var emptyAncestorInfo = {
    current: null,

    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,

    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  var updatedAncestorInfo = function (oldInfo, tag, instance) {
    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
    var info = { tag: tag, instance: instance };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }
    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    }

    // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.current = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }
    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }
    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }
    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }
    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }
    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }
    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };

  /**
   * Returns whether
   */
  var isTagValidWithParent = function (tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';
      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but
      case 'option':
        return tag === '#text';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      case 'colgroup':
        return tag === 'col' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      case 'html':
        return tag === 'head' || tag === 'body';
      case '#document':
        return tag === 'html';
    }

    // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'body':
      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frame':
      case 'head':
      case 'html':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };

  /**
   * Returns whether
   */
  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':
      case 'pre':
      case 'listing':
      case 'table':
      case 'hr':
      case 'xmp':
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  /**
   * Given a ReactCompositeComponent instance, return a list of its recursive
   * owners, starting at the root and ending with the instance itself.
   */
  var findOwnerStack = function (instance) {
    if (!instance) {
      return [];
    }

    var stack = [];
    do {
      stack.push(instance);
    } while (instance = instance._currentElement._owner);
    stack.reverse();
    return stack;
  };

  var didWarn = {};

  validateDOMNesting = function (childTag, childText, childInstance, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;

    if (childText != null) {
      process.env.NODE_ENV !== 'production' ? warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;
      childTag = '#text';
    }

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var problematic = invalidParent || invalidAncestor;

    if (problematic) {
      var ancestorTag = problematic.tag;
      var ancestorInstance = problematic.instance;

      var childOwner = childInstance && childInstance._currentElement._owner;
      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;

      var childOwners = findOwnerStack(childOwner);
      var ancestorOwners = findOwnerStack(ancestorOwner);

      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
      var i;

      var deepestCommon = -1;
      for (i = 0; i < minStackLen; i++) {
        if (childOwners[i] === ancestorOwners[i]) {
          deepestCommon = i;
        } else {
          break;
        }
      }

      var UNKNOWN = '(unknown)';
      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ownerInfo = [].concat(
      // If the parent and child instances have a common owner ancestor, start
      // with that -- otherwise we just start with the parent's owners.
      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
      // If we're warning about an invalid (non-parent) ancestry, add '...'
      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');

      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
      if (didWarn[warnKey]) {
        return;
      }
      didWarn[warnKey] = true;

      var tagDisplayName = childTag;
      var whitespaceInfo = '';
      if (childTag === '#text') {
        if (/\S/.test(childText)) {
          tagDisplayName = 'Text nodes';
        } else {
          tagDisplayName = 'Whitespace text nodes';
          whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + 'each line of your source code.';
        }
      } else {
        tagDisplayName = '<' + childTag + '>';
      }

      if (invalidParent) {
        var info = '';
        if (ancestorTag === 'table' && childTag === 'tr') {
          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
        }
        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s ' + 'See %s.%s', tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
      } else {
        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
      }
    }
  };

  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;

  // For testing
  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;
    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
  };
}

module.exports = validateDOMNesting;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */

function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

module.exports = getEventCharCode;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element') || 0xeac7;

  var isValidElement = function (object) {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(188)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(538)();
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = warning;
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _baseGetTag = __webpack_require__(545);

var _baseGetTag2 = _interopRequireDefault(_baseGetTag);

var _getPrototype = __webpack_require__(550);

var _getPrototype2 = _interopRequireDefault(_getPrototype);

var _isObjectLike = __webpack_require__(552);

var _isObjectLike2 = _interopRequireDefault(_isObjectLike);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!(0, _isObjectLike2.default)(value) || (0, _baseGetTag2.default)(value) != objectTag) {
    return false;
  }
  var proto = (0, _getPrototype2.default)(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}

exports.default = isPlainObject;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _redux = __webpack_require__(97);

var _counter = __webpack_require__(565);

var _counter2 = _interopRequireDefault(_counter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const rootReducer = (0, _redux.combineReducers)({
  counter: _counter2.default
});

exports.default = rootReducer;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function () {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function () {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['CloseCurlyDoubleQuote', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['CloseCurlyQuote', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];

var alphaIndex = {};
var charIndex = {};

createIndexes(alphaIndex, charIndex);

/**
 * @constructor
 */
function Html5Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.decode = function (str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function (s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1) === 'x' ? parseInt(entity.substr(2).toLowerCase(), 16) : parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.decode = function (str) {
    return new Html5Entities().decode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encode = function (str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var charInfo = charIndex[str.charCodeAt(i)];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        result += str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.encode = function (str) {
    return new Html5Entities().encode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonUTF = function (str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var charInfo = charIndex[c];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.encodeNonUTF = function (str) {
    return new Html5Entities().encodeNonUTF(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonASCII = function (str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.encodeNonASCII = function (str) {
    return new Html5Entities().encodeNonASCII(str);
};

/**
 * @param {Object} alphaIndex Passed by reference.
 * @param {Object} charIndex Passed by reference.
 */
function createIndexes(alphaIndex, charIndex) {
    var i = ENTITIES.length;
    var _results = [];
    while (i--) {
        var e = ENTITIES[i];
        var alpha = e[0];
        var chars = e[1];
        var chr = chars[0];
        var addChar = chr < 32 || chr > 126 || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;
        var charInfo;
        if (addChar) {
            charInfo = charIndex[chr] = charIndex[chr] || {};
        }
        if (chars[1]) {
            var chr2 = chars[1];
            alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);
            _results.push(addChar && (charInfo[chr2] = alpha));
        } else {
            alphaIndex[alpha] = String.fromCharCode(chr);
            _results.push(addChar && (charInfo[''] = alpha));
        }
    }
}

module.exports = Html5Entities;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = !__webpack_require__(11) && !__webpack_require__(6)(function () {
  return Object.defineProperty(__webpack_require__(98)('div'), 'a', { get: function () {
      return 7;
    } }).a != 7;
});

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.f = __webpack_require__(9);

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(18);
var toIObject = __webpack_require__(23);
var arrayIndexOf = __webpack_require__(75)(false);
var IE_PROTO = __webpack_require__(100)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var dP = __webpack_require__(12);
var anObject = __webpack_require__(4);
var getKeys = __webpack_require__(48);

module.exports = __webpack_require__(11) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(23);
var gOPN = __webpack_require__(51).f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)

var getKeys = __webpack_require__(48);
var gOPS = __webpack_require__(76);
var pIE = __webpack_require__(67);
var toObject = __webpack_require__(15);
var IObject = __webpack_require__(66);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(6)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) {
    B[k] = k;
  });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  }return T;
} : $assign;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var aFunction = __webpack_require__(17);
var isObject = __webpack_require__(8);
var invoke = __webpack_require__(155);
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  }return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function () /* args... */{
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
                  var un = that === undefined;
                  switch (args.length) {
                                    case 0:
                                                      return un ? fn() : fn.call(that);
                                    case 1:
                                                      return un ? fn(args[0]) : fn.call(that, args[0]);
                                    case 2:
                                                      return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
                                    case 3:
                                                      return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
                                    case 4:
                                                      return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
                  }return fn.apply(that, args);
};

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $parseInt = __webpack_require__(5).parseInt;
var $trim = __webpack_require__(59).trim;
var ws = __webpack_require__(104);
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
} : $parseInt;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $parseFloat = __webpack_require__(5).parseFloat;
var $trim = __webpack_require__(59).trim;

module.exports = 1 / $parseFloat(__webpack_require__(104) + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var cof = __webpack_require__(29);
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(8);
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.2.2.16 Math.fround(x)
var sign = __webpack_require__(107);
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// call something on iterator step with safe closing on error
var anObject = __webpack_require__(4);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var aFunction = __webpack_require__(17);
var toObject = __webpack_require__(15);
var IObject = __webpack_require__(66);
var toLength = __webpack_require__(13);

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (; isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)


var toObject = __webpack_require__(15);
var toAbsoluteIndex = __webpack_require__(49);
var toLength = __webpack_require__(13);

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];else delete O[to];
    to += inc;
    from += inc;
  }return O;
};

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (done, value) {
  return { value: value, done: !!done };
};

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__(11) && /./g.flags != 'g') __webpack_require__(12).f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(80)
});

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(4);
var isObject = __webpack_require__(8);
var newPromiseCapability = __webpack_require__(122);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var strong = __webpack_require__(170);
var validate = __webpack_require__(61);
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__(83)(MAP, function (get) {
  return function Map() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var dP = __webpack_require__(12).f;
var create = __webpack_require__(50);
var redefineAll = __webpack_require__(55);
var ctx = __webpack_require__(28);
var anInstance = __webpack_require__(53);
var forOf = __webpack_require__(54);
var $iterDefine = __webpack_require__(110);
var step = __webpack_require__(165);
var setSpecies = __webpack_require__(52);
var DESCRIPTORS = __webpack_require__(11);
var fastKey = __webpack_require__(42).fastKey;
var validate = __webpack_require__(61);
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type
      that._i = create(null); // index
      that._f = undefined; // first entry
      that._l = undefined; // last entry
      that[SIZE] = 0; // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        }return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
      // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key, // <- key
        v: value, // <- value
        p: prev = that._l, // <- previous entry
        n: undefined, // <- next entry
        r: false // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    }return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind; // kind
      this._l = undefined; // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var strong = __webpack_require__(170);
var validate = __webpack_require__(61);
var SET = 'Set';

// 23.2 Set Objects
module.exports = __webpack_require__(83)(SET, function (get) {
  return function Set() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var each = __webpack_require__(36)(0);
var redefine = __webpack_require__(20);
var meta = __webpack_require__(42);
var assign = __webpack_require__(153);
var weak = __webpack_require__(173);
var isObject = __webpack_require__(8);
var fails = __webpack_require__(6);
var validate = __webpack_require__(61);
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = __webpack_require__(83)(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () {
  return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7;
})) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
        // store all the rest on native weakmap
      }return method.call(this, a, b);
    });
  });
}

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var redefineAll = __webpack_require__(55);
var getWeak = __webpack_require__(42).getWeak;
var anObject = __webpack_require__(4);
var isObject = __webpack_require__(8);
var anInstance = __webpack_require__(53);
var forOf = __webpack_require__(54);
var createArrayMethod = __webpack_require__(36);
var $has = __webpack_require__(18);
var validate = __webpack_require__(61);
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type
      that._i = id++; // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__(34);
var toLength = __webpack_require__(13);
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// all object keys, includes non-enumerable and symbols
var gOPN = __webpack_require__(51);
var gOPS = __webpack_require__(76);
var anObject = __webpack_require__(4);
var Reflect = __webpack_require__(5).Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray

var isArray = __webpack_require__(77);
var isObject = __webpack_require__(8);
var toLength = __webpack_require__(13);
var ctx = __webpack_require__(28);
var IS_CONCAT_SPREADABLE = __webpack_require__(9)('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(13);
var repeat = __webpack_require__(106);
var defined = __webpack_require__(33);

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getKeys = __webpack_require__(48);
var toIObject = __webpack_require__(23);
var isEnum = __webpack_require__(67).f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) if (isEnum.call(O, key = keys[i++])) {
      result.push(isEntries ? [key, O[key]] : O[key]);
    }return result;
  };
};

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(68);
var from = __webpack_require__(180);
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var forOf = __webpack_require__(54);

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (arguments.length === 0
  // eslint-disable-next-line no-self-compare
  || x != x
  // eslint-disable-next-line no-self-compare
  || inLow != inLow
  // eslint-disable-next-line no-self-compare
  || inHigh != inHigh
  // eslint-disable-next-line no-self-compare
  || outLow != outLow
  // eslint-disable-next-line no-self-compare
  || outHigh != outHigh) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(63),
    _assign = __webpack_require__(10);

var ReactNoopUpdateQueue = __webpack_require__(183);

var canDefineProperty = __webpack_require__(89);
var emptyObject = __webpack_require__(90);
var invariant = __webpack_require__(2);
var lowPriorityWarning = __webpack_require__(124);

/**
 * Base class helpers for the updating state of a component.
 */
function ReactComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

ReactComponent.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
ReactComponent.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
  this.updater.enqueueSetState(this, partialState);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'setState');
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
ReactComponent.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'forceUpdate');
  }
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
if (process.env.NODE_ENV !== 'production') {
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };
  var defineDeprecationWarning = function (methodName, info) {
    if (canDefineProperty) {
      Object.defineProperty(ReactComponent.prototype, methodName, {
        get: function () {
          lowPriorityWarning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
          return undefined;
        }
      });
    }
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

/**
 * Base class helpers for the updating state of a component.
 */
function ReactPureComponent(props, context, updater) {
  // Duplicated from ReactComponent.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

function ComponentDummy() {}
ComponentDummy.prototype = ReactComponent.prototype;
ReactPureComponent.prototype = new ComponentDummy();
ReactPureComponent.prototype.constructor = ReactPureComponent;
// Avoid an extra prototype jump for these methods.
_assign(ReactPureComponent.prototype, ReactComponent.prototype);
ReactPureComponent.prototype.isPureReactComponent = true;

module.exports = {
  Component: ReactComponent,
  PureComponent: ReactPureComponent
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var warning = __webpack_require__(3);

function warnNoop(publicInstance, callerName) {
  if (process.env.NODE_ENV !== 'production') {
    var constructor = publicInstance.constructor;
    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback) {},

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    warnNoop(publicInstance, 'setState');
  }
};

module.exports = ReactNoopUpdateQueue;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



// The Symbol used to tag the ReactElement type. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.

var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

module.exports = REACT_ELEMENT_TYPE;

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/* global Symbol */

var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

/**
 * Returns the iterator method function contained on the iterable object.
 *
 * Be sure to invoke the function with the iterable as context:
 *
 *     var iteratorFn = getIteratorFn(myIterable);
 *     if (iteratorFn) {
 *       var iterator = iteratorFn.call(myIterable);
 *       ...
 *     }
 *
 * @param {?object} maybeIterable
 * @return {?function}
 */
function getIteratorFn(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

module.exports = getIteratorFn;

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */



var ReactCurrentOwner = __webpack_require__(37);
var ReactComponentTreeHook = __webpack_require__(22);
var ReactElement = __webpack_require__(56);

var checkReactTypeSpec = __webpack_require__(442);

var canDefineProperty = __webpack_require__(89);
var getIteratorFn = __webpack_require__(185);
var warning = __webpack_require__(3);
var lowPriorityWarning = __webpack_require__(124);

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = ReactCurrentOwner.current.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

function getSourceInfoErrorAddendum(elementProps) {
  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
    var source = elementProps.__source;
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return ' Check your code at ' + fileName + ':' + lineNumber + '.';
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      info = ' Check the top-level render call using <' + parentName + '>.';
    }
  }
  return info;
}

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});

  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
  if (memoizer[currentComponentErrorInfo]) {
    return;
  }
  memoizer[currentComponentErrorInfo] = true;

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwner = '';
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
  }

  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (ReactElement.isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (ReactElement.isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    // Entry iterators provide implicit keys.
    if (iteratorFn) {
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (ReactElement.isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var componentClass = element.type;
  if (typeof componentClass !== 'function') {
    return;
  }
  var name = componentClass.displayName || componentClass.name;
  if (componentClass.propTypes) {
    checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
  }
}

var ReactElementValidator = {
  createElement: function (type, props, children) {
    var validType = typeof type === 'string' || typeof type === 'function';
    // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.
    if (!validType) {
      if (typeof type !== 'function' && typeof type !== 'string') {
        var info = '';
        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + "it's defined in.";
        }

        var sourceInfo = getSourceInfoErrorAddendum(props);
        if (sourceInfo) {
          info += sourceInfo;
        } else {
          info += getDeclarationErrorAddendum();
        }

        info += ReactComponentTreeHook.getCurrentStackAddendum();

        var currentSource = props !== null && props !== undefined && props.__source !== undefined ? props.__source : null;
        ReactComponentTreeHook.pushNonStandardWarningStack(true, currentSource);
        process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info) : void 0;
        ReactComponentTreeHook.popNonStandardWarningStack();
      }
    }

    var element = ReactElement.createElement.apply(this, arguments);

    // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.
    if (element == null) {
      return element;
    }

    // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)
    if (validType) {
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], type);
      }
    }

    validatePropTypes(element);

    return element;
  },

  createFactory: function (type) {
    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
    // Legacy hook TODO: Warn if this is accessed
    validatedFactory.type = type;

    if (process.env.NODE_ENV !== 'production') {
      if (canDefineProperty) {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function () {
            lowPriorityWarning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }
    }

    return validatedFactory;
  },

  cloneElement: function (element, props, children) {
    var newElement = ReactElement.cloneElement.apply(this, arguments);
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], newElement.type);
    }
    validatePropTypes(newElement);
    return newElement;
  }
};

module.exports = ReactElementValidator;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



// React 15.5 references this module, and assumes PropTypes are still callable in production.
// Therefore we re-export development-only version with all the PropTypes checks here.
// However if one is migrating to the `prop-types` npm library, they will go through the
// `index.js` entry point, and it will branch depending on the environment.

var factory = __webpack_require__(188);
module.exports = function (isValidElement) {
  // It is still allowed in 15.5.
  var throwOnDirectAccess = false;
  return factory(isValidElement, throwOnDirectAccess);
};

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var emptyFunction = __webpack_require__(26);
var invariant = __webpack_require__(2);
var warning = __webpack_require__(3);

var ReactPropTypesSecret = __webpack_require__(125);
var checkPropTypes = __webpack_require__(446);

module.exports = function (isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (!manualPropTypeCallCache[cacheKey] &&
          // Avoid spamming the console because they are often not actionable except for lib authors
          manualPropTypeWarningCount < 3) {
            warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName);
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(false, 'Invalid argument supplid to oneOfType. Expected an array of check functions, but ' + 'received %s at index %s.', getPostfixForTypeWarning(checker), i);
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactDOMComponentFlags = {
  hasCachedChildNodes: 1 << 0
};

module.exports = ReactDOMComponentFlags;

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(7);

var invariant = __webpack_require__(2);

/**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;

  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  if (Array.isArray(current)) {
    if (Array.isArray(next)) {
      current.push.apply(current, next);
      return current;
    }
    current.push(next);
    return current;
  }

  if (Array.isArray(next)) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

module.exports = accumulateInto;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 */

function forEachAccumulated(arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
}

module.exports = forEachAccumulated;

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ExecutionEnvironment = __webpack_require__(16);

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor() {
  if (!contentKey && ExecutionEnvironment.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
  }
  return contentKey;
}

module.exports = getTextContentAccessor;

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(7);

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var PooledClass = __webpack_require__(57);

var invariant = __webpack_require__(2);

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.getPooled()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
  function CallbackQueue(arg) {
    _classCallCheck(this, CallbackQueue);

    this._callbacks = null;
    this._contexts = null;
    this._arg = arg;
  }

  /**
   * Enqueues a callback to be invoked when `notifyAll` is invoked.
   *
   * @param {function} callback Invoked when `notifyAll` is invoked.
   * @param {?object} context Context to call `callback` with.
   * @internal
   */

  CallbackQueue.prototype.enqueue = function enqueue(callback, context) {
    this._callbacks = this._callbacks || [];
    this._callbacks.push(callback);
    this._contexts = this._contexts || [];
    this._contexts.push(context);
  };

  /**
   * Invokes all enqueued callbacks and clears the queue. This is invoked after
   * the DOM representation of a component has been created or updated.
   *
   * @internal
   */

  CallbackQueue.prototype.notifyAll = function notifyAll() {
    var callbacks = this._callbacks;
    var contexts = this._contexts;
    var arg = this._arg;
    if (callbacks && contexts) {
      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
      this._callbacks = null;
      this._contexts = null;
      for (var i = 0; i < callbacks.length; i++) {
        callbacks[i].call(contexts[i], arg);
      }
      callbacks.length = 0;
      contexts.length = 0;
    }
  };

  CallbackQueue.prototype.checkpoint = function checkpoint() {
    return this._callbacks ? this._callbacks.length : 0;
  };

  CallbackQueue.prototype.rollback = function rollback(len) {
    if (this._callbacks && this._contexts) {
      this._callbacks.length = len;
      this._contexts.length = len;
    }
  };

  /**
   * Resets the internal queue.
   *
   * @internal
   */

  CallbackQueue.prototype.reset = function reset() {
    this._callbacks = null;
    this._contexts = null;
  };

  /**
   * `PooledClass` looks for this.
   */

  CallbackQueue.prototype.destructor = function destructor() {
    this.reset();
  };

  return CallbackQueue;
}();

module.exports = PooledClass.addPoolingTo(CallbackQueue);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactFeatureFlags = {
  // When true, call console.time() before and .timeEnd() after each top-level
  // render (both initial renders and updates). Useful when looking at prod-mode
  // timeline profiles in Chrome, for example.
  logTopLevelRenders: false
};

module.exports = ReactFeatureFlags;

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactDOMComponentTree = __webpack_require__(14);

function isCheckable(elem) {
  var type = elem.type;
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
}

function getTracker(inst) {
  return inst._wrapperState.valueTracker;
}

function attachTracker(inst, tracker) {
  inst._wrapperState.valueTracker = tracker;
}

function detachTracker(inst) {
  delete inst._wrapperState.valueTracker;
}

function getValueFromNode(node) {
  var value;
  if (node) {
    value = isCheckable(node) ? '' + node.checked : node.value;
  }
  return value;
}

var inputValueTracking = {
  // exposed for testing
  _getTrackerFromNode: function (node) {
    return getTracker(ReactDOMComponentTree.getInstanceFromNode(node));
  },

  track: function (inst) {
    if (getTracker(inst)) {
      return;
    }

    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var valueField = isCheckable(node) ? 'checked' : 'value';
    var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);

    var currentValue = '' + node[valueField];

    // if someone has already defined a value or Safari, then bail
    // and don't track value will cause over reporting of changes,
    // but it's better then a hard failure
    // (needed for certain tests that spyOn input values and Safari)
    if (node.hasOwnProperty(valueField) || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
      return;
    }

    Object.defineProperty(node, valueField, {
      enumerable: descriptor.enumerable,
      configurable: true,
      get: function () {
        return descriptor.get.call(this);
      },
      set: function (value) {
        currentValue = '' + value;
        descriptor.set.call(this, value);
      }
    });

    attachTracker(inst, {
      getValue: function () {
        return currentValue;
      },
      setValue: function (value) {
        currentValue = '' + value;
      },
      stopTracking: function () {
        detachTracker(inst);
        delete node[valueField];
      }
    });
  },

  updateValueIfChanged: function (inst) {
    if (!inst) {
      return false;
    }
    var tracker = getTracker(inst);

    if (!tracker) {
      inputValueTracking.track(inst);
      return true;
    }

    var lastValue = tracker.getValue();
    var nextValue = getValueFromNode(ReactDOMComponentTree.getNodeFromInstance(inst));

    if (nextValue !== lastValue) {
      tracker.setValue(nextValue);
      return true;
    }

    return false;
  },
  stopTracking: function (inst) {
    var tracker = getTracker(inst);
    if (tracker) {
      tracker.stopTracking();
    }
  }
};

module.exports = inputValueTracking;

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */

var supportedInputTypes = {
  color: true,
  date: true,
  datetime: true,
  'datetime-local': true,
  email: true,
  month: true,
  number: true,
  password: true,
  range: true,
  search: true,
  tel: true,
  text: true,
  time: true,
  url: true,
  week: true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

  if (nodeName === 'input') {
    return !!supportedInputTypes[elem.type];
  }

  if (nodeName === 'textarea') {
    return true;
  }

  return false;
}

module.exports = isTextInputElement;

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ViewportMetrics = {
  currentScrollLeft: 0,

  currentScrollTop: 0,

  refreshScrollValues: function (scrollPosition) {
    ViewportMetrics.currentScrollLeft = scrollPosition.x;
    ViewportMetrics.currentScrollTop = scrollPosition.y;
  }
};

module.exports = ViewportMetrics;

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ExecutionEnvironment = __webpack_require__(16);
var escapeTextContentForBrowser = __webpack_require__(95);
var setInnerHTML = __webpack_require__(94);

/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */
var setTextContent = function (node, text) {
  if (text) {
    var firstChild = node.firstChild;

    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
};

if (ExecutionEnvironment.canUseDOM) {
  if (!('textContent' in document.documentElement)) {
    setTextContent = function (node, text) {
      if (node.nodeType === 3) {
        node.nodeValue = text;
        return;
      }
      setInnerHTML(node, escapeTextContentForBrowser(text));
    };
  }
}

module.exports = setTextContent;

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * CSS properties which accept numbers but are not in units of "px".
 */

var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Most style properties can be unset by doing .style[prop] = '' but IE8
 * doesn't like doing that with shorthand properties so for the properties that
 * IE8 breaks on, which are listed here, we instead unset each of the
 * individual properties. See http://bugs.jquery.com/ticket/12385.
 * The 4-value 'clock' properties like margin, padding, border-width seem to
 * behave without any problems. Curiously, list-style works too without any
 * special prodding.
 */
var shorthandPropertyExpansions = {
  background: {
    backgroundAttachment: true,
    backgroundColor: true,
    backgroundImage: true,
    backgroundPositionX: true,
    backgroundPositionY: true,
    backgroundRepeat: true
  },
  backgroundPosition: {
    backgroundPositionX: true,
    backgroundPositionY: true
  },
  border: {
    borderWidth: true,
    borderStyle: true,
    borderColor: true
  },
  borderBottom: {
    borderBottomWidth: true,
    borderBottomStyle: true,
    borderBottomColor: true
  },
  borderLeft: {
    borderLeftWidth: true,
    borderLeftStyle: true,
    borderLeftColor: true
  },
  borderRight: {
    borderRightWidth: true,
    borderRightStyle: true,
    borderRightColor: true
  },
  borderTop: {
    borderTopWidth: true,
    borderTopStyle: true,
    borderTopColor: true
  },
  font: {
    fontStyle: true,
    fontVariant: true,
    fontWeight: true,
    fontSize: true,
    lineHeight: true,
    fontFamily: true
  },
  outline: {
    outlineWidth: true,
    outlineStyle: true,
    outlineColor: true
  }
};

var CSSProperty = {
  isUnitlessNumber: isUnitlessNumber,
  shorthandPropertyExpansions: shorthandPropertyExpansions
};

module.exports = CSSProperty;

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMProperty = __webpack_require__(44);
var ReactDOMComponentTree = __webpack_require__(14);
var ReactInstrumentation = __webpack_require__(27);

var quoteAttributeValueForBrowser = __webpack_require__(485);
var warning = __webpack_require__(3);

var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};

function isAttributeNameSafe(attributeName) {
  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
    return true;
  }
  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
    return false;
  }
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }
  illegalAttributeNameCache[attributeName] = true;
  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
  return false;
}

function shouldIgnoreValue(propertyInfo, value) {
  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
}

/**
 * Operations for dealing with DOM properties.
 */
var DOMPropertyOperations = {
  /**
   * Creates markup for the ID property.
   *
   * @param {string} id Unescaped ID.
   * @return {string} Markup string.
   */
  createMarkupForID: function (id) {
    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
  },

  setAttributeForID: function (node, id) {
    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
  },

  createMarkupForRoot: function () {
    return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
  },

  setAttributeForRoot: function (node) {
    node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
  },

  /**
   * Creates markup for a property.
   *
   * @param {string} name
   * @param {*} value
   * @return {?string} Markup string, or null if the property was invalid.
   */
  createMarkupForProperty: function (name, value) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      if (shouldIgnoreValue(propertyInfo, value)) {
        return '';
      }
      var attributeName = propertyInfo.attributeName;
      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
        return attributeName + '=""';
      }
      return attributeName + '=' + quoteAttributeValueForBrowser(value);
    } else if (DOMProperty.isCustomAttribute(name)) {
      if (value == null) {
        return '';
      }
      return name + '=' + quoteAttributeValueForBrowser(value);
    }
    return null;
  },

  /**
   * Creates markup for a custom property.
   *
   * @param {string} name
   * @param {*} value
   * @return {string} Markup string, or empty string if the property was invalid.
   */
  createMarkupForCustomAttribute: function (name, value) {
    if (!isAttributeNameSafe(name) || value == null) {
      return '';
    }
    return name + '=' + quoteAttributeValueForBrowser(value);
  },

  /**
   * Sets the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   * @param {*} value
   */
  setValueForProperty: function (node, name, value) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, value);
      } else if (shouldIgnoreValue(propertyInfo, value)) {
        this.deleteValueForProperty(node, name);
        return;
      } else if (propertyInfo.mustUseProperty) {
        // Contrary to `setAttribute`, object properties are properly
        // `toString`ed by IE8/9.
        node[propertyInfo.propertyName] = value;
      } else {
        var attributeName = propertyInfo.attributeName;
        var namespace = propertyInfo.attributeNamespace;
        // `setAttribute` with objects becomes only `[object]` in IE8/9,
        // ('' + value) makes it output the correct toString()-value.
        if (namespace) {
          node.setAttributeNS(namespace, attributeName, '' + value);
        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
          node.setAttribute(attributeName, '');
        } else {
          node.setAttribute(attributeName, '' + value);
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      DOMPropertyOperations.setValueForAttribute(node, name, value);
      return;
    }

    if (process.env.NODE_ENV !== 'production') {
      var payload = {};
      payload[name] = value;
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'update attribute',
        payload: payload
      });
    }
  },

  setValueForAttribute: function (node, name, value) {
    if (!isAttributeNameSafe(name)) {
      return;
    }
    if (value == null) {
      node.removeAttribute(name);
    } else {
      node.setAttribute(name, '' + value);
    }

    if (process.env.NODE_ENV !== 'production') {
      var payload = {};
      payload[name] = value;
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'update attribute',
        payload: payload
      });
    }
  },

  /**
   * Deletes an attributes from a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForAttribute: function (node, name) {
    node.removeAttribute(name);
    if (process.env.NODE_ENV !== 'production') {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'remove attribute',
        payload: name
      });
    }
  },

  /**
   * Deletes the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForProperty: function (node, name) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, undefined);
      } else if (propertyInfo.mustUseProperty) {
        var propName = propertyInfo.propertyName;
        if (propertyInfo.hasBooleanValue) {
          node[propName] = false;
        } else {
          node[propName] = '';
        }
      } else {
        node.removeAttribute(propertyInfo.attributeName);
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      node.removeAttribute(name);
    }

    if (process.env.NODE_ENV !== 'production') {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'remove attribute',
        payload: name
      });
    }
  }
};

module.exports = DOMPropertyOperations;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(10);

var LinkedValueUtils = __webpack_require__(134);
var ReactDOMComponentTree = __webpack_require__(14);
var ReactUpdates = __webpack_require__(38);

var warning = __webpack_require__(3);

var didWarnValueLink = false;
var didWarnValueDefaultValue = false;

function updateOptionsIfPendingUpdateAndMounted() {
  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
    this._wrapperState.pendingUpdate = false;

    var props = this._currentElement.props;
    var value = LinkedValueUtils.getValue(props);

    if (value != null) {
      updateOptions(this, Boolean(props.multiple), value);
    }
  }
}

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

var valuePropNames = ['value', 'defaultValue'];

/**
 * Validation function for `value` and `defaultValue`.
 * @private
 */
function checkSelectPropTypes(inst, props) {
  var owner = inst._currentElement._owner;
  LinkedValueUtils.checkPropTypes('select', props, owner);

  if (props.valueLink !== undefined && !didWarnValueLink) {
    process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
    didWarnValueLink = true;
  }

  for (var i = 0; i < valuePropNames.length; i++) {
    var propName = valuePropNames[i];
    if (props[propName] == null) {
      continue;
    }
    var isArray = Array.isArray(props[propName]);
    if (props.multiple && !isArray) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
    } else if (!props.multiple && isArray) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
    }
  }
}

/**
 * @param {ReactDOMComponent} inst
 * @param {boolean} multiple
 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
 * @private
 */
function updateOptions(inst, multiple, propValue) {
  var selectedValue, i;
  var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;

  if (multiple) {
    selectedValue = {};
    for (i = 0; i < propValue.length; i++) {
      selectedValue['' + propValue[i]] = true;
    }
    for (i = 0; i < options.length; i++) {
      var selected = selectedValue.hasOwnProperty(options[i].value);
      if (options[i].selected !== selected) {
        options[i].selected = selected;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    selectedValue = '' + propValue;
    for (i = 0; i < options.length; i++) {
      if (options[i].value === selectedValue) {
        options[i].selected = true;
        return;
      }
    }
    if (options.length) {
      options[0].selected = true;
    }
  }
}

/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */
var ReactDOMSelect = {
  getHostProps: function (inst, props) {
    return _assign({}, props, {
      onChange: inst._wrapperState.onChange,
      value: undefined
    });
  },

  mountWrapper: function (inst, props) {
    if (process.env.NODE_ENV !== 'production') {
      checkSelectPropTypes(inst, props);
    }

    var value = LinkedValueUtils.getValue(props);
    inst._wrapperState = {
      pendingUpdate: false,
      initialValue: value != null ? value : props.defaultValue,
      listeners: null,
      onChange: _handleChange.bind(inst),
      wasMultiple: Boolean(props.multiple)
    };

    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
      didWarnValueDefaultValue = true;
    }
  },

  getSelectValueContext: function (inst) {
    // ReactDOMOption looks at this initial value so the initial generated
    // markup has correct `selected` attributes
    return inst._wrapperState.initialValue;
  },

  postUpdateWrapper: function (inst) {
    var props = inst._currentElement.props;

    // After the initial mount, we control selected-ness manually so don't pass
    // this value down
    inst._wrapperState.initialValue = undefined;

    var wasMultiple = inst._wrapperState.wasMultiple;
    inst._wrapperState.wasMultiple = Boolean(props.multiple);

    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      inst._wrapperState.pendingUpdate = false;
      updateOptions(inst, Boolean(props.multiple), value);
    } else if (wasMultiple !== Boolean(props.multiple)) {
      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
      if (props.defaultValue != null) {
        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
      } else {
        // Revert the select back to its default unselected state.
        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
      }
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  if (this._rootNodeID) {
    this._wrapperState.pendingUpdate = true;
  }
  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
  return returnValue;
}

module.exports = ReactDOMSelect;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(7),
    _assign = __webpack_require__(10);

var ReactCompositeComponent = __webpack_require__(493);
var ReactEmptyComponent = __webpack_require__(206);
var ReactHostComponent = __webpack_require__(207);

var getNextDebugID = __webpack_require__(496);
var invariant = __webpack_require__(2);
var warning = __webpack_require__(3);

// To avoid a cyclic dependency, we create the final class in this module
var ReactCompositeComponentWrapper = function (element) {
  this.construct(element);
};

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Check if the type reference is a known internal type. I.e. not a user
 * provided composite type.
 *
 * @param {function} type
 * @return {boolean} Returns true if this is a valid internal type.
 */
function isInternalComponentType(type) {
  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
}

/**
 * Given a ReactNode, create an instance that will actually be mounted.
 *
 * @param {ReactNode} node
 * @param {boolean} shouldHaveDebugID
 * @return {object} A new instance of the element's constructor.
 * @protected
 */
function instantiateReactComponent(node, shouldHaveDebugID) {
  var instance;

  if (node === null || node === false) {
    instance = ReactEmptyComponent.create(instantiateReactComponent);
  } else if (typeof node === 'object') {
    var element = node;
    var type = element.type;
    if (typeof type !== 'function' && typeof type !== 'string') {
      var info = '';
      if (process.env.NODE_ENV !== 'production') {
        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + "it's defined in.";
        }
      }
      info += getDeclarationErrorAddendum(element._owner);
       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info) : _prodInvariant('130', type == null ? type : typeof type, info) : void 0;
    }

    // Special case string values
    if (typeof element.type === 'string') {
      instance = ReactHostComponent.createInternalComponent(element);
    } else if (isInternalComponentType(element.type)) {
      // This is temporarily available for custom components that are not string
      // representations. I.e. ART. Once those are updated to use the string
      // representation, we can drop this code path.
      instance = new element.type(element);

      // We renamed this. Allow the old name for compat. :(
      if (!instance.getHostNode) {
        instance.getHostNode = instance.getNativeNode;
      }
    } else {
      instance = new ReactCompositeComponentWrapper(element);
    }
  } else if (typeof node === 'string' || typeof node === 'number') {
    instance = ReactHostComponent.createInstanceForText(node);
  } else {
     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : _prodInvariant('131', typeof node) : void 0;
  }

  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
  }

  // These two fields are used by the DOM and ART diffing algorithms
  // respectively. Instead of using expandos on components, we should be
  // storing the state needed by the diffing algorithms elsewhere.
  instance._mountIndex = 0;
  instance._mountImage = null;

  if (process.env.NODE_ENV !== 'production') {
    instance._debugID = shouldHaveDebugID ? getNextDebugID() : 0;
  }

  // Internal instances should fully constructed at this point, so they should
  // not get any new fields added to them at this point.
  if (process.env.NODE_ENV !== 'production') {
    if (Object.preventExtensions) {
      Object.preventExtensions(instance);
    }
  }

  return instance;
}

_assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, {
  _instantiateReactComponent: instantiateReactComponent
});

module.exports = instantiateReactComponent;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(7);

var React = __webpack_require__(62);

var invariant = __webpack_require__(2);

var ReactNodeTypes = {
  HOST: 0,
  COMPOSITE: 1,
  EMPTY: 2,

  getType: function (node) {
    if (node === null || node === false) {
      return ReactNodeTypes.EMPTY;
    } else if (React.isValidElement(node)) {
      if (typeof node.type === 'function') {
        return ReactNodeTypes.COMPOSITE;
      } else {
        return ReactNodeTypes.HOST;
      }
    }
     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
  }
};

module.exports = ReactNodeTypes;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var emptyComponentFactory;

var ReactEmptyComponentInjection = {
  injectEmptyComponentFactory: function (factory) {
    emptyComponentFactory = factory;
  }
};

var ReactEmptyComponent = {
  create: function (instantiate) {
    return emptyComponentFactory(instantiate);
  }
};

ReactEmptyComponent.injection = ReactEmptyComponentInjection;

module.exports = ReactEmptyComponent;

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(7);

var invariant = __webpack_require__(2);

var genericComponentClass = null;
var textComponentClass = null;

var ReactHostComponentInjection = {
  // This accepts a class that receives the tag string. This is a catch all
  // that can render any kind of tag.
  injectGenericComponentClass: function (componentClass) {
    genericComponentClass = componentClass;
  },
  // This accepts a text component class that takes the text string to be
  // rendered as props.
  injectTextComponentClass: function (componentClass) {
    textComponentClass = componentClass;
  }
};

/**
 * Get a host internal component class for a specific tag.
 *
 * @param {ReactElement} element The element to create.
 * @return {function} The internal class constructor function.
 */
function createInternalComponent(element) {
  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
  return new genericComponentClass(element);
}

/**
 * @param {ReactText} text
 * @return {ReactComponent}
 */
function createInstanceForText(text) {
  return new textComponentClass(text);
}

/**
 * @param {ReactComponent} component
 * @return {boolean}
 */
function isTextComponent(component) {
  return component instanceof textComponentClass;
}

var ReactHostComponent = {
  createInternalComponent: createInternalComponent,
  createInstanceForText: createInstanceForText,
  isTextComponent: isTextComponent,
  injection: ReactHostComponentInjection
};

module.exports = ReactHostComponent;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(7);

var ReactCurrentOwner = __webpack_require__(37);
var REACT_ELEMENT_TYPE = __webpack_require__(497);

var getIteratorFn = __webpack_require__(498);
var invariant = __webpack_require__(2);
var KeyEscapeUtils = __webpack_require__(138);
var warning = __webpack_require__(3);

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * This is inlined from ReactElement since this file is shared between
 * isomorphic and renderers. We could extract this to a
 *
 */

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (component && typeof component === 'object' && component.key != null) {
    // Explicit key
    return KeyEscapeUtils.escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' ||
  // The following is inlined from ReactElement. This means we can optimize
  // some checks. React Fiber also inlines this logic for similar purposes.
  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if (process.env.NODE_ENV !== 'production') {
          var mapsAsChildrenAddendum = '';
          if (ReactCurrentOwner.current) {
            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
            if (mapsAsChildrenOwnerName) {
              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
            }
          }
          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      if (process.env.NODE_ENV !== 'production') {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = " It looks like you're using an element created by a different " + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner.current) {
          var name = ReactCurrentOwner.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var emptyFunction = __webpack_require__(26);

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if (process.env.NODE_ENV !== 'production') {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactDOMSelection = __webpack_require__(510);

var containsNode = __webpack_require__(512);
var focusNode = __webpack_require__(199);
var getActiveElement = __webpack_require__(211);

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */
var ReactInputSelection = {
  hasSelectionCapabilities: function (elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
  },

  getSelectionInformation: function () {
    var focusedElem = getActiveElement();
    return {
      focusedElem: focusedElem,
      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
    };
  },

  /**
   * @restoreSelection: If any selection information was potentially lost,
   * restore it. This is useful when performing operations that could remove dom
   * nodes and place them back in, resulting in focus being lost.
   */
  restoreSelection: function (priorSelectionInformation) {
    var curFocusedElem = getActiveElement();
    var priorFocusedElem = priorSelectionInformation.focusedElem;
    var priorSelectionRange = priorSelectionInformation.selectionRange;
    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
      }
      focusNode(priorFocusedElem);
    }
  },

  /**
   * @getSelection: Gets the selection bounds of a focused textarea, input or
   * contentEditable node.
   * -@input: Look up selection bounds of this input
   * -@return {start: selectionStart, end: selectionEnd}
   */
  getSelection: function (input) {
    var selection;

    if ('selectionStart' in input) {
      // Modern browser with input or textarea.
      selection = {
        start: input.selectionStart,
        end: input.selectionEnd
      };
    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
      // IE8 input.
      var range = document.selection.createRange();
      // There can only be one selection per document in IE, so it must
      // be in our element.
      if (range.parentElement() === input) {
        selection = {
          start: -range.moveStart('character', -input.value.length),
          end: -range.moveEnd('character', -input.value.length)
        };
      }
    } else {
      // Content editable or old IE textarea.
      selection = ReactDOMSelection.getOffsets(input);
    }

    return selection || { start: 0, end: 0 };
  },

  /**
   * @setSelection: Sets the selection bounds of a textarea or input and focuses
   * the input.
   * -@input     Set selection bounds of this input or textarea
   * -@offsets   Object of same form that is returned from get*
   */
  setSelection: function (input, offsets) {
    var start = offsets.start;
    var end = offsets.end;
    if (end === undefined) {
      end = start;
    }

    if ('selectionStart' in input) {
      input.selectionStart = start;
      input.selectionEnd = Math.min(end, input.value.length);
    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
      var range = input.createTextRange();
      range.collapse(true);
      range.moveStart('character', start);
      range.moveEnd('character', end - start);
      range.select();
    } else {
      ReactDOMSelection.setOffsets(input, offsets);
    }
  }
};

module.exports = ReactInputSelection;

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 *
 * @param {?DOMDocument} doc Defaults to current document.
 * @return {?DOMElement}
 */

function getActiveElement(doc) /*?DOMElement*/{
  doc = doc || (typeof document !== 'undefined' ? document : undefined);
  if (typeof doc === 'undefined') {
    return null;
  }
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

module.exports = getActiveElement;

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(7);

var DOMLazyTree = __webpack_require__(65);
var DOMProperty = __webpack_require__(44);
var React = __webpack_require__(62);
var ReactBrowserEventEmitter = __webpack_require__(96);
var ReactCurrentOwner = __webpack_require__(37);
var ReactDOMComponentTree = __webpack_require__(14);
var ReactDOMContainerInfo = __webpack_require__(527);
var ReactDOMFeatureFlags = __webpack_require__(528);
var ReactFeatureFlags = __webpack_require__(194);
var ReactInstanceMap = __webpack_require__(72);
var ReactInstrumentation = __webpack_require__(27);
var ReactMarkupChecksum = __webpack_require__(529);
var ReactReconciler = __webpack_require__(64);
var ReactUpdateQueue = __webpack_require__(139);
var ReactUpdates = __webpack_require__(38);

var emptyObject = __webpack_require__(90);
var instantiateReactComponent = __webpack_require__(204);
var invariant = __webpack_require__(2);
var setInnerHTML = __webpack_require__(94);
var shouldUpdateReactComponent = __webpack_require__(137);
var warning = __webpack_require__(3);

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;

var ELEMENT_NODE_TYPE = 1;
var DOC_NODE_TYPE = 9;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

var instancesByReactRootID = {};

/**
 * Finds the index of the first character
 * that's not common between the two given strings.
 *
 * @return {number} the index of the character where the strings diverge
 */
function firstDifferenceIndex(string1, string2) {
  var minLen = Math.min(string1.length, string2.length);
  for (var i = 0; i < minLen; i++) {
    if (string1.charAt(i) !== string2.charAt(i)) {
      return i;
    }
  }
  return string1.length === string2.length ? -1 : minLen;
}

/**
 * @param {DOMElement|DOMDocument} container DOM element that may contain
 * a React component
 * @return {?*} DOM element that may have the reactRoot ID, or null.
 */
function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

function internalGetID(node) {
  // If node is something like a window, document, or text node, none of
  // which support attributes or a .getAttribute method, gracefully return
  // the empty string, as if the attribute were missing.
  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
}

/**
 * Mounts this component and inserts it into the DOM.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {DOMElement} container DOM element to mount into.
 * @param {ReactReconcileTransaction} transaction
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
  var markerName;
  if (ReactFeatureFlags.logTopLevelRenders) {
    var wrappedElement = wrapperInstance._currentElement.props.child;
    var type = wrappedElement.type;
    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
    console.time(markerName);
  }

  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */
  );

  if (markerName) {
    console.timeEnd(markerName);
  }

  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
}

/**
 * Batched mount.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {DOMElement} container DOM element to mount into.
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
  /* useCreateElement */
  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
  ReactUpdates.ReactReconcileTransaction.release(transaction);
}

/**
 * Unmounts a component and removes it from the DOM.
 *
 * @param {ReactComponent} instance React component instance.
 * @param {DOMElement} container DOM element to unmount from.
 * @final
 * @internal
 * @see {ReactMount.unmountComponentAtNode}
 */
function unmountComponentFromNode(instance, container, safely) {
  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onBeginFlush();
  }
  ReactReconciler.unmountComponent(instance, safely);
  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onEndFlush();
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    container = container.documentElement;
  }

  // http://jsperf.com/emptying-a-node
  while (container.lastChild) {
    container.removeChild(container.lastChild);
  }
}

/**
 * True if the supplied DOM node has a direct React-rendered child that is
 * not a React root element. Useful for warning in `render`,
 * `unmountComponentAtNode`, etc.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM element contains a direct child that was
 * rendered by React but is not a root element.
 * @internal
 */
function hasNonRootReactChild(container) {
  var rootEl = getReactRootElementInContainer(container);
  if (rootEl) {
    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
    return !!(inst && inst._hostParent);
  }
}

/**
 * True if the supplied DOM node is a React DOM element and
 * it has been rendered by another copy of React.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM has been rendered by another copy of React
 * @internal
 */
function nodeIsRenderedByOtherInstance(container) {
  var rootEl = getReactRootElementInContainer(container);
  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
}

/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */
function isValidContainer(node) {
  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
}

/**
 * True if the supplied DOM node is a valid React node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid React DOM node.
 * @internal
 */
function isReactNode(node) {
  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
}

function getHostRootInstanceInContainer(container) {
  var rootEl = getReactRootElementInContainer(container);
  var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
}

function getTopLevelWrapperInContainer(container) {
  var root = getHostRootInstanceInContainer(container);
  return root ? root._hostContainerInfo._topLevelWrapper : null;
}

/**
 * Temporary (?) hack so that we can store all top-level pending updates on
 * composites instead of having to worry about different types of components
 * here.
 */
var topLevelRootCounter = 1;
var TopLevelWrapper = function () {
  this.rootID = topLevelRootCounter++;
};
TopLevelWrapper.prototype.isReactComponent = {};
if (process.env.NODE_ENV !== 'production') {
  TopLevelWrapper.displayName = 'TopLevelWrapper';
}
TopLevelWrapper.prototype.render = function () {
  return this.props.child;
};
TopLevelWrapper.isReactTopLevelWrapper = true;

/**
 * Mounting is the process of initializing a React component by creating its
 * representative DOM elements and inserting them into a supplied `container`.
 * Any prior content inside `container` is destroyed in the process.
 *
 *   ReactMount.render(
 *     component,
 *     document.getElementById('container')
 *   );
 *
 *   <div id="container">                   <-- Supplied `container`.
 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
 *       // ...                                 component.
 *     </div>
 *   </div>
 *
 * Inside of `container`, the first element rendered is the "reactRoot".
 */
var ReactMount = {
  TopLevelWrapper: TopLevelWrapper,

  /**
   * Used by devtools. The keys are not important.
   */
  _instancesByReactRootID: instancesByReactRootID,

  /**
   * This is a hook provided to support rendering React components while
   * ensuring that the apparent scroll position of its `container` does not
   * change.
   *
   * @param {DOMElement} container The `container` being rendered into.
   * @param {function} renderCallback This must be called once to do the render.
   */
  scrollMonitor: function (container, renderCallback) {
    renderCallback();
  },

  /**
   * Take a component that's already mounted into the DOM and replace its props
   * @param {ReactComponent} prevComponent component instance already in the DOM
   * @param {ReactElement} nextElement component instance to render
   * @param {DOMElement} container container to render into
   * @param {?function} callback function triggered on completion
   */
  _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
    ReactMount.scrollMonitor(container, function () {
      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
      if (callback) {
        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
      }
    });

    return prevComponent;
  },

  /**
   * Render a new component into the DOM. Hooked by hooks!
   *
   * @param {ReactElement} nextElement element to render
   * @param {DOMElement} container container to render into
   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
   * @return {ReactComponent} nextComponent
   */
  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case.
    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;

    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
    var componentInstance = instantiateReactComponent(nextElement, false);

    // The initial render is synchronous but any updates that happen during
    // rendering, in componentWillMount or componentDidMount, will be batched
    // according to the current batching strategy.

    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);

    var wrapperID = componentInstance._instance.rootID;
    instancesByReactRootID[wrapperID] = componentInstance;

    return componentInstance;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
  },

  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
    !React.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? " Instead of passing a string like 'div', pass " + "React.createElement('div') or <div />." : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : // Check if it quacks like an element
    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? " Instead of passing a string like 'div', pass " + "React.createElement('div') or <div />." : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;

    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;

    var nextWrappedElement = React.createElement(TopLevelWrapper, {
      child: nextElement
    });

    var nextContext;
    if (parentComponent) {
      var parentInst = ReactInstanceMap.get(parentComponent);
      nextContext = parentInst._processChildContext(parentInst._context);
    } else {
      nextContext = emptyObject;
    }

    var prevComponent = getTopLevelWrapperInContainer(container);

    if (prevComponent) {
      var prevWrappedElement = prevComponent._currentElement;
      var prevElement = prevWrappedElement.props.child;
      if (shouldUpdateReactComponent(prevElement, nextElement)) {
        var publicInst = prevComponent._renderedComponent.getPublicInstance();
        var updatedCallback = callback && function () {
          callback.call(publicInst);
        };
        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
        return publicInst;
      } else {
        ReactMount.unmountComponentAtNode(container);
      }
    }

    var reactRootElement = getReactRootElementInContainer(container);
    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
    var containerHasNonRootReactChild = hasNonRootReactChild(container);

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;

      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
        var rootElementSibling = reactRootElement;
        while (rootElementSibling) {
          if (internalGetID(rootElementSibling)) {
            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
            break;
          }
          rootElementSibling = rootElementSibling.nextSibling;
        }
      }
    }

    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
    if (callback) {
      callback.call(component);
    }
    return component;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  render: function (nextElement, container, callback) {
    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
  },

  /**
   * Unmounts and destroys the React component rendered in the `container`.
   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
   *
   * @param {DOMElement} container DOM element containing a React component.
   * @return {boolean} True if a component was found in and unmounted from
   *                   `container`
   */
  unmountComponentAtNode: function (container) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case. (Strictly speaking, unmounting won't cause a
    // render but we still don't expect to be in a render call here.)
    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by another copy of React.') : void 0;
    }

    var prevComponent = getTopLevelWrapperInContainer(container);
    if (!prevComponent) {
      // Check if the node being unmounted was rendered by React, but isn't a
      // root node.
      var containerHasNonRootReactChild = hasNonRootReactChild(container);

      // Check if the container itself is a React root node.
      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);

      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
      }

      return false;
    }
    delete instancesByReactRootID[prevComponent._instance.rootID];
    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
    return true;
  },

  _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {
    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;

    if (shouldReuseMarkup) {
      var rootElement = getReactRootElementInContainer(container);
      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
        ReactDOMComponentTree.precacheNode(instance, rootElement);
        return;
      } else {
        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

        var rootMarkup = rootElement.outerHTML;
        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

        var normalizedMarkup = markup;
        if (process.env.NODE_ENV !== 'production') {
          // because rootMarkup is retrieved from the DOM, various normalizations
          // will have occurred which will not be present in `markup`. Here,
          // insert markup into a <div> or <iframe> depending on the container
          // type to perform the same normalizations before comparing.
          var normalizer;
          if (container.nodeType === ELEMENT_NODE_TYPE) {
            normalizer = document.createElement('div');
            normalizer.innerHTML = markup;
            normalizedMarkup = normalizer.innerHTML;
          } else {
            normalizer = document.createElement('iframe');
            document.body.appendChild(normalizer);
            normalizer.contentDocument.write(markup);
            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
            document.body.removeChild(normalizer);
          }
        }

        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);

        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;

        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
        }
      }
    }

    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;

    if (transaction.useCreateElement) {
      while (container.lastChild) {
        container.removeChild(container.lastChild);
      }
      DOMLazyTree.insertTreeBefore(container, markup, null);
    } else {
      setInnerHTML(container, markup);
      ReactDOMComponentTree.precacheNode(instance, container.firstChild);
    }

    if (process.env.NODE_ENV !== 'production') {
      var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
      if (hostNode._debugID !== 0) {
        ReactInstrumentation.debugTool.onHostOperation({
          instanceID: hostNode._debugID,
          type: 'mount',
          payload: markup.toString()
        });
      }
    }
  }
};

module.exports = ReactMount;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactNodeTypes = __webpack_require__(205);

function getHostComponentFromComposite(inst) {
  var type;

  while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
    inst = inst._renderedComponent;
  }

  if (type === ReactNodeTypes.HOST) {
    return inst._renderedComponent;
  } else if (type === ReactNodeTypes.EMPTY) {
    return null;
  }
}

module.exports = getHostComponentFromComposite;

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.connect = exports.connectAdvanced = exports.createProvider = exports.Provider = undefined;

var _Provider = __webpack_require__(537);

var _Provider2 = _interopRequireDefault(_Provider);

var _connectAdvanced = __webpack_require__(216);

var _connectAdvanced2 = _interopRequireDefault(_connectAdvanced);

var _connect = __webpack_require__(542);

var _connect2 = _interopRequireDefault(_connect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.Provider = _Provider2.default;
exports.createProvider = _Provider.createProvider;
exports.connectAdvanced = _connectAdvanced2.default;
exports.connect = _connect2.default;

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.storeShape = exports.subscriptionShape = undefined;

var _propTypes = __webpack_require__(142);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var subscriptionShape = exports.subscriptionShape = _propTypes2.default.shape({
  trySubscribe: _propTypes2.default.func.isRequired,
  tryUnsubscribe: _propTypes2.default.func.isRequired,
  notifyNestedSubs: _propTypes2.default.func.isRequired,
  isSubscribed: _propTypes2.default.func.isRequired
});

var storeShape = exports.storeShape = _propTypes2.default.shape({
  subscribe: _propTypes2.default.func.isRequired,
  dispatch: _propTypes2.default.func.isRequired,
  getState: _propTypes2.default.func.isRequired
});

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = connectAdvanced;

var _hoistNonReactStatics = __webpack_require__(539);

var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

var _invariant = __webpack_require__(540);

var _invariant2 = _interopRequireDefault(_invariant);

var _react = __webpack_require__(88);

var _Subscription = __webpack_require__(541);

var _Subscription2 = _interopRequireDefault(_Subscription);

var _PropTypes = __webpack_require__(215);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && (typeof call === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _objectWithoutProperties(obj, keys) {
  var target = {};for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
  }return target;
}

var hotReloadingVersion = 0;
var dummyState = {};
function noop() {}
function makeSelectorStateful(sourceSelector, store) {
  // wrap the selector in an object that tracks its results between runs.
  var selector = {
    run: function runComponentSelector(props) {
      try {
        var nextProps = sourceSelector(store.getState(), props);
        if (nextProps !== selector.props || selector.error) {
          selector.shouldComponentUpdate = true;
          selector.props = nextProps;
          selector.error = null;
        }
      } catch (error) {
        selector.shouldComponentUpdate = true;
        selector.error = error;
      }
    }
  };

  return selector;
}

function connectAdvanced(
/*
  selectorFactory is a func that is responsible for returning the selector function used to
  compute new props from state, props, and dispatch. For example:
     export default connectAdvanced((dispatch, options) => (state, props) => ({
      thing: state.things[props.thingId],
      saveThing: fields => dispatch(actionCreators.saveThing(props.thingId, fields)),
    }))(YourComponent)
   Access to dispatch is provided to the factory so selectorFactories can bind actionCreators
  outside of their selector as an optimization. Options passed to connectAdvanced are passed to
  the selectorFactory, along with displayName and WrappedComponent, as the second argument.
   Note that selectorFactory is responsible for all caching/memoization of inbound and outbound
  props. Do not use connectAdvanced directly without memoizing results between calls to your
  selector, otherwise the Connect component will re-render on every state or props change.
*/
selectorFactory) {
  var _contextTypes, _childContextTypes;

  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$getDisplayName = _ref.getDisplayName,
      getDisplayName = _ref$getDisplayName === undefined ? function (name) {
    return 'ConnectAdvanced(' + name + ')';
  } : _ref$getDisplayName,
      _ref$methodName = _ref.methodName,
      methodName = _ref$methodName === undefined ? 'connectAdvanced' : _ref$methodName,
      _ref$renderCountProp = _ref.renderCountProp,
      renderCountProp = _ref$renderCountProp === undefined ? undefined : _ref$renderCountProp,
      _ref$shouldHandleStat = _ref.shouldHandleStateChanges,
      shouldHandleStateChanges = _ref$shouldHandleStat === undefined ? true : _ref$shouldHandleStat,
      _ref$storeKey = _ref.storeKey,
      storeKey = _ref$storeKey === undefined ? 'store' : _ref$storeKey,
      _ref$withRef = _ref.withRef,
      withRef = _ref$withRef === undefined ? false : _ref$withRef,
      connectOptions = _objectWithoutProperties(_ref, ['getDisplayName', 'methodName', 'renderCountProp', 'shouldHandleStateChanges', 'storeKey', 'withRef']);

  var subscriptionKey = storeKey + 'Subscription';
  var version = hotReloadingVersion++;

  var contextTypes = (_contextTypes = {}, _contextTypes[storeKey] = _PropTypes.storeShape, _contextTypes[subscriptionKey] = _PropTypes.subscriptionShape, _contextTypes);
  var childContextTypes = (_childContextTypes = {}, _childContextTypes[subscriptionKey] = _PropTypes.subscriptionShape, _childContextTypes);

  return function wrapWithConnect(WrappedComponent) {
    (0, _invariant2.default)(typeof WrappedComponent == 'function', 'You must pass a component to the function returned by ' + ('connect. Instead received ' + JSON.stringify(WrappedComponent)));

    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';

    var displayName = getDisplayName(wrappedComponentName);

    var selectorFactoryOptions = _extends({}, connectOptions, {
      getDisplayName: getDisplayName,
      methodName: methodName,
      renderCountProp: renderCountProp,
      shouldHandleStateChanges: shouldHandleStateChanges,
      storeKey: storeKey,
      withRef: withRef,
      displayName: displayName,
      wrappedComponentName: wrappedComponentName,
      WrappedComponent: WrappedComponent
    });

    var Connect = function (_Component) {
      _inherits(Connect, _Component);

      function Connect(props, context) {
        _classCallCheck(this, Connect);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

        _this.version = version;
        _this.state = {};
        _this.renderCount = 0;
        _this.store = props[storeKey] || context[storeKey];
        _this.propsMode = Boolean(props[storeKey]);
        _this.setWrappedInstance = _this.setWrappedInstance.bind(_this);

        (0, _invariant2.default)(_this.store, 'Could not find "' + storeKey + '" in either the context or props of ' + ('"' + displayName + '". Either wrap the root component in a <Provider>, ') + ('or explicitly pass "' + storeKey + '" as a prop to "' + displayName + '".'));

        _this.initSelector();
        _this.initSubscription();
        return _this;
      }

      Connect.prototype.getChildContext = function getChildContext() {
        var _ref2;

        // If this component received store from props, its subscription should be transparent
        // to any descendants receiving store+subscription from context; it passes along
        // subscription passed to it. Otherwise, it shadows the parent subscription, which allows
        // Connect to control ordering of notifications to flow top-down.
        var subscription = this.propsMode ? null : this.subscription;
        return _ref2 = {}, _ref2[subscriptionKey] = subscription || this.context[subscriptionKey], _ref2;
      };

      Connect.prototype.componentDidMount = function componentDidMount() {
        if (!shouldHandleStateChanges) return;

        // componentWillMount fires during server side rendering, but componentDidMount and
        // componentWillUnmount do not. Because of this, trySubscribe happens during ...didMount.
        // Otherwise, unsubscription would never take place during SSR, causing a memory leak.
        // To handle the case where a child component may have triggered a state change by
        // dispatching an action in its componentWillMount, we have to re-run the select and maybe
        // re-render.
        this.subscription.trySubscribe();
        this.selector.run(this.props);
        if (this.selector.shouldComponentUpdate) this.forceUpdate();
      };

      Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        this.selector.run(nextProps);
      };

      Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
        return this.selector.shouldComponentUpdate;
      };

      Connect.prototype.componentWillUnmount = function componentWillUnmount() {
        if (this.subscription) this.subscription.tryUnsubscribe();
        this.subscription = null;
        this.notifyNestedSubs = noop;
        this.store = null;
        this.selector.run = noop;
        this.selector.shouldComponentUpdate = false;
      };

      Connect.prototype.getWrappedInstance = function getWrappedInstance() {
        (0, _invariant2.default)(withRef, 'To access the wrapped instance, you need to specify ' + ('{ withRef: true } in the options argument of the ' + methodName + '() call.'));
        return this.wrappedInstance;
      };

      Connect.prototype.setWrappedInstance = function setWrappedInstance(ref) {
        this.wrappedInstance = ref;
      };

      Connect.prototype.initSelector = function initSelector() {
        var sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions);
        this.selector = makeSelectorStateful(sourceSelector, this.store);
        this.selector.run(this.props);
      };

      Connect.prototype.initSubscription = function initSubscription() {
        if (!shouldHandleStateChanges) return;

        // parentSub's source should match where store came from: props vs. context. A component
        // connected to the store via props shouldn't use subscription from context, or vice versa.
        var parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey];
        this.subscription = new _Subscription2.default(this.store, parentSub, this.onStateChange.bind(this));

        // `notifyNestedSubs` is duplicated to handle the case where the component is  unmounted in
        // the middle of the notification loop, where `this.subscription` will then be null. An
        // extra null check every change can be avoided by copying the method onto `this` and then
        // replacing it with a no-op on unmount. This can probably be avoided if Subscription's
        // listeners logic is changed to not call listeners that have been unsubscribed in the
        // middle of the notification loop.
        this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription);
      };

      Connect.prototype.onStateChange = function onStateChange() {
        this.selector.run(this.props);

        if (!this.selector.shouldComponentUpdate) {
          this.notifyNestedSubs();
        } else {
          this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate;
          this.setState(dummyState);
        }
      };

      Connect.prototype.notifyNestedSubsOnComponentDidUpdate = function notifyNestedSubsOnComponentDidUpdate() {
        // `componentDidUpdate` is conditionally implemented when `onStateChange` determines it
        // needs to notify nested subs. Once called, it unimplements itself until further state
        // changes occur. Doing it this way vs having a permanent `componentDidUpdate` that does
        // a boolean check every time avoids an extra method call most of the time, resulting
        // in some perf boost.
        this.componentDidUpdate = undefined;
        this.notifyNestedSubs();
      };

      Connect.prototype.isSubscribed = function isSubscribed() {
        return Boolean(this.subscription) && this.subscription.isSubscribed();
      };

      Connect.prototype.addExtraProps = function addExtraProps(props) {
        if (!withRef && !renderCountProp && !(this.propsMode && this.subscription)) return props;
        // make a shallow copy so that fields added don't leak to the original selector.
        // this is especially important for 'ref' since that's a reference back to the component
        // instance. a singleton memoized selector would then be holding a reference to the
        // instance, preventing the instance from being garbage collected, and that would be bad
        var withExtras = _extends({}, props);
        if (withRef) withExtras.ref = this.setWrappedInstance;
        if (renderCountProp) withExtras[renderCountProp] = this.renderCount++;
        if (this.propsMode && this.subscription) withExtras[subscriptionKey] = this.subscription;
        return withExtras;
      };

      Connect.prototype.render = function render() {
        var selector = this.selector;
        selector.shouldComponentUpdate = false;

        if (selector.error) {
          throw selector.error;
        } else {
          return (0, _react.createElement)(WrappedComponent, this.addExtraProps(selector.props));
        }
      };

      return Connect;
    }(_react.Component);

    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = displayName;
    Connect.childContextTypes = childContextTypes;
    Connect.contextTypes = contextTypes;
    Connect.propTypes = contextTypes;

    if (process.env.NODE_ENV !== 'production') {
      Connect.prototype.componentWillUpdate = function componentWillUpdate() {
        var _this2 = this;

        // We are hot reloading!
        if (this.version !== version) {
          this.version = version;
          this.initSelector();

          // If any connected descendants don't hot reload (and resubscribe in the process), their
          // listeners will be lost when we unsubscribe. Unfortunately, by copying over all
          // listeners, this does mean that the old versions of connected descendants will still be
          // notified of state changes; however, their onStateChange function is a no-op so this
          // isn't a huge deal.
          var oldListeners = [];

          if (this.subscription) {
            oldListeners = this.subscription.listeners.get();
            this.subscription.tryUnsubscribe();
          }
          this.initSubscription();
          if (shouldHandleStateChanges) {
            this.subscription.trySubscribe();
            oldListeners.forEach(function (listener) {
              return _this2.subscription.listeners.subscribe(listener);
            });
          }
        }
      };
    }

    return (0, _hoistNonReactStatics2.default)(Connect, WrappedComponent);
  };
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ActionTypes = undefined;
exports.default = createStore;

var _isPlainObject = __webpack_require__(144);

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _symbolObservable = __webpack_require__(553);

var _symbolObservable2 = _interopRequireDefault(_symbolObservable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var ActionTypes = exports.ActionTypes = {
  INIT: '@@redux/INIT'

  /**
   * Creates a Redux store that holds the state tree.
   * The only way to change the data in the store is to call `dispatch()` on it.
   *
   * There should only be a single store in your app. To specify how different
   * parts of the state tree respond to actions, you may combine several reducers
   * into a single reducer function by using `combineReducers`.
   *
   * @param {Function} reducer A function that returns the next state tree, given
   * the current state tree and the action to handle.
   *
   * @param {any} [preloadedState] The initial state. You may optionally specify it
   * to hydrate the state from the server in universal apps, or to restore a
   * previously serialized user session.
   * If you use `combineReducers` to produce the root reducer function, this must be
   * an object with the same shape as `combineReducers` keys.
   *
   * @param {Function} [enhancer] The store enhancer. You may optionally specify it
   * to enhance the store with third-party capabilities such as middleware,
   * time travel, persistence, etc. The only store enhancer that ships with Redux
   * is `applyMiddleware()`.
   *
   * @returns {Store} A Redux store that lets you read the state, dispatch actions
   * and subscribe to changes.
   */
};function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }

  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */
  function getState() {
    return currentState;
  }

  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */
  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected listener to be a function.');
    }

    var isSubscribed = true;

    ensureCanMutateNextListeners();
    nextListeners.push(listener);

    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      isSubscribed = false;

      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }

  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing “what changed”. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */
  function dispatch(action) {
    if (!(0, _isPlainObject2.default)(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;
    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }

  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer;
    dispatch({ type: ActionTypes.INIT });
  }

  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */
  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object') {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return { unsubscribe: unsubscribe };
      }
    }, _ref[_symbolObservable2.default] = function () {
      return this;
    }, _ref;
  }

  // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.
  dispatch({ type: ActionTypes.INIT });

  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[_symbolObservable2.default] = observable, _ref2;
}

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _root = __webpack_require__(546);

var _root2 = _interopRequireDefault(_root);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Built-in value references. */
var Symbol = _root2.default.Symbol;

exports.default = Symbol;

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = warning;
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = compose;
/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */

function compose() {
  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(undefined, arguments));
    };
  });
}

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrapMapToPropsConstant = wrapMapToPropsConstant;
exports.getDependsOnOwnProps = getDependsOnOwnProps;
exports.wrapMapToPropsFunc = wrapMapToPropsFunc;

var _verifyPlainObject = __webpack_require__(222);

var _verifyPlainObject2 = _interopRequireDefault(_verifyPlainObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch, options) {
    var constant = getConstant(dispatch, options);

    function constantSelector() {
      return constant;
    }
    constantSelector.dependsOnOwnProps = false;
    return constantSelector;
  };
}

// dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args
// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine
// whether mapToProps needs to be invoked when props have changed.
// 
// A length of one signals that mapToProps does not depend on props from the parent component.
// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and
// therefore not reporting its length accurately..
function getDependsOnOwnProps(mapToProps) {
  return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
}

// Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,
// this function wraps mapToProps in a proxy function which does several things:
// 
//  * Detects whether the mapToProps function being called depends on props, which
//    is used by selectorFactory to decide if it should reinvoke on props changes.
//    
//  * On first call, handles mapToProps if returns another function, and treats that
//    new function as the true mapToProps for subsequent calls.
//    
//  * On first call, verifies the first result is a plain object, in order to warn
//    the developer that their mapToProps function is not returning a valid result.
//    
function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, _ref) {
    var displayName = _ref.displayName;

    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
    };

    // allow detectFactoryAndVerify to get ownProps
    proxy.dependsOnOwnProps = true;

    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps;
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
      var props = proxy(stateOrDispatch, ownProps);

      if (typeof props === 'function') {
        proxy.mapToProps = props;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
        props = proxy(stateOrDispatch, ownProps);
      }

      if (process.env.NODE_ENV !== 'production') (0, _verifyPlainObject2.default)(props, displayName, methodName);

      return props;
    };

    return proxy;
  };
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = verifyPlainObject;

var _isPlainObject = __webpack_require__(144);

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _warning = __webpack_require__(143);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function verifyPlainObject(value, displayName, methodName) {
  if (!(0, _isPlainObject2.default)(value)) {
    (0, _warning2.default)(methodName + '() in ' + displayName + ' must return a plain object. Instead received ' + value + '.');
  }
}

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
const SET_COUNTER = exports.SET_COUNTER = 'SET_COUNTER';
const INCREMENT_COUNTER = exports.INCREMENT_COUNTER = 'INCREMENT_COUNTER';
const DECREMENT_COUNTER = exports.DECREMENT_COUNTER = 'DECREMENT_COUNTER';

const set = exports.set = value => {
  type: SET_COUNTER, value;
};

const increment = exports.increment = () => {
  type: INCREMENT_COUNTER;
};

const decrement = exports.decrement = () => {
  type: DECREMENT_COUNTER;
};

const incrementIfOdd = exports.incrementIfOdd = () => (dispatch, getState) => {
  const { counter } = getState();

  if (counter % 2 === 0) {
    return;
  }

  dispatch(increment());
};

const incrementAsync = exports.incrementAsync = (delay = 1000) => dispatch => {
  setTimeout(() => {
    dispatch(increment());
  }, delay);
};

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(225);
module.exports = __webpack_require__(234);


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

/*eslint-env browser*/
/*global __resourceQuery __webpack_public_path__*/

var options = {
  path: "/__webpack_hmr",
  timeout: 20 * 1000,
  overlay: true,
  reload: false,
  log: true,
  warn: true,
  name: ''
};
if (false) {
  var querystring = require('querystring');
  var overrides = querystring.parse(__resourceQuery.slice(1));
  if (overrides.path) options.path = overrides.path;
  if (overrides.timeout) options.timeout = overrides.timeout;
  if (overrides.overlay) options.overlay = overrides.overlay !== 'false';
  if (overrides.reload) options.reload = overrides.reload !== 'false';
  if (overrides.noInfo && overrides.noInfo !== 'false') {
    options.log = false;
  }
  if (overrides.name) {
    options.name = overrides.name;
  }
  if (overrides.quiet && overrides.quiet !== 'false') {
    options.log = false;
    options.warn = false;
  }
  if (overrides.dynamicPublicPath) {
    options.path = __webpack_public_path__ + options.path;
  }
}

if (typeof window === 'undefined') {
  // do nothing
} else if (typeof window.EventSource === 'undefined') {
  console.warn("webpack-hot-middleware's client requires EventSource to work. " + "You should include a polyfill if you want to support this browser: " + "https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events#Tools");
} else {
  connect();
}

function EventSourceWrapper() {
  var source;
  var lastActivity = new Date();
  var listeners = [];

  init();
  var timer = setInterval(function () {
    if (new Date() - lastActivity > options.timeout) {
      handleDisconnect();
    }
  }, options.timeout / 2);

  function init() {
    source = new window.EventSource(options.path);
    source.onopen = handleOnline;
    source.onerror = handleDisconnect;
    source.onmessage = handleMessage;
  }

  function handleOnline() {
    if (options.log) console.log("[HMR] connected");
    lastActivity = new Date();
  }

  function handleMessage(event) {
    lastActivity = new Date();
    for (var i = 0; i < listeners.length; i++) {
      listeners[i](event);
    }
  }

  function handleDisconnect() {
    clearInterval(timer);
    source.close();
    setTimeout(init, options.timeout);
  }

  return {
    addMessageListener: function (fn) {
      listeners.push(fn);
    }
  };
}

function getEventSourceWrapper() {
  if (!window.__whmEventSourceWrapper) {
    window.__whmEventSourceWrapper = {};
  }
  if (!window.__whmEventSourceWrapper[options.path]) {
    // cache the wrapper for other entries loaded on
    // the same page with the same options.path
    window.__whmEventSourceWrapper[options.path] = EventSourceWrapper();
  }
  return window.__whmEventSourceWrapper[options.path];
}

function connect() {
  getEventSourceWrapper().addMessageListener(handleMessage);

  function handleMessage(event) {
    if (event.data == "\uD83D\uDC93") {
      return;
    }
    try {
      processMessage(JSON.parse(event.data));
    } catch (ex) {
      if (options.warn) {
        console.warn("Invalid HMR message: " + event.data + "\n" + ex);
      }
    }
  }
}

// the reporter needs to be a singleton on the page
// in case the client is being used by multiple bundles
// we only want to report once.
// all the errors will go to all clients
var singletonKey = '__webpack_hot_middleware_reporter__';
var reporter;
if (typeof window !== 'undefined') {
  if (!window[singletonKey]) {
    window[singletonKey] = createReporter();
  }
  reporter = window[singletonKey];
}

function createReporter() {
  var strip = __webpack_require__(226);

  var overlay;
  if (typeof document !== 'undefined' && options.overlay) {
    overlay = __webpack_require__(228);
  }

  var styles = {
    errors: "color: #ff0000;",
    warnings: "color: #999933;"
  };
  var previousProblems = null;
  function log(type, obj) {
    var newProblems = obj[type].map(function (msg) {
      return strip(msg);
    }).join('\n');
    if (previousProblems == newProblems) {
      return;
    } else {
      previousProblems = newProblems;
    }

    var style = styles[type];
    var name = obj.name ? "'" + obj.name + "' " : "";
    var title = "[HMR] bundle " + name + "has " + obj[type].length + " " + type;
    // NOTE: console.warn or console.error will print the stack trace
    // which isn't helpful here, so using console.log to escape it.
    if (console.group && console.groupEnd) {
      console.group("%c" + title, style);
      console.log("%c" + newProblems, style);
      console.groupEnd();
    } else {
      console.log("%c" + title + "\n\t%c" + newProblems.replace(/\n/g, "\n\t"), style + "font-weight: bold;", style + "font-weight: normal;");
    }
  }

  return {
    cleanProblemsCache: function () {
      previousProblems = null;
    },
    problems: function (type, obj) {
      if (options.warn) {
        log(type, obj);
      }
      if (overlay && type !== 'warnings') overlay.showProblems(type, obj[type]);
    },
    success: function () {
      if (overlay) overlay.clear();
    },
    useCustomOverlay: function (customOverlay) {
      overlay = customOverlay;
    }
  };
}

var processUpdate = __webpack_require__(233);

var customHandler;
var subscribeAllHandler;
function processMessage(obj) {
  switch (obj.action) {
    case "building":
      if (options.log) {
        console.log("[HMR] bundle " + (obj.name ? "'" + obj.name + "' " : "") + "rebuilding");
      }
      break;
    case "built":
      if (options.log) {
        console.log("[HMR] bundle " + (obj.name ? "'" + obj.name + "' " : "") + "rebuilt in " + obj.time + "ms");
      }
    // fall through
    case "sync":
      if (obj.name && options.name && obj.name !== options.name) {
        return;
      }
      if (obj.errors.length > 0) {
        if (reporter) reporter.problems('errors', obj);
      } else {
        if (reporter) {
          if (obj.warnings.length > 0) {
            reporter.problems('warnings', obj);
          } else {
            reporter.cleanProblemsCache();
          }
          reporter.success();
        }
        processUpdate(obj.hash, obj.modules, options);
      }
      break;
    default:
      if (customHandler) {
        customHandler(obj);
      }
  }

  if (subscribeAllHandler) {
    subscribeAllHandler(obj);
  }
}

if (module) {
  module.exports = {
    subscribeAll: function subscribeAll(handler) {
      subscribeAllHandler = handler;
    },
    subscribe: function subscribe(handler) {
      customHandler = handler;
    },
    useCustomOverlay: function useCustomOverlay(customOverlay) {
      if (reporter) reporter.useCustomOverlay(customOverlay);
    }
  };
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(146)(module)))

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ansiRegex = __webpack_require__(227)();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	return (/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g
	);
};

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*eslint-env browser*/

var clientOverlay = document.createElement('div');
clientOverlay.id = 'webpack-hot-middleware-clientOverlay';
var styles = {
  background: 'rgba(0,0,0,0.85)',
  color: '#E8E8E8',
  lineHeight: '1.2',
  whiteSpace: 'pre',
  fontFamily: 'Menlo, Consolas, monospace',
  fontSize: '13px',
  position: 'fixed',
  zIndex: 9999,
  padding: '10px',
  left: 0,
  right: 0,
  top: 0,
  bottom: 0,
  overflow: 'auto',
  dir: 'ltr',
  textAlign: 'left'
};
for (var key in styles) {
  clientOverlay.style[key] = styles[key];
}

var ansiHTML = __webpack_require__(229);
var colors = {
  reset: ['transparent', 'transparent'],
  black: '181818',
  red: 'E36049',
  green: 'B3CB74',
  yellow: 'FFD080',
  blue: '7CAFC2',
  magenta: '7FACCA',
  cyan: 'C3C2EF',
  lightgrey: 'EBE7E3',
  darkgrey: '6D7891'
};
ansiHTML.setColors(colors);

var Entities = __webpack_require__(230).AllHtmlEntities;
var entities = new Entities();

exports.showProblems = function showProblems(type, lines) {
  clientOverlay.innerHTML = '';
  lines.forEach(function (msg) {
    msg = ansiHTML(entities.encode(msg));
    var div = document.createElement('div');
    div.style.marginBottom = '26px';
    div.innerHTML = problemType(type) + ' in ' + msg;
    clientOverlay.appendChild(div);
  });
  if (document.body) {
    document.body.appendChild(clientOverlay);
  }
};

exports.clear = function clear() {
  if (document.body && clientOverlay.parentNode) {
    document.body.removeChild(clientOverlay);
  }
};

var problemColors = {
  errors: colors.red,
  warnings: colors.yellow
};

function problemType(type) {
  var color = problemColors[type] || colors.red;
  return '<span style="background-color:#' + color + '; color:#fff; padding:2px 4px; border-radius: 2px">' + type.slice(0, -1).toUpperCase() + '</span>';
}

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ansiHTML;

// Reference to https://github.com/sindresorhus/ansi-regex
var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/;

var _defColors = {
  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]
  black: '000',
  red: 'ff0000',
  green: '209805',
  yellow: 'e8bf03',
  blue: '0000ff',
  magenta: 'ff00ff',
  cyan: '00ffee',
  lightgrey: 'f0f0f0',
  darkgrey: '888'
};
var _styles = {
  30: 'black',
  31: 'red',
  32: 'green',
  33: 'yellow',
  34: 'blue',
  35: 'magenta',
  36: 'cyan',
  37: 'lightgrey'
};
var _openTags = {
  '1': 'font-weight:bold', // bold
  '2': 'opacity:0.5', // dim
  '3': '<i>', // italic
  '4': '<u>', // underscore
  '8': 'display:none', // hidden
  '9': '<del>' // delete
};
var _closeTags = {
  '23': '</i>', // reset italic
  '24': '</u>', // reset underscore
  '29': '</del>' // reset delete
};[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
  _closeTags[n] = '</span>';
});

/**
 * Converts text with ANSI color codes to HTML markup.
 * @param {String} text
 * @returns {*}
 */
function ansiHTML(text) {
  // Returns the text if the string has no ANSI escape code.
  if (!_regANSI.test(text)) {
    return text;
  }

  // Cache opened sequence.
  var ansiCodes = [];
  // Replace with markup.
  var ret = text.replace(/\033\[(\d+)*m/g, function (match, seq) {
    var ot = _openTags[seq];
    if (ot) {
      // If current sequence has been opened, close it.
      if (!!~ansiCodes.indexOf(seq)) {
        // eslint-disable-line no-extra-boolean-cast
        ansiCodes.pop();
        return '</span>';
      }
      // Open tag.
      ansiCodes.push(seq);
      return ot[0] === '<' ? ot : '<span style="' + ot + ';">';
    }

    var ct = _closeTags[seq];
    if (ct) {
      // Pop sequence
      ansiCodes.pop();
      return ct;
    }
    return '';
  });

  // Make sure tags are closed.
  var l = ansiCodes.length;l > 0 && (ret += Array(l + 1).join('</span>'));

  return ret;
}

/**
 * Customize colors.
 * @param {Object} colors reference to _defColors
 */
ansiHTML.setColors = function (colors) {
  if (typeof colors !== 'object') {
    throw new Error('`colors` parameter must be an Object.');
  }

  var _finalColors = {};
  for (var key in _defColors) {
    var hex = colors.hasOwnProperty(key) ? colors[key] : null;
    if (!hex) {
      _finalColors[key] = _defColors[key];
      continue;
    }
    if ('reset' === key) {
      if (typeof hex === 'string') {
        hex = [hex];
      }
      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {
        return typeof h !== 'string';
      })) {
        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000');
      }
      var defHexColor = _defColors[key];
      if (!hex[0]) {
        hex[0] = defHexColor[0];
      }
      if (hex.length === 1 || !hex[1]) {
        hex = [hex[0]];
        hex.push(defHexColor[1]);
      }

      hex = hex.slice(0, 2);
    } else if (typeof hex !== 'string') {
      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000');
    }
    _finalColors[key] = hex;
  }
  _setTags(_finalColors);
};

/**
 * Reset colors.
 */
ansiHTML.reset = function () {
  _setTags(_defColors);
};

/**
 * Expose tags, including open and close.
 * @type {Object}
 */
ansiHTML.tags = {};

if (Object.defineProperty) {
  Object.defineProperty(ansiHTML.tags, 'open', {
    get: function () {
      return _openTags;
    }
  });
  Object.defineProperty(ansiHTML.tags, 'close', {
    get: function () {
      return _closeTags;
    }
  });
} else {
  ansiHTML.tags.open = _openTags;
  ansiHTML.tags.close = _closeTags;
}

function _setTags(colors) {
  // reset all
  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1];
  // inverse
  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0];
  // dark grey
  _openTags['90'] = 'color:#' + colors.darkgrey;

  for (var code in _styles) {
    var color = _styles[code];
    var oriColor = colors[color] || '000';
    _openTags[code] = 'color:#' + oriColor;
    code = parseInt(code);
    _openTags[(code + 10).toString()] = 'background:#' + oriColor;
  }
}

ansiHTML.reset();

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  XmlEntities: __webpack_require__(231),
  Html4Entities: __webpack_require__(232),
  Html5Entities: __webpack_require__(147),
  AllHtmlEntities: __webpack_require__(147)
};

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ALPHA_INDEX = {
    '&lt': '<',
    '&gt': '>',
    '&quot': '"',
    '&apos': '\'',
    '&amp': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&apos;': '\'',
    '&amp;': '&'
};

var CHAR_INDEX = {
    60: 'lt',
    62: 'gt',
    34: 'quot',
    39: 'apos',
    38: 'amp'
};

var CHAR_S_INDEX = {
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&apos;',
    '&': '&amp;'
};

/**
 * @constructor
 */
function XmlEntities() {}

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encode = function (str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/<|>|"|'|&/g, function (s) {
        return CHAR_S_INDEX[s];
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.encode = function (str) {
    return new XmlEntities().encode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.decode = function (str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&#?[0-9a-zA-Z]+;?/g, function (s) {
        if (s.charAt(1) === '#') {
            var code = s.charAt(2).toLowerCase() === 'x' ? parseInt(s.substr(3), 16) : parseInt(s.substr(2));

            if (isNaN(code) || code < -32768 || code > 65535) {
                return '';
            }
            return String.fromCharCode(code);
        }
        return ALPHA_INDEX[s] || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.decode = function (str) {
    return new XmlEntities().decode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonUTF = function (str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var alpha = CHAR_INDEX[c];
        if (alpha) {
            result += "&" + alpha + ";";
            i++;
            continue;
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.encodeNonUTF = function (str) {
    return new XmlEntities().encodeNonUTF(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonASCII = function (str) {
    if (!str || !str.length) {
        return '';
    }
    var strLenght = str.length;
    var result = '';
    var i = 0;
    while (i < strLenght) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.encodeNonASCII = function (str) {
    return new XmlEntities().encodeNonASCII(str);
};

module.exports = XmlEntities;

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'Aelig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'OElig', 'oelig', 'Scaron', 'scaron', 'Yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'Dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'Prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'lArr', 'uArr', 'rArr', 'dArr', 'hArr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];
var HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];

var alphaIndex = {};
var numIndex = {};

var i = 0;
var length = HTML_ALPHA.length;
while (i < length) {
    var a = HTML_ALPHA[i];
    var c = HTML_CODES[i];
    alphaIndex[a] = String.fromCharCode(c);
    numIndex[c] = a;
    i++;
}

/**
 * @constructor
 */
function Html4Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.decode = function (str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function (s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1).toLowerCase() === 'x' ? parseInt(entity.substr(2), 16) : parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.decode = function (str) {
    return new Html4Entities().decode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encode = function (str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var alpha = numIndex[str.charCodeAt(i)];
        result += alpha ? "&" + alpha + ";" : str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encode = function (str) {
    return new Html4Entities().encode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonUTF = function (str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var cc = str.charCodeAt(i);
        var alpha = numIndex[cc];
        if (alpha) {
            result += "&" + alpha + ";";
        } else if (cc < 32 || cc > 126) {
            result += "&#" + cc + ";";
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonUTF = function (str) {
    return new Html4Entities().encodeNonUTF(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonASCII = function (str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonASCII = function (str) {
    return new Html4Entities().encodeNonASCII(str);
};

module.exports = Html4Entities;

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Based heavily on https://github.com/webpack/webpack/blob/
 *  c0afdf9c6abc1dd70707c594e473802a566f7b6e/hot/only-dev-server.js
 * Original copyright Tobias Koppers @sokra (MIT license)
 */

/* global window __webpack_hash__ */

if (false) {
  throw new Error("[HMR] Hot Module Replacement is disabled.");
}

var hmrDocsUrl = "http://webpack.github.io/docs/hot-module-replacement-with-webpack.html"; // eslint-disable-line max-len

var lastHash;
var failureStatuses = { abort: 1, fail: 1 };
var applyOptions = { ignoreUnaccepted: true };

function upToDate(hash) {
  if (hash) lastHash = hash;
  return lastHash == __webpack_require__.h();
}

module.exports = function (hash, moduleMap, options) {
  var reload = options.reload;
  if (!upToDate(hash) && module.hot.status() == "idle") {
    if (options.log) console.log("[HMR] Checking for updates on the server...");
    check();
  }

  function check() {
    var cb = function (err, updatedModules) {
      if (err) return handleError(err);

      if (!updatedModules) {
        if (options.warn) {
          console.warn("[HMR] Cannot find update (Full reload needed)");
          console.warn("[HMR] (Probably because of restarting the server)");
        }
        performReload();
        return null;
      }

      var applyCallback = function (applyErr, renewedModules) {
        if (applyErr) return handleError(applyErr);

        if (!upToDate()) check();

        logUpdates(updatedModules, renewedModules);
      };

      var applyResult = module.hot.apply(applyOptions, applyCallback);
      // webpack 2 promise
      if (applyResult && applyResult.then) {
        // HotModuleReplacement.runtime.js refers to the result as `outdatedModules`
        applyResult.then(function (outdatedModules) {
          applyCallback(null, outdatedModules);
        });
        applyResult.catch(applyCallback);
      }
    };

    var result = module.hot.check(false, cb);
    // webpack 2 promise
    if (result && result.then) {
      result.then(function (updatedModules) {
        cb(null, updatedModules);
      });
      result.catch(cb);
    }
  }

  function logUpdates(updatedModules, renewedModules) {
    var unacceptedModules = updatedModules.filter(function (moduleId) {
      return renewedModules && renewedModules.indexOf(moduleId) < 0;
    });

    if (unacceptedModules.length > 0) {
      if (options.warn) {
        console.warn("[HMR] The following modules couldn't be hot updated: " + "(Full reload needed)\n" + "This is usually because the modules which have changed " + "(and their parents) do not know how to hot reload themselves. " + "See " + hmrDocsUrl + " for more details.");
        unacceptedModules.forEach(function (moduleId) {
          console.warn("[HMR]  - " + moduleMap[moduleId]);
        });
      }
      performReload();
      return;
    }

    if (options.log) {
      if (!renewedModules || renewedModules.length === 0) {
        console.log("[HMR] Nothing hot updated.");
      } else {
        console.log("[HMR] Updated modules:");
        renewedModules.forEach(function (moduleId) {
          console.log("[HMR]  - " + moduleMap[moduleId]);
        });
      }

      if (upToDate()) {
        console.log("[HMR] App is up to date.");
      }
    }
  }

  function handleError(err) {
    if (module.hot.status() in failureStatuses) {
      if (options.warn) {
        console.warn("[HMR] Cannot check for update (Full reload needed)");
        console.warn("[HMR] " + err.stack || err.message);
      }
      performReload();
      return;
    }
    if (options.warn) {
      console.warn("[HMR] Update check failed: " + err.stack || err.message);
    }
  }

  function performReload() {
    if (reload) {
      if (options.warn) console.warn("[HMR] Reloading page");
      window.location.reload();
    }
  }
};

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(235);

var _react = __webpack_require__(88);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(451);

var _reactRedux = __webpack_require__(214);

var _configureStore = __webpack_require__(563);

var _configureStore2 = _interopRequireDefault(_configureStore);

var _App = __webpack_require__(566);

var _App2 = _interopRequireDefault(_App);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const preloadedState = window.__PRELOADED_STATE__;
const store = (0, _configureStore2.default)(preloadedState);
const rootElement = document.getElementById('app');

(0, _reactDom.render)(_react2.default.createElement(
  _reactRedux.Provider,
  { store: store },
  _react2.default.createElement(_App2.default, null)
), rootElement);

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

__webpack_require__(236);

__webpack_require__(433);

__webpack_require__(434);

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)))

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(237);
__webpack_require__(239);
__webpack_require__(240);
__webpack_require__(241);
__webpack_require__(242);
__webpack_require__(243);
__webpack_require__(244);
__webpack_require__(245);
__webpack_require__(246);
__webpack_require__(247);
__webpack_require__(248);
__webpack_require__(249);
__webpack_require__(250);
__webpack_require__(251);
__webpack_require__(252);
__webpack_require__(253);
__webpack_require__(255);
__webpack_require__(256);
__webpack_require__(257);
__webpack_require__(258);
__webpack_require__(259);
__webpack_require__(260);
__webpack_require__(261);
__webpack_require__(262);
__webpack_require__(263);
__webpack_require__(264);
__webpack_require__(265);
__webpack_require__(266);
__webpack_require__(267);
__webpack_require__(268);
__webpack_require__(269);
__webpack_require__(270);
__webpack_require__(271);
__webpack_require__(272);
__webpack_require__(273);
__webpack_require__(274);
__webpack_require__(275);
__webpack_require__(276);
__webpack_require__(277);
__webpack_require__(278);
__webpack_require__(279);
__webpack_require__(280);
__webpack_require__(281);
__webpack_require__(282);
__webpack_require__(283);
__webpack_require__(284);
__webpack_require__(285);
__webpack_require__(286);
__webpack_require__(287);
__webpack_require__(288);
__webpack_require__(289);
__webpack_require__(290);
__webpack_require__(291);
__webpack_require__(292);
__webpack_require__(293);
__webpack_require__(294);
__webpack_require__(295);
__webpack_require__(296);
__webpack_require__(297);
__webpack_require__(298);
__webpack_require__(299);
__webpack_require__(300);
__webpack_require__(301);
__webpack_require__(302);
__webpack_require__(303);
__webpack_require__(304);
__webpack_require__(305);
__webpack_require__(306);
__webpack_require__(307);
__webpack_require__(308);
__webpack_require__(309);
__webpack_require__(310);
__webpack_require__(311);
__webpack_require__(312);
__webpack_require__(313);
__webpack_require__(314);
__webpack_require__(315);
__webpack_require__(317);
__webpack_require__(318);
__webpack_require__(320);
__webpack_require__(321);
__webpack_require__(322);
__webpack_require__(323);
__webpack_require__(324);
__webpack_require__(325);
__webpack_require__(326);
__webpack_require__(328);
__webpack_require__(329);
__webpack_require__(330);
__webpack_require__(331);
__webpack_require__(332);
__webpack_require__(333);
__webpack_require__(334);
__webpack_require__(335);
__webpack_require__(336);
__webpack_require__(337);
__webpack_require__(338);
__webpack_require__(339);
__webpack_require__(340);
__webpack_require__(119);
__webpack_require__(341);
__webpack_require__(342);
__webpack_require__(166);
__webpack_require__(343);
__webpack_require__(344);
__webpack_require__(345);
__webpack_require__(346);
__webpack_require__(347);
__webpack_require__(169);
__webpack_require__(171);
__webpack_require__(172);
__webpack_require__(348);
__webpack_require__(349);
__webpack_require__(350);
__webpack_require__(351);
__webpack_require__(352);
__webpack_require__(353);
__webpack_require__(354);
__webpack_require__(355);
__webpack_require__(356);
__webpack_require__(357);
__webpack_require__(358);
__webpack_require__(359);
__webpack_require__(360);
__webpack_require__(361);
__webpack_require__(362);
__webpack_require__(363);
__webpack_require__(364);
__webpack_require__(365);
__webpack_require__(366);
__webpack_require__(367);
__webpack_require__(368);
__webpack_require__(369);
__webpack_require__(370);
__webpack_require__(371);
__webpack_require__(372);
__webpack_require__(373);
__webpack_require__(374);
__webpack_require__(375);
__webpack_require__(376);
__webpack_require__(377);
__webpack_require__(378);
__webpack_require__(379);
__webpack_require__(380);
__webpack_require__(381);
__webpack_require__(382);
__webpack_require__(383);
__webpack_require__(384);
__webpack_require__(385);
__webpack_require__(386);
__webpack_require__(387);
__webpack_require__(388);
__webpack_require__(389);
__webpack_require__(390);
__webpack_require__(391);
__webpack_require__(392);
__webpack_require__(393);
__webpack_require__(394);
__webpack_require__(395);
__webpack_require__(396);
__webpack_require__(397);
__webpack_require__(398);
__webpack_require__(399);
__webpack_require__(400);
__webpack_require__(401);
__webpack_require__(402);
__webpack_require__(403);
__webpack_require__(404);
__webpack_require__(405);
__webpack_require__(406);
__webpack_require__(407);
__webpack_require__(408);
__webpack_require__(409);
__webpack_require__(410);
__webpack_require__(411);
__webpack_require__(412);
__webpack_require__(413);
__webpack_require__(414);
__webpack_require__(415);
__webpack_require__(416);
__webpack_require__(417);
__webpack_require__(418);
__webpack_require__(419);
__webpack_require__(420);
__webpack_require__(421);
__webpack_require__(422);
__webpack_require__(423);
__webpack_require__(424);
__webpack_require__(425);
__webpack_require__(426);
__webpack_require__(427);
__webpack_require__(428);
__webpack_require__(429);
__webpack_require__(430);
__webpack_require__(431);
__webpack_require__(432);
module.exports = __webpack_require__(31);

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim

var global = __webpack_require__(5);
var has = __webpack_require__(18);
var DESCRIPTORS = __webpack_require__(11);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(20);
var META = __webpack_require__(42).KEY;
var $fails = __webpack_require__(6);
var shared = __webpack_require__(74);
var setToStringTag = __webpack_require__(58);
var uid = __webpack_require__(46);
var wks = __webpack_require__(9);
var wksExt = __webpack_require__(149);
var wksDefine = __webpack_require__(99);
var enumKeys = __webpack_require__(238);
var isArray = __webpack_require__(77);
var anObject = __webpack_require__(4);
var toIObject = __webpack_require__(23);
var toPrimitive = __webpack_require__(32);
var createDesc = __webpack_require__(45);
var _create = __webpack_require__(50);
var gOPNExt = __webpack_require__(152);
var $GOPD = __webpack_require__(24);
var $DP = __webpack_require__(12);
var $keys = __webpack_require__(48);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () {
      return dP(this, 'a', { value: 7 }).a;
    }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    }return setSymbolDesc(it, key, D);
  }return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  }return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  }return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(51).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(67).f = $propertyIsEnumerable;
  __webpack_require__(76).f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(47)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols =
// 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () {
    setter = true;
  },
  useSimple: function () {
    setter = false;
  }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    replacer = args[1];
    if (typeof replacer == 'function') $replacer = replacer;
    if ($replacer || !isArray(replacer)) replacer = function (key, value) {
      if ($replacer) value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(19)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(48);
var gOPS = __webpack_require__(76);
var pIE = __webpack_require__(67);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  }return result;
};

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__(50) });

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(11), 'Object', { defineProperty: __webpack_require__(12).f });

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !__webpack_require__(11), 'Object', { defineProperties: __webpack_require__(151) });

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(23);
var $getOwnPropertyDescriptor = __webpack_require__(24).f;

__webpack_require__(35)('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(15);
var $getPrototypeOf = __webpack_require__(25);

__webpack_require__(35)('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(15);
var $keys = __webpack_require__(48);

__webpack_require__(35)('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(35)('getOwnPropertyNames', function () {
  return __webpack_require__(152).f;
});

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(8);
var meta = __webpack_require__(42).onFreeze;

__webpack_require__(35)('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.2.17 Object.seal(O)
var isObject = __webpack_require__(8);
var meta = __webpack_require__(42).onFreeze;

__webpack_require__(35)('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__(8);
var meta = __webpack_require__(42).onFreeze;

__webpack_require__(35)('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.2.12 Object.isFrozen(O)
var isObject = __webpack_require__(8);

__webpack_require__(35)('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.2.13 Object.isSealed(O)
var isObject = __webpack_require__(8);

__webpack_require__(35)('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.2.11 Object.isExtensible(O)
var isObject = __webpack_require__(8);

__webpack_require__(35)('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(0);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(153) });

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__(0);
$export($export.S, 'Object', { is: __webpack_require__(254) });

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(0);
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(103).set });

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.3.6 Object.prototype.toString()

var classof = __webpack_require__(68);
var test = {};
test[__webpack_require__(9)('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  __webpack_require__(20)(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = __webpack_require__(0);

$export($export.P, 'Function', { bind: __webpack_require__(154) });

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var dP = __webpack_require__(12).f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || __webpack_require__(11) && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(8);
var getPrototypeOf = __webpack_require__(25);
var HAS_INSTANCE = __webpack_require__(9)('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(12).f(FunctionProto, HAS_INSTANCE, { value: function (O) {
    if (typeof this != 'function' || !isObject(O)) return false;
    if (!isObject(this.prototype)) return O instanceof this;
    // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
    while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
    return false;
  } });

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var $parseInt = __webpack_require__(156);
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var $parseFloat = __webpack_require__(157);
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(5);
var has = __webpack_require__(18);
var cof = __webpack_require__(29);
var inheritIfRequired = __webpack_require__(105);
var toPrimitive = __webpack_require__(32);
var fails = __webpack_require__(6);
var gOPN = __webpack_require__(51).f;
var gOPD = __webpack_require__(24).f;
var dP = __webpack_require__(12).f;
var $trim = __webpack_require__(59).trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(__webpack_require__(50)(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66:case 98:
          radix = 2;maxCode = 49;break; // fast equal /^0b[01]+$/i
        case 79:case 111:
          radix = 8;maxCode = 55;break; // fast equal /^0o[0-7]+$/i
        default:
          return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      }return parseInt(digits, radix);
    }
  }return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
    // check on 1..constructor(foo) case
    && (BROKEN_COF ? fails(function () {
      proto.valueOf.call(that);
    }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = __webpack_require__(11) ? gOPN(Base) : (
  // ES3:
  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
  // ES6 (in case, if modules with ES6 Number statics required before):
  'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  __webpack_require__(20)(global, NUMBER, $Number);
}

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var toInteger = __webpack_require__(34);
var aNumberValue = __webpack_require__(158);
var repeat = __webpack_require__(106);
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = c % n * 1e7;
  }
};
var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  }return s;
};
var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  }return n;
};

$export($export.P + $export.F * (!!$toFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !__webpack_require__(6)(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    }return m;
  }
});

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var $fails = __webpack_require__(6);
var aNumberValue = __webpack_require__(158);
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(0);

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.1.2.2 Number.isFinite(number)
var $export = __webpack_require__(0);
var _isFinite = __webpack_require__(5).isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(0);

$export($export.S, 'Number', { isInteger: __webpack_require__(159) });

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(0);

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.1.2.5 Number.isSafeInteger(number)
var $export = __webpack_require__(0);
var isInteger = __webpack_require__(159);
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(0);

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(0);

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var $parseFloat = __webpack_require__(157);
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var $parseInt = __webpack_require__(156);
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.2.2.3 Math.acosh(x)
var $export = __webpack_require__(0);
var log1p = __webpack_require__(160);
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
// V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
&& Math.floor($acosh(Number.MAX_VALUE)) == 710
// Tor Browser bug: Math.acosh(Infinity) -> NaN
&& $acosh(Infinity) == Infinity), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.2.2.5 Math.asinh(x)
var $export = __webpack_require__(0);
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.2.2.7 Math.atanh(x)
var $export = __webpack_require__(0);
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.2.2.9 Math.cbrt(x)
var $export = __webpack_require__(0);
var sign = __webpack_require__(107);

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.2.2.11 Math.clz32(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.2.2.12 Math.cosh(x)
var $export = __webpack_require__(0);
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.2.2.14 Math.expm1(x)
var $export = __webpack_require__(0);
var $expm1 = __webpack_require__(108);

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.2.2.16 Math.fround(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', { fround: __webpack_require__(161) });

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
var $export = __webpack_require__(0);
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) {
    // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.2.2.18 Math.imul(x, y)
var $export = __webpack_require__(0);
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * __webpack_require__(6)(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.2.2.20 Math.log1p(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', { log1p: __webpack_require__(160) });

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', { sign: __webpack_require__(107) });

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.2.2.30 Math.sinh(x)
var $export = __webpack_require__(0);
var expm1 = __webpack_require__(108);
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * __webpack_require__(6)(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.2.2.33 Math.tanh(x)
var $export = __webpack_require__(0);
var expm1 = __webpack_require__(108);
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var toAbsoluteIndex = __webpack_require__(49);
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) {
    // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
    }return res.join('');
  }
});

/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var toIObject = __webpack_require__(23);
var toLength = __webpack_require__(13);

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    }return res.join('');
  }
});

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.1.3.25 String.prototype.trim()

__webpack_require__(59)('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $at = __webpack_require__(109)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(110)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0; // next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var $at = __webpack_require__(109)(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])


var $export = __webpack_require__(0);
var toLength = __webpack_require__(13);
var context = __webpack_require__(112);
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * __webpack_require__(113)(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
  }
});

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)


var $export = __webpack_require__(0);
var context = __webpack_require__(112);
var INCLUDES = 'includes';

$export($export.P + $export.F * __webpack_require__(113)(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(106)
});

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])


var $export = __webpack_require__(0);
var toLength = __webpack_require__(13);
var context = __webpack_require__(112);
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * __webpack_require__(113)(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
  }
});

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.2 String.prototype.anchor(name)

__webpack_require__(21)('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.3 String.prototype.big()

__webpack_require__(21)('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.4 String.prototype.blink()

__webpack_require__(21)('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.5 String.prototype.bold()

__webpack_require__(21)('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.6 String.prototype.fixed()

__webpack_require__(21)('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.7 String.prototype.fontcolor(color)

__webpack_require__(21)('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.8 String.prototype.fontsize(size)

__webpack_require__(21)('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.9 String.prototype.italics()

__webpack_require__(21)('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.10 String.prototype.link(url)

__webpack_require__(21)('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.11 String.prototype.small()

__webpack_require__(21)('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.12 String.prototype.strike()

__webpack_require__(21)('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.13 String.prototype.sub()

__webpack_require__(21)('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.14 String.prototype.sup()

__webpack_require__(21)('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__(0);

$export($export.S, 'Date', { now: function () {
    return new Date().getTime();
  } });

/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var toObject = __webpack_require__(15);
var toPrimitive = __webpack_require__(32);

$export($export.P + $export.F * __webpack_require__(6)(function () {
  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({ toISOString: function () {
      return 1;
    } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = __webpack_require__(0);
var toISOString = __webpack_require__(316);

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});

/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()

var fails = __webpack_require__(6);
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
}) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(20)(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var TO_PRIMITIVE = __webpack_require__(9)('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) __webpack_require__(19)(proto, TO_PRIMITIVE, __webpack_require__(319));

/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(4);
var toPrimitive = __webpack_require__(32);
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(0);

$export($export.S, 'Array', { isArray: __webpack_require__(77) });

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ctx = __webpack_require__(28);
var $export = __webpack_require__(0);
var toObject = __webpack_require__(15);
var call = __webpack_require__(162);
var isArrayIter = __webpack_require__(114);
var toLength = __webpack_require__(13);
var createProperty = __webpack_require__(115);
var getIterFn = __webpack_require__(116);

$export($export.S + $export.F * !__webpack_require__(79)(function (iter) {
  Array.from(iter);
}), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var createProperty = __webpack_require__(115);

// WebKit Array.of isn't generic
$export($export.S + $export.F * __webpack_require__(6)(function () {
  function F() {/* empty */}
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of() /* ...args */{
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.13 Array.prototype.join(separator)

var $export = __webpack_require__(0);
var toIObject = __webpack_require__(23);
var arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (__webpack_require__(66) != Object || !__webpack_require__(30)(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var html = __webpack_require__(102);
var cof = __webpack_require__(29);
var toAbsoluteIndex = __webpack_require__(49);
var toLength = __webpack_require__(13);
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * __webpack_require__(6)(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = Array(size);
    var i = 0;
    for (; i < size; i++) cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];
    return cloned;
  }
});

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var aFunction = __webpack_require__(17);
var toObject = __webpack_require__(15);
var fails = __webpack_require__(6);
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !__webpack_require__(30)($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined ? $sort.call(toObject(this)) : $sort.call(toObject(this), aFunction(comparefn));
  }
});

/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var $forEach = __webpack_require__(36)(0);
var STRICT = __webpack_require__(30)([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(8);
var isArray = __webpack_require__(77);
var SPECIES = __webpack_require__(9)('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  }return C === undefined ? Array : C;
};

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var $map = __webpack_require__(36)(1);

$export($export.P + $export.F * !__webpack_require__(30)([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var $filter = __webpack_require__(36)(2);

$export($export.P + $export.F * !__webpack_require__(30)([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var $some = __webpack_require__(36)(3);

$export($export.P + $export.F * !__webpack_require__(30)([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var $every = __webpack_require__(36)(4);

$export($export.P + $export.F * !__webpack_require__(30)([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var $reduce = __webpack_require__(163);

$export($export.P + $export.F * !__webpack_require__(30)([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var $reduce = __webpack_require__(163);

$export($export.P + $export.F * !__webpack_require__(30)([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var $indexOf = __webpack_require__(75)(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(30)($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
    // convert -0 to +0
    ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
  }
});

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var toIObject = __webpack_require__(23);
var toInteger = __webpack_require__(34);
var toLength = __webpack_require__(13);
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(30)($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (; index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
    return -1;
  }
});

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = __webpack_require__(0);

$export($export.P, 'Array', { copyWithin: __webpack_require__(164) });

__webpack_require__(43)('copyWithin');

/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(0);

$export($export.P, 'Array', { fill: __webpack_require__(118) });

__webpack_require__(43)('fill');

/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

var $export = __webpack_require__(0);
var $find = __webpack_require__(36)(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(43)(KEY);

/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)

var $export = __webpack_require__(0);
var $find = __webpack_require__(36)(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(43)(KEY);

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(52)('Array');

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(5);
var inheritIfRequired = __webpack_require__(105);
var dP = __webpack_require__(12).f;
var gOPN = __webpack_require__(51).f;
var isRegExp = __webpack_require__(78);
var $flags = __webpack_require__(80);
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__(11) && (!CORRECT_NEW || __webpack_require__(6)(function () {
  re2[__webpack_require__(9)('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f), tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () {
        return Base[key];
      },
      set: function (it) {
        Base[key] = it;
      }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  __webpack_require__(20)(global, 'RegExp', $RegExp);
}

__webpack_require__(52)('RegExp');

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(166);
var anObject = __webpack_require__(4);
var $flags = __webpack_require__(80);
var DESCRIPTORS = __webpack_require__(11);
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  __webpack_require__(20)(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (__webpack_require__(6)(function () {
  return $toString.call({ source: 'a', flags: 'b' }) != '/a/b';
})) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
  // FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// @@match logic
__webpack_require__(81)('match', 1, function (defined, MATCH, $match) {
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp) {
    'use strict';

    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});

/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// @@replace logic
__webpack_require__(81)('replace', 2, function (defined, REPLACE, $replace) {
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue) {
    'use strict';

    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// @@search logic
__webpack_require__(81)('search', 1, function (defined, SEARCH, $search) {
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp) {
    'use strict';

    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});

/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// @@split logic
__webpack_require__(81)('split', 2, function (defined, SPLIT, $split) {
  'use strict';

  var isRegExp = __webpack_require__(78);
  var _split = $split;
  var $push = [].push;
  var $SPLIT = 'split';
  var LENGTH = 'length';
  var LAST_INDEX = 'lastIndex';
  if ('abbc'[$SPLIT](/(b)*/)[1] == 'c' || 'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || 'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || '.'[$SPLIT](/()()/)[LENGTH] > 1 || ''[$SPLIT](/.?/)[LENGTH]) {
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while (match = separatorCopy.exec(string)) {
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          // eslint-disable-next-line no-loop-func
          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;
          });
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
    // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    $split = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit) {
    var O = defined(this);
    var fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});

/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__(47);
var global = __webpack_require__(5);
var ctx = __webpack_require__(28);
var classof = __webpack_require__(68);
var $export = __webpack_require__(0);
var isObject = __webpack_require__(8);
var aFunction = __webpack_require__(17);
var anInstance = __webpack_require__(53);
var forOf = __webpack_require__(54);
var speciesConstructor = __webpack_require__(82);
var task = __webpack_require__(120).set;
var microtask = __webpack_require__(121)();
var newPromiseCapabilityModule = __webpack_require__(122);
var perform = __webpack_require__(167);
var promiseResolve = __webpack_require__(168);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () {/* empty */};
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(9)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) {/* empty */}
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) domain.exit();
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    }promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  if (promise._h == 1) return false;
  var chain = promise._a || promise._c;
  var i = 0;
  var reaction;
  while (chain.length > i) {
    reaction = chain[i++];
    if (reaction.fail || !isUnhandled(reaction.promise)) return false;
  }return true;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = []; // <- awaiting reactions
    this._a = undefined; // <- checked in isUnhandled reactions
    this._s = 0; // <- state
    this._d = false; // <- done
    this._v = undefined; // <- value
    this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false; // <- notify
  };
  Internal.prototype = __webpack_require__(55)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(58)($Promise, PROMISE);
__webpack_require__(52)(PROMISE);
Wrapper = __webpack_require__(31)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(79)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var weak = __webpack_require__(173);
var validate = __webpack_require__(61);
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
__webpack_require__(83)(WEAK_SET, function (get) {
  return function WeakSet() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var $typed = __webpack_require__(84);
var buffer = __webpack_require__(123);
var anObject = __webpack_require__(4);
var toAbsoluteIndex = __webpack_require__(49);
var toLength = __webpack_require__(13);
var isObject = __webpack_require__(8);
var ArrayBuffer = __webpack_require__(5).ArrayBuffer;
var speciesConstructor = __webpack_require__(82);
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * __webpack_require__(6)(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var final = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < final) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    }return result;
  }
});

__webpack_require__(52)(ARRAY_BUFFER);

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
$export($export.G + $export.W + $export.F * !__webpack_require__(84).ABV, {
  DataView: __webpack_require__(123).DataView
});

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(39)('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(39)('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(39)('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(39)('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(39)('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(39)('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(39)('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(39)('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(39)('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = __webpack_require__(0);
var aFunction = __webpack_require__(17);
var anObject = __webpack_require__(4);
var rApply = (__webpack_require__(5).Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !__webpack_require__(6)(function () {
  rApply(function () {/* empty */});
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = __webpack_require__(0);
var create = __webpack_require__(50);
var aFunction = __webpack_require__(17);
var anObject = __webpack_require__(4);
var isObject = __webpack_require__(8);
var fails = __webpack_require__(6);
var bind = __webpack_require__(154);
var rConstruct = (__webpack_require__(5).Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() {/* empty */}
  return !(rConstruct(function () {/* empty */}, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () {/* empty */});
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0:
          return new Target();
        case 1:
          return new Target(args[0]);
        case 2:
          return new Target(args[0], args[1]);
        case 3:
          return new Target(args[0], args[1], args[2]);
        case 4:
          return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = __webpack_require__(12);
var $export = __webpack_require__(0);
var anObject = __webpack_require__(4);
var toPrimitive = __webpack_require__(32);

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * __webpack_require__(6)(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = __webpack_require__(0);
var gOPD = __webpack_require__(24).f;
var anObject = __webpack_require__(4);

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 26.1.5 Reflect.enumerate(target)

var $export = __webpack_require__(0);
var anObject = __webpack_require__(4);
var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target
  this._i = 0; // next index
  var keys = this._k = []; // keys
  var key;
  for (key in iterated) keys.push(key);
};
__webpack_require__(111)(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
    if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});

/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = __webpack_require__(24);
var getPrototypeOf = __webpack_require__(25);
var has = __webpack_require__(18);
var $export = __webpack_require__(0);
var isObject = __webpack_require__(8);
var anObject = __webpack_require__(4);

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });

/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = __webpack_require__(24);
var $export = __webpack_require__(0);
var anObject = __webpack_require__(4);

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 26.1.8 Reflect.getPrototypeOf(target)
var $export = __webpack_require__(0);
var getProto = __webpack_require__(25);
var anObject = __webpack_require__(4);

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__(0);

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 26.1.10 Reflect.isExtensible(target)
var $export = __webpack_require__(0);
var anObject = __webpack_require__(4);
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 26.1.11 Reflect.ownKeys(target)
var $export = __webpack_require__(0);

$export($export.S, 'Reflect', { ownKeys: __webpack_require__(175) });

/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 26.1.12 Reflect.preventExtensions(target)
var $export = __webpack_require__(0);
var anObject = __webpack_require__(4);
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = __webpack_require__(12);
var gOPD = __webpack_require__(24);
var getPrototypeOf = __webpack_require__(25);
var has = __webpack_require__(18);
var $export = __webpack_require__(0);
var createDesc = __webpack_require__(45);
var anObject = __webpack_require__(4);
var isObject = __webpack_require__(8);

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
    existingDescriptor.value = V;
    dP.f(receiver, propertyKey, existingDescriptor);
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });

/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = __webpack_require__(0);
var setProto = __webpack_require__(103);

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/Array.prototype.includes

var $export = __webpack_require__(0);
var $includes = __webpack_require__(75)(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(43)('includes');

/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap

var $export = __webpack_require__(0);
var flattenIntoArray = __webpack_require__(176);
var toObject = __webpack_require__(15);
var toLength = __webpack_require__(13);
var aFunction = __webpack_require__(17);
var arraySpeciesCreate = __webpack_require__(117);

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

__webpack_require__(43)('flatMap');

/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten

var $export = __webpack_require__(0);
var flattenIntoArray = __webpack_require__(176);
var toObject = __webpack_require__(15);
var toLength = __webpack_require__(13);
var toInteger = __webpack_require__(34);
var arraySpeciesCreate = __webpack_require__(117);

$export($export.P, 'Array', {
  flatten: function flatten() /* depthArg = 1 */{
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

__webpack_require__(43)('flatten');

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/mathiasbynens/String.prototype.at

var $export = __webpack_require__(0);
var $at = __webpack_require__(109)(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});

/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end

var $export = __webpack_require__(0);
var $pad = __webpack_require__(177);

$export($export.P, 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end

var $export = __webpack_require__(0);
var $pad = __webpack_require__(177);

$export($export.P, 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim

__webpack_require__(59)('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');

/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim

__webpack_require__(59)('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/String.prototype.matchAll/

var $export = __webpack_require__(0);
var defined = __webpack_require__(33);
var toLength = __webpack_require__(13);
var isRegExp = __webpack_require__(78);
var getFlags = __webpack_require__(80);
var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function (regexp, string) {
  this._r = regexp;
  this._s = string;
};

__webpack_require__(111)($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);
  return { value: match, done: match === null };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});

/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(99)('asyncIterator');

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(99)('observable');

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __webpack_require__(0);
var ownKeys = __webpack_require__(175);
var toIObject = __webpack_require__(23);
var gOPD = __webpack_require__(24);
var createProperty = __webpack_require__(115);

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});

/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(0);
var $values = __webpack_require__(178)(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(0);
var $entries = __webpack_require__(178)(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var toObject = __webpack_require__(15);
var aFunction = __webpack_require__(17);
var $defineProperty = __webpack_require__(12);

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
__webpack_require__(11) && $export($export.P + __webpack_require__(85), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
  }
});

/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var toObject = __webpack_require__(15);
var aFunction = __webpack_require__(17);
var $defineProperty = __webpack_require__(12);

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
__webpack_require__(11) && $export($export.P + __webpack_require__(85), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
  }
});

/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var toObject = __webpack_require__(15);
var toPrimitive = __webpack_require__(32);
var getPrototypeOf = __webpack_require__(25);
var getOwnPropertyDescriptor = __webpack_require__(24).f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
__webpack_require__(11) && $export($export.P + __webpack_require__(85), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});

/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var toObject = __webpack_require__(15);
var toPrimitive = __webpack_require__(32);
var getPrototypeOf = __webpack_require__(25);
var getOwnPropertyDescriptor = __webpack_require__(24).f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
__webpack_require__(11) && $export($export.P + __webpack_require__(85), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});

/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(0);

$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(179)('Map') });

/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(0);

$export($export.P + $export.R, 'Set', { toJSON: __webpack_require__(179)('Set') });

/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__(86)('Map');

/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
__webpack_require__(86)('Set');

/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
__webpack_require__(86)('WeakMap');

/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
__webpack_require__(86)('WeakSet');

/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__(87)('Map');

/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
__webpack_require__(87)('Set');

/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
__webpack_require__(87)('WeakMap');

/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
__webpack_require__(87)('WeakSet');

/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://github.com/tc39/proposal-global
var $export = __webpack_require__(0);

$export($export.G, { global: __webpack_require__(5) });

/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://github.com/tc39/proposal-global
var $export = __webpack_require__(0);

$export($export.S, 'System', { global: __webpack_require__(5) });

/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://github.com/ljharb/proposal-is-error
var $export = __webpack_require__(0);
var cof = __webpack_require__(29);

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});

/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});

/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });

/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);
var RAD_PER_DEG = 180 / Math.PI;

$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});

/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);
var scale = __webpack_require__(181);
var fround = __webpack_require__(161);

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});

/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});

/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});

/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});

/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });

/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);
var DEG_PER_RAD = Math.PI / 180;

$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});

/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', { scale: __webpack_require__(181) });

/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});

/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// http://jfbastien.github.io/papers/Math.signbit.html
var $export = __webpack_require__(0);

$export($export.S, 'Math', { signbit: function signbit(x) {
    // eslint-disable-next-line no-self-compare
    return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
  } });

/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally


var $export = __webpack_require__(0);
var core = __webpack_require__(31);
var global = __webpack_require__(5);
var speciesConstructor = __webpack_require__(82);
var promiseResolve = __webpack_require__(168);

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
    var C = speciesConstructor(this, core.Promise || global.Promise);
    var isFunction = typeof onFinally == 'function';
    return this.then(isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () {
        return x;
      });
    } : onFinally, isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () {
        throw e;
      });
    } : onFinally);
  } });

/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try

var $export = __webpack_require__(0);
var newPromiseCapability = __webpack_require__(122);
var perform = __webpack_require__(167);

$export($export.S, 'Promise', { 'try': function (callbackfn) {
    var promiseCapability = newPromiseCapability.f(this);
    var result = perform(callbackfn);
    (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
    return promiseCapability.promise;
  } });

/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var metadata = __webpack_require__(40);
var anObject = __webpack_require__(4);
var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
    ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
  } });

/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var metadata = __webpack_require__(40);
var anObject = __webpack_require__(4);
var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;

metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
    var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
    var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
    if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
    if (metadataMap.size) return true;
    var targetMetadata = store.get(target);
    targetMetadata['delete'](targetKey);
    return !!targetMetadata.size || store['delete'](target);
  } });

/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var metadata = __webpack_require__(40);
var anObject = __webpack_require__(4);
var getPrototypeOf = __webpack_require__(25);
var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
    return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  } });

/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Set = __webpack_require__(171);
var from = __webpack_require__(180);
var metadata = __webpack_require__(40);
var anObject = __webpack_require__(4);
var getPrototypeOf = __webpack_require__(25);
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
    return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
  } });

/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var metadata = __webpack_require__(40);
var anObject = __webpack_require__(4);
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
    return ordinaryGetOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  } });

/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var metadata = __webpack_require__(40);
var anObject = __webpack_require__(4);
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
    return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
  } });

/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var metadata = __webpack_require__(40);
var anObject = __webpack_require__(4);
var getPrototypeOf = __webpack_require__(25);
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
    return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  } });

/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var metadata = __webpack_require__(40);
var anObject = __webpack_require__(4);
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
    return ordinaryHasOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  } });

/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $metadata = __webpack_require__(40);
var anObject = __webpack_require__(4);
var aFunction = __webpack_require__(17);
var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;

$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
    return function decorator(target, targetKey) {
      ordinaryDefineOwnMetadata(metadataKey, metadataValue, (targetKey !== undefined ? anObject : aFunction)(target), toMetaKey(targetKey));
    };
  } });

/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = __webpack_require__(0);
var microtask = __webpack_require__(121)();
var process = __webpack_require__(5).process;
var isNode = __webpack_require__(29)(process) == 'process';

$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});

/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/zenparsing/es-observable

var $export = __webpack_require__(0);
var global = __webpack_require__(5);
var core = __webpack_require__(31);
var microtask = __webpack_require__(121)();
var OBSERVABLE = __webpack_require__(9)('observable');
var aFunction = __webpack_require__(17);
var anObject = __webpack_require__(4);
var anInstance = __webpack_require__(53);
var redefineAll = __webpack_require__(55);
var hide = __webpack_require__(19);
var forOf = __webpack_require__(54);
var RETURN = forOf.RETURN;

var getMethod = function (fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function (subscription) {
  var cleanup = subscription._c;
  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function (subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function (subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function (observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;
    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function () {
        subscription.unsubscribe();
      };else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  }if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() {
    closeSubscription(this);
  }
});

var SubscriptionObserver = function (subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    }cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      }cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function (value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }
    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          }observer.complete();
        }
      });
      return function () {
        done = true;
      };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = Array(l); i < l;) items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          }observer.complete();
        }
      });
      return function () {
        done = true;
      };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function () {
  return this;
});

$export($export.G, { Observable: $Observable });

__webpack_require__(52)('Observable');

/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// ie9- setTimeout & setInterval additional parameters fix
var global = __webpack_require__(5);
var $export = __webpack_require__(0);
var navigator = global.navigator;
var slice = [].slice;
var MSIE = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(0);
var $task = __webpack_require__(120);
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $iterators = __webpack_require__(119);
var getKeys = __webpack_require__(48);
var redefine = __webpack_require__(20);
var global = __webpack_require__(5);
var hide = __webpack_require__(19);
var Iterators = __webpack_require__(60);
var wks = __webpack_require__(9);
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!function (global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction ||
    // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function (arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
      // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
      // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));

    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function (object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function (skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function () {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function (exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function (record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function (iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
}(
// Among the various tricks for obtaining a reference to the global
// object, this seems to be the most reliable technique that does not
// use indirect eval (which violates Content Security Policy).
typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : undefined);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)))

/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(435);
module.exports = __webpack_require__(31).RegExp.escape;

/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://github.com/benjamingr/RexExp.escape
var $export = __webpack_require__(0);
var $re = __webpack_require__(436)(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', { escape: function escape(it) {
    return $re(it);
  } });

/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (regExp, replace) {
  var replacer = replace === Object(replace) ? function (part) {
    return replace[part];
  } : replace;
  return function (it) {
    return String(it).replace(regExp, replacer);
  };
};

/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var PooledClass = __webpack_require__(438);
var ReactElement = __webpack_require__(56);

var emptyFunction = __webpack_require__(26);
var traverseAllChildren = __webpack_require__(439);

var twoArgumentPooler = PooledClass.twoArgumentPooler;
var fourArgumentPooler = PooledClass.fourArgumentPooler;

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * traversal. Allows avoiding binding callbacks.
 *
 * @constructor ForEachBookKeeping
 * @param {!function} forEachFunction Function to perform traversal with.
 * @param {?*} forEachContext Context to perform context with.
 */
function ForEachBookKeeping(forEachFunction, forEachContext) {
  this.func = forEachFunction;
  this.context = forEachContext;
  this.count = 0;
}
ForEachBookKeeping.prototype.destructor = function () {
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  ForEachBookKeeping.release(traverseContext);
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * mapping. Allows avoiding binding callbacks.
 *
 * @constructor MapBookKeeping
 * @param {!*} mapResult Object containing the ordered map of results.
 * @param {!function} mapFunction Function to perform mapping with.
 * @param {?*} mapContext Context to perform mapping with.
 */
function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
  this.result = mapResult;
  this.keyPrefix = keyPrefix;
  this.func = mapFunction;
  this.context = mapContext;
  this.count = 0;
}
MapBookKeeping.prototype.destructor = function () {
  this.result = null;
  this.keyPrefix = null;
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;

  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (ReactElement.isValidElement(mappedChild)) {
      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

function forEachSingleChildDummy(traverseContext, child, name) {
  return null;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, forEachSingleChildDummy, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

var ReactChildren = {
  forEach: forEachChildren,
  map: mapChildren,
  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
  count: countChildren,
  toArray: toArray
};

module.exports = ReactChildren;

/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(63);

var invariant = __webpack_require__(2);

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function (a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function (a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fourArgumentPooler = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances.
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function (CopyConstructor, pooler) {
  // Casting as any so that flow ignores the actual implementation and trusts
  // it to match the type we declared
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fourArgumentPooler: fourArgumentPooler
};

module.exports = PooledClass;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(63);

var ReactCurrentOwner = __webpack_require__(37);
var REACT_ELEMENT_TYPE = __webpack_require__(184);

var getIteratorFn = __webpack_require__(185);
var invariant = __webpack_require__(2);
var KeyEscapeUtils = __webpack_require__(440);
var warning = __webpack_require__(3);

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * This is inlined from ReactElement since this file is shared between
 * isomorphic and renderers. We could extract this to a
 *
 */

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (component && typeof component === 'object' && component.key != null) {
    // Explicit key
    return KeyEscapeUtils.escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' ||
  // The following is inlined from ReactElement. This means we can optimize
  // some checks. React Fiber also inlines this logic for similar purposes.
  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if (process.env.NODE_ENV !== 'production') {
          var mapsAsChildrenAddendum = '';
          if (ReactCurrentOwner.current) {
            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
            if (mapsAsChildrenOwnerName) {
              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
            }
          }
          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      if (process.env.NODE_ENV !== 'production') {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = " It looks like you're using an element created by a different " + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner.current) {
          var name = ReactCurrentOwner.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 440 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * Unescape and unwrap key for human-readable display
 *
 * @param {string} key to unescape.
 * @return {string} the unescaped key.
 */
function unescape(key) {
  var unescapeRegex = /(=0|=2)/g;
  var unescaperLookup = {
    '=0': '=',
    '=2': ':'
  };
  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

  return ('' + keySubstring).replace(unescapeRegex, function (match) {
    return unescaperLookup[match];
  });
}

var KeyEscapeUtils = {
  escape: escape,
  unescape: unescape
};

module.exports = KeyEscapeUtils;

/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactElement = __webpack_require__(56);

/**
 * Create a factory that creates HTML tag elements.
 *
 * @private
 */
var createDOMFactory = ReactElement.createFactory;
if (process.env.NODE_ENV !== 'production') {
  var ReactElementValidator = __webpack_require__(186);
  createDOMFactory = ReactElementValidator.createFactory;
}

/**
 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
 *
 * @public
 */
var ReactDOMFactories = {
  a: createDOMFactory('a'),
  abbr: createDOMFactory('abbr'),
  address: createDOMFactory('address'),
  area: createDOMFactory('area'),
  article: createDOMFactory('article'),
  aside: createDOMFactory('aside'),
  audio: createDOMFactory('audio'),
  b: createDOMFactory('b'),
  base: createDOMFactory('base'),
  bdi: createDOMFactory('bdi'),
  bdo: createDOMFactory('bdo'),
  big: createDOMFactory('big'),
  blockquote: createDOMFactory('blockquote'),
  body: createDOMFactory('body'),
  br: createDOMFactory('br'),
  button: createDOMFactory('button'),
  canvas: createDOMFactory('canvas'),
  caption: createDOMFactory('caption'),
  cite: createDOMFactory('cite'),
  code: createDOMFactory('code'),
  col: createDOMFactory('col'),
  colgroup: createDOMFactory('colgroup'),
  data: createDOMFactory('data'),
  datalist: createDOMFactory('datalist'),
  dd: createDOMFactory('dd'),
  del: createDOMFactory('del'),
  details: createDOMFactory('details'),
  dfn: createDOMFactory('dfn'),
  dialog: createDOMFactory('dialog'),
  div: createDOMFactory('div'),
  dl: createDOMFactory('dl'),
  dt: createDOMFactory('dt'),
  em: createDOMFactory('em'),
  embed: createDOMFactory('embed'),
  fieldset: createDOMFactory('fieldset'),
  figcaption: createDOMFactory('figcaption'),
  figure: createDOMFactory('figure'),
  footer: createDOMFactory('footer'),
  form: createDOMFactory('form'),
  h1: createDOMFactory('h1'),
  h2: createDOMFactory('h2'),
  h3: createDOMFactory('h3'),
  h4: createDOMFactory('h4'),
  h5: createDOMFactory('h5'),
  h6: createDOMFactory('h6'),
  head: createDOMFactory('head'),
  header: createDOMFactory('header'),
  hgroup: createDOMFactory('hgroup'),
  hr: createDOMFactory('hr'),
  html: createDOMFactory('html'),
  i: createDOMFactory('i'),
  iframe: createDOMFactory('iframe'),
  img: createDOMFactory('img'),
  input: createDOMFactory('input'),
  ins: createDOMFactory('ins'),
  kbd: createDOMFactory('kbd'),
  keygen: createDOMFactory('keygen'),
  label: createDOMFactory('label'),
  legend: createDOMFactory('legend'),
  li: createDOMFactory('li'),
  link: createDOMFactory('link'),
  main: createDOMFactory('main'),
  map: createDOMFactory('map'),
  mark: createDOMFactory('mark'),
  menu: createDOMFactory('menu'),
  menuitem: createDOMFactory('menuitem'),
  meta: createDOMFactory('meta'),
  meter: createDOMFactory('meter'),
  nav: createDOMFactory('nav'),
  noscript: createDOMFactory('noscript'),
  object: createDOMFactory('object'),
  ol: createDOMFactory('ol'),
  optgroup: createDOMFactory('optgroup'),
  option: createDOMFactory('option'),
  output: createDOMFactory('output'),
  p: createDOMFactory('p'),
  param: createDOMFactory('param'),
  picture: createDOMFactory('picture'),
  pre: createDOMFactory('pre'),
  progress: createDOMFactory('progress'),
  q: createDOMFactory('q'),
  rp: createDOMFactory('rp'),
  rt: createDOMFactory('rt'),
  ruby: createDOMFactory('ruby'),
  s: createDOMFactory('s'),
  samp: createDOMFactory('samp'),
  script: createDOMFactory('script'),
  section: createDOMFactory('section'),
  select: createDOMFactory('select'),
  small: createDOMFactory('small'),
  source: createDOMFactory('source'),
  span: createDOMFactory('span'),
  strong: createDOMFactory('strong'),
  style: createDOMFactory('style'),
  sub: createDOMFactory('sub'),
  summary: createDOMFactory('summary'),
  sup: createDOMFactory('sup'),
  table: createDOMFactory('table'),
  tbody: createDOMFactory('tbody'),
  td: createDOMFactory('td'),
  textarea: createDOMFactory('textarea'),
  tfoot: createDOMFactory('tfoot'),
  th: createDOMFactory('th'),
  thead: createDOMFactory('thead'),
  time: createDOMFactory('time'),
  title: createDOMFactory('title'),
  tr: createDOMFactory('tr'),
  track: createDOMFactory('track'),
  u: createDOMFactory('u'),
  ul: createDOMFactory('ul'),
  'var': createDOMFactory('var'),
  video: createDOMFactory('video'),
  wbr: createDOMFactory('wbr'),

  // SVG
  circle: createDOMFactory('circle'),
  clipPath: createDOMFactory('clipPath'),
  defs: createDOMFactory('defs'),
  ellipse: createDOMFactory('ellipse'),
  g: createDOMFactory('g'),
  image: createDOMFactory('image'),
  line: createDOMFactory('line'),
  linearGradient: createDOMFactory('linearGradient'),
  mask: createDOMFactory('mask'),
  path: createDOMFactory('path'),
  pattern: createDOMFactory('pattern'),
  polygon: createDOMFactory('polygon'),
  polyline: createDOMFactory('polyline'),
  radialGradient: createDOMFactory('radialGradient'),
  rect: createDOMFactory('rect'),
  stop: createDOMFactory('stop'),
  svg: createDOMFactory('svg'),
  text: createDOMFactory('text'),
  tspan: createDOMFactory('tspan')
};

module.exports = ReactDOMFactories;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(63);

var ReactPropTypeLocationNames = __webpack_require__(443);
var ReactPropTypesSecret = __webpack_require__(444);

var invariant = __webpack_require__(2);
var warning = __webpack_require__(3);

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = __webpack_require__(22);
}

var loggedTypeFailures = {};

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?object} element The React element that is being type-checked
 * @param {?number} debugID The React component instance that is being type-checked
 * @private
 */
function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
  for (var typeSpecName in typeSpecs) {
    if (typeSpecs.hasOwnProperty(typeSpecName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
      } catch (ex) {
        error = ex;
      }
      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var componentStackInfo = '';

        if (process.env.NODE_ENV !== 'production') {
          if (!ReactComponentTreeHook) {
            ReactComponentTreeHook = __webpack_require__(22);
          }
          if (debugID !== null) {
            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
          } else if (element !== null) {
            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
          }
        }

        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
      }
    }
  }
}

module.exports = checkReactTypeSpec;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactPropTypeLocationNames = {};

if (process.env.NODE_ENV !== 'production') {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

module.exports = ReactPropTypeLocationNames;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _require = __webpack_require__(56),
    isValidElement = _require.isValidElement;

var factory = __webpack_require__(187);

module.exports = factory(isValidElement);

/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



if (process.env.NODE_ENV !== 'production') {
  var invariant = __webpack_require__(2);
  var warning = __webpack_require__(3);
  var ReactPropTypesSecret = __webpack_require__(125);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', location, typeSpecName);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



module.exports = '15.6.1';

/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _require = __webpack_require__(182),
    Component = _require.Component;

var _require2 = __webpack_require__(56),
    isValidElement = _require2.isValidElement;

var ReactNoopUpdateQueue = __webpack_require__(183);
var factory = __webpack_require__(449);

module.exports = factory(Component, isValidElement, ReactNoopUpdateQueue);

/***/ }),
/* 449 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(10);

var emptyObject = __webpack_require__(90);
var _invariant = __webpack_require__(2);

if (process.env.NODE_ENV !== 'production') {
  var warning = __webpack_require__(3);
}

var MIXINS_KEY = 'mixins';

// Helper function to allow the creation of anonymous functions which do not
// have .name set to the name of the variable being assigned to.
function identity(fn) {
  return fn;
}

var ReactPropTypeLocationNames;
if (process.env.NODE_ENV !== 'production') {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
} else {
  ReactPropTypeLocationNames = {};
}

function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
  /**
   * Policies that describe methods in `ReactClassInterface`.
   */

  var injectedMixins = [];

  /**
   * Composite components are higher-level components that compose other composite
   * or host components.
   *
   * To create a new type of `ReactClass`, pass a specification of
   * your new class to `React.createClass`. The only requirement of your class
   * specification is that you implement a `render` method.
   *
   *   var MyComponent = React.createClass({
   *     render: function() {
   *       return <div>Hello World</div>;
   *     }
   *   });
   *
   * The class specification supports a specific protocol of methods that have
   * special meaning (e.g. `render`). See `ReactClassInterface` for
   * more the comprehensive protocol. Any other properties and methods in the
   * class specification will be available on the prototype.
   *
   * @interface ReactClassInterface
   * @internal
   */
  var ReactClassInterface = {
    /**
     * An array of Mixin objects to include when defining your component.
     *
     * @type {array}
     * @optional
     */
    mixins: 'DEFINE_MANY',

    /**
     * An object containing properties and methods that should be defined on
     * the component's constructor instead of its prototype (static methods).
     *
     * @type {object}
     * @optional
     */
    statics: 'DEFINE_MANY',

    /**
     * Definition of prop types for this component.
     *
     * @type {object}
     * @optional
     */
    propTypes: 'DEFINE_MANY',

    /**
     * Definition of context types for this component.
     *
     * @type {object}
     * @optional
     */
    contextTypes: 'DEFINE_MANY',

    /**
     * Definition of context types this component sets for its children.
     *
     * @type {object}
     * @optional
     */
    childContextTypes: 'DEFINE_MANY',

    // ==== Definition methods ====

    /**
     * Invoked when the component is mounted. Values in the mapping will be set on
     * `this.props` if that prop is not specified (i.e. using an `in` check).
     *
     * This method is invoked before `getInitialState` and therefore cannot rely
     * on `this.state` or use `this.setState`.
     *
     * @return {object}
     * @optional
     */
    getDefaultProps: 'DEFINE_MANY_MERGED',

    /**
     * Invoked once before the component is mounted. The return value will be used
     * as the initial value of `this.state`.
     *
     *   getInitialState: function() {
     *     return {
     *       isOn: false,
     *       fooBaz: new BazFoo()
     *     }
     *   }
     *
     * @return {object}
     * @optional
     */
    getInitialState: 'DEFINE_MANY_MERGED',

    /**
     * @return {object}
     * @optional
     */
    getChildContext: 'DEFINE_MANY_MERGED',

    /**
     * Uses props from `this.props` and state from `this.state` to render the
     * structure of the component.
     *
     * No guarantees are made about when or how often this method is invoked, so
     * it must not have side effects.
     *
     *   render: function() {
     *     var name = this.props.name;
     *     return <div>Hello, {name}!</div>;
     *   }
     *
     * @return {ReactComponent}
     * @required
     */
    render: 'DEFINE_ONCE',

    // ==== Delegate methods ====

    /**
     * Invoked when the component is initially created and about to be mounted.
     * This may have side effects, but any external subscriptions or data created
     * by this method must be cleaned up in `componentWillUnmount`.
     *
     * @optional
     */
    componentWillMount: 'DEFINE_MANY',

    /**
     * Invoked when the component has been mounted and has a DOM representation.
     * However, there is no guarantee that the DOM node is in the document.
     *
     * Use this as an opportunity to operate on the DOM when the component has
     * been mounted (initialized and rendered) for the first time.
     *
     * @param {DOMElement} rootNode DOM element representing the component.
     * @optional
     */
    componentDidMount: 'DEFINE_MANY',

    /**
     * Invoked before the component receives new props.
     *
     * Use this as an opportunity to react to a prop transition by updating the
     * state using `this.setState`. Current props are accessed via `this.props`.
     *
     *   componentWillReceiveProps: function(nextProps, nextContext) {
     *     this.setState({
     *       likesIncreasing: nextProps.likeCount > this.props.likeCount
     *     });
     *   }
     *
     * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
     * transition may cause a state change, but the opposite is not true. If you
     * need it, you are probably looking for `componentWillUpdate`.
     *
     * @param {object} nextProps
     * @optional
     */
    componentWillReceiveProps: 'DEFINE_MANY',

    /**
     * Invoked while deciding if the component should be updated as a result of
     * receiving new props, state and/or context.
     *
     * Use this as an opportunity to `return false` when you're certain that the
     * transition to the new props/state/context will not require a component
     * update.
     *
     *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
     *     return !equal(nextProps, this.props) ||
     *       !equal(nextState, this.state) ||
     *       !equal(nextContext, this.context);
     *   }
     *
     * @param {object} nextProps
     * @param {?object} nextState
     * @param {?object} nextContext
     * @return {boolean} True if the component should update.
     * @optional
     */
    shouldComponentUpdate: 'DEFINE_ONCE',

    /**
     * Invoked when the component is about to update due to a transition from
     * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
     * and `nextContext`.
     *
     * Use this as an opportunity to perform preparation before an update occurs.
     *
     * NOTE: You **cannot** use `this.setState()` in this method.
     *
     * @param {object} nextProps
     * @param {?object} nextState
     * @param {?object} nextContext
     * @param {ReactReconcileTransaction} transaction
     * @optional
     */
    componentWillUpdate: 'DEFINE_MANY',

    /**
     * Invoked when the component's DOM representation has been updated.
     *
     * Use this as an opportunity to operate on the DOM when the component has
     * been updated.
     *
     * @param {object} prevProps
     * @param {?object} prevState
     * @param {?object} prevContext
     * @param {DOMElement} rootNode DOM element representing the component.
     * @optional
     */
    componentDidUpdate: 'DEFINE_MANY',

    /**
     * Invoked when the component is about to be removed from its parent and have
     * its DOM representation destroyed.
     *
     * Use this as an opportunity to deallocate any external resources.
     *
     * NOTE: There is no `componentDidUnmount` since your component will have been
     * destroyed by that point.
     *
     * @optional
     */
    componentWillUnmount: 'DEFINE_MANY',

    // ==== Advanced methods ====

    /**
     * Updates the component's currently mounted DOM representation.
     *
     * By default, this implements React's rendering and reconciliation algorithm.
     * Sophisticated clients may wish to override this.
     *
     * @param {ReactReconcileTransaction} transaction
     * @internal
     * @overridable
     */
    updateComponent: 'OVERRIDE_BASE'
  };

  /**
   * Mapping from class specification keys to special processing functions.
   *
   * Although these are declared like instance properties in the specification
   * when defining classes using `React.createClass`, they are actually static
   * and are accessible on the constructor instead of the prototype. Despite
   * being static, they must be defined outside of the "statics" key under
   * which all other static methods are defined.
   */
  var RESERVED_SPEC_KEYS = {
    displayName: function (Constructor, displayName) {
      Constructor.displayName = displayName;
    },
    mixins: function (Constructor, mixins) {
      if (mixins) {
        for (var i = 0; i < mixins.length; i++) {
          mixSpecIntoComponent(Constructor, mixins[i]);
        }
      }
    },
    childContextTypes: function (Constructor, childContextTypes) {
      if (process.env.NODE_ENV !== 'production') {
        validateTypeDef(Constructor, childContextTypes, 'childContext');
      }
      Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
    },
    contextTypes: function (Constructor, contextTypes) {
      if (process.env.NODE_ENV !== 'production') {
        validateTypeDef(Constructor, contextTypes, 'context');
      }
      Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
    },
    /**
     * Special case getDefaultProps which should move into statics but requires
     * automatic merging.
     */
    getDefaultProps: function (Constructor, getDefaultProps) {
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
      } else {
        Constructor.getDefaultProps = getDefaultProps;
      }
    },
    propTypes: function (Constructor, propTypes) {
      if (process.env.NODE_ENV !== 'production') {
        validateTypeDef(Constructor, propTypes, 'prop');
      }
      Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
    },
    statics: function (Constructor, statics) {
      mixStaticSpecIntoComponent(Constructor, statics);
    },
    autobind: function () {}
  };

  function validateTypeDef(Constructor, typeDef, location) {
    for (var propName in typeDef) {
      if (typeDef.hasOwnProperty(propName)) {
        // use a warning instead of an _invariant so components
        // don't show up in prod but only in __DEV__
        if (process.env.NODE_ENV !== 'production') {
          warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName);
        }
      }
    }
  }

  function validateMethodOverride(isAlreadyDefined, name) {
    var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

    // Disallow overriding of base class methods unless explicitly allowed.
    if (ReactClassMixin.hasOwnProperty(name)) {
      _invariant(specPolicy === 'OVERRIDE_BASE', 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name);
    }

    // Disallow defining methods more than once unless explicitly allowed.
    if (isAlreadyDefined) {
      _invariant(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED', 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name);
    }
  }

  /**
   * Mixin helper which handles policy validation and reserved
   * specification keys when building React classes.
   */
  function mixSpecIntoComponent(Constructor, spec) {
    if (!spec) {
      if (process.env.NODE_ENV !== 'production') {
        var typeofSpec = typeof spec;
        var isMixinValid = typeofSpec === 'object' && spec !== null;

        if (process.env.NODE_ENV !== 'production') {
          warning(isMixinValid, "%s: You're attempting to include a mixin that is either null " + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec);
        }
      }

      return;
    }

    _invariant(typeof spec !== 'function', "ReactClass: You're attempting to " + 'use a component class or function as a mixin. Instead, just use a ' + 'regular object.');
    _invariant(!isValidElement(spec), "ReactClass: You're attempting to " + 'use a component as a mixin. Instead, just use a regular object.');

    var proto = Constructor.prototype;
    var autoBindPairs = proto.__reactAutoBindPairs;

    // By handling mixins before any other properties, we ensure the same
    // chaining order is applied to methods with DEFINE_MANY policy, whether
    // mixins are listed before or after these methods in the spec.
    if (spec.hasOwnProperty(MIXINS_KEY)) {
      RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
    }

    for (var name in spec) {
      if (!spec.hasOwnProperty(name)) {
        continue;
      }

      if (name === MIXINS_KEY) {
        // We have already handled mixins in a special case above.
        continue;
      }

      var property = spec[name];
      var isAlreadyDefined = proto.hasOwnProperty(name);
      validateMethodOverride(isAlreadyDefined, name);

      if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
        RESERVED_SPEC_KEYS[name](Constructor, property);
      } else {
        // Setup methods on prototype:
        // The following member methods should not be automatically bound:
        // 1. Expected ReactClass methods (in the "interface").
        // 2. Overridden methods (that were mixed in).
        var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
        var isFunction = typeof property === 'function';
        var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

        if (shouldAutoBind) {
          autoBindPairs.push(name, property);
          proto[name] = property;
        } else {
          if (isAlreadyDefined) {
            var specPolicy = ReactClassInterface[name];

            // These cases should already be caught by validateMethodOverride.
            _invariant(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY'), 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name);

            // For methods which are defined more than once, call the existing
            // methods before calling the new property, merging if appropriate.
            if (specPolicy === 'DEFINE_MANY_MERGED') {
              proto[name] = createMergedResultFunction(proto[name], property);
            } else if (specPolicy === 'DEFINE_MANY') {
              proto[name] = createChainedFunction(proto[name], property);
            }
          } else {
            proto[name] = property;
            if (process.env.NODE_ENV !== 'production') {
              // Add verbose displayName to the function, which helps when looking
              // at profiling tools.
              if (typeof property === 'function' && spec.displayName) {
                proto[name].displayName = spec.displayName + '_' + name;
              }
            }
          }
        }
      }
    }
  }

  function mixStaticSpecIntoComponent(Constructor, statics) {
    if (!statics) {
      return;
    }
    for (var name in statics) {
      var property = statics[name];
      if (!statics.hasOwnProperty(name)) {
        continue;
      }

      var isReserved = name in RESERVED_SPEC_KEYS;
      _invariant(!isReserved, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name);

      var isInherited = name in Constructor;
      _invariant(!isInherited, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name);
      Constructor[name] = property;
    }
  }

  /**
   * Merge two objects, but throw if both contain the same key.
   *
   * @param {object} one The first object, which is mutated.
   * @param {object} two The second object
   * @return {object} one after it has been mutated to contain everything in two.
   */
  function mergeIntoWithNoDuplicateKeys(one, two) {
    _invariant(one && two && typeof one === 'object' && typeof two === 'object', 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.');

    for (var key in two) {
      if (two.hasOwnProperty(key)) {
        _invariant(one[key] === undefined, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key);
        one[key] = two[key];
      }
    }
    return one;
  }

  /**
   * Creates a function that invokes two functions and merges their return values.
   *
   * @param {function} one Function to invoke first.
   * @param {function} two Function to invoke second.
   * @return {function} Function that invokes the two argument functions.
   * @private
   */
  function createMergedResultFunction(one, two) {
    return function mergedResult() {
      var a = one.apply(this, arguments);
      var b = two.apply(this, arguments);
      if (a == null) {
        return b;
      } else if (b == null) {
        return a;
      }
      var c = {};
      mergeIntoWithNoDuplicateKeys(c, a);
      mergeIntoWithNoDuplicateKeys(c, b);
      return c;
    };
  }

  /**
   * Creates a function that invokes two functions and ignores their return vales.
   *
   * @param {function} one Function to invoke first.
   * @param {function} two Function to invoke second.
   * @return {function} Function that invokes the two argument functions.
   * @private
   */
  function createChainedFunction(one, two) {
    return function chainedFunction() {
      one.apply(this, arguments);
      two.apply(this, arguments);
    };
  }

  /**
   * Binds a method to the component.
   *
   * @param {object} component Component whose method is going to be bound.
   * @param {function} method Method to be bound.
   * @return {function} The bound method.
   */
  function bindAutoBindMethod(component, method) {
    var boundMethod = method.bind(component);
    if (process.env.NODE_ENV !== 'production') {
      boundMethod.__reactBoundContext = component;
      boundMethod.__reactBoundMethod = method;
      boundMethod.__reactBoundArguments = null;
      var componentName = component.constructor.displayName;
      var _bind = boundMethod.bind;
      boundMethod.bind = function (newThis) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        // User is trying to bind() an autobound method; we effectively will
        // ignore the value of "this" that the user is trying to use, so
        // let's warn.
        if (newThis !== component && newThis !== null) {
          if (process.env.NODE_ENV !== 'production') {
            warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName);
          }
        } else if (!args.length) {
          if (process.env.NODE_ENV !== 'production') {
            warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName);
          }
          return boundMethod;
        }
        var reboundMethod = _bind.apply(boundMethod, arguments);
        reboundMethod.__reactBoundContext = component;
        reboundMethod.__reactBoundMethod = method;
        reboundMethod.__reactBoundArguments = args;
        return reboundMethod;
      };
    }
    return boundMethod;
  }

  /**
   * Binds all auto-bound methods in a component.
   *
   * @param {object} component Component whose method is going to be bound.
   */
  function bindAutoBindMethods(component) {
    var pairs = component.__reactAutoBindPairs;
    for (var i = 0; i < pairs.length; i += 2) {
      var autoBindKey = pairs[i];
      var method = pairs[i + 1];
      component[autoBindKey] = bindAutoBindMethod(component, method);
    }
  }

  var IsMountedPreMixin = {
    componentDidMount: function () {
      this.__isMounted = true;
    }
  };

  var IsMountedPostMixin = {
    componentWillUnmount: function () {
      this.__isMounted = false;
    }
  };

  /**
   * Add more to the ReactClass base class. These are all legacy features and
   * therefore not already part of the modern ReactComponent.
   */
  var ReactClassMixin = {
    /**
     * TODO: This will be deprecated because state should always keep a consistent
     * type signature and the only use case for this, is to avoid that.
     */
    replaceState: function (newState, callback) {
      this.updater.enqueueReplaceState(this, newState, callback);
    },

    /**
     * Checks whether or not this composite component is mounted.
     * @return {boolean} True if mounted, false otherwise.
     * @protected
     * @final
     */
    isMounted: function () {
      if (process.env.NODE_ENV !== 'production') {
        warning(this.__didWarnIsMounted, '%s: isMounted is deprecated. Instead, make sure to clean up ' + 'subscriptions and pending requests in componentWillUnmount to ' + 'prevent memory leaks.', this.constructor && this.constructor.displayName || this.name || 'Component');
        this.__didWarnIsMounted = true;
      }
      return !!this.__isMounted;
    }
  };

  var ReactClassComponent = function () {};
  _assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

  /**
   * Creates a composite component class given a class specification.
   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  function createClass(spec) {
    // To keep our warnings more understandable, we'll use a little hack here to
    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
    // unnecessarily identify a class without displayName as 'Constructor'.
    var Constructor = identity(function (props, context, updater) {
      // This constructor gets overridden by mocks. The argument is used
      // by mocks to assert on what gets mounted.

      if (process.env.NODE_ENV !== 'production') {
        warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory');
      }

      // Wire up auto-binding
      if (this.__reactAutoBindPairs.length) {
        bindAutoBindMethods(this);
      }

      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;

      this.state = null;

      // ReactClasses doesn't have constructors. Instead, they use the
      // getInitialState and componentWillMount methods for initialization.

      var initialState = this.getInitialState ? this.getInitialState() : null;
      if (process.env.NODE_ENV !== 'production') {
        // We allow auto-mocks to proceed as if they're returning null.
        if (initialState === undefined && this.getInitialState._isMockFunction) {
          // This is probably bad practice. Consider warning here and
          // deprecating this convenience.
          initialState = null;
        }
      }
      _invariant(typeof initialState === 'object' && !Array.isArray(initialState), '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent');

      this.state = initialState;
    });
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;
    Constructor.prototype.__reactAutoBindPairs = [];

    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

    mixSpecIntoComponent(Constructor, IsMountedPreMixin);
    mixSpecIntoComponent(Constructor, spec);
    mixSpecIntoComponent(Constructor, IsMountedPostMixin);

    // Initialize the defaultProps property after all mixins have been merged.
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    if (process.env.NODE_ENV !== 'production') {
      // This is a tag to indicate that the use of these method names is ok,
      // since it's used with createClass. If it's not, then it's likely a
      // mistake so we'll warn you to use the static property, property
      // initializer or constructor respectively.
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps.isReactClassApproved = {};
      }
      if (Constructor.prototype.getInitialState) {
        Constructor.prototype.getInitialState.isReactClassApproved = {};
      }
    }

    _invariant(Constructor.prototype.render, 'createClass(...): Class specification must implement a `render` method.');

    if (process.env.NODE_ENV !== 'production') {
      warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component');
      warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component');
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    return Constructor;
  }

  return createClass;
}

module.exports = factory;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 450 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */


var _prodInvariant = __webpack_require__(63);

var ReactElement = __webpack_require__(56);

var invariant = __webpack_require__(2);

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */
function onlyChild(children) {
  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
  return children;
}

module.exports = onlyChild;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 451 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(452);

/***/ }),
/* 452 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/



var ReactDOMComponentTree = __webpack_require__(14);
var ReactDefaultInjection = __webpack_require__(453);
var ReactMount = __webpack_require__(212);
var ReactReconciler = __webpack_require__(64);
var ReactUpdates = __webpack_require__(38);
var ReactVersion = __webpack_require__(531);

var findDOMNode = __webpack_require__(532);
var getHostComponentFromComposite = __webpack_require__(213);
var renderSubtreeIntoContainer = __webpack_require__(533);
var warning = __webpack_require__(3);

ReactDefaultInjection.inject();

var ReactDOM = {
  findDOMNode: findDOMNode,
  render: ReactMount.render,
  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
  version: ReactVersion,

  /* eslint-disable camelcase */
  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
  /* eslint-enable camelcase */
};

// Inject the runtime into a devtools global hook regardless of browser.
// Allows for debugging when the hook is injected on the page.
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
    ComponentTree: {
      getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
      getNodeFromInstance: function (inst) {
        // inst is an internal instance (but could be a composite)
        if (inst._renderedComponent) {
          inst = getHostComponentFromComposite(inst);
        }
        if (inst) {
          return ReactDOMComponentTree.getNodeFromInstance(inst);
        } else {
          return null;
        }
      }
    },
    Mount: ReactMount,
    Reconciler: ReactReconciler
  });
}

if (process.env.NODE_ENV !== 'production') {
  var ExecutionEnvironment = __webpack_require__(16);
  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
    // First check if devtools is not installed
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
      // If we're in Chrome or Firefox, provide a download link if not installed.
      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
        // Firefox does not have the issue with devtools loaded over file://
        var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
        console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
      }
    }

    var testFunc = function testFn() {};
    process.env.NODE_ENV !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, "It looks like you're using a minified copy of the development build " + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;

    // If we're in IE8, check to see if we are in compatibility mode and provide
    // information on preventing compatibility mode
    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;

    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;

    var expectedFeatures = [
    // shims
    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.trim];

    for (var i = 0; i < expectedFeatures.length; i++) {
      if (!expectedFeatures[i]) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
        break;
      }
    }
  }
}

if (process.env.NODE_ENV !== 'production') {
  var ReactInstrumentation = __webpack_require__(27);
  var ReactDOMUnknownPropertyHook = __webpack_require__(534);
  var ReactDOMNullInputValuePropHook = __webpack_require__(535);
  var ReactDOMInvalidARIAHook = __webpack_require__(536);

  ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
  ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
  ReactInstrumentation.debugTool.addHook(ReactDOMInvalidARIAHook);
}

module.exports = ReactDOM;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 453 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ARIADOMPropertyConfig = __webpack_require__(454);
var BeforeInputEventPlugin = __webpack_require__(455);
var ChangeEventPlugin = __webpack_require__(459);
var DefaultEventPluginOrder = __webpack_require__(467);
var EnterLeaveEventPlugin = __webpack_require__(468);
var HTMLDOMPropertyConfig = __webpack_require__(469);
var ReactComponentBrowserEnvironment = __webpack_require__(470);
var ReactDOMComponent = __webpack_require__(476);
var ReactDOMComponentTree = __webpack_require__(14);
var ReactDOMEmptyComponent = __webpack_require__(502);
var ReactDOMTreeTraversal = __webpack_require__(503);
var ReactDOMTextComponent = __webpack_require__(504);
var ReactDefaultBatchingStrategy = __webpack_require__(505);
var ReactEventListener = __webpack_require__(506);
var ReactInjection = __webpack_require__(508);
var ReactReconcileTransaction = __webpack_require__(509);
var SVGDOMPropertyConfig = __webpack_require__(515);
var SelectEventPlugin = __webpack_require__(516);
var SimpleEventPlugin = __webpack_require__(517);

var alreadyInjected = false;

function inject() {
  if (alreadyInjected) {
    // TODO: This is currently true because these injections are shared between
    // the client and the server package. They should be built independently
    // and not share any injection state. Then this problem will be solved.
    return;
  }
  alreadyInjected = true;

  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

  /**
   * Inject modules for resolving DOM hierarchy and plugin ordering.
   */
  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);

  /**
   * Some important event plugins included by default (without having to require
   * them).
   */
  ReactInjection.EventPluginHub.injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin
  });

  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);

  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);

  ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
    return new ReactDOMEmptyComponent(instantiate);
  });

  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
}

module.exports = {
  inject: inject
};

/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ARIADOMPropertyConfig = {
  Properties: {
    // Global States and Properties
    'aria-current': 0, // state
    'aria-details': 0,
    'aria-disabled': 0, // state
    'aria-hidden': 0, // state
    'aria-invalid': 0, // state
    'aria-keyshortcuts': 0,
    'aria-label': 0,
    'aria-roledescription': 0,
    // Widget Attributes
    'aria-autocomplete': 0,
    'aria-checked': 0,
    'aria-expanded': 0,
    'aria-haspopup': 0,
    'aria-level': 0,
    'aria-modal': 0,
    'aria-multiline': 0,
    'aria-multiselectable': 0,
    'aria-orientation': 0,
    'aria-placeholder': 0,
    'aria-pressed': 0,
    'aria-readonly': 0,
    'aria-required': 0,
    'aria-selected': 0,
    'aria-sort': 0,
    'aria-valuemax': 0,
    'aria-valuemin': 0,
    'aria-valuenow': 0,
    'aria-valuetext': 0,
    // Live Region Attributes
    'aria-atomic': 0,
    'aria-busy': 0,
    'aria-live': 0,
    'aria-relevant': 0,
    // Drag-and-Drop Attributes
    'aria-dropeffect': 0,
    'aria-grabbed': 0,
    // Relationship Attributes
    'aria-activedescendant': 0,
    'aria-colcount': 0,
    'aria-colindex': 0,
    'aria-colspan': 0,
    'aria-controls': 0,
    'aria-describedby': 0,
    'aria-errormessage': 0,
    'aria-flowto': 0,
    'aria-labelledby': 0,
    'aria-owns': 0,
    'aria-posinset': 0,
    'aria-rowcount': 0,
    'aria-rowindex': 0,
    'aria-rowspan': 0,
    'aria-setsize': 0
  },
  DOMAttributeNames: {},
  DOMPropertyNames: {}
};

module.exports = ARIADOMPropertyConfig;

/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var EventPropagators = __webpack_require__(69);
var ExecutionEnvironment = __webpack_require__(16);
var FallbackCompositionState = __webpack_require__(456);
var SyntheticCompositionEvent = __webpack_require__(457);
var SyntheticInputEvent = __webpack_require__(458);

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

var documentMode = null;
if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
}

// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: 'onBeforeInput',
      captured: 'onBeforeInputCapture'
    },
    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionEnd',
      captured: 'onCompositionEndCapture'
    },
    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionStart',
      captured: 'onCompositionStartCapture'
    },
    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionUpdate',
      captured: 'onCompositionUpdateCapture'
    },
    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  }
};

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case 'topCompositionStart':
      return eventTypes.compositionStart;
    case 'topCompositionEnd':
      return eventTypes.compositionEnd;
    case 'topCompositionUpdate':
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionStart(topLevelType, nativeEvent) {
  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topKeyUp':
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case 'topKeyDown':
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;
    case 'topKeyPress':
    case 'topMouseDown':
    case 'topBlur':
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */
function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;
  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }
  return null;
}

// Track the current IME composition fallback object, if any.
var currentComposition = null;

/**
 * @return {?object} A SyntheticCompositionEvent.
 */
function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(topLevelType);
  } else if (!currentComposition) {
    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionStart;
    }
  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
    eventType = eventTypes.compositionEnd;
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!currentComposition && eventType === eventTypes.compositionStart) {
      currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
    } else if (eventType === eventTypes.compositionEnd) {
      if (currentComposition) {
        fallbackData = currentComposition.getData();
      }
    }
  }

  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

  if (fallbackData) {
    // Inject data generated from fallback path into the synthetic event.
    // This matches the property of native CompositionEventInterface.
    event.data = fallbackData;
  } else {
    var customData = getDataFromCustomEvent(nativeEvent);
    if (customData !== null) {
      event.data = customData;
    }
  }

  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */
function getNativeBeforeInputChars(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topCompositionEnd':
      return getDataFromCustomEvent(nativeEvent);
    case 'topKeyPress':
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case 'topTextInput':
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data;

      // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to blacklist it.
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */
function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  // If composition event is available, we extract a string only at
  // compositionevent, otherwise extract it at fallback events.
  if (currentComposition) {
    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      var chars = currentComposition.getData();
      FallbackCompositionState.release(currentComposition);
      currentComposition = null;
      return chars;
    }
    return null;
  }

  switch (topLevelType) {
    case 'topPaste':
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;
    case 'topKeyPress':
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
        return String.fromCharCode(nativeEvent.which);
      }
      return null;
    case 'topCompositionEnd':
      return useFallbackCompositionData ? null : nativeEvent.data;
    default:
      return null;
  }
}

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */
function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
  }

  // If no characters are being inserted, no BeforeInput event should
  // be fired.
  if (!chars) {
    return null;
  }

  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

  event.data = chars;
  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */
var BeforeInputEventPlugin = {
  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
  }
};

module.exports = BeforeInputEventPlugin;

/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(10);

var PooledClass = __webpack_require__(57);

var getTextContentAccessor = __webpack_require__(192);

/**
 * This helper class stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 * @param {DOMEventTarget} root
 */
function FallbackCompositionState(root) {
  this._root = root;
  this._startText = this.getText();
  this._fallbackText = null;
}

_assign(FallbackCompositionState.prototype, {
  destructor: function () {
    this._root = null;
    this._startText = null;
    this._fallbackText = null;
  },

  /**
   * Get current text of input.
   *
   * @return {string}
   */
  getText: function () {
    if ('value' in this._root) {
      return this._root.value;
    }
    return this._root[getTextContentAccessor()];
  },

  /**
   * Determine the differing substring between the initially stored
   * text content and the current content.
   *
   * @return {string}
   */
  getData: function () {
    if (this._fallbackText) {
      return this._fallbackText;
    }

    var start;
    var startValue = this._startText;
    var startLength = startValue.length;
    var end;
    var endValue = this.getText();
    var endLength = endValue.length;

    for (start = 0; start < startLength; start++) {
      if (startValue[start] !== endValue[start]) {
        break;
      }
    }

    var minEnd = startLength - start;
    for (end = 1; end <= minEnd; end++) {
      if (startValue[startLength - end] !== endValue[endLength - end]) {
        break;
      }
    }

    var sliceTail = end > 1 ? 1 - end : undefined;
    this._fallbackText = endValue.slice(start, sliceTail);
    return this._fallbackText;
  }
});

PooledClass.addPoolingTo(FallbackCompositionState);

module.exports = FallbackCompositionState;

/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticEvent = __webpack_require__(41);

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

module.exports = SyntheticCompositionEvent;

/***/ }),
/* 458 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticEvent = __webpack_require__(41);

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);

module.exports = SyntheticInputEvent;

/***/ }),
/* 459 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var EventPluginHub = __webpack_require__(70);
var EventPropagators = __webpack_require__(69);
var ExecutionEnvironment = __webpack_require__(16);
var ReactDOMComponentTree = __webpack_require__(14);
var ReactUpdates = __webpack_require__(38);
var SyntheticEvent = __webpack_require__(41);

var inputValueTracking = __webpack_require__(195);
var getEventTarget = __webpack_require__(128);
var isEventSupported = __webpack_require__(129);
var isTextInputElement = __webpack_require__(196);

var eventTypes = {
  change: {
    phasedRegistrationNames: {
      bubbled: 'onChange',
      captured: 'onChangeCapture'
    },
    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
  }
};

function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
  var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, target);
  event.type = 'change';
  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}
/**
 * For IE shims
 */
var activeElement = null;
var activeElementInst = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

var doesChangeEventBubble = false;
if (ExecutionEnvironment.canUseDOM) {
  // See `handleChange` comment below
  doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  ReactUpdates.batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  EventPluginHub.enqueueEvents(event);
  EventPluginHub.processEventQueue(false);
}

function startWatchingForChangeEventIE8(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
}

function stopWatchingForChangeEventIE8() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
  activeElement = null;
  activeElementInst = null;
}

function getInstIfValueChanged(targetInst, nativeEvent) {
  var updated = inputValueTracking.updateValueIfChanged(targetInst);
  var simulated = nativeEvent.simulated === true && ChangeEventPlugin._allowSimulatedPassThrough;

  if (updated || simulated) {
    return targetInst;
  }
}

function getTargetInstForChangeEvent(topLevelType, targetInst) {
  if (topLevelType === 'topChange') {
    return targetInst;
  }
}

function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
  if (topLevelType === 'topFocus') {
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForChangeEventIE8();
    startWatchingForChangeEventIE8(target, targetInst);
  } else if (topLevelType === 'topBlur') {
    stopWatchingForChangeEventIE8();
  }
}

/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events.

  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
}

/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onpropertychange', handlePropertyChange);
}

/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onpropertychange', handlePropertyChange);

  activeElement = null;
  activeElementInst = null;
}

/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  if (getInstIfValueChanged(activeElementInst, nativeEvent)) {
    manualDispatchChangeEvent(nativeEvent);
  }
}

function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {
  if (topLevelType === 'topFocus') {
    // In IE8, we can capture almost all .value changes by adding a
    // propertychange handler and looking for events with propertyName
    // equal to 'value'
    // In IE9, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(target, targetInst);
  } else if (topLevelType === 'topBlur') {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetInstForInputEventPolyfill(topLevelType, targetInst, nativeEvent) {
  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    return getInstIfValueChanged(activeElementInst, nativeEvent);
  }
}

/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetInstForClickEvent(topLevelType, targetInst, nativeEvent) {
  if (topLevelType === 'topClick') {
    return getInstIfValueChanged(targetInst, nativeEvent);
  }
}

function getTargetInstForInputOrChangeEvent(topLevelType, targetInst, nativeEvent) {
  if (topLevelType === 'topInput' || topLevelType === 'topChange') {
    return getInstIfValueChanged(targetInst, nativeEvent);
  }
}

function handleControlledInputBlur(inst, node) {
  // TODO: In IE, inst is occasionally null. Why?
  if (inst == null) {
    return;
  }

  // Fiber and ReactDOM keep wrapper state in separate places
  var state = inst._wrapperState || node._wrapperState;

  if (!state || !state.controlled || node.type !== 'number') {
    return;
  }

  // If controlled, assign the value attribute to the current value on blur
  var value = '' + node.value;
  if (node.getAttribute('value') !== value) {
    node.setAttribute('value', value);
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {
  eventTypes: eventTypes,

  _allowSimulatedPassThrough: true,
  _isInputEventSupported: isInputEventSupported,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

    var getTargetInstFunc, handleEventFunc;
    if (shouldUseChangeEvent(targetNode)) {
      if (doesChangeEventBubble) {
        getTargetInstFunc = getTargetInstForChangeEvent;
      } else {
        handleEventFunc = handleEventsForChangeEventIE8;
      }
    } else if (isTextInputElement(targetNode)) {
      if (isInputEventSupported) {
        getTargetInstFunc = getTargetInstForInputOrChangeEvent;
      } else {
        getTargetInstFunc = getTargetInstForInputEventPolyfill;
        handleEventFunc = handleEventsForInputEventPolyfill;
      }
    } else if (shouldUseClickEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForClickEvent;
    }

    if (getTargetInstFunc) {
      var inst = getTargetInstFunc(topLevelType, targetInst, nativeEvent);
      if (inst) {
        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(topLevelType, targetNode, targetInst);
    }

    // When blurring, set the value attribute for number inputs
    if (topLevelType === 'topBlur') {
      handleControlledInputBlur(targetInst, targetNode);
    }
  }
};

module.exports = ChangeEventPlugin;

/***/ }),
/* 460 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactOwner = __webpack_require__(461);

var ReactRef = {};

function attachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(component.getPublicInstance());
  } else {
    // Legacy ref
    ReactOwner.addComponentAsRefTo(component, ref, owner);
  }
}

function detachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(null);
  } else {
    // Legacy ref
    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
  }
}

ReactRef.attachRefs = function (instance, element) {
  if (element === null || typeof element !== 'object') {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    attachRef(ref, instance, element._owner);
  }
};

ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
  // If either the owner or a `ref` has changed, make sure the newest owner
  // has stored a reference to `this`, and the previous owner (if different)
  // has forgotten the reference to `this`. We use the element instead
  // of the public this.props because the post processing cannot determine
  // a ref. The ref conceptually lives on the element.

  // TODO: Should this even be possible? The owner cannot change because
  // it's forbidden by shouldUpdateReactComponent. The ref can change
  // if you swap the keys of but not the refs. Reconsider where this check
  // is made. It probably belongs where the key checking and
  // instantiateReactComponent is done.

  var prevRef = null;
  var prevOwner = null;
  if (prevElement !== null && typeof prevElement === 'object') {
    prevRef = prevElement.ref;
    prevOwner = prevElement._owner;
  }

  var nextRef = null;
  var nextOwner = null;
  if (nextElement !== null && typeof nextElement === 'object') {
    nextRef = nextElement.ref;
    nextOwner = nextElement._owner;
  }

  return prevRef !== nextRef ||
  // If owner changes but we have an unchanged function ref, don't update refs
  typeof nextRef === 'string' && nextOwner !== prevOwner;
};

ReactRef.detachRefs = function (instance, element) {
  if (element === null || typeof element !== 'object') {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    detachRef(ref, instance, element._owner);
  }
};

module.exports = ReactRef;

/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(7);

var invariant = __webpack_require__(2);

/**
 * @param {?object} object
 * @return {boolean} True if `object` is a valid owner.
 * @final
 */
function isValidOwner(object) {
  return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
}

/**
 * ReactOwners are capable of storing references to owned components.
 *
 * All components are capable of //being// referenced by owner components, but
 * only ReactOwner components are capable of //referencing// owned components.
 * The named reference is known as a "ref".
 *
 * Refs are available when mounted and updated during reconciliation.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return (
 *         <div onClick={this.handleClick}>
 *           <CustomComponent ref="custom" />
 *         </div>
 *       );
 *     },
 *     handleClick: function() {
 *       this.refs.custom.handleClick();
 *     },
 *     componentDidMount: function() {
 *       this.refs.custom.initialize();
 *     }
 *   });
 *
 * Refs should rarely be used. When refs are used, they should only be done to
 * control data that is not handled by React's data flow.
 *
 * @class ReactOwner
 */
var ReactOwner = {
  /**
   * Adds a component by ref to an owner component.
   *
   * @param {ReactComponent} component Component to reference.
   * @param {string} ref Name by which to refer to the component.
   * @param {ReactOwner} owner Component on which to record the ref.
   * @final
   * @internal
   */
  addComponentAsRefTo: function (component, ref, owner) {
    !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
    owner.attachRef(ref, component);
  },

  /**
   * Removes a component by ref from an owner component.
   *
   * @param {ReactComponent} component Component to dereference.
   * @param {string} ref Name of the ref to remove.
   * @param {ReactOwner} owner Component on which the ref is recorded.
   * @final
   * @internal
   */
  removeComponentAsRefFrom: function (component, ref, owner) {
    !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
    var ownerPublicInstance = owner.getPublicInstance();
    // Check that `component`'s owner is still alive and that `component` is still the current ref
    // because we do not want to detach the ref if another component stole it.
    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
      owner.detachRef(ref);
    }
  }
};

module.exports = ReactOwner;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 462 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactInvalidSetStateWarningHook = __webpack_require__(463);
var ReactHostOperationHistoryHook = __webpack_require__(464);
var ReactComponentTreeHook = __webpack_require__(22);
var ExecutionEnvironment = __webpack_require__(16);

var performanceNow = __webpack_require__(465);
var warning = __webpack_require__(3);

var hooks = [];
var didHookThrowForEvent = {};

function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
  try {
    fn.call(context, arg1, arg2, arg3, arg4, arg5);
  } catch (e) {
    process.env.NODE_ENV !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
    didHookThrowForEvent[event] = true;
  }
}

function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
  for (var i = 0; i < hooks.length; i++) {
    var hook = hooks[i];
    var fn = hook[event];
    if (fn) {
      callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
    }
  }
}

var isProfiling = false;
var flushHistory = [];
var lifeCycleTimerStack = [];
var currentFlushNesting = 0;
var currentFlushMeasurements = [];
var currentFlushStartTime = 0;
var currentTimerDebugID = null;
var currentTimerStartTime = 0;
var currentTimerNestedFlushDuration = 0;
var currentTimerType = null;

var lifeCycleTimerHasWarned = false;

function clearHistory() {
  ReactComponentTreeHook.purgeUnmountedComponents();
  ReactHostOperationHistoryHook.clearHistory();
}

function getTreeSnapshot(registeredIDs) {
  return registeredIDs.reduce(function (tree, id) {
    var ownerID = ReactComponentTreeHook.getOwnerID(id);
    var parentID = ReactComponentTreeHook.getParentID(id);
    tree[id] = {
      displayName: ReactComponentTreeHook.getDisplayName(id),
      text: ReactComponentTreeHook.getText(id),
      updateCount: ReactComponentTreeHook.getUpdateCount(id),
      childIDs: ReactComponentTreeHook.getChildIDs(id),
      // Text nodes don't have owners but this is close enough.
      ownerID: ownerID || parentID && ReactComponentTreeHook.getOwnerID(parentID) || 0,
      parentID: parentID
    };
    return tree;
  }, {});
}

function resetMeasurements() {
  var previousStartTime = currentFlushStartTime;
  var previousMeasurements = currentFlushMeasurements;
  var previousOperations = ReactHostOperationHistoryHook.getHistory();

  if (currentFlushNesting === 0) {
    currentFlushStartTime = 0;
    currentFlushMeasurements = [];
    clearHistory();
    return;
  }

  if (previousMeasurements.length || previousOperations.length) {
    var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
    flushHistory.push({
      duration: performanceNow() - previousStartTime,
      measurements: previousMeasurements || [],
      operations: previousOperations || [],
      treeSnapshot: getTreeSnapshot(registeredIDs)
    });
  }

  clearHistory();
  currentFlushStartTime = performanceNow();
  currentFlushMeasurements = [];
}

function checkDebugID(debugID) {
  var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (allowRoot && debugID === 0) {
    return;
  }
  if (!debugID) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
  }
}

function beginLifeCycleTimer(debugID, timerType) {
  if (currentFlushNesting === 0) {
    return;
  }
  if (currentTimerType && !lifeCycleTimerHasWarned) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
    lifeCycleTimerHasWarned = true;
  }
  currentTimerStartTime = performanceNow();
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = debugID;
  currentTimerType = timerType;
}

function endLifeCycleTimer(debugID, timerType) {
  if (currentFlushNesting === 0) {
    return;
  }
  if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
    lifeCycleTimerHasWarned = true;
  }
  if (isProfiling) {
    currentFlushMeasurements.push({
      timerType: timerType,
      instanceID: debugID,
      duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
    });
  }
  currentTimerStartTime = 0;
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = null;
  currentTimerType = null;
}

function pauseCurrentLifeCycleTimer() {
  var currentTimer = {
    startTime: currentTimerStartTime,
    nestedFlushStartTime: performanceNow(),
    debugID: currentTimerDebugID,
    timerType: currentTimerType
  };
  lifeCycleTimerStack.push(currentTimer);
  currentTimerStartTime = 0;
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = null;
  currentTimerType = null;
}

function resumeCurrentLifeCycleTimer() {
  var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(),
      startTime = _lifeCycleTimerStack$.startTime,
      nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime,
      debugID = _lifeCycleTimerStack$.debugID,
      timerType = _lifeCycleTimerStack$.timerType;

  var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
  currentTimerStartTime = startTime;
  currentTimerNestedFlushDuration += nestedFlushDuration;
  currentTimerDebugID = debugID;
  currentTimerType = timerType;
}

var lastMarkTimeStamp = 0;
var canUsePerformanceMeasure = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';

function shouldMark(debugID) {
  if (!isProfiling || !canUsePerformanceMeasure) {
    return false;
  }
  var element = ReactComponentTreeHook.getElement(debugID);
  if (element == null || typeof element !== 'object') {
    return false;
  }
  var isHostElement = typeof element.type === 'string';
  if (isHostElement) {
    return false;
  }
  return true;
}

function markBegin(debugID, markType) {
  if (!shouldMark(debugID)) {
    return;
  }

  var markName = debugID + '::' + markType;
  lastMarkTimeStamp = performanceNow();
  performance.mark(markName);
}

function markEnd(debugID, markType) {
  if (!shouldMark(debugID)) {
    return;
  }

  var markName = debugID + '::' + markType;
  var displayName = ReactComponentTreeHook.getDisplayName(debugID) || 'Unknown';

  // Chrome has an issue of dropping markers recorded too fast:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=640652
  // To work around this, we will not report very small measurements.
  // I determined the magic number by tweaking it back and forth.
  // 0.05ms was enough to prevent the issue, but I set it to 0.1ms to be safe.
  // When the bug is fixed, we can `measure()` unconditionally if we want to.
  var timeStamp = performanceNow();
  if (timeStamp - lastMarkTimeStamp > 0.1) {
    var measurementName = displayName + ' [' + markType + ']';
    performance.measure(measurementName, markName);
  }

  performance.clearMarks(markName);
  if (measurementName) {
    performance.clearMeasures(measurementName);
  }
}

var ReactDebugTool = {
  addHook: function (hook) {
    hooks.push(hook);
  },
  removeHook: function (hook) {
    for (var i = 0; i < hooks.length; i++) {
      if (hooks[i] === hook) {
        hooks.splice(i, 1);
        i--;
      }
    }
  },
  isProfiling: function () {
    return isProfiling;
  },
  beginProfiling: function () {
    if (isProfiling) {
      return;
    }

    isProfiling = true;
    flushHistory.length = 0;
    resetMeasurements();
    ReactDebugTool.addHook(ReactHostOperationHistoryHook);
  },
  endProfiling: function () {
    if (!isProfiling) {
      return;
    }

    isProfiling = false;
    resetMeasurements();
    ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
  },
  getFlushHistory: function () {
    return flushHistory;
  },
  onBeginFlush: function () {
    currentFlushNesting++;
    resetMeasurements();
    pauseCurrentLifeCycleTimer();
    emitEvent('onBeginFlush');
  },
  onEndFlush: function () {
    resetMeasurements();
    currentFlushNesting--;
    resumeCurrentLifeCycleTimer();
    emitEvent('onEndFlush');
  },
  onBeginLifeCycleTimer: function (debugID, timerType) {
    checkDebugID(debugID);
    emitEvent('onBeginLifeCycleTimer', debugID, timerType);
    markBegin(debugID, timerType);
    beginLifeCycleTimer(debugID, timerType);
  },
  onEndLifeCycleTimer: function (debugID, timerType) {
    checkDebugID(debugID);
    endLifeCycleTimer(debugID, timerType);
    markEnd(debugID, timerType);
    emitEvent('onEndLifeCycleTimer', debugID, timerType);
  },
  onBeginProcessingChildContext: function () {
    emitEvent('onBeginProcessingChildContext');
  },
  onEndProcessingChildContext: function () {
    emitEvent('onEndProcessingChildContext');
  },
  onHostOperation: function (operation) {
    checkDebugID(operation.instanceID);
    emitEvent('onHostOperation', operation);
  },
  onSetState: function () {
    emitEvent('onSetState');
  },
  onSetChildren: function (debugID, childDebugIDs) {
    checkDebugID(debugID);
    childDebugIDs.forEach(checkDebugID);
    emitEvent('onSetChildren', debugID, childDebugIDs);
  },
  onBeforeMountComponent: function (debugID, element, parentDebugID) {
    checkDebugID(debugID);
    checkDebugID(parentDebugID, true);
    emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
    markBegin(debugID, 'mount');
  },
  onMountComponent: function (debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'mount');
    emitEvent('onMountComponent', debugID);
  },
  onBeforeUpdateComponent: function (debugID, element) {
    checkDebugID(debugID);
    emitEvent('onBeforeUpdateComponent', debugID, element);
    markBegin(debugID, 'update');
  },
  onUpdateComponent: function (debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'update');
    emitEvent('onUpdateComponent', debugID);
  },
  onBeforeUnmountComponent: function (debugID) {
    checkDebugID(debugID);
    emitEvent('onBeforeUnmountComponent', debugID);
    markBegin(debugID, 'unmount');
  },
  onUnmountComponent: function (debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'unmount');
    emitEvent('onUnmountComponent', debugID);
  },
  onTestEvent: function () {
    emitEvent('onTestEvent');
  }
};

// TODO remove these when RN/www gets updated
ReactDebugTool.addDevtool = ReactDebugTool.addHook;
ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;

ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
ReactDebugTool.addHook(ReactComponentTreeHook);
var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
if (/[?&]react_perf\b/.test(url)) {
  ReactDebugTool.beginProfiling();
}

module.exports = ReactDebugTool;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 463 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var warning = __webpack_require__(3);

if (process.env.NODE_ENV !== 'production') {
  var processingChildContext = false;

  var warnInvalidSetState = function () {
    process.env.NODE_ENV !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
  };
}

var ReactInvalidSetStateWarningHook = {
  onBeginProcessingChildContext: function () {
    processingChildContext = true;
  },
  onEndProcessingChildContext: function () {
    processingChildContext = false;
  },
  onSetState: function () {
    warnInvalidSetState();
  }
};

module.exports = ReactInvalidSetStateWarningHook;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 464 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var history = [];

var ReactHostOperationHistoryHook = {
  onHostOperation: function (operation) {
    history.push(operation);
  },
  clearHistory: function () {
    if (ReactHostOperationHistoryHook._preventClearing) {
      // Should only be used for tests.
      return;
    }

    history = [];
  },
  getHistory: function () {
    return history;
  }
};

module.exports = ReactHostOperationHistoryHook;

/***/ }),
/* 465 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var performance = __webpack_require__(466);

var performanceNow;

/**
 * Detect if we can use `window.performance.now()` and gracefully fallback to
 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
 * because of Facebook's testing infrastructure.
 */
if (performance.now) {
  performanceNow = function performanceNow() {
    return performance.now();
  };
} else {
  performanceNow = function performanceNow() {
    return Date.now();
  };
}

module.exports = performanceNow;

/***/ }),
/* 466 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */



var ExecutionEnvironment = __webpack_require__(16);

var performance;

if (ExecutionEnvironment.canUseDOM) {
  performance = window.performance || window.msPerformance || window.webkitPerformance;
}

module.exports = performance || {};

/***/ }),
/* 467 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */

var DefaultEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

module.exports = DefaultEventPluginOrder;

/***/ }),
/* 468 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var EventPropagators = __webpack_require__(69);
var ReactDOMComponentTree = __webpack_require__(14);
var SyntheticMouseEvent = __webpack_require__(93);

var eventTypes = {
  mouseEnter: {
    registrationName: 'onMouseEnter',
    dependencies: ['topMouseOut', 'topMouseOver']
  },
  mouseLeave: {
    registrationName: 'onMouseLeave',
    dependencies: ['topMouseOut', 'topMouseOver']
  }
};

var EnterLeaveEventPlugin = {
  eventTypes: eventTypes,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (nativeEventTarget.window === nativeEventTarget) {
      // `nativeEventTarget` is probably a window object.
      win = nativeEventTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = nativeEventTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from;
    var to;
    if (topLevelType === 'topMouseOut') {
      from = targetInst;
      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
      to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
    } else {
      // Moving to a node from outside the window.
      from = null;
      to = targetInst;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
    var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);

    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
    leave.type = 'mouseleave';
    leave.target = fromNode;
    leave.relatedTarget = toNode;

    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
    enter.type = 'mouseenter';
    enter.target = toNode;
    enter.relatedTarget = fromNode;

    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);

    return [leave, enter];
  }
};

module.exports = EnterLeaveEventPlugin;

/***/ }),
/* 469 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMProperty = __webpack_require__(44);

var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

var HTMLDOMPropertyConfig = {
  isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
  Properties: {
    /**
     * Standard Properties
     */
    accept: 0,
    acceptCharset: 0,
    accessKey: 0,
    action: 0,
    allowFullScreen: HAS_BOOLEAN_VALUE,
    allowTransparency: 0,
    alt: 0,
    // specifies target context for links with `preload` type
    as: 0,
    async: HAS_BOOLEAN_VALUE,
    autoComplete: 0,
    // autoFocus is polyfilled/normalized by AutoFocusUtils
    // autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    capture: HAS_BOOLEAN_VALUE,
    cellPadding: 0,
    cellSpacing: 0,
    charSet: 0,
    challenge: 0,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    cite: 0,
    classID: 0,
    className: 0,
    cols: HAS_POSITIVE_NUMERIC_VALUE,
    colSpan: 0,
    content: 0,
    contentEditable: 0,
    contextMenu: 0,
    controls: HAS_BOOLEAN_VALUE,
    coords: 0,
    crossOrigin: 0,
    data: 0, // For `<object />` acts as `src`.
    dateTime: 0,
    'default': HAS_BOOLEAN_VALUE,
    defer: HAS_BOOLEAN_VALUE,
    dir: 0,
    disabled: HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: 0,
    encType: 0,
    form: 0,
    formAction: 0,
    formEncType: 0,
    formMethod: 0,
    formNoValidate: HAS_BOOLEAN_VALUE,
    formTarget: 0,
    frameBorder: 0,
    headers: 0,
    height: 0,
    hidden: HAS_BOOLEAN_VALUE,
    high: 0,
    href: 0,
    hrefLang: 0,
    htmlFor: 0,
    httpEquiv: 0,
    icon: 0,
    id: 0,
    inputMode: 0,
    integrity: 0,
    is: 0,
    keyParams: 0,
    keyType: 0,
    kind: 0,
    label: 0,
    lang: 0,
    list: 0,
    loop: HAS_BOOLEAN_VALUE,
    low: 0,
    manifest: 0,
    marginHeight: 0,
    marginWidth: 0,
    max: 0,
    maxLength: 0,
    media: 0,
    mediaGroup: 0,
    method: 0,
    min: 0,
    minLength: 0,
    // Caution; `option.selected` is not updated if `select.multiple` is
    // disabled with `removeAttribute`.
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    name: 0,
    nonce: 0,
    noValidate: HAS_BOOLEAN_VALUE,
    open: HAS_BOOLEAN_VALUE,
    optimum: 0,
    pattern: 0,
    placeholder: 0,
    playsInline: HAS_BOOLEAN_VALUE,
    poster: 0,
    preload: 0,
    profile: 0,
    radioGroup: 0,
    readOnly: HAS_BOOLEAN_VALUE,
    referrerPolicy: 0,
    rel: 0,
    required: HAS_BOOLEAN_VALUE,
    reversed: HAS_BOOLEAN_VALUE,
    role: 0,
    rows: HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: HAS_NUMERIC_VALUE,
    sandbox: 0,
    scope: 0,
    scoped: HAS_BOOLEAN_VALUE,
    scrolling: 0,
    seamless: HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    shape: 0,
    size: HAS_POSITIVE_NUMERIC_VALUE,
    sizes: 0,
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: 0,
    src: 0,
    srcDoc: 0,
    srcLang: 0,
    srcSet: 0,
    start: HAS_NUMERIC_VALUE,
    step: 0,
    style: 0,
    summary: 0,
    tabIndex: 0,
    target: 0,
    title: 0,
    // Setting .type throws on non-<input> tags
    type: 0,
    useMap: 0,
    value: 0,
    width: 0,
    wmode: 0,
    wrap: 0,

    /**
     * RDFa Properties
     */
    about: 0,
    datatype: 0,
    inlist: 0,
    prefix: 0,
    // property is also supported for OpenGraph in meta tags.
    property: 0,
    resource: 0,
    'typeof': 0,
    vocab: 0,

    /**
     * Non-standard Properties
     */
    // autoCapitalize and autoCorrect are supported in Mobile Safari for
    // keyboard hints.
    autoCapitalize: 0,
    autoCorrect: 0,
    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
    autoSave: 0,
    // color is for Safari mask-icon link
    color: 0,
    // itemProp, itemScope, itemType are for
    // Microdata support. See http://schema.org/docs/gs.html
    itemProp: 0,
    itemScope: HAS_BOOLEAN_VALUE,
    itemType: 0,
    // itemID and itemRef are for Microdata support as well but
    // only specified in the WHATWG spec document. See
    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
    itemID: 0,
    itemRef: 0,
    // results show looking glass icon and recent searches on input
    // search fields in WebKit/Blink
    results: 0,
    // IE-only attribute that specifies security restrictions on an iframe
    // as an alternative to the sandbox attribute on IE<10
    security: 0,
    // IE-only attribute that controls focus behavior
    unselectable: 0
  },
  DOMAttributeNames: {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMPropertyNames: {},
  DOMMutationMethods: {
    value: function (node, value) {
      if (value == null) {
        return node.removeAttribute('value');
      }

      // Number inputs get special treatment due to some edge cases in
      // Chrome. Let everything else assign the value attribute as normal.
      // https://github.com/facebook/react/issues/7253#issuecomment-236074326
      if (node.type !== 'number' || node.hasAttribute('value') === false) {
        node.setAttribute('value', '' + value);
      } else if (node.validity && !node.validity.badInput && node.ownerDocument.activeElement !== node) {
        // Don't assign an attribute if validation reports bad
        // input. Chrome will clear the value. Additionally, don't
        // operate on inputs that have focus, otherwise Chrome might
        // strip off trailing decimal places and cause the user's
        // cursor position to jump to the beginning of the input.
        //
        // In ReactDOMInput, we have an onBlur event that will trigger
        // this function again when focus is lost.
        node.setAttribute('value', '' + value);
      }
    }
  }
};

module.exports = HTMLDOMPropertyConfig;

/***/ }),
/* 470 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMChildrenOperations = __webpack_require__(131);
var ReactDOMIDOperations = __webpack_require__(475);

/**
 * Abstracts away all functionality of the reconciler that requires knowledge of
 * the browser context. TODO: These callers should be refactored to avoid the
 * need for this injection.
 */
var ReactComponentBrowserEnvironment = {
  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,

  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup
};

module.exports = ReactComponentBrowserEnvironment;

/***/ }),
/* 471 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(7);

var DOMLazyTree = __webpack_require__(65);
var ExecutionEnvironment = __webpack_require__(16);

var createNodesFromMarkup = __webpack_require__(472);
var emptyFunction = __webpack_require__(26);
var invariant = __webpack_require__(2);

var Danger = {
  /**
   * Replaces a node with a string of markup at its current position within its
   * parent. The markup must render into a single root node.
   *
   * @param {DOMElement} oldChild Child node to replace.
   * @param {string} markup Markup to render in place of the child node.
   * @internal
   */
  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
    !(oldChild.nodeName !== 'HTML') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;

    if (typeof markup === 'string') {
      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
      oldChild.parentNode.replaceChild(newChild, oldChild);
    } else {
      DOMLazyTree.replaceChildWithTree(oldChild, markup);
    }
  }
};

module.exports = Danger;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 472 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/*eslint-disable fb-www/unsafe-html*/

var ExecutionEnvironment = __webpack_require__(16);

var createArrayFromMixed = __webpack_require__(473);
var getMarkupWrap = __webpack_require__(474);
var invariant = __webpack_require__(2);

/**
 * Dummy container used to render all markup.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Pattern used by `getNodeName`.
 */
var nodeNamePattern = /^\s*<(\w+)/;

/**
 * Extracts the `nodeName` of the first element in a string of markup.
 *
 * @param {string} markup String of markup.
 * @return {?string} Node name of the supplied markup.
 */
function getNodeName(markup) {
  var nodeNameMatch = markup.match(nodeNamePattern);
  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
}

/**
 * Creates an array containing the nodes rendered from the supplied markup. The
 * optionally supplied `handleScript` function will be invoked once for each
 * <script> element that is rendered. If no `handleScript` function is supplied,
 * an exception is thrown if any <script> elements are rendered.
 *
 * @param {string} markup A string of valid HTML markup.
 * @param {?function} handleScript Invoked once for each rendered <script>.
 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
 */
function createNodesFromMarkup(markup, handleScript) {
  var node = dummyNode;
  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
  var nodeName = getNodeName(markup);

  var wrap = nodeName && getMarkupWrap(nodeName);
  if (wrap) {
    node.innerHTML = wrap[1] + markup + wrap[2];

    var wrapDepth = wrap[0];
    while (wrapDepth--) {
      node = node.lastChild;
    }
  } else {
    node.innerHTML = markup;
  }

  var scripts = node.getElementsByTagName('script');
  if (scripts.length) {
    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
    createArrayFromMixed(scripts).forEach(handleScript);
  }

  var nodes = Array.from(node.childNodes);
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
  return nodes;
}

module.exports = createNodesFromMarkup;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 473 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var invariant = __webpack_require__(2);

/**
 * Convert array-like objects to arrays.
 *
 * This API assumes the caller knows the contents of the data type. For less
 * well defined inputs use createArrayFromMixed.
 *
 * @param {object|function|filelist} obj
 * @return {array}
 */
function toArray(obj) {
  var length = obj.length;

  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
  // in old versions of Safari).
  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;

  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;

  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;

  !(typeof obj.callee !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;

  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
  // without method will throw during the slice call and skip straight to the
  // fallback.
  if (obj.hasOwnProperty) {
    try {
      return Array.prototype.slice.call(obj);
    } catch (e) {
      // IE < 9 does not support Array#slice on collections objects
    }
  }

  // Fall back to copying key by key. This assumes all keys have a value,
  // so will not preserve sparsely populated inputs.
  var ret = Array(length);
  for (var ii = 0; ii < length; ii++) {
    ret[ii] = obj[ii];
  }
  return ret;
}

/**
 * Perform a heuristic test to determine if an object is "array-like".
 *
 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
 *   Joshu replied: "Mu."
 *
 * This function determines if its argument has "array nature": it returns
 * true if the argument is an actual array, an `arguments' object, or an
 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
 *
 * It will return false for other array-like objects like Filelist.
 *
 * @param {*} obj
 * @return {boolean}
 */
function hasArrayNature(obj) {
  return (
    // not null/false
    !!obj && (
    // arrays are objects, NodeLists are functions in Safari
    typeof obj == 'object' || typeof obj == 'function') &&
    // quacks like an array
    'length' in obj &&
    // not window
    !('setInterval' in obj) &&
    // no DOM node should be considered an array-like
    // a 'select' element has 'length' and 'item' properties on IE8
    typeof obj.nodeType != 'number' && (
    // a real array
    Array.isArray(obj) ||
    // arguments
    'callee' in obj ||
    // HTMLCollection/NodeList
    'item' in obj)
  );
}

/**
 * Ensure that the argument is an array by wrapping it in an array if it is not.
 * Creates a copy of the argument if it is already an array.
 *
 * This is mostly useful idiomatically:
 *
 *   var createArrayFromMixed = require('createArrayFromMixed');
 *
 *   function takesOneOrMoreThings(things) {
 *     things = createArrayFromMixed(things);
 *     ...
 *   }
 *
 * This allows you to treat `things' as an array, but accept scalars in the API.
 *
 * If you need to convert an array-like object, like `arguments`, into an array
 * use toArray instead.
 *
 * @param {*} obj
 * @return {array}
 */
function createArrayFromMixed(obj) {
  if (!hasArrayNature(obj)) {
    return [obj];
  } else if (Array.isArray(obj)) {
    return obj.slice();
  } else {
    return toArray(obj);
  }
}

module.exports = createArrayFromMixed;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 474 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/*eslint-disable fb-www/unsafe-html */

var ExecutionEnvironment = __webpack_require__(16);

var invariant = __webpack_require__(2);

/**
 * Dummy container used to detect which wraps are necessary.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Some browsers cannot use `innerHTML` to render certain elements standalone,
 * so we wrap them, render the wrapped nodes, then extract the desired node.
 *
 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
 */

var shouldWrap = {};

var selectWrap = [1, '<select multiple="true">', '</select>'];
var tableWrap = [1, '<table>', '</table>'];
var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];

var markupWrap = {
  '*': [1, '?<div>', '</div>'],

  'area': [1, '<map>', '</map>'],
  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  'legend': [1, '<fieldset>', '</fieldset>'],
  'param': [1, '<object>', '</object>'],
  'tr': [2, '<table><tbody>', '</tbody></table>'],

  'optgroup': selectWrap,
  'option': selectWrap,

  'caption': tableWrap,
  'colgroup': tableWrap,
  'tbody': tableWrap,
  'tfoot': tableWrap,
  'thead': tableWrap,

  'td': trWrap,
  'th': trWrap
};

// Initialize the SVG elements since we know they'll always need to be wrapped
// consistently. If they are created inside a <div> they will be initialized in
// the wrong namespace (and will not display).
var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
svgElements.forEach(function (nodeName) {
  markupWrap[nodeName] = svgWrap;
  shouldWrap[nodeName] = true;
});

/**
 * Gets the markup wrap configuration for the supplied `nodeName`.
 *
 * NOTE: This lazily detects which wraps are necessary for the current browser.
 *
 * @param {string} nodeName Lowercase `nodeName`.
 * @return {?array} Markup wrap configuration, if applicable.
 */
function getMarkupWrap(nodeName) {
  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
  if (!markupWrap.hasOwnProperty(nodeName)) {
    nodeName = '*';
  }
  if (!shouldWrap.hasOwnProperty(nodeName)) {
    if (nodeName === '*') {
      dummyNode.innerHTML = '<link />';
    } else {
      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
    }
    shouldWrap[nodeName] = !dummyNode.firstChild;
  }
  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
}

module.exports = getMarkupWrap;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 475 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMChildrenOperations = __webpack_require__(131);
var ReactDOMComponentTree = __webpack_require__(14);

/**
 * Operations used to process updates to DOM nodes.
 */
var ReactDOMIDOperations = {
  /**
   * Updates a component's children by processing a series of updates.
   *
   * @param {array<object>} updates List of update configurations.
   * @internal
   */
  dangerouslyProcessChildrenUpdates: function (parentInst, updates) {
    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
    DOMChildrenOperations.processUpdates(node, updates);
  }
};

module.exports = ReactDOMIDOperations;

/***/ }),
/* 476 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/* global hasOwnProperty:true */



var _prodInvariant = __webpack_require__(7),
    _assign = __webpack_require__(10);

var AutoFocusUtils = __webpack_require__(477);
var CSSPropertyOperations = __webpack_require__(478);
var DOMLazyTree = __webpack_require__(65);
var DOMNamespaces = __webpack_require__(132);
var DOMProperty = __webpack_require__(44);
var DOMPropertyOperations = __webpack_require__(201);
var EventPluginHub = __webpack_require__(70);
var EventPluginRegistry = __webpack_require__(91);
var ReactBrowserEventEmitter = __webpack_require__(96);
var ReactDOMComponentFlags = __webpack_require__(189);
var ReactDOMComponentTree = __webpack_require__(14);
var ReactDOMInput = __webpack_require__(488);
var ReactDOMOption = __webpack_require__(489);
var ReactDOMSelect = __webpack_require__(203);
var ReactDOMTextarea = __webpack_require__(490);
var ReactInstrumentation = __webpack_require__(27);
var ReactMultiChild = __webpack_require__(491);
var ReactServerRenderingTransaction = __webpack_require__(500);

var emptyFunction = __webpack_require__(26);
var escapeTextContentForBrowser = __webpack_require__(95);
var invariant = __webpack_require__(2);
var isEventSupported = __webpack_require__(129);
var shallowEqual = __webpack_require__(136);
var inputValueTracking = __webpack_require__(195);
var validateDOMNesting = __webpack_require__(140);
var warning = __webpack_require__(3);

var Flags = ReactDOMComponentFlags;
var deleteListener = EventPluginHub.deleteListener;
var getNode = ReactDOMComponentTree.getNodeFromInstance;
var listenTo = ReactBrowserEventEmitter.listenTo;
var registrationNameModules = EventPluginRegistry.registrationNameModules;

// For quickly matching children type, to test if can be treated as content.
var CONTENT_TYPES = { string: true, number: true };

var STYLE = 'style';
var HTML = '__html';
var RESERVED_PROPS = {
  children: null,
  dangerouslySetInnerHTML: null,
  suppressContentEditableWarning: null
};

// Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
var DOC_FRAGMENT_TYPE = 11;

function getDeclarationErrorAddendum(internalInstance) {
  if (internalInstance) {
    var owner = internalInstance._currentElement._owner || null;
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' This DOM node was rendered by `' + name + '`.';
      }
    }
  }
  return '';
}

function friendlyStringify(obj) {
  if (typeof obj === 'object') {
    if (Array.isArray(obj)) {
      return '[' + obj.map(friendlyStringify).join(', ') + ']';
    } else {
      var pairs = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
        }
      }
      return '{' + pairs.join(', ') + '}';
    }
  } else if (typeof obj === 'string') {
    return JSON.stringify(obj);
  } else if (typeof obj === 'function') {
    return '[function object]';
  }
  // Differs from JSON.stringify in that undefined because undefined and that
  // inf and nan don't become null
  return String(obj);
}

var styleMutationWarning = {};

function checkAndWarnForMutatedStyle(style1, style2, component) {
  if (style1 == null || style2 == null) {
    return;
  }
  if (shallowEqual(style1, style2)) {
    return;
  }

  var componentName = component._tag;
  var owner = component._currentElement._owner;
  var ownerName;
  if (owner) {
    ownerName = owner.getName();
  }

  var hash = ownerName + '|' + componentName;

  if (styleMutationWarning.hasOwnProperty(hash)) {
    return;
  }

  styleMutationWarning[hash] = true;

  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
}

/**
 * @param {object} component
 * @param {?object} props
 */
function assertValidProps(component, props) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if (voidElementTags[component._tag]) {
    !(props.children == null && props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
  }
  if (props.dangerouslySetInnerHTML != null) {
    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
  }
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
    process.env.NODE_ENV !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
    process.env.NODE_ENV !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
  }
  !(props.style == null || typeof props.style === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
}

function enqueuePutListener(inst, registrationName, listener, transaction) {
  if (transaction instanceof ReactServerRenderingTransaction) {
    return;
  }
  if (process.env.NODE_ENV !== 'production') {
    // IE8 has no API for event capturing and the `onScroll` event doesn't
    // bubble.
    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), "This browser doesn't support the `onScroll` event") : void 0;
  }
  var containerInfo = inst._hostContainerInfo;
  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
  listenTo(registrationName, doc);
  transaction.getReactMountReady().enqueue(putListener, {
    inst: inst,
    registrationName: registrationName,
    listener: listener
  });
}

function putListener() {
  var listenerToPut = this;
  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
}

function inputPostMount() {
  var inst = this;
  ReactDOMInput.postMountWrapper(inst);
}

function textareaPostMount() {
  var inst = this;
  ReactDOMTextarea.postMountWrapper(inst);
}

function optionPostMount() {
  var inst = this;
  ReactDOMOption.postMountWrapper(inst);
}

var setAndValidateContentChildDev = emptyFunction;
if (process.env.NODE_ENV !== 'production') {
  setAndValidateContentChildDev = function (content) {
    var hasExistingContent = this._contentDebugID != null;
    var debugID = this._debugID;
    // This ID represents the inlined child that has no backing instance:
    var contentDebugID = -debugID;

    if (content == null) {
      if (hasExistingContent) {
        ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
      }
      this._contentDebugID = null;
      return;
    }

    validateDOMNesting(null, String(content), this, this._ancestorInfo);
    this._contentDebugID = contentDebugID;
    if (hasExistingContent) {
      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
    } else {
      ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
    }
  };
}

// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents = {
  topAbort: 'abort',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTimeUpdate: 'timeupdate',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting'
};

function trackInputValue() {
  inputValueTracking.track(this);
}

function trapBubbledEventsLocal() {
  var inst = this;
  // If a component renders to null or if another component fatals and causes
  // the state of the tree to be corrupted, `node` here can be null.
  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
  var node = getNode(inst);
  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;

  switch (inst._tag) {
    case 'iframe':
    case 'object':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
      break;
    case 'video':
    case 'audio':
      inst._wrapperState.listeners = [];
      // Create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(event, mediaEvents[event], node));
        }
      }
      break;
    case 'source':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node)];
      break;
    case 'img':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node), ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
      break;
    case 'form':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topReset', 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent('topSubmit', 'submit', node)];
      break;
    case 'input':
    case 'select':
    case 'textarea':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topInvalid', 'invalid', node)];
      break;
  }
}

function postUpdateSelectWrapper() {
  ReactDOMSelect.postUpdateWrapper(this);
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.

var omittedCloseTags = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
  // NOTE: menuitem's close tag should be omitted, but that causes problems.
};

var newlineEatingTags = {
  listing: true,
  pre: true,
  textarea: true
};

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _assign({
  menuitem: true
}, omittedCloseTags);

// We accept any tag to be rendered but since this gets injected into arbitrary
// HTML, we want to make sure that it's a safe tag.
// http://www.w3.org/TR/REC-xml/#NT-Name

var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
var validatedTagCache = {};
var hasOwnProperty = {}.hasOwnProperty;

function validateDangerousTag(tag) {
  if (!hasOwnProperty.call(validatedTagCache, tag)) {
    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
    validatedTagCache[tag] = true;
  }
}

function isCustomComponent(tagName, props) {
  return tagName.indexOf('-') >= 0 || props.is != null;
}

var globalIdCounter = 1;

/**
 * Creates a new React class that is idempotent and capable of containing other
 * React components. It accepts event listeners and DOM properties that are
 * valid according to `DOMProperty`.
 *
 *  - Event listeners: `onClick`, `onMouseDown`, etc.
 *  - DOM properties: `className`, `name`, `title`, etc.
 *
 * The `style` property functions differently from the DOM API. It accepts an
 * object mapping of style properties to values.
 *
 * @constructor ReactDOMComponent
 * @extends ReactMultiChild
 */
function ReactDOMComponent(element) {
  var tag = element.type;
  validateDangerousTag(tag);
  this._currentElement = element;
  this._tag = tag.toLowerCase();
  this._namespaceURI = null;
  this._renderedChildren = null;
  this._previousStyle = null;
  this._previousStyleCopy = null;
  this._hostNode = null;
  this._hostParent = null;
  this._rootNodeID = 0;
  this._domID = 0;
  this._hostContainerInfo = null;
  this._wrapperState = null;
  this._topLevelWrapper = null;
  this._flags = 0;
  if (process.env.NODE_ENV !== 'production') {
    this._ancestorInfo = null;
    setAndValidateContentChildDev.call(this, null);
  }
}

ReactDOMComponent.displayName = 'ReactDOMComponent';

ReactDOMComponent.Mixin = {
  /**
   * Generates root tag markup then recurses. This method has side effects and
   * is not idempotent.
   *
   * @internal
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?ReactDOMComponent} the parent component instance
   * @param {?object} info about the host container
   * @param {object} context
   * @return {string} The computed markup.
   */
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    this._rootNodeID = globalIdCounter++;
    this._domID = hostContainerInfo._idCounter++;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var props = this._currentElement.props;

    switch (this._tag) {
      case 'audio':
      case 'form':
      case 'iframe':
      case 'img':
      case 'link':
      case 'object':
      case 'source':
      case 'video':
        this._wrapperState = {
          listeners: null
        };
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'input':
        ReactDOMInput.mountWrapper(this, props, hostParent);
        props = ReactDOMInput.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trackInputValue, this);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'option':
        ReactDOMOption.mountWrapper(this, props, hostParent);
        props = ReactDOMOption.getHostProps(this, props);
        break;
      case 'select':
        ReactDOMSelect.mountWrapper(this, props, hostParent);
        props = ReactDOMSelect.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'textarea':
        ReactDOMTextarea.mountWrapper(this, props, hostParent);
        props = ReactDOMTextarea.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trackInputValue, this);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
    }

    assertValidProps(this, props);

    // We create tags in the namespace of their parent container, except HTML
    // tags get no namespace.
    var namespaceURI;
    var parentTag;
    if (hostParent != null) {
      namespaceURI = hostParent._namespaceURI;
      parentTag = hostParent._tag;
    } else if (hostContainerInfo._tag) {
      namespaceURI = hostContainerInfo._namespaceURI;
      parentTag = hostContainerInfo._tag;
    }
    if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
      namespaceURI = DOMNamespaces.html;
    }
    if (namespaceURI === DOMNamespaces.html) {
      if (this._tag === 'svg') {
        namespaceURI = DOMNamespaces.svg;
      } else if (this._tag === 'math') {
        namespaceURI = DOMNamespaces.mathml;
      }
    }
    this._namespaceURI = namespaceURI;

    if (process.env.NODE_ENV !== 'production') {
      var parentInfo;
      if (hostParent != null) {
        parentInfo = hostParent._ancestorInfo;
      } else if (hostContainerInfo._tag) {
        parentInfo = hostContainerInfo._ancestorInfo;
      }
      if (parentInfo) {
        // parentInfo should always be present except for the top-level
        // component when server rendering
        validateDOMNesting(this._tag, null, this, parentInfo);
      }
      this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
    }

    var mountImage;
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var el;
      if (namespaceURI === DOMNamespaces.html) {
        if (this._tag === 'script') {
          // Create the script via .innerHTML so its "parser-inserted" flag is
          // set to true and it does not execute
          var div = ownerDocument.createElement('div');
          var type = this._currentElement.type;
          div.innerHTML = '<' + type + '></' + type + '>';
          el = div.removeChild(div.firstChild);
        } else if (props.is) {
          el = ownerDocument.createElement(this._currentElement.type, props.is);
        } else {
          // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
          // See discussion in https://github.com/facebook/react/pull/6896
          // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
          el = ownerDocument.createElement(this._currentElement.type);
        }
      } else {
        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
      }
      ReactDOMComponentTree.precacheNode(this, el);
      this._flags |= Flags.hasCachedChildNodes;
      if (!this._hostParent) {
        DOMPropertyOperations.setAttributeForRoot(el);
      }
      this._updateDOMProperties(null, props, transaction);
      var lazyTree = DOMLazyTree(el);
      this._createInitialChildren(transaction, props, context, lazyTree);
      mountImage = lazyTree;
    } else {
      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
      var tagContent = this._createContentMarkup(transaction, props, context);
      if (!tagContent && omittedCloseTags[this._tag]) {
        mountImage = tagOpen + '/>';
      } else {
        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
      }
    }

    switch (this._tag) {
      case 'input':
        transaction.getReactMountReady().enqueue(inputPostMount, this);
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'textarea':
        transaction.getReactMountReady().enqueue(textareaPostMount, this);
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'select':
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'button':
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'option':
        transaction.getReactMountReady().enqueue(optionPostMount, this);
        break;
    }

    return mountImage;
  },

  /**
   * Creates markup for the open tag and all attributes.
   *
   * This method has side effects because events get registered.
   *
   * Iterating over object properties is faster than iterating over arrays.
   * @see http://jsperf.com/obj-vs-arr-iteration
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @return {string} Markup of opening tag.
   */
  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
    var ret = '<' + this._currentElement.type;

    for (var propKey in props) {
      if (!props.hasOwnProperty(propKey)) {
        continue;
      }
      var propValue = props[propKey];
      if (propValue == null) {
        continue;
      }
      if (registrationNameModules.hasOwnProperty(propKey)) {
        if (propValue) {
          enqueuePutListener(this, propKey, propValue, transaction);
        }
      } else {
        if (propKey === STYLE) {
          if (propValue) {
            if (process.env.NODE_ENV !== 'production') {
              // See `_updateDOMProperties`. style block
              this._previousStyle = propValue;
            }
            propValue = this._previousStyleCopy = _assign({}, props.style);
          }
          propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
        }
        var markup = null;
        if (this._tag != null && isCustomComponent(this._tag, props)) {
          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
          }
        } else {
          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
        }
        if (markup) {
          ret += ' ' + markup;
        }
      }
    }

    // For static pages, no need to put React ID and checksum. Saves lots of
    // bytes.
    if (transaction.renderToStaticMarkup) {
      return ret;
    }

    if (!this._hostParent) {
      ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
    }
    ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
    return ret;
  },

  /**
   * Creates markup for the content between the tags.
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @param {object} context
   * @return {string} Content markup.
   */
  _createContentMarkup: function (transaction, props, context) {
    var ret = '';

    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        ret = innerHTML.__html;
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      if (contentToUse != null) {
        // TODO: Validate that text is allowed as a child of this node
        ret = escapeTextContentForBrowser(contentToUse);
        if (process.env.NODE_ENV !== 'production') {
          setAndValidateContentChildDev.call(this, contentToUse);
        }
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        ret = mountImages.join('');
      }
    }
    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
      // text/html ignores the first character in these tags if it's a newline
      // Prefer to break application/xml over text/html (for now) by adding
      // a newline specifically to get eaten by the parser. (Alternately for
      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
      // \r is normalized out by HTMLTextAreaElement#value.)
      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
      // See: Parsing of "textarea" "listing" and "pre" elements
      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
      return '\n' + ret;
    } else {
      return ret;
    }
  },

  _createInitialChildren: function (transaction, props, context, lazyTree) {
    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      // TODO: Validate that text is allowed as a child of this node
      if (contentToUse != null) {
        // Avoid setting textContent when the text is empty. In IE11 setting
        // textContent on a text area will cause the placeholder to not
        // show within the textarea until it has been focused and blurred again.
        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
        if (contentToUse !== '') {
          if (process.env.NODE_ENV !== 'production') {
            setAndValidateContentChildDev.call(this, contentToUse);
          }
          DOMLazyTree.queueText(lazyTree, contentToUse);
        }
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        for (var i = 0; i < mountImages.length; i++) {
          DOMLazyTree.queueChild(lazyTree, mountImages[i]);
        }
      }
    }
  },

  /**
   * Receives a next element and updates the component.
   *
   * @internal
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   */
  receiveComponent: function (nextElement, transaction, context) {
    var prevElement = this._currentElement;
    this._currentElement = nextElement;
    this.updateComponent(transaction, prevElement, nextElement, context);
  },

  /**
   * Updates a DOM component after it has already been allocated and
   * attached to the DOM. Reconciles the root DOM node, then recurses.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevElement
   * @param {ReactElement} nextElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevElement, nextElement, context) {
    var lastProps = prevElement.props;
    var nextProps = this._currentElement.props;

    switch (this._tag) {
      case 'input':
        lastProps = ReactDOMInput.getHostProps(this, lastProps);
        nextProps = ReactDOMInput.getHostProps(this, nextProps);
        break;
      case 'option':
        lastProps = ReactDOMOption.getHostProps(this, lastProps);
        nextProps = ReactDOMOption.getHostProps(this, nextProps);
        break;
      case 'select':
        lastProps = ReactDOMSelect.getHostProps(this, lastProps);
        nextProps = ReactDOMSelect.getHostProps(this, nextProps);
        break;
      case 'textarea':
        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
        break;
    }

    assertValidProps(this, nextProps);
    this._updateDOMProperties(lastProps, nextProps, transaction);
    this._updateDOMChildren(lastProps, nextProps, transaction, context);

    switch (this._tag) {
      case 'input':
        // Update the wrapper around inputs *after* updating props. This has to
        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
        // raise warnings and prevent the new value from being assigned.
        ReactDOMInput.updateWrapper(this);
        break;
      case 'textarea':
        ReactDOMTextarea.updateWrapper(this);
        break;
      case 'select':
        // <select> value update needs to occur after <option> children
        // reconciliation
        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
        break;
    }
  },

  /**
   * Reconciles the properties by detecting differences in property values and
   * updating the DOM as necessary. This function is probably the single most
   * critical path for performance optimization.
   *
   * TODO: Benchmark whether checking for changed values in memory actually
   *       improves performance (especially statically positioned elements).
   * TODO: Benchmark the effects of putting this at the top since 99% of props
   *       do not change for a given reconciliation.
   * TODO: Benchmark areas that can be improved with caching.
   *
   * @private
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {?DOMElement} node
   */
  _updateDOMProperties: function (lastProps, nextProps, transaction) {
    var propKey;
    var styleName;
    var styleUpdates;
    for (propKey in lastProps) {
      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
        continue;
      }
      if (propKey === STYLE) {
        var lastStyle = this._previousStyleCopy;
        for (styleName in lastStyle) {
          if (lastStyle.hasOwnProperty(styleName)) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = '';
          }
        }
        this._previousStyleCopy = null;
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (lastProps[propKey]) {
          // Only call deleteListener if there was a listener previously or
          // else willDeleteListener gets called when there wasn't actually a
          // listener (e.g., onClick={null})
          deleteListener(this, propKey);
        }
      } else if (isCustomComponent(this._tag, lastProps)) {
        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
          DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
        }
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
      }
    }
    for (propKey in nextProps) {
      var nextProp = nextProps[propKey];
      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
        continue;
      }
      if (propKey === STYLE) {
        if (nextProp) {
          if (process.env.NODE_ENV !== 'production') {
            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
            this._previousStyle = nextProp;
          }
          nextProp = this._previousStyleCopy = _assign({}, nextProp);
        } else {
          this._previousStyleCopy = null;
        }
        if (lastProp) {
          // Unset styles on `lastProp` but not on `nextProp`.
          for (styleName in lastProp) {
            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = '';
            }
          }
          // Update styles that changed since `lastProp`.
          for (styleName in nextProp) {
            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = nextProp[styleName];
            }
          }
        } else {
          // Relies on `updateStylesByID` not mutating `styleUpdates`.
          styleUpdates = nextProp;
        }
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (nextProp) {
          enqueuePutListener(this, propKey, nextProp, transaction);
        } else if (lastProp) {
          deleteListener(this, propKey);
        }
      } else if (isCustomComponent(this._tag, nextProps)) {
        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
          DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
        }
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        var node = getNode(this);
        // If we're updating to null or undefined, we should remove the property
        // from the DOM node instead of inadvertently setting to a string. This
        // brings us in line with the same behavior we have on initial render.
        if (nextProp != null) {
          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
        } else {
          DOMPropertyOperations.deleteValueForProperty(node, propKey);
        }
      }
    }
    if (styleUpdates) {
      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
    }
  },

  /**
   * Reconciles the children with the various properties that affect the
   * children content.
   *
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   */
  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

    // Note the use of `!=` which checks for null or undefined.
    var lastChildren = lastContent != null ? null : lastProps.children;
    var nextChildren = nextContent != null ? null : nextProps.children;

    // If we're switching from children to content/html or vice versa, remove
    // the old content
    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
    if (lastChildren != null && nextChildren == null) {
      this.updateChildren(null, transaction, context);
    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
      this.updateTextContent('');
      if (process.env.NODE_ENV !== 'production') {
        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
      }
    }

    if (nextContent != null) {
      if (lastContent !== nextContent) {
        this.updateTextContent('' + nextContent);
        if (process.env.NODE_ENV !== 'production') {
          setAndValidateContentChildDev.call(this, nextContent);
        }
      }
    } else if (nextHtml != null) {
      if (lastHtml !== nextHtml) {
        this.updateMarkup('' + nextHtml);
      }
      if (process.env.NODE_ENV !== 'production') {
        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
      }
    } else if (nextChildren != null) {
      if (process.env.NODE_ENV !== 'production') {
        setAndValidateContentChildDev.call(this, null);
      }

      this.updateChildren(nextChildren, transaction, context);
    }
  },

  getHostNode: function () {
    return getNode(this);
  },

  /**
   * Destroys all event registrations for this instance. Does not remove from
   * the DOM. That must be done by the parent.
   *
   * @internal
   */
  unmountComponent: function (safely) {
    switch (this._tag) {
      case 'audio':
      case 'form':
      case 'iframe':
      case 'img':
      case 'link':
      case 'object':
      case 'source':
      case 'video':
        var listeners = this._wrapperState.listeners;
        if (listeners) {
          for (var i = 0; i < listeners.length; i++) {
            listeners[i].remove();
          }
        }
        break;
      case 'input':
      case 'textarea':
        inputValueTracking.stopTracking(this);
        break;
      case 'html':
      case 'head':
      case 'body':
        /**
         * Components like <html> <head> and <body> can't be removed or added
         * easily in a cross-browser way, however it's valuable to be able to
         * take advantage of React's reconciliation for styling and <title>
         * management. So we just document it and throw in dangerous cases.
         */
         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
        break;
    }

    this.unmountChildren(safely);
    ReactDOMComponentTree.uncacheNode(this);
    EventPluginHub.deleteAllListeners(this);
    this._rootNodeID = 0;
    this._domID = 0;
    this._wrapperState = null;

    if (process.env.NODE_ENV !== 'production') {
      setAndValidateContentChildDev.call(this, null);
    }
  },

  getPublicInstance: function () {
    return getNode(this);
  }
};

_assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);

module.exports = ReactDOMComponent;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 477 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactDOMComponentTree = __webpack_require__(14);

var focusNode = __webpack_require__(199);

var AutoFocusUtils = {
  focusDOMComponent: function () {
    focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
  }
};

module.exports = AutoFocusUtils;

/***/ }),
/* 478 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var CSSProperty = __webpack_require__(200);
var ExecutionEnvironment = __webpack_require__(16);
var ReactInstrumentation = __webpack_require__(27);

var camelizeStyleName = __webpack_require__(479);
var dangerousStyleValue = __webpack_require__(481);
var hyphenateStyleName = __webpack_require__(482);
var memoizeStringOnly = __webpack_require__(484);
var warning = __webpack_require__(3);

var processStyleName = memoizeStringOnly(function (styleName) {
  return hyphenateStyleName(styleName);
});

var hasShorthandPropertyBug = false;
var styleFloatAccessor = 'cssFloat';
if (ExecutionEnvironment.canUseDOM) {
  var tempStyle = document.createElement('div').style;
  try {
    // IE8 throws "Invalid argument." if resetting shorthand style properties.
    tempStyle.font = '';
  } catch (e) {
    hasShorthandPropertyBug = true;
  }
  // IE8 only supports accessing cssFloat (standard) as styleFloat
  if (document.documentElement.style.cssFloat === undefined) {
    styleFloatAccessor = 'styleFloat';
  }
}

if (process.env.NODE_ENV !== 'production') {
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

  // style values shouldn't contain a semicolon
  var badStyleValueWithSemicolonPattern = /;\s*$/;

  var warnedStyleNames = {};
  var warnedStyleValues = {};
  var warnedForNaNValue = false;

  var warnHyphenatedStyleName = function (name, owner) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
  };

  var warnBadVendoredStyleName = function (name, owner) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
  };

  var warnStyleValueWithSemicolon = function (name, value, owner) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    process.env.NODE_ENV !== 'production' ? warning(false, "Style property values shouldn't contain a semicolon.%s " + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
  };

  var warnStyleValueIsNaN = function (name, value, owner) {
    if (warnedForNaNValue) {
      return;
    }

    warnedForNaNValue = true;
    process.env.NODE_ENV !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
  };

  var checkRenderMessage = function (owner) {
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' Check the render method of `' + name + '`.';
      }
    }
    return '';
  };

  /**
   * @param {string} name
   * @param {*} value
   * @param {ReactDOMComponent} component
   */
  var warnValidStyle = function (name, value, component) {
    var owner;
    if (component) {
      owner = component._currentElement._owner;
    }
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name, owner);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name, owner);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value, owner);
    }

    if (typeof value === 'number' && isNaN(value)) {
      warnStyleValueIsNaN(name, value, owner);
    }
  };
}

/**
 * Operations for dealing with CSS properties.
 */
var CSSPropertyOperations = {
  /**
   * Serializes a mapping of style properties for use as inline styles:
   *
   *   > createMarkupForStyles({width: '200px', height: 0})
   *   "width:200px;height:0;"
   *
   * Undefined values are ignored so that declarative programming is easier.
   * The result should be HTML-escaped before insertion into the DOM.
   *
   * @param {object} styles
   * @param {ReactDOMComponent} component
   * @return {?string}
   */
  createMarkupForStyles: function (styles, component) {
    var serialized = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var isCustomProperty = styleName.indexOf('--') === 0;
      var styleValue = styles[styleName];
      if (process.env.NODE_ENV !== 'production') {
        if (!isCustomProperty) {
          warnValidStyle(styleName, styleValue, component);
        }
      }
      if (styleValue != null) {
        serialized += processStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue, component, isCustomProperty) + ';';
      }
    }
    return serialized || null;
  },

  /**
   * Sets the value for multiple styles on a node.  If a value is specified as
   * '' (empty string), the corresponding style property will be unset.
   *
   * @param {DOMElement} node
   * @param {object} styles
   * @param {ReactDOMComponent} component
   */
  setValueForStyles: function (node, styles, component) {
    if (process.env.NODE_ENV !== 'production') {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: component._debugID,
        type: 'update styles',
        payload: styles
      });
    }

    var style = node.style;
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var isCustomProperty = styleName.indexOf('--') === 0;
      if (process.env.NODE_ENV !== 'production') {
        if (!isCustomProperty) {
          warnValidStyle(styleName, styles[styleName], component);
        }
      }
      var styleValue = dangerousStyleValue(styleName, styles[styleName], component, isCustomProperty);
      if (styleName === 'float' || styleName === 'cssFloat') {
        styleName = styleFloatAccessor;
      }
      if (isCustomProperty) {
        style.setProperty(styleName, styleValue);
      } else if (styleValue) {
        style[styleName] = styleValue;
      } else {
        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
        if (expansion) {
          // Shorthand property that IE8 won't like unsetting, so unset each
          // component to placate it
          for (var individualStyleName in expansion) {
            style[individualStyleName] = '';
          }
        } else {
          style[styleName] = '';
        }
      }
    }
  }
};

module.exports = CSSPropertyOperations;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 479 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */



var camelize = __webpack_require__(480);

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;

/***/ }),
/* 480 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;

/***/ }),
/* 481 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var CSSProperty = __webpack_require__(200);
var warning = __webpack_require__(3);

var isUnitlessNumber = CSSProperty.isUnitlessNumber;
var styleWarnings = {};

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @param {ReactDOMComponent} component
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value, component, isCustomProperty) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  var isNonNumeric = isNaN(value);
  if (isCustomProperty || isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
    return '' + value; // cast to string
  }

  if (typeof value === 'string') {
    if (process.env.NODE_ENV !== 'production') {
      // Allow '0' to pass through without warning. 0 is already special and
      // doesn't require units, so we don't need to warn about it.
      if (component && value !== '0') {
        var owner = component._currentElement._owner;
        var ownerName = owner ? owner.getName() : null;
        if (ownerName && !styleWarnings[ownerName]) {
          styleWarnings[ownerName] = {};
        }
        var warned = false;
        if (ownerName) {
          var warnings = styleWarnings[ownerName];
          warned = warnings[name];
          if (!warned) {
            warnings[name] = true;
          }
        }
        if (!warned) {
          process.env.NODE_ENV !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
        }
      }
    }
    value = value.trim();
  }
  return value + 'px';
}

module.exports = dangerousStyleValue;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 482 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */



var hyphenate = __webpack_require__(483);

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;

/***/ }),
/* 483 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;

/***/ }),
/* 484 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @typechecks static-only
 */



/**
 * Memoizes the return value of a function that accepts one string argument.
 */

function memoizeStringOnly(callback) {
  var cache = {};
  return function (string) {
    if (!cache.hasOwnProperty(string)) {
      cache[string] = callback.call(this, string);
    }
    return cache[string];
  };
}

module.exports = memoizeStringOnly;

/***/ }),
/* 485 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var escapeTextContentForBrowser = __webpack_require__(95);

/**
 * Escapes attribute value to prevent scripting attacks.
 *
 * @param {*} value Value to escape.
 * @return {string} An escaped string.
 */
function quoteAttributeValueForBrowser(value) {
  return '"' + escapeTextContentForBrowser(value) + '"';
}

module.exports = quoteAttributeValueForBrowser;

/***/ }),
/* 486 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var EventPluginHub = __webpack_require__(70);

function runEventQueueInBatch(events) {
  EventPluginHub.enqueueEvents(events);
  EventPluginHub.processEventQueue(false);
}

var ReactEventEmitterMixin = {
  /**
   * Streams a fired top-level event to `EventPluginHub` where plugins have the
   * opportunity to create `ReactEvent`s to be dispatched.
   */
  handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
    runEventQueueInBatch(events);
  }
};

module.exports = ReactEventEmitterMixin;

/***/ }),
/* 487 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ExecutionEnvironment = __webpack_require__(16);

/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};

  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
  prefixes['Moz' + styleProp] = 'moz' + eventName;
  prefixes['ms' + styleProp] = 'MS' + eventName;
  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

  return prefixes;
}

/**
 * A list of event names to a configurable list of vendor prefixes.
 */
var vendorPrefixes = {
  animationend: makePrefixMap('Animation', 'AnimationEnd'),
  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
  animationstart: makePrefixMap('Animation', 'AnimationStart'),
  transitionend: makePrefixMap('Transition', 'TransitionEnd')
};

/**
 * Event names that have already been detected and prefixed (if applicable).
 */
var prefixedEventNames = {};

/**
 * Element to check for prefixes on.
 */
var style = {};

/**
 * Bootstrap if a DOM exists.
 */
if (ExecutionEnvironment.canUseDOM) {
  style = document.createElement('div').style;

  // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are usable, and if not remove them from the map.
  if (!('AnimationEvent' in window)) {
    delete vendorPrefixes.animationend.animation;
    delete vendorPrefixes.animationiteration.animation;
    delete vendorPrefixes.animationstart.animation;
  }

  // Same as above
  if (!('TransitionEvent' in window)) {
    delete vendorPrefixes.transitionend.transition;
  }
}

/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  } else if (!vendorPrefixes[eventName]) {
    return eventName;
  }

  var prefixMap = vendorPrefixes[eventName];

  for (var styleProp in prefixMap) {
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
      return prefixedEventNames[eventName] = prefixMap[styleProp];
    }
  }

  return '';
}

module.exports = getVendorPrefixedEventName;

/***/ }),
/* 488 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(7),
    _assign = __webpack_require__(10);

var DOMPropertyOperations = __webpack_require__(201);
var LinkedValueUtils = __webpack_require__(134);
var ReactDOMComponentTree = __webpack_require__(14);
var ReactUpdates = __webpack_require__(38);

var invariant = __webpack_require__(2);
var warning = __webpack_require__(3);

var didWarnValueLink = false;
var didWarnCheckedLink = false;
var didWarnValueDefaultValue = false;
var didWarnCheckedDefaultChecked = false;
var didWarnControlledToUncontrolled = false;
var didWarnUncontrolledToControlled = false;

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMInput.updateWrapper(this);
  }
}

function isControlled(props) {
  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
  return usesChecked ? props.checked != null : props.value != null;
}

/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */
var ReactDOMInput = {
  getHostProps: function (inst, props) {
    var value = LinkedValueUtils.getValue(props);
    var checked = LinkedValueUtils.getChecked(props);

    var hostProps = _assign({
      // Make sure we set .type before any other properties (setting .value
      // before .type means .value is lost in IE11 and below)
      type: undefined,
      // Make sure we set .step before .value (setting .value before .step
      // means .value is rounded on mount, based upon step precision)
      step: undefined,
      // Make sure we set .min & .max before .value (to ensure proper order
      // in corner cases such as min or max deriving from value, e.g. Issue #7170)
      min: undefined,
      max: undefined
    }, props, {
      defaultChecked: undefined,
      defaultValue: undefined,
      value: value != null ? value : inst._wrapperState.initialValue,
      checked: checked != null ? checked : inst._wrapperState.initialChecked,
      onChange: inst._wrapperState.onChange
    });

    return hostProps;
  },

  mountWrapper: function (inst, props) {
    if (process.env.NODE_ENV !== 'production') {
      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);

      var owner = inst._currentElement._owner;

      if (props.valueLink !== undefined && !didWarnValueLink) {
        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnValueLink = true;
      }
      if (props.checkedLink !== undefined && !didWarnCheckedLink) {
        process.env.NODE_ENV !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnCheckedLink = true;
      }
      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnCheckedDefaultChecked = true;
      }
      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnValueDefaultValue = true;
      }
    }

    var defaultValue = props.defaultValue;
    inst._wrapperState = {
      initialChecked: props.checked != null ? props.checked : props.defaultChecked,
      initialValue: props.value != null ? props.value : defaultValue,
      listeners: null,
      onChange: _handleChange.bind(inst),
      controlled: isControlled(props)
    };
  },

  updateWrapper: function (inst) {
    var props = inst._currentElement.props;

    if (process.env.NODE_ENV !== 'production') {
      var controlled = isControlled(props);
      var owner = inst._currentElement._owner;

      if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnUncontrolledToControlled = true;
      }
      if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnControlledToUncontrolled = true;
      }
    }

    // TODO: Shouldn't this be getChecked(props)?
    var checked = props.checked;
    if (checked != null) {
      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
    }

    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      if (value === 0 && node.value === '') {
        node.value = '0';
        // Note: IE9 reports a number inputs as 'text', so check props instead.
      } else if (props.type === 'number') {
        // Simulate `input.valueAsNumber`. IE9 does not support it
        var valueAsNumber = parseFloat(node.value, 10) || 0;

        if (
        // eslint-disable-next-line
        value != valueAsNumber ||
        // eslint-disable-next-line
        value == valueAsNumber && node.value != value) {
          // Cast `value` to a string to ensure the value is set correctly. While
          // browsers typically do this as necessary, jsdom doesn't.
          node.value = '' + value;
        }
      } else if (node.value !== '' + value) {
        // Cast `value` to a string to ensure the value is set correctly. While
        // browsers typically do this as necessary, jsdom doesn't.
        node.value = '' + value;
      }
    } else {
      if (props.value == null && props.defaultValue != null) {
        // In Chrome, assigning defaultValue to certain input types triggers input validation.
        // For number inputs, the display value loses trailing decimal points. For email inputs,
        // Chrome raises "The specified value <x> is not a valid email address".
        //
        // Here we check to see if the defaultValue has actually changed, avoiding these problems
        // when the user is inputting text
        //
        // https://github.com/facebook/react/issues/7253
        if (node.defaultValue !== '' + props.defaultValue) {
          node.defaultValue = '' + props.defaultValue;
        }
      }
      if (props.checked == null && props.defaultChecked != null) {
        node.defaultChecked = !!props.defaultChecked;
      }
    }
  },

  postMountWrapper: function (inst) {
    var props = inst._currentElement.props;

    // This is in postMount because we need access to the DOM node, which is not
    // available until after the component has mounted.
    var node = ReactDOMComponentTree.getNodeFromInstance(inst);

    // Detach value from defaultValue. We won't do anything if we're working on
    // submit or reset inputs as those values & defaultValues are linked. They
    // are not resetable nodes so this operation doesn't matter and actually
    // removes browser-default values (eg "Submit Query") when no value is
    // provided.

    switch (props.type) {
      case 'submit':
      case 'reset':
        break;
      case 'color':
      case 'date':
      case 'datetime':
      case 'datetime-local':
      case 'month':
      case 'time':
      case 'week':
        // This fixes the no-show issue on iOS Safari and Android Chrome:
        // https://github.com/facebook/react/issues/7233
        node.value = '';
        node.value = node.defaultValue;
        break;
      default:
        node.value = node.value;
        break;
    }

    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
    // this is needed to work around a chrome bug where setting defaultChecked
    // will sometimes influence the value of checked (even after detachment).
    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
    // We need to temporarily unset name to avoid disrupting radio button groups.
    var name = node.name;
    if (name !== '') {
      node.name = '';
    }
    node.defaultChecked = !node.defaultChecked;
    node.defaultChecked = !node.defaultChecked;
    if (name !== '') {
      node.name = name;
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;

  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  // Here we use asap to wait until all updates have propagated, which
  // is important when using controlled components within layers:
  // https://github.com/facebook/react/issues/1698
  ReactUpdates.asap(forceUpdateIfMounted, this);

  var name = props.name;
  if (props.type === 'radio' && name != null) {
    var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    }

    // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form, let's just use the global
    // `querySelectorAll` to ensure we don't miss anything.
    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];
      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      }
      // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React radio buttons with non-React ones.
      var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
      // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.
      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
    }
  }

  return returnValue;
}

module.exports = ReactDOMInput;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 489 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(10);

var React = __webpack_require__(62);
var ReactDOMComponentTree = __webpack_require__(14);
var ReactDOMSelect = __webpack_require__(203);

var warning = __webpack_require__(3);
var didWarnInvalidOptionChildren = false;

function flattenChildren(children) {
  var content = '';

  // Flatten children and warn if they aren't strings or numbers;
  // invalid types are ignored.
  React.Children.forEach(children, function (child) {
    if (child == null) {
      return;
    }
    if (typeof child === 'string' || typeof child === 'number') {
      content += child;
    } else if (!didWarnInvalidOptionChildren) {
      didWarnInvalidOptionChildren = true;
      process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
    }
  });

  return content;
}

/**
 * Implements an <option> host component that warns when `selected` is set.
 */
var ReactDOMOption = {
  mountWrapper: function (inst, props, hostParent) {
    // TODO (yungsters): Remove support for `selected` in <option>.
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
    }

    // Look up whether this option is 'selected'
    var selectValue = null;
    if (hostParent != null) {
      var selectParent = hostParent;

      if (selectParent._tag === 'optgroup') {
        selectParent = selectParent._hostParent;
      }

      if (selectParent != null && selectParent._tag === 'select') {
        selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
      }
    }

    // If the value is null (e.g., no specified value or after initial mount)
    // or missing (e.g., for <datalist>), we don't change props.selected
    var selected = null;
    if (selectValue != null) {
      var value;
      if (props.value != null) {
        value = props.value + '';
      } else {
        value = flattenChildren(props.children);
      }
      selected = false;
      if (Array.isArray(selectValue)) {
        // multiple
        for (var i = 0; i < selectValue.length; i++) {
          if ('' + selectValue[i] === value) {
            selected = true;
            break;
          }
        }
      } else {
        selected = '' + selectValue === value;
      }
    }

    inst._wrapperState = { selected: selected };
  },

  postMountWrapper: function (inst) {
    // value="" should make a value attribute (#6219)
    var props = inst._currentElement.props;
    if (props.value != null) {
      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
      node.setAttribute('value', props.value);
    }
  },

  getHostProps: function (inst, props) {
    var hostProps = _assign({ selected: undefined, children: undefined }, props);

    // Read state only from initial mount because <select> updates value
    // manually; we need the initial state only for server rendering
    if (inst._wrapperState.selected != null) {
      hostProps.selected = inst._wrapperState.selected;
    }

    var content = flattenChildren(props.children);

    if (content) {
      hostProps.children = content;
    }

    return hostProps;
  }
};

module.exports = ReactDOMOption;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 490 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(7),
    _assign = __webpack_require__(10);

var LinkedValueUtils = __webpack_require__(134);
var ReactDOMComponentTree = __webpack_require__(14);
var ReactUpdates = __webpack_require__(38);

var invariant = __webpack_require__(2);
var warning = __webpack_require__(3);

var didWarnValueLink = false;
var didWarnValDefaultVal = false;

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMTextarea.updateWrapper(this);
  }
}

/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */
var ReactDOMTextarea = {
  getHostProps: function (inst, props) {
    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;

    // Always set children to the same thing. In IE9, the selection range will
    // get reset if `textContent` is mutated.  We could add a check in setTextContent
    // to only set the value if/when the value differs from the node value (which would
    // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
    // The value can be a boolean or object so that's why it's forced to be a string.
    var hostProps = _assign({}, props, {
      value: undefined,
      defaultValue: undefined,
      children: '' + inst._wrapperState.initialValue,
      onChange: inst._wrapperState.onChange
    });

    return hostProps;
  },

  mountWrapper: function (inst, props) {
    if (process.env.NODE_ENV !== 'production') {
      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
      if (props.valueLink !== undefined && !didWarnValueLink) {
        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnValueLink = true;
      }
      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
        didWarnValDefaultVal = true;
      }
    }

    var value = LinkedValueUtils.getValue(props);
    var initialValue = value;

    // Only bother fetching default value if we're going to use it
    if (value == null) {
      var defaultValue = props.defaultValue;
      // TODO (yungsters): Remove support for children content in <textarea>.
      var children = props.children;
      if (children != null) {
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
        }
        !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
        if (Array.isArray(children)) {
          !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
          children = children[0];
        }

        defaultValue = '' + children;
      }
      if (defaultValue == null) {
        defaultValue = '';
      }
      initialValue = defaultValue;
    }

    inst._wrapperState = {
      initialValue: '' + initialValue,
      listeners: null,
      onChange: _handleChange.bind(inst)
    };
  },

  updateWrapper: function (inst) {
    var props = inst._currentElement.props;

    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      var newValue = '' + value;

      // To avoid side effects (such as losing text selection), only set value if changed
      if (newValue !== node.value) {
        node.value = newValue;
      }
      if (props.defaultValue == null) {
        node.defaultValue = newValue;
      }
    }
    if (props.defaultValue != null) {
      node.defaultValue = props.defaultValue;
    }
  },

  postMountWrapper: function (inst) {
    // This is in postMount because we need access to the DOM node, which is not
    // available until after the component has mounted.
    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var textContent = node.textContent;

    // Only set node.value if textContent is equal to the expected
    // initial value. In IE10/IE11 there is a bug where the placeholder attribute
    // will populate textContent as well.
    // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
    if (textContent === inst._wrapperState.initialValue) {
      node.value = textContent;
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);
  ReactUpdates.asap(forceUpdateIfMounted, this);
  return returnValue;
}

module.exports = ReactDOMTextarea;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 491 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(7);

var ReactComponentEnvironment = __webpack_require__(135);
var ReactInstanceMap = __webpack_require__(72);
var ReactInstrumentation = __webpack_require__(27);

var ReactCurrentOwner = __webpack_require__(37);
var ReactReconciler = __webpack_require__(64);
var ReactChildReconciler = __webpack_require__(492);

var emptyFunction = __webpack_require__(26);
var flattenChildren = __webpack_require__(499);
var invariant = __webpack_require__(2);

/**
 * Make an update for markup to be rendered and inserted at a supplied index.
 *
 * @param {string} markup Markup that renders into an element.
 * @param {number} toIndex Destination index.
 * @private
 */
function makeInsertMarkup(markup, afterNode, toIndex) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'INSERT_MARKUP',
    content: markup,
    fromIndex: null,
    fromNode: null,
    toIndex: toIndex,
    afterNode: afterNode
  };
}

/**
 * Make an update for moving an existing element to another index.
 *
 * @param {number} fromIndex Source index of the existing element.
 * @param {number} toIndex Destination index of the element.
 * @private
 */
function makeMove(child, afterNode, toIndex) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'MOVE_EXISTING',
    content: null,
    fromIndex: child._mountIndex,
    fromNode: ReactReconciler.getHostNode(child),
    toIndex: toIndex,
    afterNode: afterNode
  };
}

/**
 * Make an update for removing an element at an index.
 *
 * @param {number} fromIndex Index of the element to remove.
 * @private
 */
function makeRemove(child, node) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'REMOVE_NODE',
    content: null,
    fromIndex: child._mountIndex,
    fromNode: node,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Make an update for setting the markup of a node.
 *
 * @param {string} markup Markup that renders into an element.
 * @private
 */
function makeSetMarkup(markup) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'SET_MARKUP',
    content: markup,
    fromIndex: null,
    fromNode: null,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Make an update for setting the text content.
 *
 * @param {string} textContent Text content to set.
 * @private
 */
function makeTextContent(textContent) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'TEXT_CONTENT',
    content: textContent,
    fromIndex: null,
    fromNode: null,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Push an update, if any, onto the queue. Creates a new queue if none is
 * passed and always returns the queue. Mutative.
 */
function enqueue(queue, update) {
  if (update) {
    queue = queue || [];
    queue.push(update);
  }
  return queue;
}

/**
 * Processes any enqueued updates.
 *
 * @private
 */
function processQueue(inst, updateQueue) {
  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
}

var setChildrenForInstrumentation = emptyFunction;
if (process.env.NODE_ENV !== 'production') {
  var getDebugID = function (inst) {
    if (!inst._debugID) {
      // Check for ART-like instances. TODO: This is silly/gross.
      var internal;
      if (internal = ReactInstanceMap.get(inst)) {
        inst = internal;
      }
    }
    return inst._debugID;
  };
  setChildrenForInstrumentation = function (children) {
    var debugID = getDebugID(this);
    // TODO: React Native empty components are also multichild.
    // This means they still get into this method but don't have _debugID.
    if (debugID !== 0) {
      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
        return children[key]._debugID;
      }) : []);
    }
  };
}

/**
 * ReactMultiChild are capable of reconciling multiple children.
 *
 * @class ReactMultiChild
 * @internal
 */
var ReactMultiChild = {
  /**
   * Provides common functionality for components that must reconcile multiple
   * children. This is used by `ReactDOMComponent` to mount, update, and
   * unmount child components.
   *
   * @lends {ReactMultiChild.prototype}
   */
  Mixin: {
    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
      if (process.env.NODE_ENV !== 'production') {
        var selfDebugID = getDebugID(this);
        if (this._currentElement) {
          try {
            ReactCurrentOwner.current = this._currentElement._owner;
            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
          } finally {
            ReactCurrentOwner.current = null;
          }
        }
      }
      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
    },

    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
      var nextChildren;
      var selfDebugID = 0;
      if (process.env.NODE_ENV !== 'production') {
        selfDebugID = getDebugID(this);
        if (this._currentElement) {
          try {
            ReactCurrentOwner.current = this._currentElement._owner;
            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
          } finally {
            ReactCurrentOwner.current = null;
          }
          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
          return nextChildren;
        }
      }
      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
      return nextChildren;
    },

    /**
     * Generates a "mount image" for each of the supplied children. In the case
     * of `ReactDOMComponent`, a mount image is a string of markup.
     *
     * @param {?object} nestedChildren Nested child maps.
     * @return {array} An array of mounted representations.
     * @internal
     */
    mountChildren: function (nestedChildren, transaction, context) {
      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
      this._renderedChildren = children;

      var mountImages = [];
      var index = 0;
      for (var name in children) {
        if (children.hasOwnProperty(name)) {
          var child = children[name];
          var selfDebugID = 0;
          if (process.env.NODE_ENV !== 'production') {
            selfDebugID = getDebugID(this);
          }
          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
          child._mountIndex = index++;
          mountImages.push(mountImage);
        }
      }

      if (process.env.NODE_ENV !== 'production') {
        setChildrenForInstrumentation.call(this, children);
      }

      return mountImages;
    },

    /**
     * Replaces any rendered children with a text content string.
     *
     * @param {string} nextContent String of content.
     * @internal
     */
    updateTextContent: function (nextContent) {
      var prevChildren = this._renderedChildren;
      // Remove any rendered children.
      ReactChildReconciler.unmountChildren(prevChildren, false);
      for (var name in prevChildren) {
        if (prevChildren.hasOwnProperty(name)) {
           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
        }
      }
      // Set new text content.
      var updates = [makeTextContent(nextContent)];
      processQueue(this, updates);
    },

    /**
     * Replaces any rendered children with a markup string.
     *
     * @param {string} nextMarkup String of markup.
     * @internal
     */
    updateMarkup: function (nextMarkup) {
      var prevChildren = this._renderedChildren;
      // Remove any rendered children.
      ReactChildReconciler.unmountChildren(prevChildren, false);
      for (var name in prevChildren) {
        if (prevChildren.hasOwnProperty(name)) {
           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
        }
      }
      var updates = [makeSetMarkup(nextMarkup)];
      processQueue(this, updates);
    },

    /**
     * Updates the rendered children with new children.
     *
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    updateChildren: function (nextNestedChildrenElements, transaction, context) {
      // Hook used by React ART
      this._updateChildren(nextNestedChildrenElements, transaction, context);
    },

    /**
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @final
     * @protected
     */
    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
      var prevChildren = this._renderedChildren;
      var removedNodes = {};
      var mountImages = [];
      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
      if (!nextChildren && !prevChildren) {
        return;
      }
      var updates = null;
      var name;
      // `nextIndex` will increment for each child in `nextChildren`, but
      // `lastIndex` will be the last index visited in `prevChildren`.
      var nextIndex = 0;
      var lastIndex = 0;
      // `nextMountIndex` will increment for each newly mounted child.
      var nextMountIndex = 0;
      var lastPlacedNode = null;
      for (name in nextChildren) {
        if (!nextChildren.hasOwnProperty(name)) {
          continue;
        }
        var prevChild = prevChildren && prevChildren[name];
        var nextChild = nextChildren[name];
        if (prevChild === nextChild) {
          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
          prevChild._mountIndex = nextIndex;
        } else {
          if (prevChild) {
            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
            // The `removedNodes` loop below will actually remove the child.
          }
          // The child must be instantiated before it's mounted.
          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
          nextMountIndex++;
        }
        nextIndex++;
        lastPlacedNode = ReactReconciler.getHostNode(nextChild);
      }
      // Remove children that are no longer present.
      for (name in removedNodes) {
        if (removedNodes.hasOwnProperty(name)) {
          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
        }
      }
      if (updates) {
        processQueue(this, updates);
      }
      this._renderedChildren = nextChildren;

      if (process.env.NODE_ENV !== 'production') {
        setChildrenForInstrumentation.call(this, nextChildren);
      }
    },

    /**
     * Unmounts all rendered children. This should be used to clean up children
     * when this component is unmounted. It does not actually perform any
     * backend operations.
     *
     * @internal
     */
    unmountChildren: function (safely) {
      var renderedChildren = this._renderedChildren;
      ReactChildReconciler.unmountChildren(renderedChildren, safely);
      this._renderedChildren = null;
    },

    /**
     * Moves a child component to the supplied index.
     *
     * @param {ReactComponent} child Component to move.
     * @param {number} toIndex Destination index of the element.
     * @param {number} lastIndex Last index visited of the siblings of `child`.
     * @protected
     */
    moveChild: function (child, afterNode, toIndex, lastIndex) {
      // If the index of `child` is less than `lastIndex`, then it needs to
      // be moved. Otherwise, we do not need to move it because a child will be
      // inserted or moved before `child`.
      if (child._mountIndex < lastIndex) {
        return makeMove(child, afterNode, toIndex);
      }
    },

    /**
     * Creates a child component.
     *
     * @param {ReactComponent} child Component to create.
     * @param {string} mountImage Markup to insert.
     * @protected
     */
    createChild: function (child, afterNode, mountImage) {
      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
    },

    /**
     * Removes a child component.
     *
     * @param {ReactComponent} child Child to remove.
     * @protected
     */
    removeChild: function (child, node) {
      return makeRemove(child, node);
    },

    /**
     * Mounts a child with the supplied name.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to mount.
     * @param {string} name Name of the child.
     * @param {number} index Index at which to insert the child.
     * @param {ReactReconcileTransaction} transaction
     * @private
     */
    _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {
      child._mountIndex = index;
      return this.createChild(child, afterNode, mountImage);
    },

    /**
     * Unmounts a rendered child.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to unmount.
     * @private
     */
    _unmountChild: function (child, node) {
      var update = this.removeChild(child, node);
      child._mountIndex = null;
      return update;
    }
  }
};

module.exports = ReactMultiChild;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 492 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactReconciler = __webpack_require__(64);

var instantiateReactComponent = __webpack_require__(204);
var KeyEscapeUtils = __webpack_require__(138);
var shouldUpdateReactComponent = __webpack_require__(137);
var traverseAllChildren = __webpack_require__(208);
var warning = __webpack_require__(3);

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = __webpack_require__(22);
}

function instantiateChild(childInstances, child, name, selfDebugID) {
  // We found a component instance.
  var keyUnique = childInstances[name] === undefined;
  if (process.env.NODE_ENV !== 'production') {
    if (!ReactComponentTreeHook) {
      ReactComponentTreeHook = __webpack_require__(22);
    }
    if (!keyUnique) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
    }
  }
  if (child != null && keyUnique) {
    childInstances[name] = instantiateReactComponent(child, true);
  }
}

/**
 * ReactChildReconciler provides helpers for initializing or updating a set of
 * children. Its output is suitable for passing it onto ReactMultiChild which
 * does diffed reordering and insertion.
 */
var ReactChildReconciler = {
  /**
   * Generates a "mount image" for each of the supplied children. In the case
   * of `ReactDOMComponent`, a mount image is a string of markup.
   *
   * @param {?object} nestedChildNodes Nested child maps.
   * @return {?object} A set of child instances.
   * @internal
   */
  instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID) // 0 in production and for roots
  {
    if (nestedChildNodes == null) {
      return null;
    }
    var childInstances = {};

    if (process.env.NODE_ENV !== 'production') {
      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
        return instantiateChild(childInsts, child, name, selfDebugID);
      }, childInstances);
    } else {
      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
    }
    return childInstances;
  },

  /**
   * Updates the rendered children and returns a new set of children.
   *
   * @param {?object} prevChildren Previously initialized set of children.
   * @param {?object} nextChildren Flat child element maps.
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @return {?object} A new set of child instances.
   * @internal
   */
  updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID) // 0 in production and for roots
  {
    // We currently don't have a way to track moves here but if we use iterators
    // instead of for..in we can zip the iterators and check if an item has
    // moved.
    // TODO: If nothing has changed, return the prevChildren object so that we
    // can quickly bailout if nothing has changed.
    if (!nextChildren && !prevChildren) {
      return;
    }
    var name;
    var prevChild;
    for (name in nextChildren) {
      if (!nextChildren.hasOwnProperty(name)) {
        continue;
      }
      prevChild = prevChildren && prevChildren[name];
      var prevElement = prevChild && prevChild._currentElement;
      var nextElement = nextChildren[name];
      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
        nextChildren[name] = prevChild;
      } else {
        if (prevChild) {
          removedNodes[name] = ReactReconciler.getHostNode(prevChild);
          ReactReconciler.unmountComponent(prevChild, false);
        }
        // The child must be instantiated before it's mounted.
        var nextChildInstance = instantiateReactComponent(nextElement, true);
        nextChildren[name] = nextChildInstance;
        // Creating mount image now ensures refs are resolved in right order
        // (see https://github.com/facebook/react/pull/7101 for explanation).
        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
        mountImages.push(nextChildMountImage);
      }
    }
    // Unmount children that are no longer present.
    for (name in prevChildren) {
      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
        prevChild = prevChildren[name];
        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
        ReactReconciler.unmountComponent(prevChild, false);
      }
    }
  },

  /**
   * Unmounts all rendered children. This should be used to clean up children
   * when this component is unmounted.
   *
   * @param {?object} renderedChildren Previously initialized set of children.
   * @internal
   */
  unmountChildren: function (renderedChildren, safely) {
    for (var name in renderedChildren) {
      if (renderedChildren.hasOwnProperty(name)) {
        var renderedChild = renderedChildren[name];
        ReactReconciler.unmountComponent(renderedChild, safely);
      }
    }
  }
};

module.exports = ReactChildReconciler;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 493 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(7),
    _assign = __webpack_require__(10);

var React = __webpack_require__(62);
var ReactComponentEnvironment = __webpack_require__(135);
var ReactCurrentOwner = __webpack_require__(37);
var ReactErrorUtils = __webpack_require__(127);
var ReactInstanceMap = __webpack_require__(72);
var ReactInstrumentation = __webpack_require__(27);
var ReactNodeTypes = __webpack_require__(205);
var ReactReconciler = __webpack_require__(64);

if (process.env.NODE_ENV !== 'production') {
  var checkReactTypeSpec = __webpack_require__(494);
}

var emptyObject = __webpack_require__(90);
var invariant = __webpack_require__(2);
var shallowEqual = __webpack_require__(136);
var shouldUpdateReactComponent = __webpack_require__(137);
var warning = __webpack_require__(3);

var CompositeTypes = {
  ImpureClass: 0,
  PureClass: 1,
  StatelessFunctional: 2
};

function StatelessComponent(Component) {}
StatelessComponent.prototype.render = function () {
  var Component = ReactInstanceMap.get(this)._currentElement.type;
  var element = Component(this.props, this.context, this.updater);
  warnIfInvalidElement(Component, element);
  return element;
};

function warnIfInvalidElement(Component, element) {
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(element === null || element === false || React.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
    process.env.NODE_ENV !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
  }
}

function shouldConstruct(Component) {
  return !!(Component.prototype && Component.prototype.isReactComponent);
}

function isPureComponent(Component) {
  return !!(Component.prototype && Component.prototype.isPureReactComponent);
}

// Separated into a function to contain deoptimizations caused by try/finally.
function measureLifeCyclePerf(fn, debugID, timerType) {
  if (debugID === 0) {
    // Top-level wrappers (see ReactMount) and empty components (see
    // ReactDOMEmptyComponent) are invisible to hooks and devtools.
    // Both are implementation details that should go away in the future.
    return fn();
  }

  ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);
  try {
    return fn();
  } finally {
    ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);
  }
}

/**
 * ------------------ The Life-Cycle of a Composite Component ------------------
 *
 * - constructor: Initialization of state. The instance is now retained.
 *   - componentWillMount
 *   - render
 *   - [children's constructors]
 *     - [children's componentWillMount and render]
 *     - [children's componentDidMount]
 *     - componentDidMount
 *
 *       Update Phases:
 *       - componentWillReceiveProps (only called if parent updated)
 *       - shouldComponentUpdate
 *         - componentWillUpdate
 *           - render
 *           - [children's constructors or receive props phases]
 *         - componentDidUpdate
 *
 *     - componentWillUnmount
 *     - [children's componentWillUnmount]
 *   - [children destroyed]
 * - (destroyed): The instance is now blank, released by React and ready for GC.
 *
 * -----------------------------------------------------------------------------
 */

/**
 * An incrementing ID assigned to each component when it is mounted. This is
 * used to enforce the order in which `ReactUpdates` updates dirty components.
 *
 * @private
 */
var nextMountID = 1;

/**
 * @lends {ReactCompositeComponent.prototype}
 */
var ReactCompositeComponent = {
  /**
   * Base constructor for all composite component.
   *
   * @param {ReactElement} element
   * @final
   * @internal
   */
  construct: function (element) {
    this._currentElement = element;
    this._rootNodeID = 0;
    this._compositeType = null;
    this._instance = null;
    this._hostParent = null;
    this._hostContainerInfo = null;

    // See ReactUpdateQueue
    this._updateBatchNumber = null;
    this._pendingElement = null;
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    this._renderedNodeType = null;
    this._renderedComponent = null;
    this._context = null;
    this._mountOrder = 0;
    this._topLevelWrapper = null;

    // See ReactUpdates and ReactUpdateQueue.
    this._pendingCallbacks = null;

    // ComponentWillUnmount shall only be called once
    this._calledComponentWillUnmount = false;

    if (process.env.NODE_ENV !== 'production') {
      this._warnedAboutRefsInRender = false;
    }
  },

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?object} hostParent
   * @param {?object} hostContainerInfo
   * @param {?object} context
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    var _this = this;

    this._context = context;
    this._mountOrder = nextMountID++;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var publicProps = this._currentElement.props;
    var publicContext = this._processContext(context);

    var Component = this._currentElement.type;

    var updateQueue = transaction.getUpdateQueue();

    // Initialize the public class
    var doConstruct = shouldConstruct(Component);
    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
    var renderedElement;

    // Support functional components
    if (!doConstruct && (inst == null || inst.render == null)) {
      renderedElement = inst;
      warnIfInvalidElement(Component, renderedElement);
      !(inst === null || inst === false || React.isValidElement(inst)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
      inst = new StatelessComponent(Component);
      this._compositeType = CompositeTypes.StatelessFunctional;
    } else {
      if (isPureComponent(Component)) {
        this._compositeType = CompositeTypes.PureClass;
      } else {
        this._compositeType = CompositeTypes.ImpureClass;
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      // This will throw later in _renderValidatedComponent, but add an early
      // warning now to help debugging
      if (inst.render == null) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
      }

      var propsMutated = inst.props !== publicProps;
      var componentName = Component.displayName || Component.name || 'Component';

      process.env.NODE_ENV !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", componentName, componentName) : void 0;
    }

    // These should be set up in the constructor, but as a convenience for
    // simpler class abstractions, we set them up after the fact.
    inst.props = publicProps;
    inst.context = publicContext;
    inst.refs = emptyObject;
    inst.updater = updateQueue;

    this._instance = inst;

    // Store a reference from the instance back to the internal representation
    ReactInstanceMap.set(inst, this);

    if (process.env.NODE_ENV !== 'production') {
      // Since plain JS classes are defined without any special initialization
      // logic, we can not catch common errors early. Therefore, we have to
      // catch them here, at initialization time, instead.
      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved || inst.state, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
    }

    var initialState = inst.state;
    if (initialState === undefined) {
      inst.state = initialState = null;
    }
    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;

    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    var markup;
    if (inst.unstable_handleError) {
      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } else {
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    }

    if (inst.componentDidMount) {
      if (process.env.NODE_ENV !== 'production') {
        transaction.getReactMountReady().enqueue(function () {
          measureLifeCyclePerf(function () {
            return inst.componentDidMount();
          }, _this._debugID, 'componentDidMount');
        });
      } else {
        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
      }
    }

    return markup;
  },

  _constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {
    if (process.env.NODE_ENV !== 'production') {
      ReactCurrentOwner.current = this;
      try {
        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
      } finally {
        ReactCurrentOwner.current = null;
      }
    } else {
      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
    }
  },

  _constructComponentWithoutOwner: function (doConstruct, publicProps, publicContext, updateQueue) {
    var Component = this._currentElement.type;

    if (doConstruct) {
      if (process.env.NODE_ENV !== 'production') {
        return measureLifeCyclePerf(function () {
          return new Component(publicProps, publicContext, updateQueue);
        }, this._debugID, 'ctor');
      } else {
        return new Component(publicProps, publicContext, updateQueue);
      }
    }

    // This can still be an instance in case of factory components
    // but we'll count this as time spent rendering as the more common case.
    if (process.env.NODE_ENV !== 'production') {
      return measureLifeCyclePerf(function () {
        return Component(publicProps, publicContext, updateQueue);
      }, this._debugID, 'render');
    } else {
      return Component(publicProps, publicContext, updateQueue);
    }
  },

  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var markup;
    var checkpoint = transaction.checkpoint();
    try {
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } catch (e) {
      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
      transaction.rollback(checkpoint);
      this._instance.unstable_handleError(e);
      if (this._pendingStateQueue) {
        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
      }
      checkpoint = transaction.checkpoint();

      this._renderedComponent.unmountComponent(true);
      transaction.rollback(checkpoint);

      // Try again - we've informed the component about the error, so they can render an error message this time.
      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    }
    return markup;
  },

  performInitialMount: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var inst = this._instance;

    var debugID = 0;
    if (process.env.NODE_ENV !== 'production') {
      debugID = this._debugID;
    }

    if (inst.componentWillMount) {
      if (process.env.NODE_ENV !== 'production') {
        measureLifeCyclePerf(function () {
          return inst.componentWillMount();
        }, debugID, 'componentWillMount');
      } else {
        inst.componentWillMount();
      }
      // When mounting, calls to `setState` by `componentWillMount` will set
      // `this._pendingStateQueue` without triggering a re-render.
      if (this._pendingStateQueue) {
        inst.state = this._processPendingState(inst.props, inst.context);
      }
    }

    // If not a stateless component, we now render
    if (renderedElement === undefined) {
      renderedElement = this._renderValidatedComponent();
    }

    var nodeType = ReactNodeTypes.getType(renderedElement);
    this._renderedNodeType = nodeType;
    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
    );
    this._renderedComponent = child;

    var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);

    if (process.env.NODE_ENV !== 'production') {
      if (debugID !== 0) {
        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
      }
    }

    return markup;
  },

  getHostNode: function () {
    return ReactReconciler.getHostNode(this._renderedComponent);
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function (safely) {
    if (!this._renderedComponent) {
      return;
    }

    var inst = this._instance;

    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
      inst._calledComponentWillUnmount = true;

      if (safely) {
        var name = this.getName() + '.componentWillUnmount()';
        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
      } else {
        if (process.env.NODE_ENV !== 'production') {
          measureLifeCyclePerf(function () {
            return inst.componentWillUnmount();
          }, this._debugID, 'componentWillUnmount');
        } else {
          inst.componentWillUnmount();
        }
      }
    }

    if (this._renderedComponent) {
      ReactReconciler.unmountComponent(this._renderedComponent, safely);
      this._renderedNodeType = null;
      this._renderedComponent = null;
      this._instance = null;
    }

    // Reset pending fields
    // Even if this component is scheduled for another update in ReactUpdates,
    // it would still be ignored because these fields are reset.
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;
    this._pendingCallbacks = null;
    this._pendingElement = null;

    // These fields do not really need to be reset since this object is no
    // longer accessible.
    this._context = null;
    this._rootNodeID = 0;
    this._topLevelWrapper = null;

    // Delete the reference from the instance to this internal representation
    // which allow the internals to be properly cleaned up even if the user
    // leaks a reference to the public instance.
    ReactInstanceMap.remove(inst);

    // Some existing components rely on inst.props even after they've been
    // destroyed (in event handlers).
    // TODO: inst.props = null;
    // TODO: inst.state = null;
    // TODO: inst.context = null;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _maskContext: function (context) {
    var Component = this._currentElement.type;
    var contextTypes = Component.contextTypes;
    if (!contextTypes) {
      return emptyObject;
    }
    var maskedContext = {};
    for (var contextName in contextTypes) {
      maskedContext[contextName] = context[contextName];
    }
    return maskedContext;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`, and asserts that they are valid.
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _processContext: function (context) {
    var maskedContext = this._maskContext(context);
    if (process.env.NODE_ENV !== 'production') {
      var Component = this._currentElement.type;
      if (Component.contextTypes) {
        this._checkContextTypes(Component.contextTypes, maskedContext, 'context');
      }
    }
    return maskedContext;
  },

  /**
   * @param {object} currentContext
   * @return {object}
   * @private
   */
  _processChildContext: function (currentContext) {
    var Component = this._currentElement.type;
    var inst = this._instance;
    var childContext;

    if (inst.getChildContext) {
      if (process.env.NODE_ENV !== 'production') {
        ReactInstrumentation.debugTool.onBeginProcessingChildContext();
        try {
          childContext = inst.getChildContext();
        } finally {
          ReactInstrumentation.debugTool.onEndProcessingChildContext();
        }
      } else {
        childContext = inst.getChildContext();
      }
    }

    if (childContext) {
      !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
      if (process.env.NODE_ENV !== 'production') {
        this._checkContextTypes(Component.childContextTypes, childContext, 'child context');
      }
      for (var name in childContext) {
        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
      }
      return _assign({}, currentContext, childContext);
    }
    return currentContext;
  },

  /**
   * Assert that the context types are valid
   *
   * @param {object} typeSpecs Map of context field to a ReactPropType
   * @param {object} values Runtime values that need to be type-checked
   * @param {string} location e.g. "prop", "context", "child context"
   * @private
   */
  _checkContextTypes: function (typeSpecs, values, location) {
    if (process.env.NODE_ENV !== 'production') {
      checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
    }
  },

  receiveComponent: function (nextElement, transaction, nextContext) {
    var prevElement = this._currentElement;
    var prevContext = this._context;

    this._pendingElement = null;

    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
  },

  /**
   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
   * is set, update the component.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (transaction) {
    if (this._pendingElement != null) {
      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
    } else {
      this._updateBatchNumber = null;
    }
  },

  /**
   * Perform an update to a mounted component. The componentWillReceiveProps and
   * shouldComponentUpdate methods are called, then (assuming the update isn't
   * skipped) the remaining update lifecycle methods are called and the DOM
   * representation is updated.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevParentElement
   * @param {ReactElement} nextParentElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
    var inst = this._instance;
    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;

    var willReceive = false;
    var nextContext;

    // Determine if the context has changed or not
    if (this._context === nextUnmaskedContext) {
      nextContext = inst.context;
    } else {
      nextContext = this._processContext(nextUnmaskedContext);
      willReceive = true;
    }

    var prevProps = prevParentElement.props;
    var nextProps = nextParentElement.props;

    // Not a simple state update but a props update
    if (prevParentElement !== nextParentElement) {
      willReceive = true;
    }

    // An update here will schedule an update but immediately set
    // _pendingStateQueue which will ensure that any state updates gets
    // immediately reconciled instead of waiting for the next batch.
    if (willReceive && inst.componentWillReceiveProps) {
      if (process.env.NODE_ENV !== 'production') {
        measureLifeCyclePerf(function () {
          return inst.componentWillReceiveProps(nextProps, nextContext);
        }, this._debugID, 'componentWillReceiveProps');
      } else {
        inst.componentWillReceiveProps(nextProps, nextContext);
      }
    }

    var nextState = this._processPendingState(nextProps, nextContext);
    var shouldUpdate = true;

    if (!this._pendingForceUpdate) {
      if (inst.shouldComponentUpdate) {
        if (process.env.NODE_ENV !== 'production') {
          shouldUpdate = measureLifeCyclePerf(function () {
            return inst.shouldComponentUpdate(nextProps, nextState, nextContext);
          }, this._debugID, 'shouldComponentUpdate');
        } else {
          shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
        }
      } else {
        if (this._compositeType === CompositeTypes.PureClass) {
          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
        }
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
    }

    this._updateBatchNumber = null;
    if (shouldUpdate) {
      this._pendingForceUpdate = false;
      // Will set `this.props`, `this.state` and `this.context`.
      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
    } else {
      // If it's determined that a component should not update, we still want
      // to set props and state but we shortcut the rest of the update.
      this._currentElement = nextParentElement;
      this._context = nextUnmaskedContext;
      inst.props = nextProps;
      inst.state = nextState;
      inst.context = nextContext;
    }
  },

  _processPendingState: function (props, context) {
    var inst = this._instance;
    var queue = this._pendingStateQueue;
    var replace = this._pendingReplaceState;
    this._pendingReplaceState = false;
    this._pendingStateQueue = null;

    if (!queue) {
      return inst.state;
    }

    if (replace && queue.length === 1) {
      return queue[0];
    }

    var nextState = _assign({}, replace ? queue[0] : inst.state);
    for (var i = replace ? 1 : 0; i < queue.length; i++) {
      var partial = queue[i];
      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
    }

    return nextState;
  },

  /**
   * Merges new props and state, notifies delegate methods of update and
   * performs update.
   *
   * @param {ReactElement} nextElement Next element
   * @param {object} nextProps Next public object to set as properties.
   * @param {?object} nextState Next object to set as state.
   * @param {?object} nextContext Next public object to set as context.
   * @param {ReactReconcileTransaction} transaction
   * @param {?object} unmaskedContext
   * @private
   */
  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
    var _this2 = this;

    var inst = this._instance;

    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
    var prevProps;
    var prevState;
    var prevContext;
    if (hasComponentDidUpdate) {
      prevProps = inst.props;
      prevState = inst.state;
      prevContext = inst.context;
    }

    if (inst.componentWillUpdate) {
      if (process.env.NODE_ENV !== 'production') {
        measureLifeCyclePerf(function () {
          return inst.componentWillUpdate(nextProps, nextState, nextContext);
        }, this._debugID, 'componentWillUpdate');
      } else {
        inst.componentWillUpdate(nextProps, nextState, nextContext);
      }
    }

    this._currentElement = nextElement;
    this._context = unmaskedContext;
    inst.props = nextProps;
    inst.state = nextState;
    inst.context = nextContext;

    this._updateRenderedComponent(transaction, unmaskedContext);

    if (hasComponentDidUpdate) {
      if (process.env.NODE_ENV !== 'production') {
        transaction.getReactMountReady().enqueue(function () {
          measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate');
        });
      } else {
        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
      }
    }
  },

  /**
   * Call the component's `render` method and update the DOM accordingly.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  _updateRenderedComponent: function (transaction, context) {
    var prevComponentInstance = this._renderedComponent;
    var prevRenderedElement = prevComponentInstance._currentElement;
    var nextRenderedElement = this._renderValidatedComponent();

    var debugID = 0;
    if (process.env.NODE_ENV !== 'production') {
      debugID = this._debugID;
    }

    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
    } else {
      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
      ReactReconciler.unmountComponent(prevComponentInstance, false);

      var nodeType = ReactNodeTypes.getType(nextRenderedElement);
      this._renderedNodeType = nodeType;
      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
      );
      this._renderedComponent = child;

      var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);

      if (process.env.NODE_ENV !== 'production') {
        if (debugID !== 0) {
          var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
          ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
        }
      }

      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
    }
  },

  /**
   * Overridden in shallow rendering.
   *
   * @protected
   */
  _replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
    ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
  },

  /**
   * @protected
   */
  _renderValidatedComponentWithoutOwnerOrContext: function () {
    var inst = this._instance;
    var renderedElement;

    if (process.env.NODE_ENV !== 'production') {
      renderedElement = measureLifeCyclePerf(function () {
        return inst.render();
      }, this._debugID, 'render');
    } else {
      renderedElement = inst.render();
    }

    if (process.env.NODE_ENV !== 'production') {
      // We allow auto-mocks to proceed as if they're returning null.
      if (renderedElement === undefined && inst.render._isMockFunction) {
        // This is probably bad practice. Consider warning here and
        // deprecating this convenience.
        renderedElement = null;
      }
    }

    return renderedElement;
  },

  /**
   * @private
   */
  _renderValidatedComponent: function () {
    var renderedElement;
    if (process.env.NODE_ENV !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
      ReactCurrentOwner.current = this;
      try {
        renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
      } finally {
        ReactCurrentOwner.current = null;
      }
    } else {
      renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
    }
    !(
    // TODO: An `isValidNode` function would probably be more appropriate
    renderedElement === null || renderedElement === false || React.isValidElement(renderedElement)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;

    return renderedElement;
  },

  /**
   * Lazily allocates the refs object and stores `component` as `ref`.
   *
   * @param {string} ref Reference name.
   * @param {component} component Component to store as `ref`.
   * @final
   * @private
   */
  attachRef: function (ref, component) {
    var inst = this.getPublicInstance();
    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
    var publicComponentInstance = component.getPublicInstance();
    if (process.env.NODE_ENV !== 'production') {
      var componentName = component && component.getName ? component.getName() : 'a component';
      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
    }
    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
    refs[ref] = publicComponentInstance;
  },

  /**
   * Detaches a reference name.
   *
   * @param {string} ref Name to dereference.
   * @final
   * @private
   */
  detachRef: function (ref) {
    var refs = this.getPublicInstance().refs;
    delete refs[ref];
  },

  /**
   * Get a text description of the component that can be used to identify it
   * in error messages.
   * @return {string} The name or null.
   * @internal
   */
  getName: function () {
    var type = this._currentElement.type;
    var constructor = this._instance && this._instance.constructor;
    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
  },

  /**
   * Get the publicly accessible representation of this component - i.e. what
   * is exposed by refs and returned by render. Can be null for stateless
   * components.
   *
   * @return {ReactComponent} the public component instance.
   * @internal
   */
  getPublicInstance: function () {
    var inst = this._instance;
    if (this._compositeType === CompositeTypes.StatelessFunctional) {
      return null;
    }
    return inst;
  },

  // Stub
  _instantiateReactComponent: null
};

module.exports = ReactCompositeComponent;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 494 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(7);

var ReactPropTypeLocationNames = __webpack_require__(495);
var ReactPropTypesSecret = __webpack_require__(202);

var invariant = __webpack_require__(2);
var warning = __webpack_require__(3);

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = __webpack_require__(22);
}

var loggedTypeFailures = {};

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?object} element The React element that is being type-checked
 * @param {?number} debugID The React component instance that is being type-checked
 * @private
 */
function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
  for (var typeSpecName in typeSpecs) {
    if (typeSpecs.hasOwnProperty(typeSpecName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
      } catch (ex) {
        error = ex;
      }
      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var componentStackInfo = '';

        if (process.env.NODE_ENV !== 'production') {
          if (!ReactComponentTreeHook) {
            ReactComponentTreeHook = __webpack_require__(22);
          }
          if (debugID !== null) {
            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
          } else if (element !== null) {
            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
          }
        }

        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
      }
    }
  }
}

module.exports = checkReactTypeSpec;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 495 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactPropTypeLocationNames = {};

if (process.env.NODE_ENV !== 'production') {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

module.exports = ReactPropTypeLocationNames;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 496 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var nextDebugID = 1;

function getNextDebugID() {
  return nextDebugID++;
}

module.exports = getNextDebugID;

/***/ }),
/* 497 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



// The Symbol used to tag the ReactElement type. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.

var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

module.exports = REACT_ELEMENT_TYPE;

/***/ }),
/* 498 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/* global Symbol */

var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

/**
 * Returns the iterator method function contained on the iterable object.
 *
 * Be sure to invoke the function with the iterable as context:
 *
 *     var iteratorFn = getIteratorFn(myIterable);
 *     if (iteratorFn) {
 *       var iterator = iteratorFn.call(myIterable);
 *       ...
 *     }
 *
 * @param {?object} maybeIterable
 * @return {?function}
 */
function getIteratorFn(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

module.exports = getIteratorFn;

/***/ }),
/* 499 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var KeyEscapeUtils = __webpack_require__(138);
var traverseAllChildren = __webpack_require__(208);
var warning = __webpack_require__(3);

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = __webpack_require__(22);
}

/**
 * @param {function} traverseContext Context passed through traversal.
 * @param {?ReactComponent} child React child component.
 * @param {!string} name String name of key path to child.
 * @param {number=} selfDebugID Optional debugID of the current internal instance.
 */
function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
  // We found a component instance.
  if (traverseContext && typeof traverseContext === 'object') {
    var result = traverseContext;
    var keyUnique = result[name] === undefined;
    if (process.env.NODE_ENV !== 'production') {
      if (!ReactComponentTreeHook) {
        ReactComponentTreeHook = __webpack_require__(22);
      }
      if (!keyUnique) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
      }
    }
    if (keyUnique && child != null) {
      result[name] = child;
    }
  }
}

/**
 * Flattens children that are typically specified as `props.children`. Any null
 * children will not be included in the resulting object.
 * @return {!object} flattened children keyed by name.
 */
function flattenChildren(children, selfDebugID) {
  if (children == null) {
    return children;
  }
  var result = {};

  if (process.env.NODE_ENV !== 'production') {
    traverseAllChildren(children, function (traverseContext, child, name) {
      return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
    }, result);
  } else {
    traverseAllChildren(children, flattenSingleChildIntoContext, result);
  }
  return result;
}

module.exports = flattenChildren;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 500 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(10);

var PooledClass = __webpack_require__(57);
var Transaction = __webpack_require__(92);
var ReactInstrumentation = __webpack_require__(27);
var ReactServerUpdateQueue = __webpack_require__(501);

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [];

if (process.env.NODE_ENV !== 'production') {
  TRANSACTION_WRAPPERS.push({
    initialize: ReactInstrumentation.debugTool.onBeginFlush,
    close: ReactInstrumentation.debugTool.onEndFlush
  });
}

var noopCallbackQueue = {
  enqueue: function () {}
};

/**
 * @class ReactServerRenderingTransaction
 * @param {boolean} renderToStaticMarkup
 */
function ReactServerRenderingTransaction(renderToStaticMarkup) {
  this.reinitializeTransaction();
  this.renderToStaticMarkup = renderToStaticMarkup;
  this.useCreateElement = false;
  this.updateQueue = new ReactServerUpdateQueue(this);
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array} Empty list of operation wrap procedures.
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return noopCallbackQueue;
  },

  /**
   * @return {object} The queue to collect React async events.
   */
  getUpdateQueue: function () {
    return this.updateQueue;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function () {},

  checkpoint: function () {},

  rollback: function () {}
};

_assign(ReactServerRenderingTransaction.prototype, Transaction, Mixin);

PooledClass.addPoolingTo(ReactServerRenderingTransaction);

module.exports = ReactServerRenderingTransaction;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 501 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var ReactUpdateQueue = __webpack_require__(139);

var warning = __webpack_require__(3);

function warnNoop(publicInstance, callerName) {
  if (process.env.NODE_ENV !== 'production') {
    var constructor = publicInstance.constructor;
    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
  }
}

/**
 * This is the update queue used for server rendering.
 * It delegates to ReactUpdateQueue while server rendering is in progress and
 * switches to ReactNoopUpdateQueue after the transaction has completed.
 * @class ReactServerUpdateQueue
 * @param {Transaction} transaction
 */

var ReactServerUpdateQueue = function () {
  function ReactServerUpdateQueue(transaction) {
    _classCallCheck(this, ReactServerUpdateQueue);

    this.transaction = transaction;
  }

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */

  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
    return false;
  };

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */

  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
    }
  };

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */

  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueForceUpdate(publicInstance);
    } else {
      warnNoop(publicInstance, 'forceUpdate');
    }
  };

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object|function} completeState Next state.
   * @internal
   */

  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
    } else {
      warnNoop(publicInstance, 'replaceState');
    }
  };

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object|function} partialState Next partial state to be merged with state.
   * @internal
   */

  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
    } else {
      warnNoop(publicInstance, 'setState');
    }
  };

  return ReactServerUpdateQueue;
}();

module.exports = ReactServerUpdateQueue;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 502 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(10);

var DOMLazyTree = __webpack_require__(65);
var ReactDOMComponentTree = __webpack_require__(14);

var ReactDOMEmptyComponent = function (instantiate) {
  // ReactCompositeComponent uses this:
  this._currentElement = null;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;
  this._hostContainerInfo = null;
  this._domID = 0;
};
_assign(ReactDOMEmptyComponent.prototype, {
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    var domID = hostContainerInfo._idCounter++;
    this._domID = domID;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var nodeValue = ' react-empty: ' + this._domID + ' ';
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var node = ownerDocument.createComment(nodeValue);
      ReactDOMComponentTree.precacheNode(this, node);
      return DOMLazyTree(node);
    } else {
      if (transaction.renderToStaticMarkup) {
        // Normally we'd insert a comment node, but since this is a situation
        // where React won't take over (static pages), we can simply return
        // nothing.
        return '';
      }
      return '<!--' + nodeValue + '-->';
    }
  },
  receiveComponent: function () {},
  getHostNode: function () {
    return ReactDOMComponentTree.getNodeFromInstance(this);
  },
  unmountComponent: function () {
    ReactDOMComponentTree.uncacheNode(this);
  }
});

module.exports = ReactDOMEmptyComponent;

/***/ }),
/* 503 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(7);

var invariant = __webpack_require__(2);

/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */
function getLowestCommonAncestor(instA, instB) {
  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;

  var depthA = 0;
  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
    depthA++;
  }
  var depthB = 0;
  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
    depthB++;
  }

  // If A is deeper, crawl up.
  while (depthA - depthB > 0) {
    instA = instA._hostParent;
    depthA--;
  }

  // If B is deeper, crawl up.
  while (depthB - depthA > 0) {
    instB = instB._hostParent;
    depthB--;
  }

  // Walk in lockstep until we find a match.
  var depth = depthA;
  while (depth--) {
    if (instA === instB) {
      return instA;
    }
    instA = instA._hostParent;
    instB = instB._hostParent;
  }
  return null;
}

/**
 * Return if A is an ancestor of B.
 */
function isAncestor(instA, instB) {
  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;

  while (instB) {
    if (instB === instA) {
      return true;
    }
    instB = instB._hostParent;
  }
  return false;
}

/**
 * Return the parent instance of the passed-in instance.
 */
function getParentInstance(inst) {
  !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;

  return inst._hostParent;
}

/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */
function traverseTwoPhase(inst, fn, arg) {
  var path = [];
  while (inst) {
    path.push(inst);
    inst = inst._hostParent;
  }
  var i;
  for (i = path.length; i-- > 0;) {
    fn(path[i], 'captured', arg);
  }
  for (i = 0; i < path.length; i++) {
    fn(path[i], 'bubbled', arg);
  }
}

/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */
function traverseEnterLeave(from, to, fn, argFrom, argTo) {
  var common = from && to ? getLowestCommonAncestor(from, to) : null;
  var pathFrom = [];
  while (from && from !== common) {
    pathFrom.push(from);
    from = from._hostParent;
  }
  var pathTo = [];
  while (to && to !== common) {
    pathTo.push(to);
    to = to._hostParent;
  }
  var i;
  for (i = 0; i < pathFrom.length; i++) {
    fn(pathFrom[i], 'bubbled', argFrom);
  }
  for (i = pathTo.length; i-- > 0;) {
    fn(pathTo[i], 'captured', argTo);
  }
}

module.exports = {
  isAncestor: isAncestor,
  getLowestCommonAncestor: getLowestCommonAncestor,
  getParentInstance: getParentInstance,
  traverseTwoPhase: traverseTwoPhase,
  traverseEnterLeave: traverseEnterLeave
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 504 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(7),
    _assign = __webpack_require__(10);

var DOMChildrenOperations = __webpack_require__(131);
var DOMLazyTree = __webpack_require__(65);
var ReactDOMComponentTree = __webpack_require__(14);

var escapeTextContentForBrowser = __webpack_require__(95);
var invariant = __webpack_require__(2);
var validateDOMNesting = __webpack_require__(140);

/**
 * Text nodes violate a couple assumptions that React makes about components:
 *
 *  - When mounting text into the DOM, adjacent text nodes are merged.
 *  - Text nodes cannot be assigned a React root ID.
 *
 * This component is used to wrap strings between comment nodes so that they
 * can undergo the same reconciliation that is applied to elements.
 *
 * TODO: Investigate representing React components in the DOM with text nodes.
 *
 * @class ReactDOMTextComponent
 * @extends ReactComponent
 * @internal
 */
var ReactDOMTextComponent = function (text) {
  // TODO: This is really a ReactText (ReactNode), not a ReactElement
  this._currentElement = text;
  this._stringText = '' + text;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;

  // Properties
  this._domID = 0;
  this._mountIndex = 0;
  this._closingComment = null;
  this._commentNodes = null;
};

_assign(ReactDOMTextComponent.prototype, {
  /**
   * Creates the markup for this text node. This node is not intended to have
   * any features besides containing text content.
   *
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {string} Markup for this text node.
   * @internal
   */
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    if (process.env.NODE_ENV !== 'production') {
      var parentInfo;
      if (hostParent != null) {
        parentInfo = hostParent._ancestorInfo;
      } else if (hostContainerInfo != null) {
        parentInfo = hostContainerInfo._ancestorInfo;
      }
      if (parentInfo) {
        // parentInfo should always be present except for the top-level
        // component when server rendering
        validateDOMNesting(null, this._stringText, this, parentInfo);
      }
    }

    var domID = hostContainerInfo._idCounter++;
    var openingValue = ' react-text: ' + domID + ' ';
    var closingValue = ' /react-text ';
    this._domID = domID;
    this._hostParent = hostParent;
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var openingComment = ownerDocument.createComment(openingValue);
      var closingComment = ownerDocument.createComment(closingValue);
      var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
      if (this._stringText) {
        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
      }
      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
      ReactDOMComponentTree.precacheNode(this, openingComment);
      this._closingComment = closingComment;
      return lazyTree;
    } else {
      var escapedText = escapeTextContentForBrowser(this._stringText);

      if (transaction.renderToStaticMarkup) {
        // Normally we'd wrap this between comment nodes for the reasons stated
        // above, but since this is a situation where React won't take over
        // (static pages), we can simply return the text as it is.
        return escapedText;
      }

      return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
    }
  },

  /**
   * Updates this component by updating the text content.
   *
   * @param {ReactText} nextText The next text content
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  receiveComponent: function (nextText, transaction) {
    if (nextText !== this._currentElement) {
      this._currentElement = nextText;
      var nextStringText = '' + nextText;
      if (nextStringText !== this._stringText) {
        // TODO: Save this as pending props and use performUpdateIfNecessary
        // and/or updateComponent to do the actual update for consistency with
        // other component types?
        this._stringText = nextStringText;
        var commentNodes = this.getHostNode();
        DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
      }
    }
  },

  getHostNode: function () {
    var hostNode = this._commentNodes;
    if (hostNode) {
      return hostNode;
    }
    if (!this._closingComment) {
      var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
      var node = openingComment.nextSibling;
      while (true) {
        !(node != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
        if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
          this._closingComment = node;
          break;
        }
        node = node.nextSibling;
      }
    }
    hostNode = [this._hostNode, this._closingComment];
    this._commentNodes = hostNode;
    return hostNode;
  },

  unmountComponent: function () {
    this._closingComment = null;
    this._commentNodes = null;
    ReactDOMComponentTree.uncacheNode(this);
  }
});

module.exports = ReactDOMTextComponent;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 505 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(10);

var ReactUpdates = __webpack_require__(38);
var Transaction = __webpack_require__(92);

var emptyFunction = __webpack_require__(26);

var RESET_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: function () {
    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
  }
};

var FLUSH_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.reinitializeTransaction();
}

_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  }
});

var transaction = new ReactDefaultBatchingStrategyTransaction();

var ReactDefaultBatchingStrategy = {
  isBatchingUpdates: false,

  /**
   * Call the provided function in a context within which calls to `setState`
   * and friends are batched such that components aren't updated unnecessarily.
   */
  batchedUpdates: function (callback, a, b, c, d, e) {
    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      return callback(a, b, c, d, e);
    } else {
      return transaction.perform(callback, null, a, b, c, d, e);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;

/***/ }),
/* 506 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(10);

var EventListener = __webpack_require__(209);
var ExecutionEnvironment = __webpack_require__(16);
var PooledClass = __webpack_require__(57);
var ReactDOMComponentTree = __webpack_require__(14);
var ReactUpdates = __webpack_require__(38);

var getEventTarget = __webpack_require__(128);
var getUnboundedScrollPosition = __webpack_require__(507);

/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */
function findParent(inst) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  while (inst._hostParent) {
    inst = inst._hostParent;
  }
  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
  var container = rootNode.parentNode;
  return ReactDOMComponentTree.getClosestInstanceFromNode(container);
}

// Used to store ancestor hierarchy in top level callback
function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
  this.topLevelType = topLevelType;
  this.nativeEvent = nativeEvent;
  this.ancestors = [];
}
_assign(TopLevelCallbackBookKeeping.prototype, {
  destructor: function () {
    this.topLevelType = null;
    this.nativeEvent = null;
    this.ancestors.length = 0;
  }
});
PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);

function handleTopLevelImpl(bookKeeping) {
  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = targetInst;
  do {
    bookKeeping.ancestors.push(ancestor);
    ancestor = ancestor && findParent(ancestor);
  } while (ancestor);

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

function scrollValueMonitor(cb) {
  var scrollPosition = getUnboundedScrollPosition(window);
  cb(scrollPosition);
}

var ReactEventListener = {
  _enabled: true,
  _handleTopLevel: null,

  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

  setHandleTopLevel: function (handleTopLevel) {
    ReactEventListener._handleTopLevel = handleTopLevel;
  },

  setEnabled: function (enabled) {
    ReactEventListener._enabled = !!enabled;
  },

  isEnabled: function () {
    return ReactEventListener._enabled;
  },

  /**
   * Traps top-level events by using event bubbling.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} element Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapBubbledEvent: function (topLevelType, handlerBaseName, element) {
    if (!element) {
      return null;
    }
    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  /**
   * Traps a top-level event by using event capturing.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} element Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapCapturedEvent: function (topLevelType, handlerBaseName, element) {
    if (!element) {
      return null;
    }
    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  monitorScrollValue: function (refresh) {
    var callback = scrollValueMonitor.bind(null, refresh);
    EventListener.listen(window, 'scroll', callback);
  },

  dispatchEvent: function (topLevelType, nativeEvent) {
    if (!ReactEventListener._enabled) {
      return;
    }

    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
    try {
      // Event queue being processed in the same cycle allows
      // `preventDefault`.
      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
    } finally {
      TopLevelCallbackBookKeeping.release(bookKeeping);
    }
  }
};

module.exports = ReactEventListener;

/***/ }),
/* 507 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */



/**
 * Gets the scroll position of the supplied element or window.
 *
 * The return values are unbounded, unlike `getScrollPosition`. This means they
 * may be negative or exceed the element boundaries (which is possible using
 * inertial scrolling).
 *
 * @param {DOMWindow|DOMElement} scrollable
 * @return {object} Map with `x` and `y` keys.
 */

function getUnboundedScrollPosition(scrollable) {
  if (scrollable.Window && scrollable instanceof scrollable.Window) {
    return {
      x: scrollable.pageXOffset || scrollable.document.documentElement.scrollLeft,
      y: scrollable.pageYOffset || scrollable.document.documentElement.scrollTop
    };
  }
  return {
    x: scrollable.scrollLeft,
    y: scrollable.scrollTop
  };
}

module.exports = getUnboundedScrollPosition;

/***/ }),
/* 508 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMProperty = __webpack_require__(44);
var EventPluginHub = __webpack_require__(70);
var EventPluginUtils = __webpack_require__(126);
var ReactComponentEnvironment = __webpack_require__(135);
var ReactEmptyComponent = __webpack_require__(206);
var ReactBrowserEventEmitter = __webpack_require__(96);
var ReactHostComponent = __webpack_require__(207);
var ReactUpdates = __webpack_require__(38);

var ReactInjection = {
  Component: ReactComponentEnvironment.injection,
  DOMProperty: DOMProperty.injection,
  EmptyComponent: ReactEmptyComponent.injection,
  EventPluginHub: EventPluginHub.injection,
  EventPluginUtils: EventPluginUtils.injection,
  EventEmitter: ReactBrowserEventEmitter.injection,
  HostComponent: ReactHostComponent.injection,
  Updates: ReactUpdates.injection
};

module.exports = ReactInjection;

/***/ }),
/* 509 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(10);

var CallbackQueue = __webpack_require__(193);
var PooledClass = __webpack_require__(57);
var ReactBrowserEventEmitter = __webpack_require__(96);
var ReactInputSelection = __webpack_require__(210);
var ReactInstrumentation = __webpack_require__(27);
var Transaction = __webpack_require__(92);
var ReactUpdateQueue = __webpack_require__(139);

/**
 * Ensures that, when possible, the selection range (currently selected text
 * input) is not disturbed by performing the transaction.
 */
var SELECTION_RESTORATION = {
  /**
   * @return {Selection} Selection information.
   */
  initialize: ReactInputSelection.getSelectionInformation,
  /**
   * @param {Selection} sel Selection information returned from `initialize`.
   */
  close: ReactInputSelection.restoreSelection
};

/**
 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
 * high level DOM manipulations (like temporarily removing a text input from the
 * DOM).
 */
var EVENT_SUPPRESSION = {
  /**
   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
   * the reconciliation.
   */
  initialize: function () {
    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
    ReactBrowserEventEmitter.setEnabled(false);
    return currentlyEnabled;
  },

  /**
   * @param {boolean} previouslyEnabled Enabled status of
   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
   *   restores the previous value.
   */
  close: function (previouslyEnabled) {
    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
  }
};

/**
 * Provides a queue for collecting `componentDidMount` and
 * `componentDidUpdate` callbacks during the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function () {
    this.reactMountReady.reset();
  },

  /**
   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
   */
  close: function () {
    this.reactMountReady.notifyAll();
  }
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

if (process.env.NODE_ENV !== 'production') {
  TRANSACTION_WRAPPERS.push({
    initialize: ReactInstrumentation.debugTool.onBeginFlush,
    close: ReactInstrumentation.debugTool.onEndFlush
  });
}

/**
 * Currently:
 * - The order that these are listed in the transaction is critical:
 * - Suppresses events.
 * - Restores selection range.
 *
 * Future:
 * - Restore document/overflow scroll positions that were unintentionally
 *   modified via DOM insertions above the top viewport boundary.
 * - Implement/integrate with customized constraint based layout system and keep
 *   track of which dimensions must be remeasured.
 *
 * @class ReactReconcileTransaction
 */
function ReactReconcileTransaction(useCreateElement) {
  this.reinitializeTransaction();
  // Only server-side rendering really needs this option (see
  // `ReactServerRendering`), but server-side uses
  // `ReactServerRenderingTransaction` instead. This option is here so that it's
  // accessible and defaults to false when `ReactDOMComponent` and
  // `ReactDOMTextComponent` checks it in `mountComponent`.`
  this.renderToStaticMarkup = false;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.useCreateElement = useCreateElement;
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array<object>} List of operation wrap procedures.
   *   TODO: convert to array<TransactionWrapper>
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return this.reactMountReady;
  },

  /**
   * @return {object} The queue to collect React async events.
   */
  getUpdateQueue: function () {
    return ReactUpdateQueue;
  },

  /**
   * Save current transaction state -- if the return value from this method is
   * passed to `rollback`, the transaction will be reset to that state.
   */
  checkpoint: function () {
    // reactMountReady is the our only stateful wrapper
    return this.reactMountReady.checkpoint();
  },

  rollback: function (checkpoint) {
    this.reactMountReady.rollback(checkpoint);
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function () {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;
  }
};

_assign(ReactReconcileTransaction.prototype, Transaction, Mixin);

PooledClass.addPoolingTo(ReactReconcileTransaction);

module.exports = ReactReconcileTransaction;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 510 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ExecutionEnvironment = __webpack_require__(16);

var getNodeForCharacterOffset = __webpack_require__(511);
var getTextContentAccessor = __webpack_require__(192);

/**
 * While `isCollapsed` is available on the Selection object and `collapsed`
 * is available on the Range object, IE11 sometimes gets them wrong.
 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
 */
function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
  return anchorNode === focusNode && anchorOffset === focusOffset;
}

/**
 * Get the appropriate anchor and focus node/offset pairs for IE.
 *
 * The catch here is that IE's selection API doesn't provide information
 * about whether the selection is forward or backward, so we have to
 * behave as though it's always forward.
 *
 * IE text differs from modern selection in that it behaves as though
 * block elements end with a new line. This means character offsets will
 * differ between the two APIs.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getIEOffsets(node) {
  var selection = document.selection;
  var selectedRange = selection.createRange();
  var selectedLength = selectedRange.text.length;

  // Duplicate selection so we can move range without breaking user selection.
  var fromStart = selectedRange.duplicate();
  fromStart.moveToElementText(node);
  fromStart.setEndPoint('EndToStart', selectedRange);

  var startOffset = fromStart.text.length;
  var endOffset = startOffset + selectedLength;

  return {
    start: startOffset,
    end: endOffset
  };
}

/**
 * @param {DOMElement} node
 * @return {?object}
 */
function getModernOffsets(node) {
  var selection = window.getSelection && window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode;
  var anchorOffset = selection.anchorOffset;
  var focusNode = selection.focusNode;
  var focusOffset = selection.focusOffset;

  var currentRange = selection.getRangeAt(0);

  // In Firefox, range.startContainer and range.endContainer can be "anonymous
  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
  // divs do not seem to expose properties, triggering a "Permission denied
  // error" if any of its properties are accessed. The only seemingly possible
  // way to avoid erroring is to access a property that typically works for
  // non-anonymous divs and catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
  try {
    /* eslint-disable no-unused-expressions */
    currentRange.startContainer.nodeType;
    currentRange.endContainer.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  // If the node and offset values are the same, the selection is collapsed.
  // `Selection.isCollapsed` is available natively, but IE sometimes gets
  // this value wrong.
  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);

  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

  var tempRange = currentRange.cloneRange();
  tempRange.selectNodeContents(node);
  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);

  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
  var end = start + rangeLength;

  // Detect whether the selection is backward.
  var detectionRange = document.createRange();
  detectionRange.setStart(anchorNode, anchorOffset);
  detectionRange.setEnd(focusNode, focusOffset);
  var isBackward = detectionRange.collapsed;

  return {
    start: isBackward ? end : start,
    end: isBackward ? start : end
  };
}

/**
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setIEOffsets(node, offsets) {
  var range = document.selection.createRange().duplicate();
  var start, end;

  if (offsets.end === undefined) {
    start = offsets.start;
    end = start;
  } else if (offsets.start > offsets.end) {
    start = offsets.end;
    end = offsets.start;
  } else {
    start = offsets.start;
    end = offsets.end;
  }

  range.moveToElementText(node);
  range.moveStart('character', start);
  range.setEndPoint('EndToStart', range);
  range.moveEnd('character', end - start);
  range.select();
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setModernOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);

var ReactDOMSelection = {
  /**
   * @param {DOMElement} node
   */
  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

  /**
   * @param {DOMElement|DOMTextNode} node
   * @param {object} offsets
   */
  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
};

module.exports = ReactDOMSelection;

/***/ }),
/* 511 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */

function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === 3) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

module.exports = getNodeForCharacterOffset;

/***/ }),
/* 512 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

var isTextNode = __webpack_require__(513);

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;

/***/ }),
/* 513 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var isNode = __webpack_require__(514);

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;

/***/ }),
/* 514 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */

function isNode(object) {
  var doc = object ? object.ownerDocument || object : document;
  var defaultView = doc.defaultView || window;
  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;

/***/ }),
/* 515 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var NS = {
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace'
};

// We use attributes for everything SVG so let's avoid some duplication and run
// code instead.
// The following are all specified in the HTML config already so we exclude here.
// - class (as className)
// - color
// - height
// - id
// - lang
// - max
// - media
// - method
// - min
// - name
// - style
// - target
// - type
// - width
var ATTRS = {
  accentHeight: 'accent-height',
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 'alignment-baseline',
  allowReorder: 'allowReorder',
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 'arabic-form',
  ascent: 0,
  attributeName: 'attributeName',
  attributeType: 'attributeType',
  autoReverse: 'autoReverse',
  azimuth: 0,
  baseFrequency: 'baseFrequency',
  baseProfile: 'baseProfile',
  baselineShift: 'baseline-shift',
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 'calcMode',
  capHeight: 'cap-height',
  clip: 0,
  clipPath: 'clip-path',
  clipRule: 'clip-rule',
  clipPathUnits: 'clipPathUnits',
  colorInterpolation: 'color-interpolation',
  colorInterpolationFilters: 'color-interpolation-filters',
  colorProfile: 'color-profile',
  colorRendering: 'color-rendering',
  contentScriptType: 'contentScriptType',
  contentStyleType: 'contentStyleType',
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 'diffuseConstant',
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 'dominant-baseline',
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 'edgeMode',
  elevation: 0,
  enableBackground: 'enable-background',
  end: 0,
  exponent: 0,
  externalResourcesRequired: 'externalResourcesRequired',
  fill: 0,
  fillOpacity: 'fill-opacity',
  fillRule: 'fill-rule',
  filter: 0,
  filterRes: 'filterRes',
  filterUnits: 'filterUnits',
  floodColor: 'flood-color',
  floodOpacity: 'flood-opacity',
  focusable: 0,
  fontFamily: 'font-family',
  fontSize: 'font-size',
  fontSizeAdjust: 'font-size-adjust',
  fontStretch: 'font-stretch',
  fontStyle: 'font-style',
  fontVariant: 'font-variant',
  fontWeight: 'font-weight',
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 'glyph-name',
  glyphOrientationHorizontal: 'glyph-orientation-horizontal',
  glyphOrientationVertical: 'glyph-orientation-vertical',
  glyphRef: 'glyphRef',
  gradientTransform: 'gradientTransform',
  gradientUnits: 'gradientUnits',
  hanging: 0,
  horizAdvX: 'horiz-adv-x',
  horizOriginX: 'horiz-origin-x',
  ideographic: 0,
  imageRendering: 'image-rendering',
  'in': 0,
  in2: 0,
  intercept: 0,
  k: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  kernelMatrix: 'kernelMatrix',
  kernelUnitLength: 'kernelUnitLength',
  kerning: 0,
  keyPoints: 'keyPoints',
  keySplines: 'keySplines',
  keyTimes: 'keyTimes',
  lengthAdjust: 'lengthAdjust',
  letterSpacing: 'letter-spacing',
  lightingColor: 'lighting-color',
  limitingConeAngle: 'limitingConeAngle',
  local: 0,
  markerEnd: 'marker-end',
  markerMid: 'marker-mid',
  markerStart: 'marker-start',
  markerHeight: 'markerHeight',
  markerUnits: 'markerUnits',
  markerWidth: 'markerWidth',
  mask: 0,
  maskContentUnits: 'maskContentUnits',
  maskUnits: 'maskUnits',
  mathematical: 0,
  mode: 0,
  numOctaves: 'numOctaves',
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 'overline-position',
  overlineThickness: 'overline-thickness',
  paintOrder: 'paint-order',
  panose1: 'panose-1',
  pathLength: 'pathLength',
  patternContentUnits: 'patternContentUnits',
  patternTransform: 'patternTransform',
  patternUnits: 'patternUnits',
  pointerEvents: 'pointer-events',
  points: 0,
  pointsAtX: 'pointsAtX',
  pointsAtY: 'pointsAtY',
  pointsAtZ: 'pointsAtZ',
  preserveAlpha: 'preserveAlpha',
  preserveAspectRatio: 'preserveAspectRatio',
  primitiveUnits: 'primitiveUnits',
  r: 0,
  radius: 0,
  refX: 'refX',
  refY: 'refY',
  renderingIntent: 'rendering-intent',
  repeatCount: 'repeatCount',
  repeatDur: 'repeatDur',
  requiredExtensions: 'requiredExtensions',
  requiredFeatures: 'requiredFeatures',
  restart: 0,
  result: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  seed: 0,
  shapeRendering: 'shape-rendering',
  slope: 0,
  spacing: 0,
  specularConstant: 'specularConstant',
  specularExponent: 'specularExponent',
  speed: 0,
  spreadMethod: 'spreadMethod',
  startOffset: 'startOffset',
  stdDeviation: 'stdDeviation',
  stemh: 0,
  stemv: 0,
  stitchTiles: 'stitchTiles',
  stopColor: 'stop-color',
  stopOpacity: 'stop-opacity',
  strikethroughPosition: 'strikethrough-position',
  strikethroughThickness: 'strikethrough-thickness',
  string: 0,
  stroke: 0,
  strokeDasharray: 'stroke-dasharray',
  strokeDashoffset: 'stroke-dashoffset',
  strokeLinecap: 'stroke-linecap',
  strokeLinejoin: 'stroke-linejoin',
  strokeMiterlimit: 'stroke-miterlimit',
  strokeOpacity: 'stroke-opacity',
  strokeWidth: 'stroke-width',
  surfaceScale: 'surfaceScale',
  systemLanguage: 'systemLanguage',
  tableValues: 'tableValues',
  targetX: 'targetX',
  targetY: 'targetY',
  textAnchor: 'text-anchor',
  textDecoration: 'text-decoration',
  textRendering: 'text-rendering',
  textLength: 'textLength',
  to: 0,
  transform: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 'underline-position',
  underlineThickness: 'underline-thickness',
  unicode: 0,
  unicodeBidi: 'unicode-bidi',
  unicodeRange: 'unicode-range',
  unitsPerEm: 'units-per-em',
  vAlphabetic: 'v-alphabetic',
  vHanging: 'v-hanging',
  vIdeographic: 'v-ideographic',
  vMathematical: 'v-mathematical',
  values: 0,
  vectorEffect: 'vector-effect',
  version: 0,
  vertAdvY: 'vert-adv-y',
  vertOriginX: 'vert-origin-x',
  vertOriginY: 'vert-origin-y',
  viewBox: 'viewBox',
  viewTarget: 'viewTarget',
  visibility: 0,
  widths: 0,
  wordSpacing: 'word-spacing',
  writingMode: 'writing-mode',
  x: 0,
  xHeight: 'x-height',
  x1: 0,
  x2: 0,
  xChannelSelector: 'xChannelSelector',
  xlinkActuate: 'xlink:actuate',
  xlinkArcrole: 'xlink:arcrole',
  xlinkHref: 'xlink:href',
  xlinkRole: 'xlink:role',
  xlinkShow: 'xlink:show',
  xlinkTitle: 'xlink:title',
  xlinkType: 'xlink:type',
  xmlBase: 'xml:base',
  xmlns: 0,
  xmlnsXlink: 'xmlns:xlink',
  xmlLang: 'xml:lang',
  xmlSpace: 'xml:space',
  y: 0,
  y1: 0,
  y2: 0,
  yChannelSelector: 'yChannelSelector',
  z: 0,
  zoomAndPan: 'zoomAndPan'
};

var SVGDOMPropertyConfig = {
  Properties: {},
  DOMAttributeNamespaces: {
    xlinkActuate: NS.xlink,
    xlinkArcrole: NS.xlink,
    xlinkHref: NS.xlink,
    xlinkRole: NS.xlink,
    xlinkShow: NS.xlink,
    xlinkTitle: NS.xlink,
    xlinkType: NS.xlink,
    xmlBase: NS.xml,
    xmlLang: NS.xml,
    xmlSpace: NS.xml
  },
  DOMAttributeNames: {}
};

Object.keys(ATTRS).forEach(function (key) {
  SVGDOMPropertyConfig.Properties[key] = 0;
  if (ATTRS[key]) {
    SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
  }
});

module.exports = SVGDOMPropertyConfig;

/***/ }),
/* 516 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var EventPropagators = __webpack_require__(69);
var ExecutionEnvironment = __webpack_require__(16);
var ReactDOMComponentTree = __webpack_require__(14);
var ReactInputSelection = __webpack_require__(210);
var SyntheticEvent = __webpack_require__(41);

var getActiveElement = __webpack_require__(211);
var isTextInputElement = __webpack_require__(196);
var shallowEqual = __webpack_require__(136);

var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

var eventTypes = {
  select: {
    phasedRegistrationNames: {
      bubbled: 'onSelect',
      captured: 'onSelectCapture'
    },
    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
  }
};

var activeElement = null;
var activeElementInst = null;
var lastSelection = null;
var mouseDown = false;

// Track whether a listener exists for this plugin. If none exist, we do
// not extract events. See #3639.
var hasListener = false;

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getSelection(node) {
  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (window.getSelection) {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  } else if (document.selection) {
    var range = document.selection.createRange();
    return {
      parentElement: range.parentElement(),
      text: range.text,
      top: range.boundingTop,
      left: range.boundingLeft
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement;

    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {
  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (!hasListener) {
      return null;
    }

    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

    switch (topLevelType) {
      // Track the input node that has focus.
      case 'topFocus':
        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
          activeElement = targetNode;
          activeElementInst = targetInst;
          lastSelection = null;
        }
        break;
      case 'topBlur':
        activeElement = null;
        activeElementInst = null;
        lastSelection = null;
        break;
      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case 'topMouseDown':
        mouseDown = true;
        break;
      case 'topContextMenu':
      case 'topMouseUp':
        mouseDown = false;
        return constructSelectEvent(nativeEvent, nativeEventTarget);
      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't). IE's event fires out of order with respect
      // to key and input events on deletion, so we discard it.
      //
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      // This is also our approach for IE handling, for the reason above.
      case 'topSelectionChange':
        if (skipSelectionChangeEvent) {
          break;
        }
      // falls through
      case 'topKeyDown':
      case 'topKeyUp':
        return constructSelectEvent(nativeEvent, nativeEventTarget);
    }

    return null;
  },

  didPutListener: function (inst, registrationName, listener) {
    if (registrationName === 'onSelect') {
      hasListener = true;
    }
  }
};

module.exports = SelectEventPlugin;

/***/ }),
/* 517 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(7);

var EventListener = __webpack_require__(209);
var EventPropagators = __webpack_require__(69);
var ReactDOMComponentTree = __webpack_require__(14);
var SyntheticAnimationEvent = __webpack_require__(518);
var SyntheticClipboardEvent = __webpack_require__(519);
var SyntheticEvent = __webpack_require__(41);
var SyntheticFocusEvent = __webpack_require__(520);
var SyntheticKeyboardEvent = __webpack_require__(521);
var SyntheticMouseEvent = __webpack_require__(93);
var SyntheticDragEvent = __webpack_require__(523);
var SyntheticTouchEvent = __webpack_require__(524);
var SyntheticTransitionEvent = __webpack_require__(525);
var SyntheticUIEvent = __webpack_require__(71);
var SyntheticWheelEvent = __webpack_require__(526);

var emptyFunction = __webpack_require__(26);
var getEventCharCode = __webpack_require__(141);
var invariant = __webpack_require__(2);

/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: ['topAbort'],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = {
 *   'topAbort': { sameConfig }
 * };
 */
var eventTypes = {};
var topLevelEventsToDispatchConfig = {};
['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'canPlay', 'canPlayThrough', 'click', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
  var onEvent = 'on' + capitalizedEvent;
  var topEvent = 'top' + capitalizedEvent;

  var type = {
    phasedRegistrationNames: {
      bubbled: onEvent,
      captured: onEvent + 'Capture'
    },
    dependencies: [topEvent]
  };
  eventTypes[event] = type;
  topLevelEventsToDispatchConfig[topEvent] = type;
});

var onClickListeners = {};

function getDictionaryKey(inst) {
  // Prevents V8 performance issue:
  // https://github.com/facebook/react/pull/7232
  return '.' + inst._rootNodeID;
}

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

var SimpleEventPlugin = {
  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case 'topAbort':
      case 'topCanPlay':
      case 'topCanPlayThrough':
      case 'topDurationChange':
      case 'topEmptied':
      case 'topEncrypted':
      case 'topEnded':
      case 'topError':
      case 'topInput':
      case 'topInvalid':
      case 'topLoad':
      case 'topLoadedData':
      case 'topLoadedMetadata':
      case 'topLoadStart':
      case 'topPause':
      case 'topPlay':
      case 'topPlaying':
      case 'topProgress':
      case 'topRateChange':
      case 'topReset':
      case 'topSeeked':
      case 'topSeeking':
      case 'topStalled':
      case 'topSubmit':
      case 'topSuspend':
      case 'topTimeUpdate':
      case 'topVolumeChange':
      case 'topWaiting':
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent;
        break;
      case 'topKeyPress':
        // Firefox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if (getEventCharCode(nativeEvent) === 0) {
          return null;
        }
      /* falls through */
      case 'topKeyDown':
      case 'topKeyUp':
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case 'topBlur':
      case 'topFocus':
        EventConstructor = SyntheticFocusEvent;
        break;
      case 'topClick':
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
      /* falls through */
      case 'topDoubleClick':
      case 'topMouseDown':
      case 'topMouseMove':
      case 'topMouseUp':
      // TODO: Disabled elements should not respond to mouse events
      /* falls through */
      case 'topMouseOut':
      case 'topMouseOver':
      case 'topContextMenu':
        EventConstructor = SyntheticMouseEvent;
        break;
      case 'topDrag':
      case 'topDragEnd':
      case 'topDragEnter':
      case 'topDragExit':
      case 'topDragLeave':
      case 'topDragOver':
      case 'topDragStart':
      case 'topDrop':
        EventConstructor = SyntheticDragEvent;
        break;
      case 'topTouchCancel':
      case 'topTouchEnd':
      case 'topTouchMove':
      case 'topTouchStart':
        EventConstructor = SyntheticTouchEvent;
        break;
      case 'topAnimationEnd':
      case 'topAnimationIteration':
      case 'topAnimationStart':
        EventConstructor = SyntheticAnimationEvent;
        break;
      case 'topTransitionEnd':
        EventConstructor = SyntheticTransitionEvent;
        break;
      case 'topScroll':
        EventConstructor = SyntheticUIEvent;
        break;
      case 'topWheel':
        EventConstructor = SyntheticWheelEvent;
        break;
      case 'topCopy':
      case 'topCut':
      case 'topPaste':
        EventConstructor = SyntheticClipboardEvent;
        break;
    }
    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  },

  didPutListener: function (inst, registrationName, listener) {
    // Mobile Safari does not fire properly bubble click events on
    // non-interactive elements, which means delegated click listeners do not
    // fire. The workaround for this bug involves attaching an empty click
    // listener on the target node.
    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
      var key = getDictionaryKey(inst);
      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
      if (!onClickListeners[key]) {
        onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
      }
    }
  },

  willDeleteListener: function (inst, registrationName) {
    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
      var key = getDictionaryKey(inst);
      onClickListeners[key].remove();
      delete onClickListeners[key];
    }
  }
};

module.exports = SimpleEventPlugin;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 518 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticEvent = __webpack_require__(41);

/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */
var AnimationEventInterface = {
  animationName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);

module.exports = SyntheticAnimationEvent;

/***/ }),
/* 519 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticEvent = __webpack_require__(41);

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

module.exports = SyntheticClipboardEvent;

/***/ }),
/* 520 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticUIEvent = __webpack_require__(71);

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

module.exports = SyntheticFocusEvent;

/***/ }),
/* 521 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticUIEvent = __webpack_require__(71);

var getEventCharCode = __webpack_require__(141);
var getEventKey = __webpack_require__(522);
var getEventModifierState = __webpack_require__(130);

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

module.exports = SyntheticKeyboardEvent;

/***/ }),
/* 522 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var getEventCharCode = __webpack_require__(141);

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  Esc: 'Escape',
  Spacebar: ' ',
  Left: 'ArrowLeft',
  Up: 'ArrowUp',
  Right: 'ArrowRight',
  Down: 'ArrowDown',
  Del: 'Delete',
  Win: 'OS',
  Menu: 'ContextMenu',
  Apps: 'ContextMenu',
  Scroll: 'ScrollLock',
  MozPrintableKey: 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  8: 'Backspace',
  9: 'Tab',
  12: 'Clear',
  13: 'Enter',
  16: 'Shift',
  17: 'Control',
  18: 'Alt',
  19: 'Pause',
  20: 'CapsLock',
  27: 'Escape',
  32: ' ',
  33: 'PageUp',
  34: 'PageDown',
  35: 'End',
  36: 'Home',
  37: 'ArrowLeft',
  38: 'ArrowUp',
  39: 'ArrowRight',
  40: 'ArrowDown',
  45: 'Insert',
  46: 'Delete',
  112: 'F1',
  113: 'F2',
  114: 'F3',
  115: 'F4',
  116: 'F5',
  117: 'F6',
  118: 'F7',
  119: 'F8',
  120: 'F9',
  121: 'F10',
  122: 'F11',
  123: 'F12',
  144: 'NumLock',
  145: 'ScrollLock',
  224: 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

module.exports = getEventKey;

/***/ }),
/* 523 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticMouseEvent = __webpack_require__(93);

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

module.exports = SyntheticDragEvent;

/***/ }),
/* 524 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticUIEvent = __webpack_require__(71);

var getEventModifierState = __webpack_require__(130);

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

module.exports = SyntheticTouchEvent;

/***/ }),
/* 525 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticEvent = __webpack_require__(41);

/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */
var TransitionEventInterface = {
  propertyName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);

module.exports = SyntheticTransitionEvent;

/***/ }),
/* 526 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticMouseEvent = __webpack_require__(93);

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

module.exports = SyntheticWheelEvent;

/***/ }),
/* 527 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var validateDOMNesting = __webpack_require__(140);

var DOC_NODE_TYPE = 9;

function ReactDOMContainerInfo(topLevelWrapper, node) {
  var info = {
    _topLevelWrapper: topLevelWrapper,
    _idCounter: 1,
    _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
    _node: node,
    _tag: node ? node.nodeName.toLowerCase() : null,
    _namespaceURI: node ? node.namespaceURI : null
  };
  if (process.env.NODE_ENV !== 'production') {
    info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
  }
  return info;
}

module.exports = ReactDOMContainerInfo;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 528 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactDOMFeatureFlags = {
  useCreateElement: true,
  useFiber: false
};

module.exports = ReactDOMFeatureFlags;

/***/ }),
/* 529 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var adler32 = __webpack_require__(530);

var TAG_END = /\/?>/;
var COMMENT_START = /^<\!\-\-/;

var ReactMarkupChecksum = {
  CHECKSUM_ATTR_NAME: 'data-react-checksum',

  /**
   * @param {string} markup Markup string
   * @return {string} Markup string with checksum attribute attached
   */
  addChecksumToMarkup: function (markup) {
    var checksum = adler32(markup);

    // Add checksum (handle both parent tags, comments and self-closing tags)
    if (COMMENT_START.test(markup)) {
      return markup;
    } else {
      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
    }
  },

  /**
   * @param {string} markup to use
   * @param {DOMElement} element root React element
   * @returns {boolean} whether or not the markup is the same
   */
  canReuseMarkup: function (markup, element) {
    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
    var markupChecksum = adler32(markup);
    return markupChecksum === existingChecksum;
  }
};

module.exports = ReactMarkupChecksum;

/***/ }),
/* 530 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var MOD = 65521;

// adler32 is not cryptographically strong, and is only used to sanity check that
// markup generated on the server matches the markup generated on the client.
// This implementation (a modified version of the SheetJS version) has been optimized
// for our use case, at the expense of conforming to the adler32 specification
// for non-ascii inputs.
function adler32(data) {
  var a = 1;
  var b = 0;
  var i = 0;
  var l = data.length;
  var m = l & ~0x3;
  while (i < m) {
    var n = Math.min(i + 4096, m);
    for (; i < n; i += 4) {
      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
    }
    a %= MOD;
    b %= MOD;
  }
  for (; i < l; i++) {
    b += a += data.charCodeAt(i);
  }
  a %= MOD;
  b %= MOD;
  return a | b << 16;
}

module.exports = adler32;

/***/ }),
/* 531 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



module.exports = '15.6.1';

/***/ }),
/* 532 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(7);

var ReactCurrentOwner = __webpack_require__(37);
var ReactDOMComponentTree = __webpack_require__(14);
var ReactInstanceMap = __webpack_require__(72);

var getHostComponentFromComposite = __webpack_require__(213);
var invariant = __webpack_require__(2);
var warning = __webpack_require__(3);

/**
 * Returns the DOM node rendered by this element.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
 *
 * @param {ReactComponent|DOMElement} componentOrElement
 * @return {?DOMElement} The root node of this element.
 */
function findDOMNode(componentOrElement) {
  if (process.env.NODE_ENV !== 'production') {
    var owner = ReactCurrentOwner.current;
    if (owner !== null) {
      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
      owner._warnedAboutRefsInRender = true;
    }
  }
  if (componentOrElement == null) {
    return null;
  }
  if (componentOrElement.nodeType === 1) {
    return componentOrElement;
  }

  var inst = ReactInstanceMap.get(componentOrElement);
  if (inst) {
    inst = getHostComponentFromComposite(inst);
    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
  }

  if (typeof componentOrElement.render === 'function') {
     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
  } else {
     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
  }
}

module.exports = findDOMNode;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 533 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactMount = __webpack_require__(212);

module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ }),
/* 534 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMProperty = __webpack_require__(44);
var EventPluginRegistry = __webpack_require__(91);
var ReactComponentTreeHook = __webpack_require__(22);

var warning = __webpack_require__(3);

if (process.env.NODE_ENV !== 'production') {
  var reactProps = {
    children: true,
    dangerouslySetInnerHTML: true,
    key: true,
    ref: true,

    autoFocus: true,
    defaultValue: true,
    valueLink: true,
    defaultChecked: true,
    checkedLink: true,
    innerHTML: true,
    suppressContentEditableWarning: true,
    onFocusIn: true,
    onFocusOut: true
  };
  var warnedProperties = {};

  var validateProperty = function (tagName, name, debugID) {
    if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
      return true;
    }
    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
      return true;
    }
    if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
      return true;
    }
    warnedProperties[name] = true;
    var lowerCasedName = name.toLowerCase();

    // data-* attributes should be lowercase; suggest the lowercase version
    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

    var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;

    if (standardName != null) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      return true;
    } else if (registrationName != null) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      return true;
    } else {
      // We were unable to guess which prop the user intended.
      // It is likely that the user was just blindly spreading/forwarding props
      // Components should be careful to only render valid props/attributes.
      // Warning will be invoked in warnUnknownProperties to allow grouping.
      return false;
    }
  };
}

var warnUnknownProperties = function (debugID, element) {
  var unknownProps = [];
  for (var key in element.props) {
    var isValid = validateProperty(element.type, key, debugID);
    if (!isValid) {
      unknownProps.push(key);
    }
  }

  var unknownPropString = unknownProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (unknownProps.length === 1) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  } else if (unknownProps.length > 1) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  }
};

function handleElement(debugID, element) {
  if (element == null || typeof element.type !== 'string') {
    return;
  }
  if (element.type.indexOf('-') >= 0 || element.props.is) {
    return;
  }
  warnUnknownProperties(debugID, element);
}

var ReactDOMUnknownPropertyHook = {
  onBeforeMountComponent: function (debugID, element) {
    handleElement(debugID, element);
  },
  onBeforeUpdateComponent: function (debugID, element) {
    handleElement(debugID, element);
  }
};

module.exports = ReactDOMUnknownPropertyHook;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 535 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactComponentTreeHook = __webpack_require__(22);

var warning = __webpack_require__(3);

var didWarnValueNull = false;

function handleElement(debugID, element) {
  if (element == null) {
    return;
  }
  if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
    return;
  }
  if (element.props != null && element.props.value === null && !didWarnValueNull) {
    process.env.NODE_ENV !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;

    didWarnValueNull = true;
  }
}

var ReactDOMNullInputValuePropHook = {
  onBeforeMountComponent: function (debugID, element) {
    handleElement(debugID, element);
  },
  onBeforeUpdateComponent: function (debugID, element) {
    handleElement(debugID, element);
  }
};

module.exports = ReactDOMNullInputValuePropHook;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 536 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMProperty = __webpack_require__(44);
var ReactComponentTreeHook = __webpack_require__(22);

var warning = __webpack_require__(3);

var warnedProperties = {};
var rARIA = new RegExp('^(aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');

function validateProperty(tagName, name, debugID) {
  if (warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
    return true;
  }

  if (rARIA.test(name)) {
    var lowerCasedName = name.toLowerCase();
    var standardName = DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (standardName == null) {
      warnedProperties[name] = true;
      return false;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== standardName) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown ARIA attribute %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      warnedProperties[name] = true;
      return true;
    }
  }

  return true;
}

function warnInvalidARIAProps(debugID, element) {
  var invalidProps = [];

  for (var key in element.props) {
    var isValid = validateProperty(element.type, key, debugID);
    if (!isValid) {
      invalidProps.push(key);
    }
  }

  var unknownPropString = invalidProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (invalidProps.length === 1) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  } else if (invalidProps.length > 1) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  }
}

function handleElement(debugID, element) {
  if (element == null || typeof element.type !== 'string') {
    return;
  }
  if (element.type.indexOf('-') >= 0 || element.props.is) {
    return;
  }

  warnInvalidARIAProps(debugID, element);
}

var ReactDOMInvalidARIAHook = {
  onBeforeMountComponent: function (debugID, element) {
    if (process.env.NODE_ENV !== 'production') {
      handleElement(debugID, element);
    }
  },
  onBeforeUpdateComponent: function (debugID, element) {
    if (process.env.NODE_ENV !== 'production') {
      handleElement(debugID, element);
    }
  }
};

module.exports = ReactDOMInvalidARIAHook;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 537 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createProvider = createProvider;

var _react = __webpack_require__(88);

var _propTypes = __webpack_require__(142);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _PropTypes = __webpack_require__(215);

var _warning = __webpack_require__(143);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && (typeof call === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var didWarnAboutReceivingStore = false;
function warnAboutReceivingStore() {
  if (didWarnAboutReceivingStore) {
    return;
  }
  didWarnAboutReceivingStore = true;

  (0, _warning2.default)('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');
}

function createProvider() {
  var _Provider$childContex;

  var storeKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'store';
  var subKey = arguments[1];

  var subscriptionKey = subKey || storeKey + 'Subscription';

  var Provider = function (_Component) {
    _inherits(Provider, _Component);

    Provider.prototype.getChildContext = function getChildContext() {
      var _ref;

      return _ref = {}, _ref[storeKey] = this[storeKey], _ref[subscriptionKey] = null, _ref;
    };

    function Provider(props, context) {
      _classCallCheck(this, Provider);

      var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

      _this[storeKey] = props.store;
      return _this;
    }

    Provider.prototype.render = function render() {
      return _react.Children.only(this.props.children);
    };

    return Provider;
  }(_react.Component);

  if (process.env.NODE_ENV !== 'production') {
    Provider.prototype.componentWillReceiveProps = function (nextProps) {
      if (this[storeKey] !== nextProps.store) {
        warnAboutReceivingStore();
      }
    };
  }

  Provider.propTypes = {
    store: _PropTypes.storeShape.isRequired,
    children: _propTypes2.default.element.isRequired
  };
  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[storeKey] = _PropTypes.storeShape.isRequired, _Provider$childContex[subscriptionKey] = _PropTypes.subscriptionShape, _Provider$childContex);

  return Provider;
}

exports.default = createProvider();
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 538 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var emptyFunction = __webpack_require__(26);
var invariant = __webpack_require__(2);
var ReactPropTypesSecret = __webpack_require__(125);

module.exports = function () {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/***/ }),
/* 539 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */


var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
};

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = getPrototypeOf && getPrototypeOf(Object);

module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') {
        // don't hoist over string (html) components

        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try {
                    // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }

        return targetComponent;
    }

    return targetComponent;
};

/***/ }),
/* 540 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function (condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 541 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// encapsulates the subscription logic for connecting a component to the redux store, as
// well as nesting subscriptions of descendant components, so that we can ensure the
// ancestor components re-render before descendants

var CLEARED = null;
var nullListeners = {
  notify: function notify() {}
};

function createListenerCollection() {
  // the current/next pattern is copied from redux's createStore code.
  // TODO: refactor+expose that code to be reusable here?
  var current = [];
  var next = [];

  return {
    clear: function clear() {
      next = CLEARED;
      current = CLEARED;
    },
    notify: function notify() {
      var listeners = current = next;
      for (var i = 0; i < listeners.length; i++) {
        listeners[i]();
      }
    },
    get: function get() {
      return next;
    },
    subscribe: function subscribe(listener) {
      var isSubscribed = true;
      if (next === current) next = current.slice();
      next.push(listener);

      return function unsubscribe() {
        if (!isSubscribed || current === CLEARED) return;
        isSubscribed = false;

        if (next === current) next = current.slice();
        next.splice(next.indexOf(listener), 1);
      };
    }
  };
}

var Subscription = function () {
  function Subscription(store, parentSub, onStateChange) {
    _classCallCheck(this, Subscription);

    this.store = store;
    this.parentSub = parentSub;
    this.onStateChange = onStateChange;
    this.unsubscribe = null;
    this.listeners = nullListeners;
  }

  Subscription.prototype.addNestedSub = function addNestedSub(listener) {
    this.trySubscribe();
    return this.listeners.subscribe(listener);
  };

  Subscription.prototype.notifyNestedSubs = function notifyNestedSubs() {
    this.listeners.notify();
  };

  Subscription.prototype.isSubscribed = function isSubscribed() {
    return Boolean(this.unsubscribe);
  };

  Subscription.prototype.trySubscribe = function trySubscribe() {
    if (!this.unsubscribe) {
      this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.onStateChange) : this.store.subscribe(this.onStateChange);

      this.listeners = createListenerCollection();
    }
  };

  Subscription.prototype.tryUnsubscribe = function tryUnsubscribe() {
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = null;
      this.listeners.clear();
      this.listeners = nullListeners;
    }
  };

  return Subscription;
}();

exports.default = Subscription;

/***/ }),
/* 542 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createConnect = createConnect;

var _connectAdvanced = __webpack_require__(216);

var _connectAdvanced2 = _interopRequireDefault(_connectAdvanced);

var _shallowEqual = __webpack_require__(543);

var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

var _mapDispatchToProps = __webpack_require__(544);

var _mapDispatchToProps2 = _interopRequireDefault(_mapDispatchToProps);

var _mapStateToProps = __webpack_require__(559);

var _mapStateToProps2 = _interopRequireDefault(_mapStateToProps);

var _mergeProps = __webpack_require__(560);

var _mergeProps2 = _interopRequireDefault(_mergeProps);

var _selectorFactory = __webpack_require__(561);

var _selectorFactory2 = _interopRequireDefault(_selectorFactory);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _objectWithoutProperties(obj, keys) {
  var target = {};for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
  }return target;
}

/*
  connect is a facade over connectAdvanced. It turns its args into a compatible
  selectorFactory, which has the signature:

    (dispatch, options) => (nextState, nextOwnProps) => nextFinalProps
  
  connect passes its args to connectAdvanced as options, which will in turn pass them to
  selectorFactory each time a Connect component instance is instantiated or hot reloaded.

  selectorFactory returns a final props selector from its mapStateToProps,
  mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories, mergeProps,
  mergePropsFactories, and pure args.

  The resulting final props selector is called by the Connect component instance whenever
  it receives new props or store state.
 */

function match(arg, factories, name) {
  for (var i = factories.length - 1; i >= 0; i--) {
    var result = factories[i](arg);
    if (result) return result;
  }

  return function (dispatch, options) {
    throw new Error('Invalid value of type ' + typeof arg + ' for ' + name + ' argument when connecting component ' + options.wrappedComponentName + '.');
  };
}

function strictEqual(a, b) {
  return a === b;
}

// createConnect with default args builds the 'official' connect behavior. Calling it with
// different options opens up some testing and extensibility scenarios
function createConnect() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$connectHOC = _ref.connectHOC,
      connectHOC = _ref$connectHOC === undefined ? _connectAdvanced2.default : _ref$connectHOC,
      _ref$mapStateToPropsF = _ref.mapStateToPropsFactories,
      mapStateToPropsFactories = _ref$mapStateToPropsF === undefined ? _mapStateToProps2.default : _ref$mapStateToPropsF,
      _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories,
      mapDispatchToPropsFactories = _ref$mapDispatchToPro === undefined ? _mapDispatchToProps2.default : _ref$mapDispatchToPro,
      _ref$mergePropsFactor = _ref.mergePropsFactories,
      mergePropsFactories = _ref$mergePropsFactor === undefined ? _mergeProps2.default : _ref$mergePropsFactor,
      _ref$selectorFactory = _ref.selectorFactory,
      selectorFactory = _ref$selectorFactory === undefined ? _selectorFactory2.default : _ref$selectorFactory;

  return function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
    var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
        _ref2$pure = _ref2.pure,
        pure = _ref2$pure === undefined ? true : _ref2$pure,
        _ref2$areStatesEqual = _ref2.areStatesEqual,
        areStatesEqual = _ref2$areStatesEqual === undefined ? strictEqual : _ref2$areStatesEqual,
        _ref2$areOwnPropsEqua = _ref2.areOwnPropsEqual,
        areOwnPropsEqual = _ref2$areOwnPropsEqua === undefined ? _shallowEqual2.default : _ref2$areOwnPropsEqua,
        _ref2$areStatePropsEq = _ref2.areStatePropsEqual,
        areStatePropsEqual = _ref2$areStatePropsEq === undefined ? _shallowEqual2.default : _ref2$areStatePropsEq,
        _ref2$areMergedPropsE = _ref2.areMergedPropsEqual,
        areMergedPropsEqual = _ref2$areMergedPropsE === undefined ? _shallowEqual2.default : _ref2$areMergedPropsE,
        extraOptions = _objectWithoutProperties(_ref2, ['pure', 'areStatesEqual', 'areOwnPropsEqual', 'areStatePropsEqual', 'areMergedPropsEqual']);

    var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps');
    var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps');
    var initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps');

    return connectHOC(selectorFactory, _extends({
      // used in error messages
      methodName: 'connect',

      // used to compute Connect's displayName from the wrapped component's displayName.
      getDisplayName: function getDisplayName(name) {
        return 'Connect(' + name + ')';
      },

      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
      shouldHandleStateChanges: Boolean(mapStateToProps),

      // passed through to selectorFactory
      initMapStateToProps: initMapStateToProps,
      initMapDispatchToProps: initMapDispatchToProps,
      initMergeProps: initMergeProps,
      pure: pure,
      areStatesEqual: areStatesEqual,
      areOwnPropsEqual: areOwnPropsEqual,
      areStatePropsEqual: areStatePropsEqual,
      areMergedPropsEqual: areMergedPropsEqual

    }, extraOptions));
  };
}

exports.default = createConnect();

/***/ }),
/* 543 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = shallowEqual;
var hasOwn = Object.prototype.hasOwnProperty;

function is(x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}

function shallowEqual(objA, objB) {
  if (is(objA, objB)) return true;

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) return false;

  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwn.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

/***/ }),
/* 544 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.whenMapDispatchToPropsIsFunction = whenMapDispatchToPropsIsFunction;
exports.whenMapDispatchToPropsIsMissing = whenMapDispatchToPropsIsMissing;
exports.whenMapDispatchToPropsIsObject = whenMapDispatchToPropsIsObject;

var _redux = __webpack_require__(97);

var _wrapMapToProps = __webpack_require__(221);

function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
  return typeof mapDispatchToProps === 'function' ? (0, _wrapMapToProps.wrapMapToPropsFunc)(mapDispatchToProps, 'mapDispatchToProps') : undefined;
}

function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
  return !mapDispatchToProps ? (0, _wrapMapToProps.wrapMapToPropsConstant)(function (dispatch) {
    return { dispatch: dispatch };
  }) : undefined;
}

function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
  return mapDispatchToProps && typeof mapDispatchToProps === 'object' ? (0, _wrapMapToProps.wrapMapToPropsConstant)(function (dispatch) {
    return (0, _redux.bindActionCreators)(mapDispatchToProps, dispatch);
  }) : undefined;
}

exports.default = [whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject];

/***/ }),
/* 545 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Symbol = __webpack_require__(218);

var _Symbol2 = _interopRequireDefault(_Symbol);

var _getRawTag = __webpack_require__(548);

var _getRawTag2 = _interopRequireDefault(_getRawTag);

var _objectToString = __webpack_require__(549);

var _objectToString2 = _interopRequireDefault(_objectToString);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = _Symbol2.default ? _Symbol2.default.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? (0, _getRawTag2.default)(value) : (0, _objectToString2.default)(value);
}

exports.default = baseGetTag;

/***/ }),
/* 546 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _freeGlobal = __webpack_require__(547);

var _freeGlobal2 = _interopRequireDefault(_freeGlobal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = _freeGlobal2.default || freeSelf || Function('return this')();

exports.default = root;

/***/ }),
/* 547 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

exports.default = freeGlobal;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)))

/***/ }),
/* 548 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Symbol = __webpack_require__(218);

var _Symbol2 = _interopRequireDefault(_Symbol);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = _Symbol2.default ? _Symbol2.default.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

exports.default = getRawTag;

/***/ }),
/* 549 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

exports.default = objectToString;

/***/ }),
/* 550 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _overArg = __webpack_require__(551);

var _overArg2 = _interopRequireDefault(_overArg);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Built-in value references. */
var getPrototype = (0, _overArg2.default)(Object.getPrototypeOf, Object);

exports.default = getPrototype;

/***/ }),
/* 551 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

exports.default = overArg;

/***/ }),
/* 552 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

exports.default = isObjectLike;

/***/ }),
/* 553 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(554);

/***/ }),
/* 554 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, module) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ponyfill = __webpack_require__(555);

var _ponyfill2 = _interopRequireDefault(_ponyfill);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { 'default': obj };
}

var root; /* global window */

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (true) {
  root = module;
} else {
  root = Function('return this')();
}

var result = (0, _ponyfill2['default'])(root);
exports['default'] = result;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73), __webpack_require__(146)(module)))

/***/ }),
/* 555 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports['default'] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var _Symbol = root.Symbol;

	if (typeof _Symbol === 'function') {
		if (_Symbol.observable) {
			result = _Symbol.observable;
		} else {
			result = _Symbol('observable');
			_Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};

/***/ }),
/* 556 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = combineReducers;

var _createStore = __webpack_require__(217);

var _isPlainObject = __webpack_require__(144);

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _warning = __webpack_require__(219);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';

  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state. ' + 'If you want this reducer to hold no value, you can return null instead of undefined.';
}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!(0, _isPlainObject2.default)(inputState)) {
    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });

  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });

  if (unexpectedKeys.length > 0) {
    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
  }
}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });

    if (typeof initialState === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined. If you don\'t want to set a value for this reducer, ' + 'you can use null instead of undefined.');
    }

    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
    if (typeof reducer(undefined, { type: type }) === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined, but can be null.');
    }
  });
}

/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};
  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (process.env.NODE_ENV !== 'production') {
      if (typeof reducers[key] === 'undefined') {
        (0, _warning2.default)('No reducer provided for key "' + key + '"');
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }
  var finalReducerKeys = Object.keys(finalReducers);

  var unexpectedKeyCache = void 0;
  if (process.env.NODE_ENV !== 'production') {
    unexpectedKeyCache = {};
  }

  var shapeAssertionError = void 0;
  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var action = arguments[1];

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    if (process.env.NODE_ENV !== 'production') {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
      if (warningMessage) {
        (0, _warning2.default)(warningMessage);
      }
    }

    var hasChanged = false;
    var nextState = {};
    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === 'undefined') {
        var errorMessage = getUndefinedStateErrorMessage(_key, action);
        throw new Error(errorMessage);
      }
      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    return hasChanged ? nextState : state;
  };
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 557 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = bindActionCreators;
function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(undefined, arguments));
  };
}

/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass a single function as the first argument,
 * and get a function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */
function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
  }

  var keys = Object.keys(actionCreators);
  var boundActionCreators = {};
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var actionCreator = actionCreators[key];
    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}

/***/ }),
/* 558 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = applyMiddleware;

var _compose = __webpack_require__(220);

var _compose2 = _interopRequireDefault(_compose);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function (reducer, preloadedState, enhancer) {
      var store = createStore(reducer, preloadedState, enhancer);
      var _dispatch = store.dispatch;
      var chain = [];

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch(action) {
          return _dispatch(action);
        }
      };
      chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = _compose2.default.apply(undefined, chain)(store.dispatch);

      return _extends({}, store, {
        dispatch: _dispatch
      });
    };
  };
}

/***/ }),
/* 559 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.whenMapStateToPropsIsFunction = whenMapStateToPropsIsFunction;
exports.whenMapStateToPropsIsMissing = whenMapStateToPropsIsMissing;

var _wrapMapToProps = __webpack_require__(221);

function whenMapStateToPropsIsFunction(mapStateToProps) {
  return typeof mapStateToProps === 'function' ? (0, _wrapMapToProps.wrapMapToPropsFunc)(mapStateToProps, 'mapStateToProps') : undefined;
}

function whenMapStateToPropsIsMissing(mapStateToProps) {
  return !mapStateToProps ? (0, _wrapMapToProps.wrapMapToPropsConstant)(function () {
    return {};
  }) : undefined;
}

exports.default = [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing];

/***/ }),
/* 560 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultMergeProps = defaultMergeProps;
exports.wrapMergePropsFunc = wrapMergePropsFunc;
exports.whenMergePropsIsFunction = whenMergePropsIsFunction;
exports.whenMergePropsIsOmitted = whenMergePropsIsOmitted;

var _verifyPlainObject = __webpack_require__(222);

var _verifyPlainObject2 = _interopRequireDefault(_verifyPlainObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return _extends({}, ownProps, stateProps, dispatchProps);
}

function wrapMergePropsFunc(mergeProps) {
  return function initMergePropsProxy(dispatch, _ref) {
    var displayName = _ref.displayName,
        pure = _ref.pure,
        areMergedPropsEqual = _ref.areMergedPropsEqual;

    var hasRunOnce = false;
    var mergedProps = void 0;

    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);

      if (hasRunOnce) {
        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
      } else {
        hasRunOnce = true;
        mergedProps = nextMergedProps;

        if (process.env.NODE_ENV !== 'production') (0, _verifyPlainObject2.default)(mergedProps, displayName, 'mergeProps');
      }

      return mergedProps;
    };
  };
}

function whenMergePropsIsFunction(mergeProps) {
  return typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : undefined;
}

function whenMergePropsIsOmitted(mergeProps) {
  return !mergeProps ? function () {
    return defaultMergeProps;
  } : undefined;
}

exports.default = [whenMergePropsIsFunction, whenMergePropsIsOmitted];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 561 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.impureFinalPropsSelectorFactory = impureFinalPropsSelectorFactory;
exports.pureFinalPropsSelectorFactory = pureFinalPropsSelectorFactory;
exports.default = finalPropsSelectorFactory;

var _verifySubselectors = __webpack_require__(562);

var _verifySubselectors2 = _interopRequireDefault(_verifySubselectors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) {
  var target = {};for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
  }return target;
}

function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {
  return function impureFinalPropsSelector(state, ownProps) {
    return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);
  };
}

function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {
  var areStatesEqual = _ref.areStatesEqual,
      areOwnPropsEqual = _ref.areOwnPropsEqual,
      areStatePropsEqual = _ref.areStatePropsEqual;

  var hasRunAtLeastOnce = false;
  var state = void 0;
  var ownProps = void 0;
  var stateProps = void 0;
  var dispatchProps = void 0;
  var mergedProps = void 0;

  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState;
    ownProps = firstOwnProps;
    stateProps = mapStateToProps(state, ownProps);
    dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }

  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps);

    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);

    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewState() {
    var nextStateProps = mapStateToProps(state, ownProps);
    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    stateProps = nextStateProps;

    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);

    return mergedProps;
  }

  function handleSubsequentCalls(nextState, nextOwnProps) {
    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    var stateChanged = !areStatesEqual(nextState, state);
    state = nextState;
    ownProps = nextOwnProps;

    if (propsChanged && stateChanged) return handleNewPropsAndNewState();
    if (propsChanged) return handleNewProps();
    if (stateChanged) return handleNewState();
    return mergedProps;
  }

  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
  };
}

// TODO: Add more comments

// If pure is true, the selector returned by selectorFactory will memoize its results,
// allowing connectAdvanced's shouldComponentUpdate to return false if final
// props have not changed. If false, the selector will always return a new
// object and shouldComponentUpdate will always return true.

function finalPropsSelectorFactory(dispatch, _ref2) {
  var initMapStateToProps = _ref2.initMapStateToProps,
      initMapDispatchToProps = _ref2.initMapDispatchToProps,
      initMergeProps = _ref2.initMergeProps,
      options = _objectWithoutProperties(_ref2, ['initMapStateToProps', 'initMapDispatchToProps', 'initMergeProps']);

  var mapStateToProps = initMapStateToProps(dispatch, options);
  var mapDispatchToProps = initMapDispatchToProps(dispatch, options);
  var mergeProps = initMergeProps(dispatch, options);

  if (process.env.NODE_ENV !== 'production') {
    (0, _verifySubselectors2.default)(mapStateToProps, mapDispatchToProps, mergeProps, options.displayName);
  }

  var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;

  return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 562 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = verifySubselectors;

var _warning = __webpack_require__(143);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function verify(selector, methodName, displayName) {
  if (!selector) {
    throw new Error('Unexpected value for ' + methodName + ' in ' + displayName + '.');
  } else if (methodName === 'mapStateToProps' || methodName === 'mapDispatchToProps') {
    if (!selector.hasOwnProperty('dependsOnOwnProps')) {
      (0, _warning2.default)('The selector for ' + methodName + ' of ' + displayName + ' did not specify a value for dependsOnOwnProps.');
    }
  }
}

function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, displayName) {
  verify(mapStateToProps, 'mapStateToProps', displayName);
  verify(mapDispatchToProps, 'mapDispatchToProps', displayName);
  verify(mergeProps, 'mergeProps', displayName);
}

/***/ }),
/* 563 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _redux = __webpack_require__(97);

var _reduxThunk = __webpack_require__(564);

var _reduxThunk2 = _interopRequireDefault(_reduxThunk);

var _reducers = __webpack_require__(145);

var _reducers2 = _interopRequireDefault(_reducers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const configureStore = preloadedState => {
  const store = (0, _redux.createStore)(_reducers2.default, preloadedState, (0, _redux.applyMiddleware)(_reduxThunk2.default));

  if (true) {
    // Enable Webpack hot module replacement for reducers
    module.hot.accept(145, () => {
      const nextRootReducer = __webpack_require__(145).default;
      store.replaceReducer(nextRootReducer);
    });
  }

  return store;
};

exports.default = configureStore;

/***/ }),
/* 564 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
function createThunkMiddleware(extraArgument) {
  return function (_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return function (next) {
      return function (action) {
        if (typeof action === 'function') {
          return action(dispatch, getState, extraArgument);
        }

        return next(action);
      };
    };
  };
}

var thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;

exports['default'] = thunk;

/***/ }),
/* 565 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _actions = __webpack_require__(223);

const counter = (state = 0, action) => {
  switch (action.type) {
    case _actions.SET_COUNTER:
      return action.playload;
    case _actions.INCREMENT_COUNTER:
      return state + 1;
    case _actions.DECREMENT_COUNTER:
      return state - 1;
    default:
      return state;
  }
};

exports.default = counter;

/***/ }),
/* 566 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _reactRedux = __webpack_require__(214);

var _counter = __webpack_require__(567);

var _counter2 = _interopRequireDefault(_counter);

var _actions = __webpack_require__(223);

var CounterActions = _interopRequireWildcard(_actions);

var _redux = __webpack_require__(97);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const mapStateToProps = state => ({
  counter: state.counter
});

const mapDispatchToProps = dispatch => {
  return (0, _redux.bindActionCreators)(CounterActions, dispatch);
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(_counter2.default);

/***/ }),
/* 567 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(88);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(142);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const Counter = ({ increment, decrement, incrementIfOdd, incrementAsync, counter }) => _react2.default.createElement(
  'p',
  null,
  'Clicked: ',
  counter,
  ' times',
  ' ',
  _react2.default.createElement(
    'button',
    { onClick: increment },
    '+'
  ),
  ' ',
  _react2.default.createElement(
    'button',
    { onClick: decrement },
    '-'
  ),
  ' ',
  _react2.default.createElement(
    'button',
    { onClick: incrementIfOdd },
    'Increment If Odd'
  ),
  ' ',
  _react2.default.createElement(
    'button',
    { onClick: incrementAsync },
    'Increment async'
  )
);

Counter.propTypes = {
  increment: _propTypes2.default.func.isRequired,
  decrement: _propTypes2.default.func.isRequired,
  incrementIfOdd: _propTypes2.default.func.isRequired,
  incrementAsync: _propTypes2.default.func.isRequired,
  counter: _propTypes2.default.number.isRequired
};

exports.default = Counter;

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNWQ0MWQ2ODVjZWVjYzVhNTBiM2QiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9yZWFjdFByb2RJbnZhcmlhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NQ29tcG9uZW50VHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWh0bWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEluc3RydW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmljdC1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1zYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0VXBkYXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tZXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9ET01Qcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZm9yLW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9Qb29sZWRDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctdHJpbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdmFsaWRhdGUtY29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvcmVhY3RQcm9kSW52YXJpYW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0UmVjb25jaWxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9ET01MYXp5VHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9FdmVudFByb3BhZ2F0b3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0V2ZW50UGx1Z2luSHViLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1VJRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RJbnN0YW5jZU1hcC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1yZWdleHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZXRlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWZvcmNlZC1wYW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LWNvbGxlY3Rpb24tb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LWNvbGxlY3Rpb24tZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvcmVhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jYW5EZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRXZlbnRQbHVnaW5SZWdpc3RyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9UcmFuc2FjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNNb3VzZUV2ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL3NldElubmVySFRNTC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWR1eC9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy13cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbmhlcml0LWlmLXJlcXVpcmVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1yZXBlYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1zaWduLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtZXhwbTEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1jb250ZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLWlzLXJlZ2V4cC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1maWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Rhc2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWljcm90YXNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX25ldy1wcm9taXNlLWNhcGFiaWxpdHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYnVmZmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvbG93UHJpb3JpdHlXYXJuaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9FdmVudFBsdWdpblV0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RXJyb3JVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9nZXRFdmVudFRhcmdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9pc0V2ZW50U3VwcG9ydGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2dldEV2ZW50TW9kaWZpZXJTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9ET01DaGlsZHJlbk9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRE9NTmFtZXNwYWNlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9jcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0xpbmtlZFZhbHVlVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0tleUVzY2FwZVV0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0VXBkYXRlUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvdmFsaWRhdGVET01OZXN0aW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2dldEV2ZW50Q2hhckNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovLy8uL2NvbW1vbi9yZWR1Y2Vycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi9odG1sNS1lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYmluZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbnZva2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtaW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWZsb2F0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtbnVtYmVyLXZhbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1sb2cxcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLWZyb3VuZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktcmVkdWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWNvcHktd2l0aGluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuZmxhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcGVyZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9taXNlLXJlc29sdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXdlYWsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb3duLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmxhdHRlbi1pbnRvLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1wYWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXRvLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1mcm9tLWl0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtc2NhbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEJhc2VDbGFzc2VzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3ROb29wVXBkYXRlUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRTeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRJdGVyYXRvckZuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFbGVtZW50VmFsaWRhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01Db21wb25lbnRGbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9hY2N1bXVsYXRlSW50by5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9mb3JFYWNoQWNjdW11bGF0ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZ2V0VGV4dENvbnRlbnRBY2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9DYWxsYmFja1F1ZXVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RmVhdHVyZUZsYWdzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2lucHV0VmFsdWVUcmFja2luZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9pc1RleHRJbnB1dEVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvVmlld3BvcnRNZXRyaWNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL3NldFRleHRDb250ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9mb2N1c05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvQ1NTUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRE9NUHJvcGVydHlPcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NU2VsZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3ROb2RlVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RFbXB0eUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEhvc3RDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdElucHV0U2VsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0TW91bnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy9Qcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2NvbXBvbmVudHMvY29ubmVjdEFkdmFuY2VkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWR1eC9lcy9jcmVhdGVTdG9yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZHV4L2VzL3V0aWxzL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2NvbXBvc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3Qvd3JhcE1hcFRvUHJvcHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0LmpzIiwid2VicGFjazovLy8uL2NvbW1vbi9hY3Rpb25zL2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjayktaG90LW1pZGRsZXdhcmUvY2xpZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHJpcC1hbnNpL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnNpLXJlZ2V4L2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjayktaG90LW1pZGRsZXdhcmUvY2xpZW50LW92ZXJsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fuc2ktaHRtbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIveG1sLWVudGl0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi9odG1sNC1lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWhvdC1taWRkbGV3YXJlL3Byb2Nlc3MtdXBkYXRlLmpzIiwid2VicGFjazovLy8uL2NsaWVudC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcG9seWZpbGwvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL3NoaW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0ta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2VhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLXNlYWxlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zYW1lLXZhbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucGFyc2UtZmxvYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1maXhlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIudG8tcHJlY2lzaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtc2FmZS1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5tYXgtc2FmZS1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1mbG9hdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtaW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYWNvc2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hc2luaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmF0YW5oLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2JydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNsejMyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY29zaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmV4cG0xLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5pbXVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaWduLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2luaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnRhbmguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50cnVuYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yYXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0YXJ0cy13aXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5hbmNob3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJpZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYmxpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJvbGQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZpeGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250Y29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRzaXplLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGFsaWNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5saW5rLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zbWFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RyaWtlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdWIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1cC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLm5vdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1pc28tc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RhdGUtdG8taXNvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kYXRlLXRvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmpvaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc2xpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29tZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5ldmVyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLXJpZ2h0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmluZGV4LW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuY29weS13aXRoaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLXNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5hcnJheS1idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZGF0YS12aWV3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtY2xhbXBlZC1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQxNi1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MzItYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDMyLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQ2NC1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuY29uc3RydWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZW51bWVyYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lmhhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5vd24ta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuZmxhdC1tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuZmxhdHRlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcuYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1sZWZ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLXJpZ2h0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5tYXRjaC1hbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmVudHJpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1nZXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1zZXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1zZXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWFwLnRvLWpzb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc2V0LnRvLWpzb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWFwLm9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC5vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLW1hcC5vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLXNldC5vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAuZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQuZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLW1hcC5mcm9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstc2V0LmZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5c3RlbS5nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuZXJyb3IuaXMtZXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5jbGFtcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmRlZy1wZXItcmFkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguZGVncmVlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmZzY2FsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmlhZGRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaXN1YmguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pbXVsaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnJhZC1wZXItZGVnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGgucmFkaWFucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnNjYWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGgudW11bGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5zaWduYml0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnByb21pc2UuZmluYWxseS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5wcm9taXNlLnRyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlZmluZS1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlbGV0ZS1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1vd24tbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hc2FwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIudGltZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXBvbHlmaWxsL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vcmVnZXhwL2VzY2FwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2NvcmUucmVnZXhwLmVzY2FwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZXBsYWNlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9Qb29sZWRDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL3RyYXZlcnNlQWxsQ2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9LZXlFc2NhcGVVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NRmFjdG9yaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvY2hlY2tSZWFjdFR5cGVTcGVjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RWZXJzaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1yZWFjdC1jbGFzcy9mYWN0b3J5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvb25seUNoaWxkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET00uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3REZWZhdWx0SW5qZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0FSSUFET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9CZWZvcmVJbnB1dEV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0lucHV0RXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvQ2hhbmdlRXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RSZWYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RPd25lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERlYnVnVG9vbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9wZXJmb3JtYW5jZU5vdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvcGVyZm9ybWFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0hUTUxET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9EYW5nZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY3JlYXRlQXJyYXlGcm9tTWl4ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldE1hcmt1cFdyYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01JRE9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01Db21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvQXV0b0ZvY3VzVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvQ1NTUHJvcGVydHlPcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZGFuZ2Vyb3VzU3R5bGVWYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL21lbW9pemVTdHJpbmdPbmx5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL3F1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RXZlbnRFbWl0dGVyTWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01JbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTU9wdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTVRleHRhcmVhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0TXVsdGlDaGlsZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdENoaWxkUmVjb25jaWxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXROZXh0RGVidWdJRC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEVsZW1lbnRTeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZ2V0SXRlcmF0b3JGbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9mbGF0dGVuQ2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NRW1wdHlDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01UcmVlVHJhdmVyc2FsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NVGV4dENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RJbmplY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTVNlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jb250YWluc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2lzVGV4dE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2lzTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TVkdET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TZWxlY3RFdmVudFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TaW1wbGVFdmVudFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNBbmltYXRpb25FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNDbGlwYm9hcmRFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNGb2N1c0V2ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZ2V0RXZlbnRLZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvU3ludGhldGljRHJhZ0V2ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1RvdWNoRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvU3ludGhldGljVHJhbnNpdGlvbkV2ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1doZWVsRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01Db250YWluZXJJbmZvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NRmVhdHVyZUZsYWdzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0TWFya3VwQ2hlY2tzdW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvYWRsZXIzMi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdFZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZmluZERPTU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvcmVuZGVyU3VidHJlZUludG9Db250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTUludmFsaWRBUklBSG9vay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29tcG9uZW50cy9Qcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbnZhcmlhbnQvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvU3Vic2NyaXB0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L2Nvbm5lY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL3NoYWxsb3dFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9tYXBEaXNwYXRjaFRvUHJvcHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldFRhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX29iamVjdFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vdmVyQXJnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3ltYm9sLW9ic2VydmFibGUvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvcG9ueWZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2NvbWJpbmVSZWR1Y2Vycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVkdXgvZXMvYmluZEFjdGlvbkNyZWF0b3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWR1eC9lcy9hcHBseU1pZGRsZXdhcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvbWFwU3RhdGVUb1Byb3BzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L21lcmdlUHJvcHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3Qvc2VsZWN0b3JGYWN0b3J5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L3ZlcmlmeVN1YnNlbGVjdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9jb21tb24vc3RvcmUvY29uZmlndXJlU3RvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZHV4LXRodW5rL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9jb21tb24vcmVkdWNlcnMvY291bnRlci5qcyIsIndlYnBhY2s6Ly8vLi9jb21tb24vY29udGFpbmVycy9BcHAuanMiLCJ3ZWJwYWNrOi8vLy4vY29tbW9uL2NvbXBvbmVudHMvY291bnRlci5qcyJdLCJuYW1lcyI6WyJnbG9iYWwiLCJyZXF1aXJlIiwiY29yZSIsImhpZGUiLCJyZWRlZmluZSIsImN0eCIsIlBST1RPVFlQRSIsIiRleHBvcnQiLCJ0eXBlIiwibmFtZSIsInNvdXJjZSIsIklTX0ZPUkNFRCIsIkYiLCJJU19HTE9CQUwiLCJHIiwiSVNfU1RBVElDIiwiUyIsIklTX1BST1RPIiwiUCIsIklTX0JJTkQiLCJCIiwidGFyZ2V0IiwiZXhwb3J0cyIsImV4cFByb3RvIiwia2V5Iiwib3duIiwib3V0IiwiZXhwIiwidW5kZWZpbmVkIiwiRnVuY3Rpb24iLCJjYWxsIiwiVSIsIlciLCJSIiwibW9kdWxlIiwicHJvY2VzcyIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiRXJyb3IiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImUiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJsZW5ndGgiLCJjb25jYXQiLCJkcmFpblF1ZXVlIiwidGltZW91dCIsImxlbiIsInJ1biIsIm5leHRUaWNrIiwiYXJncyIsIkFycmF5IiwiYXJndW1lbnRzIiwiaSIsInB1c2giLCJJdGVtIiwiYXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwibGlzdGVuZXJzIiwiYmluZGluZyIsImN3ZCIsImNoZGlyIiwiZGlyIiwidW1hc2siLCJ2YWxpZGF0ZUZvcm1hdCIsImZvcm1hdCIsIk5PREVfRU5WIiwiaW52YXJpYW50IiwiY29uZGl0aW9uIiwiYSIsImIiLCJjIiwiZCIsImYiLCJlcnJvciIsImFyZ0luZGV4IiwicmVwbGFjZSIsImZyYW1lc1RvUG9wIiwiZW1wdHlGdW5jdGlvbiIsIndhcm5pbmciLCJwcmludFdhcm5pbmciLCJfbGVuIiwiX2tleSIsIm1lc3NhZ2UiLCJjb25zb2xlIiwieCIsImluZGV4T2YiLCJfbGVuMiIsIl9rZXkyIiwiaXNPYmplY3QiLCJpdCIsIlR5cGVFcnJvciIsIndpbmRvdyIsIk1hdGgiLCJzZWxmIiwiX19nIiwiZXhlYyIsInJlYWN0UHJvZEludmFyaWFudCIsImNvZGUiLCJhcmdDb3VudCIsImFyZ0lkeCIsImVuY29kZVVSSUNvbXBvbmVudCIsInN0b3JlIiwidWlkIiwiU3ltYm9sIiwiVVNFX1NZTUJPTCIsIiRleHBvcnRzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiT2JqZWN0IiwiaGFzT3duUHJvcGVydHkiLCJwcm9wSXNFbnVtZXJhYmxlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJ0b09iamVjdCIsInZhbCIsInNob3VsZFVzZU5hdGl2ZSIsImFzc2lnbiIsInRlc3QxIiwiU3RyaW5nIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInRlc3QyIiwiZnJvbUNoYXJDb2RlIiwib3JkZXIyIiwibWFwIiwibiIsImpvaW4iLCJ0ZXN0MyIsInNwbGl0IiwiZm9yRWFjaCIsImxldHRlciIsImtleXMiLCJlcnIiLCJmcm9tIiwidG8iLCJzeW1ib2xzIiwicyIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiYW5PYmplY3QiLCJJRThfRE9NX0RFRklORSIsInRvUHJpbWl0aXZlIiwiZFAiLCJPIiwiQXR0cmlidXRlcyIsInZhbHVlIiwidG9JbnRlZ2VyIiwibWluIiwiX3Byb2RJbnZhcmlhbnQiLCJET01Qcm9wZXJ0eSIsIlJlYWN0RE9NQ29tcG9uZW50RmxhZ3MiLCJBVFRSX05BTUUiLCJJRF9BVFRSSUJVVEVfTkFNRSIsIkZsYWdzIiwiaW50ZXJuYWxJbnN0YW5jZUtleSIsInJhbmRvbSIsInRvU3RyaW5nIiwic2xpY2UiLCJzaG91bGRQcmVjYWNoZU5vZGUiLCJub2RlIiwibm9kZUlEIiwibm9kZVR5cGUiLCJnZXRBdHRyaWJ1dGUiLCJub2RlVmFsdWUiLCJnZXRSZW5kZXJlZEhvc3RPclRleHRGcm9tQ29tcG9uZW50IiwiY29tcG9uZW50IiwicmVuZGVyZWQiLCJfcmVuZGVyZWRDb21wb25lbnQiLCJwcmVjYWNoZU5vZGUiLCJpbnN0IiwiaG9zdEluc3QiLCJfaG9zdE5vZGUiLCJ1bmNhY2hlTm9kZSIsInByZWNhY2hlQ2hpbGROb2RlcyIsIl9mbGFncyIsImhhc0NhY2hlZENoaWxkTm9kZXMiLCJjaGlsZHJlbiIsIl9yZW5kZXJlZENoaWxkcmVuIiwiY2hpbGROb2RlIiwiZmlyc3RDaGlsZCIsIm91dGVyIiwiY2hpbGRJbnN0IiwiY2hpbGRJRCIsIl9kb21JRCIsIm5leHRTaWJsaW5nIiwiZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUiLCJwYXJlbnRzIiwicGFyZW50Tm9kZSIsImNsb3Nlc3QiLCJwb3AiLCJnZXRJbnN0YW5jZUZyb21Ob2RlIiwiZ2V0Tm9kZUZyb21JbnN0YW5jZSIsIl9ob3N0UGFyZW50IiwiUmVhY3RET01Db21wb25lbnRUcmVlIiwiZGVmaW5lZCIsImNhblVzZURPTSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIkV4ZWN1dGlvbkVudmlyb25tZW50IiwiY2FuVXNlV29ya2VycyIsIldvcmtlciIsImNhblVzZUV2ZW50TGlzdGVuZXJzIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiY2FuVXNlVmlld3BvcnQiLCJzY3JlZW4iLCJpc0luV29ya2VyIiwiY3JlYXRlRGVzYyIsIm9iamVjdCIsImhhcyIsIlNSQyIsIlRPX1NUUklORyIsIiR0b1N0cmluZyIsIlRQTCIsImluc3BlY3RTb3VyY2UiLCJzYWZlIiwiaXNGdW5jdGlvbiIsImZhaWxzIiwicXVvdCIsImNyZWF0ZUhUTUwiLCJzdHJpbmciLCJ0YWciLCJhdHRyaWJ1dGUiLCJwMSIsIk5BTUUiLCJ0ZXN0IiwidG9Mb3dlckNhc2UiLCJSZWFjdEN1cnJlbnRPd25lciIsImlzTmF0aXZlIiwiZm4iLCJmdW5jVG9TdHJpbmciLCJyZUlzTmF0aXZlIiwiUmVnRXhwIiwiY2FuVXNlQ29sbGVjdGlvbnMiLCJNYXAiLCJTZXQiLCJzZXRJdGVtIiwiZ2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJnZXRJdGVtSURzIiwiYWRkUm9vdCIsInJlbW92ZVJvb3QiLCJnZXRSb290SURzIiwiaXRlbU1hcCIsInJvb3RJRFNldCIsImlkIiwiaXRlbSIsInNldCIsImFkZCIsIml0ZW1CeUtleSIsInJvb3RCeUtleSIsImdldEtleUZyb21JRCIsImdldElERnJvbUtleSIsInBhcnNlSW50Iiwic3Vic3RyIiwidW5tb3VudGVkSURzIiwicHVyZ2VEZWVwIiwiY2hpbGRJRHMiLCJkZXNjcmliZUNvbXBvbmVudEZyYW1lIiwib3duZXJOYW1lIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwiZ2V0RGlzcGxheU5hbWUiLCJlbGVtZW50IiwiZGlzcGxheU5hbWUiLCJkZXNjcmliZUlEIiwiUmVhY3RDb21wb25lbnRUcmVlSG9vayIsImdldEVsZW1lbnQiLCJvd25lcklEIiwiZ2V0T3duZXJJRCIsIl9zb3VyY2UiLCJvblNldENoaWxkcmVuIiwibmV4dENoaWxkSURzIiwibmV4dENoaWxkSUQiLCJuZXh0Q2hpbGQiLCJpc01vdW50ZWQiLCJwYXJlbnRJRCIsIm9uQmVmb3JlTW91bnRDb21wb25lbnQiLCJ0ZXh0IiwidXBkYXRlQ291bnQiLCJvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudCIsIm9uTW91bnRDb21wb25lbnQiLCJpc1Jvb3QiLCJvblVwZGF0ZUNvbXBvbmVudCIsIm9uVW5tb3VudENvbXBvbmVudCIsInB1cmdlVW5tb3VudGVkQ29tcG9uZW50cyIsIl9wcmV2ZW50UHVyZ2luZyIsImdldEN1cnJlbnRTdGFja0FkZGVuZHVtIiwidG9wRWxlbWVudCIsImluZm8iLCJvd25lciIsIl9vd25lciIsImdldE5hbWUiLCJjdXJyZW50T3duZXIiLCJjdXJyZW50IiwiX2RlYnVnSUQiLCJnZXRTdGFja0FkZGVuZHVtQnlJRCIsImdldFBhcmVudElEIiwiZ2V0Q2hpbGRJRHMiLCJnZXRTb3VyY2UiLCJnZXRUZXh0IiwiZ2V0VXBkYXRlQ291bnQiLCJnZXRSZWdpc3RlcmVkSURzIiwicHVzaE5vblN0YW5kYXJkV2FybmluZ1N0YWNrIiwiaXNDcmVhdGluZ0VsZW1lbnQiLCJjdXJyZW50U291cmNlIiwicmVhY3RTdGFjayIsInN0YWNrIiwicG9wTm9uU3RhbmRhcmRXYXJuaW5nU3RhY2siLCJyZWFjdFN0YWNrRW5kIiwiSU9iamVjdCIsInBJRSIsInRvSU9iamVjdCIsImdPUEQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJJRV9QUk9UTyIsIk9iamVjdFByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJjb25zdHJ1Y3RvciIsIm1ha2VFbXB0eUZ1bmN0aW9uIiwiYXJnIiwidGhhdFJldHVybnMiLCJ0aGF0UmV0dXJuc0ZhbHNlIiwidGhhdFJldHVybnNUcnVlIiwidGhhdFJldHVybnNOdWxsIiwidGhhdFJldHVybnNUaGlzIiwidGhhdFJldHVybnNBcmd1bWVudCIsImRlYnVnVG9vbCIsIlJlYWN0RGVidWdUb29sIiwiYUZ1bmN0aW9uIiwidGhhdCIsIm1ldGhvZCIsIl9fZSIsInZhbHVlT2YiLCJjZWlsIiwiZmxvb3IiLCJpc05hTiIsIktFWSIsInRvTGVuZ3RoIiwiYXNjIiwiVFlQRSIsIiRjcmVhdGUiLCJJU19NQVAiLCJJU19GSUxURVIiLCJJU19TT01FIiwiSVNfRVZFUlkiLCJJU19GSU5EX0lOREVYIiwiTk9fSE9MRVMiLCJjcmVhdGUiLCIkdGhpcyIsImNhbGxiYWNrZm4iLCJpbmRleCIsInJlc3VsdCIsInJlcyIsIl9hc3NpZ24iLCJDYWxsYmFja1F1ZXVlIiwiUG9vbGVkQ2xhc3MiLCJSZWFjdEZlYXR1cmVGbGFncyIsIlJlYWN0UmVjb25jaWxlciIsIlRyYW5zYWN0aW9uIiwiZGlydHlDb21wb25lbnRzIiwidXBkYXRlQmF0Y2hOdW1iZXIiLCJhc2FwQ2FsbGJhY2tRdWV1ZSIsImdldFBvb2xlZCIsImFzYXBFbnF1ZXVlZCIsImJhdGNoaW5nU3RyYXRlZ3kiLCJlbnN1cmVJbmplY3RlZCIsIlJlYWN0VXBkYXRlcyIsIlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24iLCJORVNURURfVVBEQVRFUyIsImluaXRpYWxpemUiLCJkaXJ0eUNvbXBvbmVudHNMZW5ndGgiLCJjbG9zZSIsInNwbGljZSIsImZsdXNoQmF0Y2hlZFVwZGF0ZXMiLCJVUERBVEVfUVVFVUVJTkciLCJjYWxsYmFja1F1ZXVlIiwicmVzZXQiLCJub3RpZnlBbGwiLCJUUkFOU0FDVElPTl9XUkFQUEVSUyIsIlJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24iLCJyZWluaXRpYWxpemVUcmFuc2FjdGlvbiIsInJlY29uY2lsZVRyYW5zYWN0aW9uIiwiZ2V0VHJhbnNhY3Rpb25XcmFwcGVycyIsImRlc3RydWN0b3IiLCJyZWxlYXNlIiwicGVyZm9ybSIsInNjb3BlIiwiYWRkUG9vbGluZ1RvIiwiYmF0Y2hlZFVwZGF0ZXMiLCJjYWxsYmFjayIsIm1vdW50T3JkZXJDb21wYXJhdG9yIiwiYzEiLCJjMiIsIl9tb3VudE9yZGVyIiwicnVuQmF0Y2hlZFVwZGF0ZXMiLCJ0cmFuc2FjdGlvbiIsInNvcnQiLCJjYWxsYmFja3MiLCJfcGVuZGluZ0NhbGxiYWNrcyIsIm1hcmtlck5hbWUiLCJsb2dUb3BMZXZlbFJlbmRlcnMiLCJuYW1lZENvbXBvbmVudCIsIl9jdXJyZW50RWxlbWVudCIsImlzUmVhY3RUb3BMZXZlbFdyYXBwZXIiLCJ0aW1lIiwicGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5IiwidGltZUVuZCIsImoiLCJlbnF1ZXVlIiwiZ2V0UHVibGljSW5zdGFuY2UiLCJlbnF1ZXVlVXBkYXRlIiwiaXNCYXRjaGluZ1VwZGF0ZXMiLCJfdXBkYXRlQmF0Y2hOdW1iZXIiLCJhc2FwIiwiY29udGV4dCIsIlJlYWN0VXBkYXRlc0luamVjdGlvbiIsImluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uIiwiUmVjb25jaWxlVHJhbnNhY3Rpb24iLCJpbmplY3RCYXRjaGluZ1N0cmF0ZWd5IiwiX2JhdGNoaW5nU3RyYXRlZ3kiLCJpbmplY3Rpb24iLCJMSUJSQVJZIiwiJHR5cGVkIiwiJGJ1ZmZlciIsImFuSW5zdGFuY2UiLCJwcm9wZXJ0eURlc2MiLCJyZWRlZmluZUFsbCIsInRvSW5kZXgiLCJ0b0Fic29sdXRlSW5kZXgiLCJjbGFzc29mIiwiaXNBcnJheUl0ZXIiLCJnT1BOIiwiZ2V0SXRlckZuIiwid2tzIiwiY3JlYXRlQXJyYXlNZXRob2QiLCJjcmVhdGVBcnJheUluY2x1ZGVzIiwic3BlY2llc0NvbnN0cnVjdG9yIiwiQXJyYXlJdGVyYXRvcnMiLCJJdGVyYXRvcnMiLCIkaXRlckRldGVjdCIsInNldFNwZWNpZXMiLCJhcnJheUZpbGwiLCJhcnJheUNvcHlXaXRoaW4iLCIkRFAiLCIkR09QRCIsIlJhbmdlRXJyb3IiLCJVaW50OEFycmF5IiwiQVJSQVlfQlVGRkVSIiwiU0hBUkVEX0JVRkZFUiIsIkJZVEVTX1BFUl9FTEVNRU5UIiwiQXJyYXlQcm90byIsIiRBcnJheUJ1ZmZlciIsIkFycmF5QnVmZmVyIiwiJERhdGFWaWV3IiwiRGF0YVZpZXciLCJhcnJheUZvckVhY2giLCJhcnJheUZpbHRlciIsImFycmF5U29tZSIsImFycmF5RXZlcnkiLCJhcnJheUZpbmQiLCJhcnJheUZpbmRJbmRleCIsImFycmF5SW5jbHVkZXMiLCJhcnJheUluZGV4T2YiLCJhcnJheVZhbHVlcyIsInZhbHVlcyIsImFycmF5S2V5cyIsImFycmF5RW50cmllcyIsImVudHJpZXMiLCJhcnJheUxhc3RJbmRleE9mIiwibGFzdEluZGV4T2YiLCJhcnJheVJlZHVjZSIsInJlZHVjZSIsImFycmF5UmVkdWNlUmlnaHQiLCJyZWR1Y2VSaWdodCIsImFycmF5Sm9pbiIsImFycmF5U29ydCIsImFycmF5U2xpY2UiLCJhcnJheVRvU3RyaW5nIiwiYXJyYXlUb0xvY2FsZVN0cmluZyIsInRvTG9jYWxlU3RyaW5nIiwiSVRFUkFUT1IiLCJUQUciLCJUWVBFRF9DT05TVFJVQ1RPUiIsIkRFRl9DT05TVFJVQ1RPUiIsIkFMTF9DT05TVFJVQ1RPUlMiLCJDT05TVFIiLCJUWVBFRF9BUlJBWSIsIlRZUEVEIiwiVklFVyIsIldST05HX0xFTkdUSCIsIiRtYXAiLCJhbGxvY2F0ZSIsIkxJVFRMRV9FTkRJQU4iLCJVaW50MTZBcnJheSIsImJ1ZmZlciIsIkZPUkNFRF9TRVQiLCJ0b09mZnNldCIsIkJZVEVTIiwib2Zmc2V0IiwidmFsaWRhdGUiLCJDIiwic3BlY2llc0Zyb21MaXN0IiwibGlzdCIsImZyb21MaXN0IiwiYWRkR2V0dGVyIiwiaW50ZXJuYWwiLCJfZCIsIiRmcm9tIiwiYUxlbiIsIm1hcGZuIiwibWFwcGluZyIsIml0ZXJGbiIsInN0ZXAiLCJpdGVyYXRvciIsIm5leHQiLCJkb25lIiwiJG9mIiwib2YiLCJUT19MT0NBTEVfQlVHIiwiJHRvTG9jYWxlU3RyaW5nIiwicHJvdG8iLCJjb3B5V2l0aGluIiwic3RhcnQiLCJldmVyeSIsImZpbGwiLCJmaWx0ZXIiLCJmaW5kIiwicHJlZGljYXRlIiwiZmluZEluZGV4Iiwic2VhcmNoRWxlbWVudCIsImluY2x1ZGVzIiwic2VwYXJhdG9yIiwicmV2ZXJzZSIsIm1pZGRsZSIsInNvbWUiLCJjb21wYXJlZm4iLCJzdWJhcnJheSIsImJlZ2luIiwiZW5kIiwiJGJlZ2luIiwiYnl0ZU9mZnNldCIsIiRzbGljZSIsIiRzZXQiLCJhcnJheUxpa2UiLCJzcmMiLCIkaXRlcmF0b3JzIiwiaXNUQUluZGV4IiwiJGdldERlc2MiLCIkc2V0RGVzYyIsImRlc2MiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImVudW1lcmFibGUiLCIkVHlwZWRBcnJheVByb3RvdHlwZSQiLCJ3cmFwcGVyIiwiQ0xBTVBFRCIsIkdFVFRFUiIsIlNFVFRFUiIsIlR5cGVkQXJyYXkiLCJCYXNlIiwiVEFDIiwiRk9SQ0VEIiwiQUJWIiwiVHlwZWRBcnJheVByb3RvdHlwZSIsImdldHRlciIsImRhdGEiLCJ2IiwibyIsInNldHRlciIsInJvdW5kIiwiYWRkRWxlbWVudCIsIiRvZmZzZXQiLCIkbGVuZ3RoIiwiYnl0ZUxlbmd0aCIsImtsYXNzIiwiJGxlbiIsImwiLCJpdGVyIiwiJG5hdGl2ZUl0ZXJhdG9yIiwiQ09SUkVDVF9JVEVSX05BTUUiLCIkaXRlcmF0b3IiLCJzaGFyZWQiLCJnZXRPckNyZWF0ZU1ldGFkYXRhTWFwIiwidGFyZ2V0S2V5IiwidGFyZ2V0TWV0YWRhdGEiLCJrZXlNZXRhZGF0YSIsIm9yZGluYXJ5SGFzT3duTWV0YWRhdGEiLCJNZXRhZGF0YUtleSIsIm1ldGFkYXRhTWFwIiwib3JkaW5hcnlHZXRPd25NZXRhZGF0YSIsIm9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEiLCJNZXRhZGF0YVZhbHVlIiwib3JkaW5hcnlPd25NZXRhZGF0YUtleXMiLCJfIiwidG9NZXRhS2V5IiwiZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkiLCJpc1Byb3h5U3VwcG9ydGVkIiwiUHJveHkiLCJzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcyIsIkV2ZW50SW50ZXJmYWNlIiwiY3VycmVudFRhcmdldCIsImV2ZW50UGhhc2UiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsInRpbWVTdGFtcCIsImV2ZW50IiwiRGF0ZSIsIm5vdyIsImRlZmF1bHRQcmV2ZW50ZWQiLCJpc1RydXN0ZWQiLCJTeW50aGV0aWNFdmVudCIsImRpc3BhdGNoQ29uZmlnIiwidGFyZ2V0SW5zdCIsIm5hdGl2ZUV2ZW50IiwibmF0aXZlRXZlbnRUYXJnZXQiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsIl90YXJnZXRJbnN0IiwiSW50ZXJmYWNlIiwicHJvcE5hbWUiLCJub3JtYWxpemUiLCJyZXR1cm5WYWx1ZSIsImlzRGVmYXVsdFByZXZlbnRlZCIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwiY2FuY2VsQnViYmxlIiwicGVyc2lzdCIsImlzUGVyc2lzdGVudCIsImdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24iLCJjb25zdHJ1Y3QiLCJwcm9wIiwiYXVnbWVudENsYXNzIiwiQ2xhc3MiLCJTdXBlciIsIkUiLCJmb3VyQXJndW1lbnRQb29sZXIiLCJnZXRWYWwiLCJhY3Rpb24iLCJ3YXJuIiwid2FybmluZ0NvbmRpdGlvbiIsIk1FVEEiLCJzZXREZXNjIiwiaXNFeHRlbnNpYmxlIiwiRlJFRVpFIiwicHJldmVudEV4dGVuc2lvbnMiLCJzZXRNZXRhIiwidyIsImZhc3RLZXkiLCJnZXRXZWFrIiwib25GcmVlemUiLCJtZXRhIiwiTkVFRCIsIlVOU0NPUEFCTEVTIiwiY2hlY2tNYXNrIiwiYml0bWFzayIsIkRPTVByb3BlcnR5SW5qZWN0aW9uIiwiTVVTVF9VU0VfUFJPUEVSVFkiLCJIQVNfQk9PTEVBTl9WQUxVRSIsIkhBU19OVU1FUklDX1ZBTFVFIiwiSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUiLCJIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFIiwiaW5qZWN0RE9NUHJvcGVydHlDb25maWciLCJkb21Qcm9wZXJ0eUNvbmZpZyIsIkluamVjdGlvbiIsIlByb3BlcnRpZXMiLCJET01BdHRyaWJ1dGVOYW1lc3BhY2VzIiwiRE9NQXR0cmlidXRlTmFtZXMiLCJET01Qcm9wZXJ0eU5hbWVzIiwiRE9NTXV0YXRpb25NZXRob2RzIiwiaXNDdXN0b21BdHRyaWJ1dGUiLCJfaXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMiLCJwcm9wZXJ0aWVzIiwibG93ZXJDYXNlZCIsInByb3BDb25maWciLCJwcm9wZXJ0eUluZm8iLCJhdHRyaWJ1dGVOYW1lIiwiYXR0cmlidXRlTmFtZXNwYWNlIiwicHJvcGVydHlOYW1lIiwibXV0YXRpb25NZXRob2QiLCJtdXN0VXNlUHJvcGVydHkiLCJoYXNCb29sZWFuVmFsdWUiLCJoYXNOdW1lcmljVmFsdWUiLCJoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSIsImhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUiLCJnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZSIsIkFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIiLCJST09UX0FUVFJJQlVURV9OQU1FIiwiQVRUUklCVVRFX05BTUVfQ0hBUiIsImF1dG9mb2N1cyIsImlzQ3VzdG9tQXR0cmlidXRlRm4iLCJiaXRtYXAiLCJweCIsIiRrZXlzIiwiZW51bUJ1Z0tleXMiLCJtYXgiLCJkUHMiLCJFbXB0eSIsImNyZWF0ZURpY3QiLCJpZnJhbWUiLCJsdCIsImd0IiwiaWZyYW1lRG9jdW1lbnQiLCJzdHlsZSIsImRpc3BsYXkiLCJhcHBlbmRDaGlsZCIsImNvbnRlbnRXaW5kb3ciLCJvcGVuIiwid3JpdGUiLCJoaWRkZW5LZXlzIiwiREVTQ1JJUFRPUlMiLCJTUEVDSUVTIiwiQ29uc3RydWN0b3IiLCJmb3JiaWRkZW5GaWVsZCIsIkJSRUFLIiwiUkVUVVJOIiwiaXRlcmFibGUiLCJjYW5EZWZpbmVQcm9wZXJ0eSIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlJFU0VSVkVEX1BST1BTIiwicmVmIiwiX19zZWxmIiwiX19zb3VyY2UiLCJzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biIsInNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5IiwiZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIiLCJwcm9wcyIsIndhcm5BYm91dEFjY2Vzc2luZ0tleSIsImRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nUmVmIiwiUmVhY3RFbGVtZW50IiwiJCR0eXBlb2YiLCJfc3RvcmUiLCJ2YWxpZGF0ZWQiLCJfc2VsZiIsImZyZWV6ZSIsImNoaWxkcmVuTGVuZ3RoIiwiY2hpbGRBcnJheSIsImRlZmF1bHRQcm9wcyIsImNyZWF0ZUZhY3RvcnkiLCJmYWN0b3J5IiwiYmluZCIsImNsb25lQW5kUmVwbGFjZUtleSIsIm9sZEVsZW1lbnQiLCJuZXdLZXkiLCJuZXdFbGVtZW50IiwiY2xvbmVFbGVtZW50IiwiaXNWYWxpZEVsZW1lbnQiLCJvbmVBcmd1bWVudFBvb2xlciIsImNvcHlGaWVsZHNGcm9tIiwiS2xhc3MiLCJpbnN0YW5jZVBvb2wiLCJpbnN0YW5jZSIsInR3b0FyZ3VtZW50UG9vbGVyIiwiYTEiLCJhMiIsInRocmVlQXJndW1lbnRQb29sZXIiLCJhMyIsImE0Iiwic3RhbmRhcmRSZWxlYXNlciIsInBvb2xTaXplIiwiREVGQVVMVF9QT09MX1NJWkUiLCJERUZBVUxUX1BPT0xFUiIsIkNvcHlDb25zdHJ1Y3RvciIsInBvb2xlciIsIk5ld0tsYXNzIiwiZGVmIiwic3RhdCIsInNwYWNlcyIsInNwYWNlIiwibm9uIiwibHRyaW0iLCJydHJpbSIsImV4cG9ydGVyIiwiQUxJQVMiLCJGT1JDRSIsInRyaW0iLCJfdCIsIlJlYWN0QmFzZUNsYXNzZXMiLCJSZWFjdENoaWxkcmVuIiwiUmVhY3RET01GYWN0b3JpZXMiLCJSZWFjdFByb3BUeXBlcyIsIlJlYWN0VmVyc2lvbiIsImNyZWF0ZVJlYWN0Q2xhc3MiLCJvbmx5Q2hpbGQiLCJsb3dQcmlvcml0eVdhcm5pbmciLCJSZWFjdEVsZW1lbnRWYWxpZGF0b3IiLCJkaWRXYXJuUHJvcFR5cGVzRGVwcmVjYXRlZCIsIl9fc3ByZWFkIiwiY3JlYXRlTWl4aW4iLCJtaXhpbiIsIndhcm5lZEZvclNwcmVhZCIsIndhcm5lZEZvckNyZWF0ZU1peGluIiwiUmVhY3QiLCJDaGlsZHJlbiIsImNvdW50IiwidG9BcnJheSIsIm9ubHkiLCJDb21wb25lbnQiLCJQdXJlQ29tcG9uZW50IiwiUHJvcFR5cGVzIiwiY3JlYXRlQ2xhc3MiLCJET00iLCJ3YXJuZWRGb3JDcmVhdGVDbGFzcyIsIndhcm5lZEZvckZhY3RvcmllcyIsIlJlYWN0UmVmIiwiUmVhY3RJbnN0cnVtZW50YXRpb24iLCJhdHRhY2hSZWZzIiwibW91bnRDb21wb25lbnQiLCJpbnRlcm5hbEluc3RhbmNlIiwiaG9zdFBhcmVudCIsImhvc3RDb250YWluZXJJbmZvIiwicGFyZW50RGVidWdJRCIsIm1hcmt1cCIsImdldFJlYWN0TW91bnRSZWFkeSIsImdldEhvc3ROb2RlIiwidW5tb3VudENvbXBvbmVudCIsInNhZmVseSIsIm9uQmVmb3JlVW5tb3VudENvbXBvbmVudCIsImRldGFjaFJlZnMiLCJyZWNlaXZlQ29tcG9uZW50IiwibmV4dEVsZW1lbnQiLCJwcmV2RWxlbWVudCIsIl9jb250ZXh0IiwicmVmc0NoYW5nZWQiLCJzaG91bGRVcGRhdGVSZWZzIiwiRE9NTmFtZXNwYWNlcyIsInNldElubmVySFRNTCIsImNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24iLCJzZXRUZXh0Q29udGVudCIsIkVMRU1FTlRfTk9ERV9UWVBFIiwiRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFIiwiZW5hYmxlTGF6eSIsImRvY3VtZW50TW9kZSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImluc2VydFRyZWVDaGlsZHJlbiIsInRyZWUiLCJpbnNlcnRUcmVlQmVmb3JlIiwiaHRtbCIsInJlZmVyZW5jZU5vZGUiLCJub2RlTmFtZSIsIm5hbWVzcGFjZVVSSSIsImluc2VydEJlZm9yZSIsInJlcGxhY2VDaGlsZFdpdGhUcmVlIiwib2xkTm9kZSIsIm5ld1RyZWUiLCJyZXBsYWNlQ2hpbGQiLCJxdWV1ZUNoaWxkIiwicGFyZW50VHJlZSIsImNoaWxkVHJlZSIsInF1ZXVlSFRNTCIsInF1ZXVlVGV4dCIsIkRPTUxhenlUcmVlIiwiY29mIiwiQVJHIiwidHJ5R2V0IiwiVCIsImNhbGxlZSIsIkV2ZW50UGx1Z2luSHViIiwiRXZlbnRQbHVnaW5VdGlscyIsImFjY3VtdWxhdGVJbnRvIiwiZm9yRWFjaEFjY3VtdWxhdGVkIiwiZ2V0TGlzdGVuZXIiLCJsaXN0ZW5lckF0UGhhc2UiLCJwcm9wYWdhdGlvblBoYXNlIiwicmVnaXN0cmF0aW9uTmFtZSIsInBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzIiwiYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyIsInBoYXNlIiwibGlzdGVuZXIiLCJfZGlzcGF0Y2hMaXN0ZW5lcnMiLCJfZGlzcGF0Y2hJbnN0YW5jZXMiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlIiwidHJhdmVyc2VUd29QaGFzZSIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0IiwicGFyZW50SW5zdCIsImdldFBhcmVudEluc3RhbmNlIiwiYWNjdW11bGF0ZURpc3BhdGNoZXMiLCJpZ25vcmVkRGlyZWN0aW9uIiwiYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzIiwiZXZlbnRzIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQiLCJhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMiLCJsZWF2ZSIsImVudGVyIiwidHJhdmVyc2VFbnRlckxlYXZlIiwiYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMiLCJFdmVudFByb3BhZ2F0b3JzIiwiRXZlbnRQbHVnaW5SZWdpc3RyeSIsIlJlYWN0RXJyb3JVdGlscyIsImxpc3RlbmVyQmFuayIsImV2ZW50UXVldWUiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UiLCJzaW11bGF0ZWQiLCJleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCIsImdldERpY3Rpb25hcnlLZXkiLCJfcm9vdE5vZGVJRCIsImlzSW50ZXJhY3RpdmUiLCJzaG91bGRQcmV2ZW50TW91c2VFdmVudCIsImRpc2FibGVkIiwiaW5qZWN0RXZlbnRQbHVnaW5PcmRlciIsImluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSIsInB1dExpc3RlbmVyIiwiYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUiLCJQbHVnaW5Nb2R1bGUiLCJyZWdpc3RyYXRpb25OYW1lTW9kdWxlcyIsImRpZFB1dExpc3RlbmVyIiwiZGVsZXRlTGlzdGVuZXIiLCJ3aWxsRGVsZXRlTGlzdGVuZXIiLCJkZWxldGVBbGxMaXN0ZW5lcnMiLCJleHRyYWN0RXZlbnRzIiwidG9wTGV2ZWxUeXBlIiwicGx1Z2lucyIsInBvc3NpYmxlUGx1Z2luIiwiZXh0cmFjdGVkRXZlbnRzIiwiZW5xdWV1ZUV2ZW50cyIsInByb2Nlc3NFdmVudFF1ZXVlIiwicHJvY2Vzc2luZ0V2ZW50UXVldWUiLCJyZXRocm93Q2F1Z2h0RXJyb3IiLCJfX3B1cmdlIiwiX19nZXRMaXN0ZW5lckJhbmsiLCJnZXRFdmVudFRhcmdldCIsIlVJRXZlbnRJbnRlcmZhY2UiLCJ2aWV3IiwiZG9jIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwicGFyZW50V2luZG93IiwiZGV0YWlsIiwiU3ludGhldGljVUlFdmVudCIsImRpc3BhdGNoTWFya2VyIiwiUmVhY3RJbnN0YW5jZU1hcCIsInJlbW92ZSIsIl9yZWFjdEludGVybmFsSW5zdGFuY2UiLCJnIiwiZXZhbCIsIlNIQVJFRCIsIklTX0lOQ0xVREVTIiwiZWwiLCJmcm9tSW5kZXgiLCJpc0FycmF5IiwiTUFUQ0giLCJpc1JlZ0V4cCIsIlNBRkVfQ0xPU0lORyIsInJpdGVyIiwic2tpcENsb3NpbmciLCJhcnIiLCJpZ25vcmVDYXNlIiwibXVsdGlsaW5lIiwidW5pY29kZSIsInN0aWNreSIsIlNZTUJPTCIsImZucyIsInN0cmZuIiwicnhmbiIsIkQiLCJmb3JPZiIsInNldFRvU3RyaW5nVGFnIiwiaW5oZXJpdElmUmVxdWlyZWQiLCJtZXRob2RzIiwiY29tbW9uIiwiSVNfV0VBSyIsIkFEREVSIiwiZml4TWV0aG9kIiwiZ2V0Q29uc3RydWN0b3IiLCJIQVNOVF9DSEFJTklORyIsIlRIUk9XU19PTl9QUklNSVRJVkVTIiwiQUNDRVBUX0lURVJBQkxFUyIsIkJVR0dZX1pFUk8iLCIkaW5zdGFuY2UiLCJjbGVhciIsInNldFN0cm9uZyIsIlR5cGVkIiwiVHlwZWRBcnJheUNvbnN0cnVjdG9ycyIsIksiLCJfX2RlZmluZVNldHRlcl9fIiwiQ09MTEVDVElPTiIsIkEiLCJtYXBGbiIsImNiIiwibmV4dEl0ZW0iLCJlbXB0eU9iamVjdCIsImV2ZW50UGx1Z2luT3JkZXIiLCJuYW1lc1RvUGx1Z2lucyIsInJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nIiwicGx1Z2luTmFtZSIsInBsdWdpbk1vZHVsZSIsInBsdWdpbkluZGV4IiwicHVibGlzaGVkRXZlbnRzIiwiZXZlbnRUeXBlcyIsImV2ZW50TmFtZSIsInB1Ymxpc2hFdmVudEZvclBsdWdpbiIsImV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyIsInBoYXNlTmFtZSIsInBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUiLCJwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZSIsInJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMiLCJkZXBlbmRlbmNpZXMiLCJsb3dlckNhc2VkTmFtZSIsInBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMiLCJvbmRibGNsaWNrIiwiaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyIiwiaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyIsImlzT3JkZXJpbmdEaXJ0eSIsImdldFBsdWdpbk1vZHVsZUZvckV2ZW50IiwiX3Jlc2V0RXZlbnRQbHVnaW5zIiwiT0JTRVJWRURfRVJST1IiLCJUcmFuc2FjdGlvbkltcGwiLCJ0cmFuc2FjdGlvbldyYXBwZXJzIiwid3JhcHBlckluaXREYXRhIiwiX2lzSW5UcmFuc2FjdGlvbiIsImlzSW5UcmFuc2FjdGlvbiIsImVycm9yVGhyb3duIiwicmV0IiwiaW5pdGlhbGl6ZUFsbCIsImNsb3NlQWxsIiwic3RhcnRJbmRleCIsImluaXREYXRhIiwiVmlld3BvcnRNZXRyaWNzIiwiZ2V0RXZlbnRNb2RpZmllclN0YXRlIiwiTW91c2VFdmVudEludGVyZmFjZSIsInNjcmVlblgiLCJzY3JlZW5ZIiwiY2xpZW50WCIsImNsaWVudFkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJtZXRhS2V5IiwiZ2V0TW9kaWZpZXJTdGF0ZSIsImJ1dHRvbiIsImJ1dHRvbnMiLCJyZWxhdGVkVGFyZ2V0IiwiZnJvbUVsZW1lbnQiLCJzcmNFbGVtZW50IiwidG9FbGVtZW50IiwicGFnZVgiLCJjdXJyZW50U2Nyb2xsTGVmdCIsInBhZ2VZIiwiY3VycmVudFNjcm9sbFRvcCIsIlN5bnRoZXRpY01vdXNlRXZlbnQiLCJXSElURVNQQUNFX1RFU1QiLCJOT05WSVNJQkxFX1RFU1QiLCJyZXVzYWJsZVNWR0NvbnRhaW5lciIsInN2ZyIsImlubmVySFRNTCIsInN2Z05vZGUiLCJ0ZXN0RWxlbWVudCIsInRleHROb2RlIiwicmVtb3ZlQ2hpbGQiLCJkZWxldGVEYXRhIiwibWF0Y2hIdG1sUmVnRXhwIiwiZXNjYXBlSHRtbCIsInN0ciIsIm1hdGNoIiwiZXNjYXBlIiwibGFzdEluZGV4IiwiY2hhckNvZGVBdCIsInN1YnN0cmluZyIsImVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciIsIlJlYWN0RXZlbnRFbWl0dGVyTWl4aW4iLCJnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSIsImlzRXZlbnRTdXBwb3J0ZWQiLCJoYXNFdmVudFBhZ2VYWSIsImFscmVhZHlMaXN0ZW5pbmdUbyIsImlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlIiwicmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyIiwidG9wRXZlbnRNYXBwaW5nIiwidG9wQWJvcnQiLCJ0b3BBbmltYXRpb25FbmQiLCJ0b3BBbmltYXRpb25JdGVyYXRpb24iLCJ0b3BBbmltYXRpb25TdGFydCIsInRvcEJsdXIiLCJ0b3BDYW5QbGF5IiwidG9wQ2FuUGxheVRocm91Z2giLCJ0b3BDaGFuZ2UiLCJ0b3BDbGljayIsInRvcENvbXBvc2l0aW9uRW5kIiwidG9wQ29tcG9zaXRpb25TdGFydCIsInRvcENvbXBvc2l0aW9uVXBkYXRlIiwidG9wQ29udGV4dE1lbnUiLCJ0b3BDb3B5IiwidG9wQ3V0IiwidG9wRG91YmxlQ2xpY2siLCJ0b3BEcmFnIiwidG9wRHJhZ0VuZCIsInRvcERyYWdFbnRlciIsInRvcERyYWdFeGl0IiwidG9wRHJhZ0xlYXZlIiwidG9wRHJhZ092ZXIiLCJ0b3BEcmFnU3RhcnQiLCJ0b3BEcm9wIiwidG9wRHVyYXRpb25DaGFuZ2UiLCJ0b3BFbXB0aWVkIiwidG9wRW5jcnlwdGVkIiwidG9wRW5kZWQiLCJ0b3BFcnJvciIsInRvcEZvY3VzIiwidG9wSW5wdXQiLCJ0b3BLZXlEb3duIiwidG9wS2V5UHJlc3MiLCJ0b3BLZXlVcCIsInRvcExvYWRlZERhdGEiLCJ0b3BMb2FkZWRNZXRhZGF0YSIsInRvcExvYWRTdGFydCIsInRvcE1vdXNlRG93biIsInRvcE1vdXNlTW92ZSIsInRvcE1vdXNlT3V0IiwidG9wTW91c2VPdmVyIiwidG9wTW91c2VVcCIsInRvcFBhc3RlIiwidG9wUGF1c2UiLCJ0b3BQbGF5IiwidG9wUGxheWluZyIsInRvcFByb2dyZXNzIiwidG9wUmF0ZUNoYW5nZSIsInRvcFNjcm9sbCIsInRvcFNlZWtlZCIsInRvcFNlZWtpbmciLCJ0b3BTZWxlY3Rpb25DaGFuZ2UiLCJ0b3BTdGFsbGVkIiwidG9wU3VzcGVuZCIsInRvcFRleHRJbnB1dCIsInRvcFRpbWVVcGRhdGUiLCJ0b3BUb3VjaENhbmNlbCIsInRvcFRvdWNoRW5kIiwidG9wVG91Y2hNb3ZlIiwidG9wVG91Y2hTdGFydCIsInRvcFRyYW5zaXRpb25FbmQiLCJ0b3BWb2x1bWVDaGFuZ2UiLCJ0b3BXYWl0aW5nIiwidG9wV2hlZWwiLCJ0b3BMaXN0ZW5lcnNJREtleSIsImdldExpc3RlbmluZ0ZvckRvY3VtZW50IiwibW91bnRBdCIsIlJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciIsIlJlYWN0RXZlbnRMaXN0ZW5lciIsImluamVjdFJlYWN0RXZlbnRMaXN0ZW5lciIsInNldEhhbmRsZVRvcExldmVsIiwiaGFuZGxlVG9wTGV2ZWwiLCJzZXRFbmFibGVkIiwiZW5hYmxlZCIsImlzRW5hYmxlZCIsImxpc3RlblRvIiwiY29udGVudERvY3VtZW50SGFuZGxlIiwiaXNMaXN0ZW5pbmciLCJkZXBlbmRlbmN5IiwidHJhcEJ1YmJsZWRFdmVudCIsInRyYXBDYXB0dXJlZEV2ZW50IiwiV0lORE9XX0hBTkRMRSIsImhhbmRsZXJCYXNlTmFtZSIsImhhbmRsZSIsInN1cHBvcnRzRXZlbnRQYWdlWFkiLCJjcmVhdGVFdmVudCIsImV2IiwiZW5zdXJlU2Nyb2xsVmFsdWVNb25pdG9yaW5nIiwicmVmcmVzaCIsInJlZnJlc2hTY3JvbGxWYWx1ZXMiLCJtb25pdG9yU2Nyb2xsVmFsdWUiLCJpc0NydXNoZWQiLCJjcmVhdGVTdG9yZSIsImNvbWJpbmVSZWR1Y2VycyIsImJpbmRBY3Rpb25DcmVhdG9ycyIsImFwcGx5TWlkZGxld2FyZSIsImNvbXBvc2UiLCJpcyIsIndrc0V4dCIsIiRTeW1ib2wiLCJjaGFyQXQiLCJkb2N1bWVudEVsZW1lbnQiLCJjaGVjayIsInNldFByb3RvdHlwZU9mIiwiYnVnZ3kiLCJfX3Byb3RvX18iLCJyZXBlYXQiLCJJbmZpbml0eSIsInNpZ24iLCIkZXhwbTEiLCJleHBtMSIsInBvcyIsIiRpdGVyQ3JlYXRlIiwiQlVHR1kiLCJGRl9JVEVSQVRPUiIsIktFWVMiLCJWQUxVRVMiLCJyZXR1cm5UaGlzIiwiREVGQVVMVCIsIklTX1NFVCIsImdldE1ldGhvZCIsImtpbmQiLCJERUZfVkFMVUVTIiwiVkFMVUVTX0JVRyIsIiRuYXRpdmUiLCIkZGVmYXVsdCIsIiRlbnRyaWVzIiwiJGFueU5hdGl2ZSIsIkl0ZXJhdG9yUHJvdG90eXBlIiwiZGVzY3JpcHRvciIsInNlYXJjaFN0cmluZyIsInJlIiwiJGRlZmluZVByb3BlcnR5IiwiZ2V0SXRlcmF0b3JNZXRob2QiLCJvcmlnaW5hbCIsImVuZFBvcyIsImFkZFRvVW5zY29wYWJsZXMiLCJpdGVyYXRlZCIsIl9pIiwiX2siLCJBcmd1bWVudHMiLCJpbnZva2UiLCJjZWwiLCJzZXRUYXNrIiwic2V0SW1tZWRpYXRlIiwiY2xlYXJUYXNrIiwiY2xlYXJJbW1lZGlhdGUiLCJNZXNzYWdlQ2hhbm5lbCIsIkRpc3BhdGNoIiwiY291bnRlciIsIk9OUkVBRFlTVEFURUNIQU5HRSIsImRlZmVyIiwiY2hhbm5lbCIsInBvcnQiLCJwb3J0MiIsInBvcnQxIiwib25tZXNzYWdlIiwicG9zdE1lc3NhZ2UiLCJpbXBvcnRTY3JpcHRzIiwibWFjcm90YXNrIiwiT2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwiV2ViS2l0TXV0YXRpb25PYnNlcnZlciIsIlByb21pc2UiLCJpc05vZGUiLCJoZWFkIiwibGFzdCIsIm5vdGlmeSIsImZsdXNoIiwicGFyZW50IiwiZG9tYWluIiwiZXhpdCIsInRvZ2dsZSIsImNyZWF0ZVRleHROb2RlIiwib2JzZXJ2ZSIsImNoYXJhY3RlckRhdGEiLCJyZXNvbHZlIiwicHJvbWlzZSIsInRoZW4iLCJ0YXNrIiwiUHJvbWlzZUNhcGFiaWxpdHkiLCJyZWplY3QiLCIkJHJlc29sdmUiLCIkJHJlamVjdCIsIkRBVEFfVklFVyIsIldST05HX0lOREVYIiwiQmFzZUJ1ZmZlciIsImFicyIsInBvdyIsImxvZyIsIkxOMiIsIkJVRkZFUiIsIkJZVEVfTEVOR1RIIiwiQllURV9PRkZTRVQiLCIkQlVGRkVSIiwiJExFTkdUSCIsIiRPRkZTRVQiLCJwYWNrSUVFRTc1NCIsIm1MZW4iLCJuQnl0ZXMiLCJlTGVuIiwiZU1heCIsImVCaWFzIiwicnQiLCJtIiwidW5wYWNrSUVFRTc1NCIsIm5CaXRzIiwiTmFOIiwidW5wYWNrSTMyIiwiYnl0ZXMiLCJwYWNrSTgiLCJwYWNrSTE2IiwicGFja0kzMiIsInBhY2tGNjQiLCJwYWNrRjMyIiwiaXNMaXR0bGVFbmRpYW4iLCJudW1JbmRleCIsImludEluZGV4IiwiX2IiLCJwYWNrIiwiY29udmVyc2lvbiIsImJ1ZmZlckxlbmd0aCIsImdldEludDgiLCJnZXRVaW50OCIsImdldEludDE2IiwiZ2V0VWludDE2IiwiZ2V0SW50MzIiLCJnZXRVaW50MzIiLCJnZXRGbG9hdDMyIiwiZ2V0RmxvYXQ2NCIsInNldEludDgiLCJzZXRVaW50OCIsInNldEludDE2Iiwic2V0VWludDE2Iiwic2V0SW50MzIiLCJzZXRVaW50MzIiLCJzZXRGbG9hdDMyIiwic2V0RmxvYXQ2NCIsIkFycmF5QnVmZmVyUHJvdG8iLCIkc2V0SW50OCIsIlJlYWN0UHJvcFR5cGVzU2VjcmV0IiwiQ29tcG9uZW50VHJlZSIsIlRyZWVUcmF2ZXJzYWwiLCJpbmplY3RDb21wb25lbnRUcmVlIiwiSW5qZWN0ZWQiLCJpbmplY3RUcmVlVHJhdmVyc2FsIiwiaXNBbmNlc3RvciIsImdldExvd2VzdENvbW1vbkFuY2VzdG9yIiwiaXNFbmRpc2giLCJpc01vdmVpc2giLCJpc1N0YXJ0aXNoIiwidmFsaWRhdGVFdmVudERpc3BhdGNoZXMiLCJkaXNwYXRjaExpc3RlbmVycyIsImRpc3BhdGNoSW5zdGFuY2VzIiwibGlzdGVuZXJzSXNBcnIiLCJsaXN0ZW5lcnNMZW4iLCJpbnN0YW5jZXNJc0FyciIsImluc3RhbmNlc0xlbiIsImV4ZWN1dGVEaXNwYXRjaCIsImludm9rZUd1YXJkZWRDYWxsYmFja1dpdGhDYXRjaCIsImludm9rZUd1YXJkZWRDYWxsYmFjayIsImV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsIiwiZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZSIsImV4ZWN1dGVEaXJlY3REaXNwYXRjaCIsImRpc3BhdGNoTGlzdGVuZXIiLCJkaXNwYXRjaEluc3RhbmNlIiwiaGFzRGlzcGF0Y2hlcyIsImFyZ0Zyb20iLCJhcmdUbyIsImNhdWdodEVycm9yIiwiZnVuYyIsImRpc3BhdGNoRXZlbnQiLCJmYWtlTm9kZSIsImJvdW5kRnVuYyIsImV2dFR5cGUiLCJldnQiLCJpbml0RXZlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQiLCJ1c2VIYXNGZWF0dXJlIiwiaW1wbGVtZW50YXRpb24iLCJoYXNGZWF0dXJlIiwiZXZlbnROYW1lU3VmZml4IiwiY2FwdHVyZSIsImlzU3VwcG9ydGVkIiwic2V0QXR0cmlidXRlIiwibW9kaWZpZXJLZXlUb1Byb3AiLCJBbHQiLCJDb250cm9sIiwiTWV0YSIsIlNoaWZ0IiwibW9kaWZpZXJTdGF0ZUdldHRlciIsImtleUFyZyIsInN5bnRoZXRpY0V2ZW50Iiwia2V5UHJvcCIsIkRhbmdlciIsImdldE5vZGVBZnRlciIsImluc2VydENoaWxkQXQiLCJpbnNlcnRMYXp5VHJlZUNoaWxkQXQiLCJtb3ZlQ2hpbGQiLCJtb3ZlRGVsaW1pdGVkVGV4dCIsImNsb3NpbmdDb21tZW50IiwicmVtb3ZlRGVsaW1pdGVkVGV4dCIsIm9wZW5pbmdDb21tZW50IiwibmV4dE5vZGUiLCJzdGFydE5vZGUiLCJyZXBsYWNlRGVsaW1pdGVkVGV4dCIsInN0cmluZ1RleHQiLCJub2RlQWZ0ZXJDb21tZW50Iiwib25Ib3N0T3BlcmF0aW9uIiwiaW5zdGFuY2VJRCIsInBheWxvYWQiLCJkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCIsIm9sZENoaWxkIiwicHJldkluc3RhbmNlIiwibmV4dEluc3RhbmNlIiwiRE9NQ2hpbGRyZW5PcGVyYXRpb25zIiwicHJvY2Vzc1VwZGF0ZXMiLCJ1cGRhdGVzIiwicGFyZW50Tm9kZURlYnVnSUQiLCJrIiwidXBkYXRlIiwiY29udGVudCIsImFmdGVyTm9kZSIsImZyb21Ob2RlIiwibWF0aG1sIiwiTVNBcHAiLCJleGVjVW5zYWZlTG9jYWxGdW5jdGlvbiIsImFyZzAiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJwcm9wVHlwZXNGYWN0b3J5IiwiaGFzUmVhZE9ubHlWYWx1ZSIsImNoZWNrYm94IiwiaW1hZ2UiLCJoaWRkZW4iLCJyYWRpbyIsInN1Ym1pdCIsIl9hc3NlcnRTaW5nbGVMaW5rIiwiaW5wdXRQcm9wcyIsImNoZWNrZWRMaW5rIiwidmFsdWVMaW5rIiwiX2Fzc2VydFZhbHVlTGluayIsIm9uQ2hhbmdlIiwiX2Fzc2VydENoZWNrZWRMaW5rIiwiY2hlY2tlZCIsInByb3BUeXBlcyIsImNvbXBvbmVudE5hbWUiLCJyZWFkT25seSIsImxvZ2dlZFR5cGVGYWlsdXJlcyIsImdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSIsIkxpbmtlZFZhbHVlVXRpbHMiLCJjaGVja1Byb3BUeXBlcyIsInRhZ05hbWUiLCJhZGRlbmR1bSIsImdldFZhbHVlIiwiZ2V0Q2hlY2tlZCIsImV4ZWN1dGVPbkNoYW5nZSIsInJlcXVlc3RDaGFuZ2UiLCJpbmplY3RlZCIsIlJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQiLCJyZXBsYWNlTm9kZVdpdGhNYXJrdXAiLCJwcm9jZXNzQ2hpbGRyZW5VcGRhdGVzIiwiaW5qZWN0RW52aXJvbm1lbnQiLCJlbnZpcm9ubWVudCIsInkiLCJzaGFsbG93RXF1YWwiLCJvYmpBIiwib2JqQiIsImtleXNBIiwia2V5c0IiLCJzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCIsInByZXZFbXB0eSIsIm5leHRFbXB0eSIsInByZXZUeXBlIiwibmV4dFR5cGUiLCJlc2NhcGVSZWdleCIsImVzY2FwZXJMb29rdXAiLCJlc2NhcGVkU3RyaW5nIiwidW5lc2NhcGUiLCJ1bmVzY2FwZVJlZ2V4IiwidW5lc2NhcGVyTG9va3VwIiwia2V5U3Vic3RyaW5nIiwiS2V5RXNjYXBlVXRpbHMiLCJmb3JtYXRVbmV4cGVjdGVkQXJndW1lbnQiLCJnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUiLCJwdWJsaWNJbnN0YW5jZSIsImNhbGxlck5hbWUiLCJjdG9yIiwiUmVhY3RVcGRhdGVRdWV1ZSIsIl93YXJuZWRBYm91dFJlZnNJblJlbmRlciIsImVucXVldWVDYWxsYmFjayIsInZhbGlkYXRlQ2FsbGJhY2siLCJlbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbCIsImVucXVldWVGb3JjZVVwZGF0ZSIsIl9wZW5kaW5nRm9yY2VVcGRhdGUiLCJlbnF1ZXVlUmVwbGFjZVN0YXRlIiwiY29tcGxldGVTdGF0ZSIsIl9wZW5kaW5nU3RhdGVRdWV1ZSIsIl9wZW5kaW5nUmVwbGFjZVN0YXRlIiwiZW5xdWV1ZVNldFN0YXRlIiwicGFydGlhbFN0YXRlIiwib25TZXRTdGF0ZSIsImVucXVldWVFbGVtZW50SW50ZXJuYWwiLCJuZXh0Q29udGV4dCIsIl9wZW5kaW5nRWxlbWVudCIsInZhbGlkYXRlRE9NTmVzdGluZyIsInNwZWNpYWxUYWdzIiwiaW5TY29wZVRhZ3MiLCJidXR0b25TY29wZVRhZ3MiLCJpbXBsaWVkRW5kVGFncyIsImVtcHR5QW5jZXN0b3JJbmZvIiwiZm9ybVRhZyIsImFUYWdJblNjb3BlIiwiYnV0dG9uVGFnSW5TY29wZSIsIm5vYnJUYWdJblNjb3BlIiwicFRhZ0luQnV0dG9uU2NvcGUiLCJsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nIiwiZGxJdGVtVGFnQXV0b2Nsb3NpbmciLCJ1cGRhdGVkQW5jZXN0b3JJbmZvIiwib2xkSW5mbyIsImFuY2VzdG9ySW5mbyIsImlzVGFnVmFsaWRXaXRoUGFyZW50IiwicGFyZW50VGFnIiwiZmluZEludmFsaWRBbmNlc3RvckZvclRhZyIsImZpbmRPd25lclN0YWNrIiwiZGlkV2FybiIsImNoaWxkVGFnIiwiY2hpbGRUZXh0IiwiY2hpbGRJbnN0YW5jZSIsInBhcmVudEluZm8iLCJpbnZhbGlkUGFyZW50IiwiaW52YWxpZEFuY2VzdG9yIiwicHJvYmxlbWF0aWMiLCJhbmNlc3RvclRhZyIsImFuY2VzdG9ySW5zdGFuY2UiLCJjaGlsZE93bmVyIiwiYW5jZXN0b3JPd25lciIsImNoaWxkT3duZXJzIiwiYW5jZXN0b3JPd25lcnMiLCJtaW5TdGFja0xlbiIsImRlZXBlc3RDb21tb24iLCJVTktOT1dOIiwiY2hpbGRPd25lck5hbWVzIiwiYW5jZXN0b3JPd25lck5hbWVzIiwib3duZXJJbmZvIiwid2FybktleSIsInRhZ0Rpc3BsYXlOYW1lIiwid2hpdGVzcGFjZUluZm8iLCJpc1RhZ1ZhbGlkSW5Db250ZXh0IiwiZ2V0RXZlbnRDaGFyQ29kZSIsImNoYXJDb2RlIiwia2V5Q29kZSIsImZvciIsInRocm93T25EaXJlY3RBY2Nlc3MiLCJvYmplY3RUYWciLCJmdW5jUHJvdG8iLCJvYmplY3RQcm90byIsIm9iamVjdEN0b3JTdHJpbmciLCJpc1BsYWluT2JqZWN0IiwiQ3RvciIsInJvb3RSZWR1Y2VyIiwid2VicGFja1BvbHlmaWxsIiwiZGVwcmVjYXRlIiwicGF0aHMiLCJFTlRJVElFUyIsImFscGhhSW5kZXgiLCJjaGFySW5kZXgiLCJjcmVhdGVJbmRleGVzIiwiSHRtbDVFbnRpdGllcyIsImRlY29kZSIsImVudGl0eSIsImNociIsImVuY29kZSIsInN0ckxlbmd0aCIsImNoYXJJbmZvIiwiYWxwaGEiLCJlbmNvZGVOb25VVEYiLCJlbmNvZGVOb25BU0NJSSIsIl9yZXN1bHRzIiwiY2hhcnMiLCJhZGRDaGFyIiwiY2hyMiIsIm5hbWVzIiwiZ2V0S2V5cyIsImRlZmluZVByb3BlcnRpZXMiLCJ3aW5kb3dOYW1lcyIsImdldFdpbmRvd05hbWVzIiwiZ09QUyIsIiRhc3NpZ24iLCJnZXRTeW1ib2xzIiwiaXNFbnVtIiwiZmFjdG9yaWVzIiwicGFydEFyZ3MiLCJib3VuZCIsInVuIiwiJHBhcnNlSW50IiwiJHRyaW0iLCJ3cyIsImhleCIsInJhZGl4IiwiJHBhcnNlRmxvYXQiLCJwYXJzZUZsb2F0IiwibXNnIiwiaXNJbnRlZ2VyIiwiaXNGaW5pdGUiLCJsb2cxcCIsIkVQU0lMT04iLCJFUFNJTE9OMzIiLCJNQVgzMiIsIk1JTjMyIiwicm91bmRUaWVzVG9FdmVuIiwiZnJvdW5kIiwiJGFicyIsIiRzaWduIiwibWVtbyIsImlzUmlnaHQiLCJpbmMiLCJmbGFncyIsIm5ld1Byb21pc2VDYXBhYmlsaXR5IiwicHJvbWlzZUNhcGFiaWxpdHkiLCJzdHJvbmciLCJNQVAiLCJlbnRyeSIsImdldEVudHJ5IiwiJGl0ZXJEZWZpbmUiLCJTSVpFIiwiX2YiLCJfbCIsInIiLCJwIiwicHJldiIsIlNFVCIsImVhY2giLCJ3ZWFrIiwiV0VBS19NQVAiLCJ1bmNhdWdodEZyb3plblN0b3JlIiwidWZzdG9yZSIsInRtcCIsIkludGVybmFsTWFwIiwiV2Vha01hcCIsIiRXZWFrTWFwIiwiJGhhcyIsIlVuY2F1Z2h0RnJvemVuU3RvcmUiLCJmaW5kVW5jYXVnaHRGcm96ZW4iLCJudW1iZXIiLCJSZWZsZWN0Iiwib3duS2V5cyIsIklTX0NPTkNBVF9TUFJFQURBQkxFIiwiZmxhdHRlbkludG9BcnJheSIsInNvdXJjZUxlbiIsImRlcHRoIiwibWFwcGVyIiwidGhpc0FyZyIsInRhcmdldEluZGV4Iiwic291cmNlSW5kZXgiLCJzcHJlYWRhYmxlIiwibWF4TGVuZ3RoIiwiZmlsbFN0cmluZyIsImxlZnQiLCJzdHJpbmdMZW5ndGgiLCJmaWxsU3RyIiwiaW50TWF4TGVuZ3RoIiwiZmlsbExlbiIsInN0cmluZ0ZpbGxlciIsImlzRW50cmllcyIsInRvSlNPTiIsInNjYWxlIiwiaW5Mb3ciLCJpbkhpZ2giLCJvdXRMb3ciLCJvdXRIaWdoIiwiUmVhY3ROb29wVXBkYXRlUXVldWUiLCJSZWFjdENvbXBvbmVudCIsInVwZGF0ZXIiLCJyZWZzIiwiaXNSZWFjdENvbXBvbmVudCIsInNldFN0YXRlIiwiZm9yY2VVcGRhdGUiLCJkZXByZWNhdGVkQVBJcyIsInJlcGxhY2VTdGF0ZSIsImRlZmluZURlcHJlY2F0aW9uV2FybmluZyIsIm1ldGhvZE5hbWUiLCJmbk5hbWUiLCJSZWFjdFB1cmVDb21wb25lbnQiLCJDb21wb25lbnREdW1teSIsImlzUHVyZVJlYWN0Q29tcG9uZW50Iiwid2Fybk5vb3AiLCJJVEVSQVRPUl9TWU1CT0wiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCIsImdldEl0ZXJhdG9yRm4iLCJtYXliZUl0ZXJhYmxlIiwiaXRlcmF0b3JGbiIsImNoZWNrUmVhY3RUeXBlU3BlYyIsImdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtIiwiZWxlbWVudFByb3BzIiwib3duZXJIYXNLZXlVc2VXYXJuaW5nIiwiZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsInBhcmVudFR5cGUiLCJwYXJlbnROYW1lIiwidmFsaWRhdGVFeHBsaWNpdEtleSIsIm1lbW9pemVyIiwidW5pcXVlS2V5IiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsInZhbGlkYXRlQ2hpbGRLZXlzIiwiY2hpbGQiLCJ2YWxpZGF0ZVByb3BUeXBlcyIsImNvbXBvbmVudENsYXNzIiwiZ2V0RGVmYXVsdFByb3BzIiwiaXNSZWFjdENsYXNzQXBwcm92ZWQiLCJ2YWxpZFR5cGUiLCJzb3VyY2VJbmZvIiwidmFsaWRhdGVkRmFjdG9yeSIsIkFOT05ZTU9VUyIsImNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyIiwiYm9vbCIsInN5bWJvbCIsImFueSIsImNyZWF0ZUFueVR5cGVDaGVja2VyIiwiYXJyYXlPZiIsImNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlciIsImNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlciIsImluc3RhbmNlT2YiLCJjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyIiwiY3JlYXRlTm9kZUNoZWNrZXIiLCJvYmplY3RPZiIsImNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIiLCJvbmVPZiIsImNyZWF0ZUVudW1UeXBlQ2hlY2tlciIsIm9uZU9mVHlwZSIsImNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIiLCJzaGFwZSIsImNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIiLCJQcm9wVHlwZUVycm9yIiwiY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIiLCJtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSIsIm1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IiwiY2hlY2tUeXBlIiwiaXNSZXF1aXJlZCIsImxvY2F0aW9uIiwicHJvcEZ1bGxOYW1lIiwic2VjcmV0IiwiY2FjaGVLZXkiLCJjaGFpbmVkQ2hlY2tUeXBlIiwiZXhwZWN0ZWRUeXBlIiwicHJvcFZhbHVlIiwicHJvcFR5cGUiLCJnZXRQcm9wVHlwZSIsInByZWNpc2VUeXBlIiwiZ2V0UHJlY2lzZVR5cGUiLCJ0eXBlQ2hlY2tlciIsImV4cGVjdGVkQ2xhc3MiLCJleHBlY3RlZENsYXNzTmFtZSIsImFjdHVhbENsYXNzTmFtZSIsImdldENsYXNzTmFtZSIsImV4cGVjdGVkVmFsdWVzIiwidmFsdWVzU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsImFycmF5T2ZUeXBlQ2hlY2tlcnMiLCJjaGVja2VyIiwiZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nIiwic2hhcGVUeXBlcyIsImlzU3ltYm9sIiwiY29udGVudEtleSIsImdldFRleHRDb250ZW50QWNjZXNzb3IiLCJfY2xhc3NDYWxsQ2hlY2siLCJfY2FsbGJhY2tzIiwiX2NvbnRleHRzIiwiX2FyZyIsImNvbnRleHRzIiwiY2hlY2twb2ludCIsInJvbGxiYWNrIiwiaXNDaGVja2FibGUiLCJlbGVtIiwiZ2V0VHJhY2tlciIsIl93cmFwcGVyU3RhdGUiLCJ2YWx1ZVRyYWNrZXIiLCJhdHRhY2hUcmFja2VyIiwidHJhY2tlciIsImRldGFjaFRyYWNrZXIiLCJnZXRWYWx1ZUZyb21Ob2RlIiwiaW5wdXRWYWx1ZVRyYWNraW5nIiwiX2dldFRyYWNrZXJGcm9tTm9kZSIsInRyYWNrIiwidmFsdWVGaWVsZCIsImN1cnJlbnRWYWx1ZSIsInNldFZhbHVlIiwic3RvcFRyYWNraW5nIiwidXBkYXRlVmFsdWVJZkNoYW5nZWQiLCJsYXN0VmFsdWUiLCJuZXh0VmFsdWUiLCJzdXBwb3J0ZWRJbnB1dFR5cGVzIiwiY29sb3IiLCJkYXRlIiwiZGF0ZXRpbWUiLCJlbWFpbCIsIm1vbnRoIiwicGFzc3dvcmQiLCJyYW5nZSIsInNlYXJjaCIsInRlbCIsInVybCIsIndlZWsiLCJpc1RleHRJbnB1dEVsZW1lbnQiLCJzY3JvbGxQb3NpdGlvbiIsImxhc3RDaGlsZCIsInRleHRDb250ZW50IiwiZm9jdXNOb2RlIiwiZm9jdXMiLCJpc1VuaXRsZXNzTnVtYmVyIiwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQiLCJib3JkZXJJbWFnZU91dHNldCIsImJvcmRlckltYWdlU2xpY2UiLCJib3JkZXJJbWFnZVdpZHRoIiwiYm94RmxleCIsImJveEZsZXhHcm91cCIsImJveE9yZGluYWxHcm91cCIsImNvbHVtbkNvdW50IiwiZmxleCIsImZsZXhHcm93IiwiZmxleFBvc2l0aXZlIiwiZmxleFNocmluayIsImZsZXhOZWdhdGl2ZSIsImZsZXhPcmRlciIsImdyaWRSb3ciLCJncmlkUm93RW5kIiwiZ3JpZFJvd1NwYW4iLCJncmlkUm93U3RhcnQiLCJncmlkQ29sdW1uIiwiZ3JpZENvbHVtbkVuZCIsImdyaWRDb2x1bW5TcGFuIiwiZ3JpZENvbHVtblN0YXJ0IiwiZm9udFdlaWdodCIsImxpbmVDbGFtcCIsImxpbmVIZWlnaHQiLCJvcGFjaXR5Iiwib3JkZXIiLCJvcnBoYW5zIiwidGFiU2l6ZSIsIndpZG93cyIsInpJbmRleCIsInpvb20iLCJmaWxsT3BhY2l0eSIsImZsb29kT3BhY2l0eSIsInN0b3BPcGFjaXR5Iiwic3Ryb2tlRGFzaGFycmF5Iiwic3Ryb2tlRGFzaG9mZnNldCIsInN0cm9rZU1pdGVybGltaXQiLCJzdHJva2VPcGFjaXR5Iiwic3Ryb2tlV2lkdGgiLCJwcmVmaXhLZXkiLCJwcmVmaXgiLCJ0b1VwcGVyQ2FzZSIsInByZWZpeGVzIiwic2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zIiwiYmFja2dyb3VuZCIsImJhY2tncm91bmRBdHRhY2htZW50IiwiYmFja2dyb3VuZENvbG9yIiwiYmFja2dyb3VuZEltYWdlIiwiYmFja2dyb3VuZFBvc2l0aW9uWCIsImJhY2tncm91bmRQb3NpdGlvblkiLCJiYWNrZ3JvdW5kUmVwZWF0IiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiYm9yZGVyIiwiYm9yZGVyV2lkdGgiLCJib3JkZXJTdHlsZSIsImJvcmRlckNvbG9yIiwiYm9yZGVyQm90dG9tIiwiYm9yZGVyQm90dG9tV2lkdGgiLCJib3JkZXJCb3R0b21TdHlsZSIsImJvcmRlckJvdHRvbUNvbG9yIiwiYm9yZGVyTGVmdCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlckxlZnRTdHlsZSIsImJvcmRlckxlZnRDb2xvciIsImJvcmRlclJpZ2h0IiwiYm9yZGVyUmlnaHRXaWR0aCIsImJvcmRlclJpZ2h0U3R5bGUiLCJib3JkZXJSaWdodENvbG9yIiwiYm9yZGVyVG9wIiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJUb3BTdHlsZSIsImJvcmRlclRvcENvbG9yIiwiZm9udCIsImZvbnRTdHlsZSIsImZvbnRWYXJpYW50IiwiZm9udFNpemUiLCJmb250RmFtaWx5Iiwib3V0bGluZSIsIm91dGxpbmVXaWR0aCIsIm91dGxpbmVTdHlsZSIsIm91dGxpbmVDb2xvciIsIkNTU1Byb3BlcnR5IiwicXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIiLCJWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCIsImlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUiLCJ2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUiLCJpc0F0dHJpYnV0ZU5hbWVTYWZlIiwic2hvdWxkSWdub3JlVmFsdWUiLCJET01Qcm9wZXJ0eU9wZXJhdGlvbnMiLCJjcmVhdGVNYXJrdXBGb3JJRCIsInNldEF0dHJpYnV0ZUZvcklEIiwiY3JlYXRlTWFya3VwRm9yUm9vdCIsInNldEF0dHJpYnV0ZUZvclJvb3QiLCJjcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eSIsImNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZSIsInNldFZhbHVlRm9yUHJvcGVydHkiLCJkZWxldGVWYWx1ZUZvclByb3BlcnR5IiwibmFtZXNwYWNlIiwic2V0QXR0cmlidXRlTlMiLCJzZXRWYWx1ZUZvckF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsImRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlIiwiZGlkV2FyblZhbHVlTGluayIsImRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSIsInVwZGF0ZU9wdGlvbnNJZlBlbmRpbmdVcGRhdGVBbmRNb3VudGVkIiwicGVuZGluZ1VwZGF0ZSIsInVwZGF0ZU9wdGlvbnMiLCJCb29sZWFuIiwibXVsdGlwbGUiLCJ2YWx1ZVByb3BOYW1lcyIsImNoZWNrU2VsZWN0UHJvcFR5cGVzIiwic2VsZWN0ZWRWYWx1ZSIsIm9wdGlvbnMiLCJzZWxlY3RlZCIsIlJlYWN0RE9NU2VsZWN0IiwiZ2V0SG9zdFByb3BzIiwibW91bnRXcmFwcGVyIiwiaW5pdGlhbFZhbHVlIiwiZGVmYXVsdFZhbHVlIiwiX2hhbmRsZUNoYW5nZSIsIndhc011bHRpcGxlIiwiZ2V0U2VsZWN0VmFsdWVDb250ZXh0IiwicG9zdFVwZGF0ZVdyYXBwZXIiLCJSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCIsIlJlYWN0RW1wdHlDb21wb25lbnQiLCJSZWFjdEhvc3RDb21wb25lbnQiLCJnZXROZXh0RGVidWdJRCIsIlJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlciIsImlzSW50ZXJuYWxDb21wb25lbnRUeXBlIiwiaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCIsInNob3VsZEhhdmVEZWJ1Z0lEIiwiY3JlYXRlSW50ZXJuYWxDb21wb25lbnQiLCJnZXROYXRpdmVOb2RlIiwiY3JlYXRlSW5zdGFuY2VGb3JUZXh0IiwiX21vdW50SW5kZXgiLCJfbW91bnRJbWFnZSIsIl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50IiwiUmVhY3ROb2RlVHlwZXMiLCJIT1NUIiwiQ09NUE9TSVRFIiwiRU1QVFkiLCJnZXRUeXBlIiwiZW1wdHlDb21wb25lbnRGYWN0b3J5IiwiUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbiIsImluamVjdEVtcHR5Q29tcG9uZW50RmFjdG9yeSIsImluc3RhbnRpYXRlIiwiZ2VuZXJpY0NvbXBvbmVudENsYXNzIiwidGV4dENvbXBvbmVudENsYXNzIiwiUmVhY3RIb3N0Q29tcG9uZW50SW5qZWN0aW9uIiwiaW5qZWN0R2VuZXJpY0NvbXBvbmVudENsYXNzIiwiaW5qZWN0VGV4dENvbXBvbmVudENsYXNzIiwiaXNUZXh0Q29tcG9uZW50IiwiU0VQQVJBVE9SIiwiU1VCU0VQQVJBVE9SIiwiZGlkV2FybkFib3V0TWFwcyIsImdldENvbXBvbmVudEtleSIsInRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsIiwibmFtZVNvRmFyIiwidHJhdmVyc2VDb250ZXh0IiwibmV4dE5hbWUiLCJzdWJ0cmVlQ291bnQiLCJuZXh0TmFtZVByZWZpeCIsImlpIiwibWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSIsIm1hcHNBc0NoaWxkcmVuT3duZXJOYW1lIiwiX2lzUmVhY3RFbGVtZW50IiwiY2hpbGRyZW5TdHJpbmciLCJ0cmF2ZXJzZUFsbENoaWxkcmVuIiwiRXZlbnRMaXN0ZW5lciIsImxpc3RlbiIsImV2ZW50VHlwZSIsImRldGFjaEV2ZW50IiwicmVnaXN0ZXJEZWZhdWx0IiwiUmVhY3RET01TZWxlY3Rpb24iLCJjb250YWluc05vZGUiLCJnZXRBY3RpdmVFbGVtZW50IiwiaXNJbkRvY3VtZW50IiwiUmVhY3RJbnB1dFNlbGVjdGlvbiIsImhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyIsImNvbnRlbnRFZGl0YWJsZSIsImdldFNlbGVjdGlvbkluZm9ybWF0aW9uIiwiZm9jdXNlZEVsZW0iLCJzZWxlY3Rpb25SYW5nZSIsImdldFNlbGVjdGlvbiIsInJlc3RvcmVTZWxlY3Rpb24iLCJwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uIiwiY3VyRm9jdXNlZEVsZW0iLCJwcmlvckZvY3VzZWRFbGVtIiwicHJpb3JTZWxlY3Rpb25SYW5nZSIsInNldFNlbGVjdGlvbiIsImlucHV0Iiwic2VsZWN0aW9uIiwic2VsZWN0aW9uU3RhcnQiLCJzZWxlY3Rpb25FbmQiLCJjcmVhdGVSYW5nZSIsInBhcmVudEVsZW1lbnQiLCJtb3ZlU3RhcnQiLCJtb3ZlRW5kIiwiZ2V0T2Zmc2V0cyIsIm9mZnNldHMiLCJjcmVhdGVUZXh0UmFuZ2UiLCJjb2xsYXBzZSIsInNlbGVjdCIsInNldE9mZnNldHMiLCJhY3RpdmVFbGVtZW50IiwiYm9keSIsIlJlYWN0RE9NQ29udGFpbmVySW5mbyIsIlJlYWN0RE9NRmVhdHVyZUZsYWdzIiwiUmVhY3RNYXJrdXBDaGVja3N1bSIsIlJPT1RfQVRUUl9OQU1FIiwiRE9DX05PREVfVFlQRSIsImluc3RhbmNlc0J5UmVhY3RSb290SUQiLCJmaXJzdERpZmZlcmVuY2VJbmRleCIsInN0cmluZzEiLCJzdHJpbmcyIiwibWluTGVuIiwiZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyIiwiY29udGFpbmVyIiwiaW50ZXJuYWxHZXRJRCIsIm1vdW50Q29tcG9uZW50SW50b05vZGUiLCJ3cmFwcGVySW5zdGFuY2UiLCJzaG91bGRSZXVzZU1hcmt1cCIsIndyYXBwZWRFbGVtZW50IiwiX3RvcExldmVsV3JhcHBlciIsIlJlYWN0TW91bnQiLCJfbW91bnRJbWFnZUludG9Ob2RlIiwiYmF0Y2hlZE1vdW50Q29tcG9uZW50SW50b05vZGUiLCJjb21wb25lbnRJbnN0YW5jZSIsInVzZUNyZWF0ZUVsZW1lbnQiLCJ1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUiLCJvbkJlZ2luRmx1c2giLCJvbkVuZEZsdXNoIiwiaGFzTm9uUm9vdFJlYWN0Q2hpbGQiLCJyb290RWwiLCJub2RlSXNSZW5kZXJlZEJ5T3RoZXJJbnN0YW5jZSIsImlzUmVhY3ROb2RlIiwiaXNWYWxpZENvbnRhaW5lciIsImhhc0F0dHJpYnV0ZSIsImdldEhvc3RSb290SW5zdGFuY2VJbkNvbnRhaW5lciIsInByZXZIb3N0SW5zdGFuY2UiLCJnZXRUb3BMZXZlbFdyYXBwZXJJbkNvbnRhaW5lciIsInJvb3QiLCJfaG9zdENvbnRhaW5lckluZm8iLCJ0b3BMZXZlbFJvb3RDb3VudGVyIiwiVG9wTGV2ZWxXcmFwcGVyIiwicm9vdElEIiwicmVuZGVyIiwiX2luc3RhbmNlc0J5UmVhY3RSb290SUQiLCJzY3JvbGxNb25pdG9yIiwicmVuZGVyQ2FsbGJhY2siLCJfdXBkYXRlUm9vdENvbXBvbmVudCIsInByZXZDb21wb25lbnQiLCJfcmVuZGVyTmV3Um9vdENvbXBvbmVudCIsIndyYXBwZXJJRCIsIl9pbnN0YW5jZSIsInJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyIiwicGFyZW50Q29tcG9uZW50IiwiX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyIiwibmV4dFdyYXBwZWRFbGVtZW50IiwiX3Byb2Nlc3NDaGlsZENvbnRleHQiLCJwcmV2V3JhcHBlZEVsZW1lbnQiLCJwdWJsaWNJbnN0IiwidXBkYXRlZENhbGxiYWNrIiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsInJlYWN0Um9vdEVsZW1lbnQiLCJjb250YWluZXJIYXNSZWFjdE1hcmt1cCIsImNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkIiwicm9vdEVsZW1lbnRTaWJsaW5nIiwiaXNDb250YWluZXJSZWFjdFJvb3QiLCJyb290RWxlbWVudCIsImNhblJldXNlTWFya3VwIiwiY2hlY2tzdW0iLCJDSEVDS1NVTV9BVFRSX05BTUUiLCJyb290TWFya3VwIiwib3V0ZXJIVE1MIiwibm9ybWFsaXplZE1hcmt1cCIsIm5vcm1hbGl6ZXIiLCJjb250ZW50RG9jdW1lbnQiLCJkaWZmSW5kZXgiLCJkaWZmZXJlbmNlIiwiaG9zdE5vZGUiLCJnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZSIsIl9yZW5kZXJlZE5vZGVUeXBlIiwiUHJvdmlkZXIiLCJjcmVhdGVQcm92aWRlciIsImNvbm5lY3RBZHZhbmNlZCIsImNvbm5lY3QiLCJzdWJzY3JpcHRpb25TaGFwZSIsInRyeVN1YnNjcmliZSIsInRyeVVuc3Vic2NyaWJlIiwibm90aWZ5TmVzdGVkU3VicyIsImlzU3Vic2NyaWJlZCIsInN0b3JlU2hhcGUiLCJzdWJzY3JpYmUiLCJkaXNwYXRjaCIsImdldFN0YXRlIiwiX2V4dGVuZHMiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIlJlZmVyZW5jZUVycm9yIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwib2JqIiwiaG90UmVsb2FkaW5nVmVyc2lvbiIsImR1bW15U3RhdGUiLCJtYWtlU2VsZWN0b3JTdGF0ZWZ1bCIsInNvdXJjZVNlbGVjdG9yIiwic2VsZWN0b3IiLCJydW5Db21wb25lbnRTZWxlY3RvciIsIm5leHRQcm9wcyIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsInNlbGVjdG9yRmFjdG9yeSIsIl9jb250ZXh0VHlwZXMiLCJfY2hpbGRDb250ZXh0VHlwZXMiLCJfcmVmIiwiX3JlZiRnZXREaXNwbGF5TmFtZSIsIl9yZWYkbWV0aG9kTmFtZSIsIl9yZWYkcmVuZGVyQ291bnRQcm9wIiwicmVuZGVyQ291bnRQcm9wIiwiX3JlZiRzaG91bGRIYW5kbGVTdGF0Iiwic2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzIiwiX3JlZiRzdG9yZUtleSIsInN0b3JlS2V5IiwiX3JlZiR3aXRoUmVmIiwid2l0aFJlZiIsImNvbm5lY3RPcHRpb25zIiwic3Vic2NyaXB0aW9uS2V5IiwiY29udGV4dFR5cGVzIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJ3cmFwV2l0aENvbm5lY3QiLCJXcmFwcGVkQ29tcG9uZW50Iiwid3JhcHBlZENvbXBvbmVudE5hbWUiLCJzZWxlY3RvckZhY3RvcnlPcHRpb25zIiwiQ29ubmVjdCIsIl9Db21wb25lbnQiLCJfdGhpcyIsInN0YXRlIiwicmVuZGVyQ291bnQiLCJwcm9wc01vZGUiLCJzZXRXcmFwcGVkSW5zdGFuY2UiLCJpbml0U2VsZWN0b3IiLCJpbml0U3Vic2NyaXB0aW9uIiwiZ2V0Q2hpbGRDb250ZXh0IiwiX3JlZjIiLCJzdWJzY3JpcHRpb24iLCJjb21wb25lbnREaWRNb3VudCIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsImdldFdyYXBwZWRJbnN0YW5jZSIsIndyYXBwZWRJbnN0YW5jZSIsInBhcmVudFN1YiIsIm9uU3RhdGVDaGFuZ2UiLCJjb21wb25lbnREaWRVcGRhdGUiLCJub3RpZnlOZXN0ZWRTdWJzT25Db21wb25lbnREaWRVcGRhdGUiLCJhZGRFeHRyYVByb3BzIiwid2l0aEV4dHJhcyIsImNvbXBvbmVudFdpbGxVcGRhdGUiLCJfdGhpczIiLCJvbGRMaXN0ZW5lcnMiLCJBY3Rpb25UeXBlcyIsIklOSVQiLCJyZWR1Y2VyIiwicHJlbG9hZGVkU3RhdGUiLCJlbmhhbmNlciIsImN1cnJlbnRSZWR1Y2VyIiwiY3VycmVudFN0YXRlIiwiY3VycmVudExpc3RlbmVycyIsIm5leHRMaXN0ZW5lcnMiLCJpc0Rpc3BhdGNoaW5nIiwiZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycyIsInVuc3Vic2NyaWJlIiwicmVwbGFjZVJlZHVjZXIiLCJuZXh0UmVkdWNlciIsIm9ic2VydmFibGUiLCJvdXRlclN1YnNjcmliZSIsIm9ic2VydmVyIiwib2JzZXJ2ZVN0YXRlIiwiZnVuY3MiLCJ3cmFwTWFwVG9Qcm9wc0NvbnN0YW50IiwiZ2V0RGVwZW5kc09uT3duUHJvcHMiLCJ3cmFwTWFwVG9Qcm9wc0Z1bmMiLCJnZXRDb25zdGFudCIsImluaXRDb25zdGFudFNlbGVjdG9yIiwiY29uc3RhbnQiLCJjb25zdGFudFNlbGVjdG9yIiwiZGVwZW5kc09uT3duUHJvcHMiLCJtYXBUb1Byb3BzIiwiaW5pdFByb3h5U2VsZWN0b3IiLCJwcm94eSIsIm1hcFRvUHJvcHNQcm94eSIsInN0YXRlT3JEaXNwYXRjaCIsIm93blByb3BzIiwiZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeSIsInZlcmlmeVBsYWluT2JqZWN0IiwiU0VUX0NPVU5URVIiLCJJTkNSRU1FTlRfQ09VTlRFUiIsIkRFQ1JFTUVOVF9DT1VOVEVSIiwiaW5jcmVtZW50IiwiZGVjcmVtZW50IiwiaW5jcmVtZW50SWZPZGQiLCJpbmNyZW1lbnRBc3luYyIsImRlbGF5IiwicGF0aCIsIm92ZXJsYXkiLCJyZWxvYWQiLCJxdWVyeXN0cmluZyIsIm92ZXJyaWRlcyIsInBhcnNlIiwiX19yZXNvdXJjZVF1ZXJ5Iiwibm9JbmZvIiwicXVpZXQiLCJkeW5hbWljUHVibGljUGF0aCIsIl9fd2VicGFja19wdWJsaWNfcGF0aF9fIiwiRXZlbnRTb3VyY2UiLCJFdmVudFNvdXJjZVdyYXBwZXIiLCJsYXN0QWN0aXZpdHkiLCJpbml0IiwidGltZXIiLCJzZXRJbnRlcnZhbCIsImhhbmRsZURpc2Nvbm5lY3QiLCJvbm9wZW4iLCJoYW5kbGVPbmxpbmUiLCJvbmVycm9yIiwiaGFuZGxlTWVzc2FnZSIsImNsZWFySW50ZXJ2YWwiLCJhZGRNZXNzYWdlTGlzdGVuZXIiLCJnZXRFdmVudFNvdXJjZVdyYXBwZXIiLCJfX3dobUV2ZW50U291cmNlV3JhcHBlciIsInByb2Nlc3NNZXNzYWdlIiwiZXgiLCJzaW5nbGV0b25LZXkiLCJyZXBvcnRlciIsImNyZWF0ZVJlcG9ydGVyIiwic3RyaXAiLCJzdHlsZXMiLCJlcnJvcnMiLCJ3YXJuaW5ncyIsInByZXZpb3VzUHJvYmxlbXMiLCJuZXdQcm9ibGVtcyIsImdyb3VwIiwiZ3JvdXBFbmQiLCJjbGVhblByb2JsZW1zQ2FjaGUiLCJwcm9ibGVtcyIsInNob3dQcm9ibGVtcyIsInN1Y2Nlc3MiLCJ1c2VDdXN0b21PdmVybGF5IiwiY3VzdG9tT3ZlcmxheSIsInByb2Nlc3NVcGRhdGUiLCJjdXN0b21IYW5kbGVyIiwic3Vic2NyaWJlQWxsSGFuZGxlciIsImhhc2giLCJtb2R1bGVzIiwic3Vic2NyaWJlQWxsIiwiaGFuZGxlciIsImFuc2lSZWdleCIsImNsaWVudE92ZXJsYXkiLCJ3aGl0ZVNwYWNlIiwicG9zaXRpb24iLCJwYWRkaW5nIiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJvdmVyZmxvdyIsInRleHRBbGlnbiIsImFuc2lIVE1MIiwiY29sb3JzIiwiYmxhY2siLCJyZWQiLCJncmVlbiIsInllbGxvdyIsImJsdWUiLCJtYWdlbnRhIiwiY3lhbiIsImxpZ2h0Z3JleSIsImRhcmtncmV5Iiwic2V0Q29sb3JzIiwiRW50aXRpZXMiLCJBbGxIdG1sRW50aXRpZXMiLCJlbnRpdGllcyIsImxpbmVzIiwiZGl2IiwibWFyZ2luQm90dG9tIiwicHJvYmxlbVR5cGUiLCJwcm9ibGVtQ29sb3JzIiwiX3JlZ0FOU0kiLCJfZGVmQ29sb3JzIiwiX3N0eWxlcyIsIl9vcGVuVGFncyIsIl9jbG9zZVRhZ3MiLCJhbnNpQ29kZXMiLCJzZXEiLCJvdCIsImN0IiwiX2ZpbmFsQ29sb3JzIiwiaCIsImRlZkhleENvbG9yIiwiX3NldFRhZ3MiLCJ0YWdzIiwib3JpQ29sb3IiLCJYbWxFbnRpdGllcyIsIkh0bWw0RW50aXRpZXMiLCJBTFBIQV9JTkRFWCIsIkNIQVJfSU5ERVgiLCJDSEFSX1NfSU5ERVgiLCJzdHJMZW5naHQiLCJIVE1MX0FMUEhBIiwiSFRNTF9DT0RFUyIsImNjIiwiaG1yRG9jc1VybCIsImxhc3RIYXNoIiwiZmFpbHVyZVN0YXR1c2VzIiwiYWJvcnQiLCJmYWlsIiwiYXBwbHlPcHRpb25zIiwiaWdub3JlVW5hY2NlcHRlZCIsInVwVG9EYXRlIiwibW9kdWxlTWFwIiwiaG90Iiwic3RhdHVzIiwidXBkYXRlZE1vZHVsZXMiLCJoYW5kbGVFcnJvciIsInBlcmZvcm1SZWxvYWQiLCJhcHBseUNhbGxiYWNrIiwiYXBwbHlFcnIiLCJyZW5ld2VkTW9kdWxlcyIsImxvZ1VwZGF0ZXMiLCJhcHBseVJlc3VsdCIsIm91dGRhdGVkTW9kdWxlcyIsImNhdGNoIiwidW5hY2NlcHRlZE1vZHVsZXMiLCJtb2R1bGVJZCIsIl9fUFJFTE9BREVEX1NUQVRFX18iLCJnZXRFbGVtZW50QnlJZCIsIl9iYWJlbFBvbHlmaWxsIiwiREVGSU5FX1BST1BFUlRZIiwiZGVmaW5lIiwicGFkU3RhcnQiLCJwYWRFbmQiLCIkZmFpbHMiLCJ3a3NEZWZpbmUiLCJlbnVtS2V5cyIsIl9jcmVhdGUiLCJnT1BORXh0IiwiJEpTT04iLCJfc3RyaW5naWZ5IiwiSElEREVOIiwiVE9fUFJJTUlUSVZFIiwiU3ltYm9sUmVnaXN0cnkiLCJBbGxTeW1ib2xzIiwiT1BTeW1ib2xzIiwiVVNFX05BVElWRSIsIlFPYmplY3QiLCJmaW5kQ2hpbGQiLCJzZXRTeW1ib2xEZXNjIiwicHJvdG9EZXNjIiwid3JhcCIsInN5bSIsIiRkZWZpbmVQcm9wZXJ0aWVzIiwiJHByb3BlcnR5SXNFbnVtZXJhYmxlIiwiJGdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIiRnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiJGdldE93blByb3BlcnR5U3ltYm9scyIsIklTX09QIiwiZXM2U3ltYm9scyIsIndlbGxLbm93blN5bWJvbHMiLCJrZXlGb3IiLCJ1c2VTZXR0ZXIiLCJ1c2VTaW1wbGUiLCJyZXBsYWNlciIsIiRyZXBsYWNlciIsIiRnZXRQcm90b3R5cGVPZiIsIiRmcmVlemUiLCIkc2VhbCIsInNlYWwiLCIkcHJldmVudEV4dGVuc2lvbnMiLCIkaXNGcm96ZW4iLCJpc0Zyb3plbiIsIiRpc1NlYWxlZCIsImlzU2VhbGVkIiwiJGlzRXh0ZW5zaWJsZSIsIkZQcm90byIsIm5hbWVSRSIsIkhBU19JTlNUQU5DRSIsIkZ1bmN0aW9uUHJvdG8iLCJOVU1CRVIiLCIkTnVtYmVyIiwiQlJPS0VOX0NPRiIsIlRSSU0iLCJ0b051bWJlciIsImFyZ3VtZW50IiwiZmlyc3QiLCJ0aGlyZCIsIm1heENvZGUiLCJkaWdpdHMiLCJOdW1iZXIiLCJhTnVtYmVyVmFsdWUiLCIkdG9GaXhlZCIsInRvRml4ZWQiLCJFUlJPUiIsIlpFUk8iLCJtdWx0aXBseSIsImRpdmlkZSIsIm51bVRvU3RyaW5nIiwidCIsImFjYyIsIngyIiwiZnJhY3Rpb25EaWdpdHMiLCJ6IiwiJHRvUHJlY2lzaW9uIiwidG9QcmVjaXNpb24iLCJwcmVjaXNpb24iLCJfaXNGaW5pdGUiLCJpc1NhZmVJbnRlZ2VyIiwiTUFYX1NBRkVfSU5URUdFUiIsIk1JTl9TQUZFX0lOVEVHRVIiLCJzcXJ0IiwiJGFjb3NoIiwiYWNvc2giLCJNQVhfVkFMVUUiLCIkYXNpbmgiLCJhc2luaCIsIiRhdGFuaCIsImF0YW5oIiwiY2JydCIsImNsejMyIiwiTE9HMkUiLCJjb3NoIiwiaHlwb3QiLCJ2YWx1ZTEiLCJ2YWx1ZTIiLCJzdW0iLCJsYXJnIiwiJGltdWwiLCJpbXVsIiwiVUlOVDE2IiwieG4iLCJ5biIsInhsIiwieWwiLCJsb2cxMCIsIkxPRzEwRSIsImxvZzIiLCJzaW5oIiwidGFuaCIsInRydW5jIiwiJGZyb21Db2RlUG9pbnQiLCJmcm9tQ29kZVBvaW50IiwicmF3IiwiY2FsbFNpdGUiLCJ0cGwiLCIkYXQiLCJwb2ludCIsImNvZGVQb2ludEF0IiwiRU5EU19XSVRIIiwiJGVuZHNXaXRoIiwiZW5kc1dpdGgiLCJlbmRQb3NpdGlvbiIsIklOQ0xVREVTIiwiU1RBUlRTX1dJVEgiLCIkc3RhcnRzV2l0aCIsInN0YXJ0c1dpdGgiLCJhbmNob3IiLCJiaWciLCJibGluayIsImJvbGQiLCJmaXhlZCIsImZvbnRjb2xvciIsImZvbnRzaXplIiwic2l6ZSIsIml0YWxpY3MiLCJsaW5rIiwic21hbGwiLCJzdHJpa2UiLCJzdWIiLCJzdXAiLCJnZXRUaW1lIiwidG9JU09TdHJpbmciLCJwdiIsIiR0b0lTT1N0cmluZyIsImx6IiwibnVtIiwiZ2V0VVRDRnVsbFllYXIiLCJnZXRVVENNaWxsaXNlY29uZHMiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJnZXRVVENIb3VycyIsImdldFVUQ01pbnV0ZXMiLCJnZXRVVENTZWNvbmRzIiwiRGF0ZVByb3RvIiwiSU5WQUxJRF9EQVRFIiwiaGludCIsImNyZWF0ZVByb3BlcnR5IiwidXBUbyIsImNsb25lZCIsIiRzb3J0IiwiJGZvckVhY2giLCJTVFJJQ1QiLCIkZmlsdGVyIiwiJHNvbWUiLCIkZXZlcnkiLCIkcmVkdWNlIiwiJGluZGV4T2YiLCJORUdBVElWRV9aRVJPIiwiJGZpbmQiLCJmb3JjZWQiLCIkZmxhZ3MiLCIkUmVnRXhwIiwicmUxIiwicmUyIiwiQ09SUkVDVF9ORVciLCJ0aVJFIiwicGlSRSIsImZpVSIsIiRtYXRjaCIsInJlZ2V4cCIsIlJFUExBQ0UiLCIkcmVwbGFjZSIsInNlYXJjaFZhbHVlIiwicmVwbGFjZVZhbHVlIiwiU0VBUkNIIiwiJHNlYXJjaCIsIlNQTElUIiwiJHNwbGl0IiwiX3NwbGl0IiwiJHB1c2giLCIkU1BMSVQiLCJMRU5HVEgiLCJMQVNUX0lOREVYIiwiTlBDRyIsImxpbWl0Iiwib3V0cHV0IiwibGFzdExhc3RJbmRleCIsInNwbGl0TGltaXQiLCJzZXBhcmF0b3JDb3B5Iiwic2VwYXJhdG9yMiIsImxhc3RMZW5ndGgiLCJtaWNyb3Rhc2siLCJuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSIsInByb21pc2VSZXNvbHZlIiwiUFJPTUlTRSIsIiRQcm9taXNlIiwiZW1wdHkiLCJJbnRlcm5hbCIsIm5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSIsIk93blByb21pc2VDYXBhYmlsaXR5IiwiV3JhcHBlciIsIkZha2VQcm9taXNlIiwiUHJvbWlzZVJlamVjdGlvbkV2ZW50IiwiaXNUaGVuYWJsZSIsImlzUmVqZWN0IiwiX24iLCJjaGFpbiIsIl9jIiwiX3YiLCJvayIsIl9zIiwicmVhY3Rpb24iLCJfaCIsIm9uSGFuZGxlVW5oYW5kbGVkIiwib25VbmhhbmRsZWQiLCJ1bmhhbmRsZWQiLCJpc1VuaGFuZGxlZCIsIm9udW5oYW5kbGVkcmVqZWN0aW9uIiwicmVhc29uIiwiX2EiLCJvbnJlamVjdGlvbmhhbmRsZWQiLCIkcmVqZWN0IiwiX3ciLCIkcmVzb2x2ZSIsImV4ZWN1dG9yIiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwiY2FwYWJpbGl0eSIsImFsbCIsInJlbWFpbmluZyIsIiRpbmRleCIsImFscmVhZHlDYWxsZWQiLCJyYWNlIiwiV0VBS19TRVQiLCJXZWFrU2V0IiwiJGlzVmlldyIsImlzVmlldyIsImZpbmFsIiwidmlld1MiLCJ2aWV3VCIsIkludDhBcnJheSIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiSW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJVaW50MzJBcnJheSIsIkZsb2F0MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsInJBcHBseSIsImZBcHBseSIsInRoaXNBcmd1bWVudCIsImFyZ3VtZW50c0xpc3QiLCJMIiwickNvbnN0cnVjdCIsIk5FV19UQVJHRVRfQlVHIiwiQVJHU19CVUciLCJUYXJnZXQiLCJuZXdUYXJnZXQiLCIkYXJncyIsInByb3BlcnR5S2V5IiwiYXR0cmlidXRlcyIsImRlbGV0ZVByb3BlcnR5IiwiRW51bWVyYXRlIiwiZW51bWVyYXRlIiwicmVjZWl2ZXIiLCJnZXRQcm90byIsIlYiLCJvd25EZXNjIiwiZXhpc3RpbmdEZXNjcmlwdG9yIiwic2V0UHJvdG8iLCIkaW5jbHVkZXMiLCJhcnJheVNwZWNpZXNDcmVhdGUiLCJmbGF0TWFwIiwiZmxhdHRlbiIsImRlcHRoQXJnIiwiYXQiLCIkcGFkIiwidHJpbUxlZnQiLCJ0cmltUmlnaHQiLCJnZXRGbGFncyIsIlJlZ0V4cFByb3RvIiwiJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yIiwiX3IiLCJtYXRjaEFsbCIsInJ4IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImdldERlc2MiLCIkdmFsdWVzIiwiX19kZWZpbmVHZXR0ZXJfXyIsIl9fbG9va3VwR2V0dGVyX18iLCJfX2xvb2t1cFNldHRlcl9fIiwiaXNFcnJvciIsImNsYW1wIiwibG93ZXIiLCJ1cHBlciIsIkRFR19QRVJfUkFEIiwiUEkiLCJSQURfUEVSX0RFRyIsImRlZ3JlZXMiLCJyYWRpYW5zIiwiZnNjYWxlIiwiaWFkZGgiLCJ4MCIsIngxIiwieTAiLCJ5MSIsIiR4MCIsIiR4MSIsIiR5MCIsImlzdWJoIiwiaW11bGgiLCJ1IiwiJHUiLCIkdiIsInUwIiwidjAiLCJ1MSIsInYxIiwidW11bGgiLCJzaWduYml0Iiwib25GaW5hbGx5IiwibWV0YWRhdGEiLCJkZWZpbmVNZXRhZGF0YSIsIm1ldGFkYXRhS2V5IiwibWV0YWRhdGFWYWx1ZSIsImRlbGV0ZU1ldGFkYXRhIiwib3JkaW5hcnlHZXRNZXRhZGF0YSIsImhhc093biIsImdldE1ldGFkYXRhIiwib3JkaW5hcnlNZXRhZGF0YUtleXMiLCJvS2V5cyIsInBLZXlzIiwiZ2V0TWV0YWRhdGFLZXlzIiwiZ2V0T3duTWV0YWRhdGEiLCJnZXRPd25NZXRhZGF0YUtleXMiLCJvcmRpbmFyeUhhc01ldGFkYXRhIiwiaGFzTWV0YWRhdGEiLCJoYXNPd25NZXRhZGF0YSIsIiRtZXRhZGF0YSIsImRlY29yYXRvciIsIk9CU0VSVkFCTEUiLCJjbGVhbnVwU3Vic2NyaXB0aW9uIiwiY2xlYW51cCIsInN1YnNjcmlwdGlvbkNsb3NlZCIsIl9vIiwiY2xvc2VTdWJzY3JpcHRpb24iLCJTdWJzY3JpcHRpb24iLCJzdWJzY3JpYmVyIiwiU3Vic2NyaXB0aW9uT2JzZXJ2ZXIiLCJjb21wbGV0ZSIsIiRPYnNlcnZhYmxlIiwiT2JzZXJ2YWJsZSIsIml0ZW1zIiwiTVNJRSIsImJvdW5kQXJncyIsIiR0YXNrIiwiVE9fU1RSSU5HX1RBRyIsIkFycmF5VmFsdWVzIiwiRE9NSXRlcmFibGVzIiwiQ1NTUnVsZUxpc3QiLCJDU1NTdHlsZURlY2xhcmF0aW9uIiwiQ1NTVmFsdWVMaXN0IiwiQ2xpZW50UmVjdExpc3QiLCJET01SZWN0TGlzdCIsIkRPTVN0cmluZ0xpc3QiLCJET01Ub2tlbkxpc3QiLCJEYXRhVHJhbnNmZXJJdGVtTGlzdCIsIkZpbGVMaXN0IiwiSFRNTEFsbENvbGxlY3Rpb24iLCJIVE1MQ29sbGVjdGlvbiIsIkhUTUxGb3JtRWxlbWVudCIsIkhUTUxTZWxlY3RFbGVtZW50IiwiTWVkaWFMaXN0IiwiTWltZVR5cGVBcnJheSIsIk5hbWVkTm9kZU1hcCIsIk5vZGVMaXN0IiwiUGFpbnRSZXF1ZXN0TGlzdCIsIlBsdWdpbiIsIlBsdWdpbkFycmF5IiwiU1ZHTGVuZ3RoTGlzdCIsIlNWR051bWJlckxpc3QiLCJTVkdQYXRoU2VnTGlzdCIsIlNWR1BvaW50TGlzdCIsIlNWR1N0cmluZ0xpc3QiLCJTVkdUcmFuc2Zvcm1MaXN0IiwiU291cmNlQnVmZmVyTGlzdCIsIlN0eWxlU2hlZXRMaXN0IiwiVGV4dFRyYWNrQ3VlTGlzdCIsIlRleHRUcmFja0xpc3QiLCJUb3VjaExpc3QiLCJjb2xsZWN0aW9ucyIsImV4cGxpY2l0IiwiQ29sbGVjdGlvbiIsIk9wIiwiaXRlcmF0b3JTeW1ib2wiLCJhc3luY0l0ZXJhdG9yU3ltYm9sIiwiYXN5bmNJdGVyYXRvciIsInRvU3RyaW5nVGFnU3ltYm9sIiwidG9TdHJpbmdUYWciLCJpbk1vZHVsZSIsInJ1bnRpbWUiLCJyZWdlbmVyYXRvclJ1bnRpbWUiLCJpbm5lckZuIiwib3V0ZXJGbiIsInRyeUxvY3NMaXN0IiwicHJvdG9HZW5lcmF0b3IiLCJHZW5lcmF0b3IiLCJnZW5lcmF0b3IiLCJDb250ZXh0IiwiX2ludm9rZSIsIm1ha2VJbnZva2VNZXRob2QiLCJ0cnlDYXRjaCIsIkdlblN0YXRlU3VzcGVuZGVkU3RhcnQiLCJHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkIiwiR2VuU3RhdGVFeGVjdXRpbmciLCJHZW5TdGF0ZUNvbXBsZXRlZCIsIkNvbnRpbnVlU2VudGluZWwiLCJHZW5lcmF0b3JGdW5jdGlvbiIsIkdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlIiwiTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUiLCJHcCIsImRlZmluZUl0ZXJhdG9yTWV0aG9kcyIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJnZW5GdW4iLCJtYXJrIiwiYXdyYXAiLCJfX2F3YWl0IiwiQXN5bmNJdGVyYXRvciIsInJlY29yZCIsInVud3JhcHBlZCIsInByZXZpb3VzUHJvbWlzZSIsImNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnIiwiYXN5bmMiLCJkb25lUmVzdWx0IiwiZGVsZWdhdGUiLCJkZWxlZ2F0ZVJlc3VsdCIsIm1heWJlSW52b2tlRGVsZWdhdGUiLCJzZW50IiwiX3NlbnQiLCJkaXNwYXRjaEV4Y2VwdGlvbiIsImFicnVwdCIsInJldHVybiIsInJlc3VsdE5hbWUiLCJuZXh0TG9jIiwicHVzaFRyeUVudHJ5IiwibG9jcyIsInRyeUxvYyIsImNhdGNoTG9jIiwiZmluYWxseUxvYyIsImFmdGVyTG9jIiwidHJ5RW50cmllcyIsInJlc2V0VHJ5RW50cnkiLCJjb21wbGV0aW9uIiwiaXRlcmF0b3JNZXRob2QiLCJza2lwVGVtcFJlc2V0Iiwic3RvcCIsInJvb3RFbnRyeSIsInJvb3RSZWNvcmQiLCJydmFsIiwiZXhjZXB0aW9uIiwibG9jIiwiY2F1Z2h0IiwiaGFzQ2F0Y2giLCJoYXNGaW5hbGx5IiwiZmluYWxseUVudHJ5IiwiZmluaXNoIiwidGhyb3duIiwiZGVsZWdhdGVZaWVsZCIsIiRyZSIsInJlZ0V4cCIsInBhcnQiLCJ1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCIsImVzY2FwZVVzZXJQcm92aWRlZEtleSIsIkZvckVhY2hCb29rS2VlcGluZyIsImZvckVhY2hGdW5jdGlvbiIsImZvckVhY2hDb250ZXh0IiwiZm9yRWFjaFNpbmdsZUNoaWxkIiwiYm9va0tlZXBpbmciLCJmb3JFYWNoQ2hpbGRyZW4iLCJmb3JFYWNoRnVuYyIsIk1hcEJvb2tLZWVwaW5nIiwibWFwUmVzdWx0Iiwia2V5UHJlZml4IiwibWFwRnVuY3Rpb24iLCJtYXBDb250ZXh0IiwibWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCIsImNoaWxkS2V5IiwibWFwcGVkQ2hpbGQiLCJtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsIiwiZXNjYXBlZFByZWZpeCIsIm1hcENoaWxkcmVuIiwiZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXkiLCJjb3VudENoaWxkcmVuIiwiY3JlYXRlRE9NRmFjdG9yeSIsImFiYnIiLCJhZGRyZXNzIiwiYXJlYSIsImFydGljbGUiLCJhc2lkZSIsImF1ZGlvIiwiYmFzZSIsImJkaSIsImJkbyIsImJsb2NrcXVvdGUiLCJiciIsImNhbnZhcyIsImNhcHRpb24iLCJjaXRlIiwiY29sIiwiY29sZ3JvdXAiLCJkYXRhbGlzdCIsImRkIiwiZGVsIiwiZGV0YWlscyIsImRmbiIsImRpYWxvZyIsImRsIiwiZHQiLCJlbSIsImVtYmVkIiwiZmllbGRzZXQiLCJmaWdjYXB0aW9uIiwiZmlndXJlIiwiZm9vdGVyIiwiZm9ybSIsImgxIiwiaDIiLCJoMyIsImg0IiwiaDUiLCJoNiIsImhlYWRlciIsImhncm91cCIsImhyIiwiaW1nIiwiaW5zIiwia2JkIiwia2V5Z2VuIiwibGFiZWwiLCJsZWdlbmQiLCJsaSIsIm1haW4iLCJtZW51IiwibWVudWl0ZW0iLCJtZXRlciIsIm5hdiIsIm5vc2NyaXB0Iiwib2wiLCJvcHRncm91cCIsIm9wdGlvbiIsInBhcmFtIiwicGljdHVyZSIsInByZSIsInByb2dyZXNzIiwicSIsInJwIiwicnVieSIsInNhbXAiLCJzY3JpcHQiLCJzZWN0aW9uIiwic3BhbiIsInN1bW1hcnkiLCJ0YWJsZSIsInRib2R5IiwidGQiLCJ0ZXh0YXJlYSIsInRmb290IiwidGgiLCJ0aGVhZCIsInRyIiwidWwiLCJ2aWRlbyIsIndiciIsImNpcmNsZSIsImNsaXBQYXRoIiwiZGVmcyIsImVsbGlwc2UiLCJsaW5lIiwibGluZWFyR3JhZGllbnQiLCJtYXNrIiwicGF0dGVybiIsInBvbHlnb24iLCJwb2x5bGluZSIsInJhZGlhbEdyYWRpZW50IiwicmVjdCIsInRzcGFuIiwiUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMiLCJ0eXBlU3BlY3MiLCJkZWJ1Z0lEIiwidHlwZVNwZWNOYW1lIiwiY29tcG9uZW50U3RhY2tJbmZvIiwiY2hpbGRDb250ZXh0IiwiX3JlcXVpcmUiLCJnZXRTdGFjayIsIl9yZXF1aXJlMiIsIl9pbnZhcmlhbnQiLCJNSVhJTlNfS0VZIiwiaWRlbnRpdHkiLCJpbmplY3RlZE1peGlucyIsIlJlYWN0Q2xhc3NJbnRlcmZhY2UiLCJtaXhpbnMiLCJzdGF0aWNzIiwiZ2V0SW5pdGlhbFN0YXRlIiwiY29tcG9uZW50V2lsbE1vdW50IiwidXBkYXRlQ29tcG9uZW50IiwiUkVTRVJWRURfU1BFQ19LRVlTIiwibWl4U3BlY0ludG9Db21wb25lbnQiLCJ2YWxpZGF0ZVR5cGVEZWYiLCJjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbiIsIm1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50IiwiYXV0b2JpbmQiLCJ0eXBlRGVmIiwidmFsaWRhdGVNZXRob2RPdmVycmlkZSIsImlzQWxyZWFkeURlZmluZWQiLCJzcGVjUG9saWN5IiwiUmVhY3RDbGFzc01peGluIiwic3BlYyIsInR5cGVvZlNwZWMiLCJpc01peGluVmFsaWQiLCJhdXRvQmluZFBhaXJzIiwiX19yZWFjdEF1dG9CaW5kUGFpcnMiLCJwcm9wZXJ0eSIsImlzUmVhY3RDbGFzc01ldGhvZCIsInNob3VsZEF1dG9CaW5kIiwiY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uIiwiaXNSZXNlcnZlZCIsImlzSW5oZXJpdGVkIiwibWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyIsIm9uZSIsInR3byIsIm1lcmdlZFJlc3VsdCIsImNoYWluZWRGdW5jdGlvbiIsImJpbmRBdXRvQmluZE1ldGhvZCIsImJvdW5kTWV0aG9kIiwiX19yZWFjdEJvdW5kQ29udGV4dCIsIl9fcmVhY3RCb3VuZE1ldGhvZCIsIl9fcmVhY3RCb3VuZEFyZ3VtZW50cyIsIl9iaW5kIiwibmV3VGhpcyIsInJlYm91bmRNZXRob2QiLCJiaW5kQXV0b0JpbmRNZXRob2RzIiwicGFpcnMiLCJhdXRvQmluZEtleSIsIklzTW91bnRlZFByZU1peGluIiwiX19pc01vdW50ZWQiLCJJc01vdW50ZWRQb3N0TWl4aW4iLCJuZXdTdGF0ZSIsIl9fZGlkV2FybklzTW91bnRlZCIsIlJlYWN0Q2xhc3NDb21wb25lbnQiLCJpbml0aWFsU3RhdGUiLCJfaXNNb2NrRnVuY3Rpb24iLCJjb21wb25lbnRTaG91bGRVcGRhdGUiLCJjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzIiwiUmVhY3REZWZhdWx0SW5qZWN0aW9uIiwiZmluZERPTU5vZGUiLCJpbmplY3QiLCJSZWFjdERPTSIsInVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIiwidW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJNb3VudCIsIlJlY29uY2lsZXIiLCJzaG93RmlsZVVybE1lc3NhZ2UiLCJwcm90b2NvbCIsImRlYnVnIiwidGVzdEZ1bmMiLCJ0ZXN0Rm4iLCJpZUNvbXBhdGliaWxpdHlNb2RlIiwiZXhwZWN0ZWRGZWF0dXJlcyIsIlJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vayIsIlJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vayIsIlJlYWN0RE9NSW52YWxpZEFSSUFIb29rIiwiYWRkSG9vayIsIkFSSUFET01Qcm9wZXJ0eUNvbmZpZyIsIkJlZm9yZUlucHV0RXZlbnRQbHVnaW4iLCJDaGFuZ2VFdmVudFBsdWdpbiIsIkRlZmF1bHRFdmVudFBsdWdpbk9yZGVyIiwiRW50ZXJMZWF2ZUV2ZW50UGx1Z2luIiwiSFRNTERPTVByb3BlcnR5Q29uZmlnIiwiUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQiLCJSZWFjdERPTUNvbXBvbmVudCIsIlJlYWN0RE9NRW1wdHlDb21wb25lbnQiLCJSZWFjdERPTVRyZWVUcmF2ZXJzYWwiLCJSZWFjdERPTVRleHRDb21wb25lbnQiLCJSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5IiwiUmVhY3RJbmplY3Rpb24iLCJTVkdET01Qcm9wZXJ0eUNvbmZpZyIsIlNlbGVjdEV2ZW50UGx1Z2luIiwiU2ltcGxlRXZlbnRQbHVnaW4iLCJhbHJlYWR5SW5qZWN0ZWQiLCJFdmVudEVtaXR0ZXIiLCJIb3N0Q29tcG9uZW50IiwiRW1wdHlDb21wb25lbnQiLCJVcGRhdGVzIiwiRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlIiwiU3ludGhldGljQ29tcG9zaXRpb25FdmVudCIsIlN5bnRoZXRpY0lucHV0RXZlbnQiLCJFTkRfS0VZQ09ERVMiLCJTVEFSVF9LRVlDT0RFIiwiY2FuVXNlQ29tcG9zaXRpb25FdmVudCIsImNhblVzZVRleHRJbnB1dEV2ZW50IiwiaXNQcmVzdG8iLCJ1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSIsIm9wZXJhIiwiU1BBQ0VCQVJfQ09ERSIsIlNQQUNFQkFSX0NIQVIiLCJiZWZvcmVJbnB1dCIsImJ1YmJsZWQiLCJjYXB0dXJlZCIsImNvbXBvc2l0aW9uRW5kIiwiY29tcG9zaXRpb25TdGFydCIsImNvbXBvc2l0aW9uVXBkYXRlIiwiaGFzU3BhY2VLZXlwcmVzcyIsImlzS2V5cHJlc3NDb21tYW5kIiwiZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUiLCJpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCIsImlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCIsImdldERhdGFGcm9tQ3VzdG9tRXZlbnQiLCJjdXJyZW50Q29tcG9zaXRpb24iLCJleHRyYWN0Q29tcG9zaXRpb25FdmVudCIsImZhbGxiYWNrRGF0YSIsImdldERhdGEiLCJjdXN0b21EYXRhIiwiZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyIsIndoaWNoIiwiZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzIiwiZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQiLCJfcm9vdCIsIl9zdGFydFRleHQiLCJfZmFsbGJhY2tUZXh0Iiwic3RhcnRWYWx1ZSIsInN0YXJ0TGVuZ3RoIiwiZW5kVmFsdWUiLCJlbmRMZW5ndGgiLCJtaW5FbmQiLCJzbGljZVRhaWwiLCJDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlIiwiSW5wdXRFdmVudEludGVyZmFjZSIsImNoYW5nZSIsImNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudCIsImFjdGl2ZUVsZW1lbnRJbnN0Iiwic2hvdWxkVXNlQ2hhbmdlRXZlbnQiLCJkb2VzQ2hhbmdlRXZlbnRCdWJibGUiLCJtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50IiwicnVuRXZlbnRJbkJhdGNoIiwic3RhcnRXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4Iiwic3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgiLCJnZXRJbnN0SWZWYWx1ZUNoYW5nZWQiLCJ1cGRhdGVkIiwiX2FsbG93U2ltdWxhdGVkUGFzc1Rocm91Z2giLCJnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQiLCJoYW5kbGVFdmVudHNGb3JDaGFuZ2VFdmVudElFOCIsImlzSW5wdXRFdmVudFN1cHBvcnRlZCIsInN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSIsImhhbmRsZVByb3BlcnR5Q2hhbmdlIiwic3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UiLCJoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGwiLCJnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsIiwic2hvdWxkVXNlQ2xpY2tFdmVudCIsImdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50IiwiZ2V0VGFyZ2V0SW5zdEZvcklucHV0T3JDaGFuZ2VFdmVudCIsImhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIiLCJjb250cm9sbGVkIiwiX2lzSW5wdXRFdmVudFN1cHBvcnRlZCIsInRhcmdldE5vZGUiLCJnZXRUYXJnZXRJbnN0RnVuYyIsImhhbmRsZUV2ZW50RnVuYyIsIlJlYWN0T3duZXIiLCJhdHRhY2hSZWYiLCJhZGRDb21wb25lbnRBc1JlZlRvIiwiZGV0YWNoUmVmIiwicmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tIiwicHJldlJlZiIsInByZXZPd25lciIsIm5leHRSZWYiLCJuZXh0T3duZXIiLCJpc1ZhbGlkT3duZXIiLCJvd25lclB1YmxpY0luc3RhbmNlIiwiUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vayIsIlJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rIiwicGVyZm9ybWFuY2VOb3ciLCJob29rcyIsImRpZEhvb2tUaHJvd0ZvckV2ZW50IiwiY2FsbEhvb2siLCJhcmc0IiwiYXJnNSIsImVtaXRFdmVudCIsImhvb2siLCJpc1Byb2ZpbGluZyIsImZsdXNoSGlzdG9yeSIsImxpZmVDeWNsZVRpbWVyU3RhY2siLCJjdXJyZW50Rmx1c2hOZXN0aW5nIiwiY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzIiwiY3VycmVudEZsdXNoU3RhcnRUaW1lIiwiY3VycmVudFRpbWVyRGVidWdJRCIsImN1cnJlbnRUaW1lclN0YXJ0VGltZSIsImN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24iLCJjdXJyZW50VGltZXJUeXBlIiwibGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQiLCJjbGVhckhpc3RvcnkiLCJnZXRUcmVlU25hcHNob3QiLCJyZWdpc3RlcmVkSURzIiwicmVzZXRNZWFzdXJlbWVudHMiLCJwcmV2aW91c1N0YXJ0VGltZSIsInByZXZpb3VzTWVhc3VyZW1lbnRzIiwicHJldmlvdXNPcGVyYXRpb25zIiwiZ2V0SGlzdG9yeSIsImR1cmF0aW9uIiwibWVhc3VyZW1lbnRzIiwib3BlcmF0aW9ucyIsInRyZWVTbmFwc2hvdCIsImNoZWNrRGVidWdJRCIsImFsbG93Um9vdCIsImJlZ2luTGlmZUN5Y2xlVGltZXIiLCJ0aW1lclR5cGUiLCJlbmRMaWZlQ3ljbGVUaW1lciIsInBhdXNlQ3VycmVudExpZmVDeWNsZVRpbWVyIiwiY3VycmVudFRpbWVyIiwic3RhcnRUaW1lIiwibmVzdGVkRmx1c2hTdGFydFRpbWUiLCJyZXN1bWVDdXJyZW50TGlmZUN5Y2xlVGltZXIiLCJfbGlmZUN5Y2xlVGltZXJTdGFjayQiLCJuZXN0ZWRGbHVzaER1cmF0aW9uIiwibGFzdE1hcmtUaW1lU3RhbXAiLCJjYW5Vc2VQZXJmb3JtYW5jZU1lYXN1cmUiLCJwZXJmb3JtYW5jZSIsImNsZWFyTWFya3MiLCJtZWFzdXJlIiwiY2xlYXJNZWFzdXJlcyIsInNob3VsZE1hcmsiLCJpc0hvc3RFbGVtZW50IiwibWFya0JlZ2luIiwibWFya1R5cGUiLCJtYXJrTmFtZSIsIm1hcmtFbmQiLCJtZWFzdXJlbWVudE5hbWUiLCJyZW1vdmVIb29rIiwiYmVnaW5Qcm9maWxpbmciLCJlbmRQcm9maWxpbmciLCJnZXRGbHVzaEhpc3RvcnkiLCJvbkJlZ2luTGlmZUN5Y2xlVGltZXIiLCJvbkVuZExpZmVDeWNsZVRpbWVyIiwib25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQiLCJvbkVuZFByb2Nlc3NpbmdDaGlsZENvbnRleHQiLCJvcGVyYXRpb24iLCJjaGlsZERlYnVnSURzIiwib25UZXN0RXZlbnQiLCJhZGREZXZ0b29sIiwicmVtb3ZlRGV2dG9vbCIsImhyZWYiLCJwcm9jZXNzaW5nQ2hpbGRDb250ZXh0Iiwid2FybkludmFsaWRTZXRTdGF0ZSIsImhpc3RvcnkiLCJfcHJldmVudENsZWFyaW5nIiwibXNQZXJmb3JtYW5jZSIsIndlYmtpdFBlcmZvcm1hbmNlIiwibW91c2VFbnRlciIsIm1vdXNlTGVhdmUiLCJ3aW4iLCJyZWxhdGVkIiwidG9Ob2RlIiwiYWNjZXB0IiwiYWNjZXB0Q2hhcnNldCIsImFjY2Vzc0tleSIsImFsbG93RnVsbFNjcmVlbiIsImFsbG93VHJhbnNwYXJlbmN5IiwiYWx0IiwiYXMiLCJhdXRvQ29tcGxldGUiLCJhdXRvUGxheSIsImNlbGxQYWRkaW5nIiwiY2VsbFNwYWNpbmciLCJjaGFyU2V0IiwiY2hhbGxlbmdlIiwiY2xhc3NJRCIsImNsYXNzTmFtZSIsImNvbHMiLCJjb2xTcGFuIiwiY29udGV4dE1lbnUiLCJjb250cm9scyIsImNvb3JkcyIsImNyb3NzT3JpZ2luIiwiZGF0ZVRpbWUiLCJkb3dubG9hZCIsImRyYWdnYWJsZSIsImVuY1R5cGUiLCJmb3JtQWN0aW9uIiwiZm9ybUVuY1R5cGUiLCJmb3JtTWV0aG9kIiwiZm9ybU5vVmFsaWRhdGUiLCJmb3JtVGFyZ2V0IiwiZnJhbWVCb3JkZXIiLCJoZWFkZXJzIiwiaGVpZ2h0IiwiaGlnaCIsImhyZWZMYW5nIiwiaHRtbEZvciIsImh0dHBFcXVpdiIsImljb24iLCJpbnB1dE1vZGUiLCJpbnRlZ3JpdHkiLCJrZXlQYXJhbXMiLCJrZXlUeXBlIiwibGFuZyIsImxvb3AiLCJsb3ciLCJtYW5pZmVzdCIsIm1hcmdpbkhlaWdodCIsIm1hcmdpbldpZHRoIiwibWVkaWEiLCJtZWRpYUdyb3VwIiwibWluTGVuZ3RoIiwibXV0ZWQiLCJub25jZSIsIm5vVmFsaWRhdGUiLCJvcHRpbXVtIiwicGxhY2Vob2xkZXIiLCJwbGF5c0lubGluZSIsInBvc3RlciIsInByZWxvYWQiLCJwcm9maWxlIiwicmFkaW9Hcm91cCIsInJlZmVycmVyUG9saWN5IiwicmVsIiwicmVxdWlyZWQiLCJyZXZlcnNlZCIsInJvbGUiLCJyb3dzIiwicm93U3BhbiIsInNhbmRib3giLCJzY29wZWQiLCJzY3JvbGxpbmciLCJzZWFtbGVzcyIsInNpemVzIiwic3BlbGxDaGVjayIsInNyY0RvYyIsInNyY0xhbmciLCJzcmNTZXQiLCJ0YWJJbmRleCIsInVzZU1hcCIsIndpZHRoIiwid21vZGUiLCJhYm91dCIsImRhdGF0eXBlIiwiaW5saXN0IiwicmVzb3VyY2UiLCJ2b2NhYiIsImF1dG9DYXBpdGFsaXplIiwiYXV0b0NvcnJlY3QiLCJhdXRvU2F2ZSIsIml0ZW1Qcm9wIiwiaXRlbVNjb3BlIiwiaXRlbVR5cGUiLCJpdGVtSUQiLCJpdGVtUmVmIiwicmVzdWx0cyIsInNlY3VyaXR5IiwidW5zZWxlY3RhYmxlIiwidmFsaWRpdHkiLCJiYWRJbnB1dCIsIlJlYWN0RE9NSURPcGVyYXRpb25zIiwiZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzIiwiY3JlYXRlTm9kZXNGcm9tTWFya3VwIiwibmV3Q2hpbGQiLCJjcmVhdGVBcnJheUZyb21NaXhlZCIsImdldE1hcmt1cFdyYXAiLCJkdW1teU5vZGUiLCJub2RlTmFtZVBhdHRlcm4iLCJnZXROb2RlTmFtZSIsIm5vZGVOYW1lTWF0Y2giLCJoYW5kbGVTY3JpcHQiLCJ3cmFwRGVwdGgiLCJzY3JpcHRzIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJub2RlcyIsImNoaWxkTm9kZXMiLCJoYXNBcnJheU5hdHVyZSIsInNob3VsZFdyYXAiLCJzZWxlY3RXcmFwIiwidGFibGVXcmFwIiwidHJXcmFwIiwic3ZnV3JhcCIsIm1hcmt1cFdyYXAiLCJzdmdFbGVtZW50cyIsIkF1dG9Gb2N1c1V0aWxzIiwiQ1NTUHJvcGVydHlPcGVyYXRpb25zIiwiUmVhY3RET01JbnB1dCIsIlJlYWN0RE9NT3B0aW9uIiwiUmVhY3RET01UZXh0YXJlYSIsIlJlYWN0TXVsdGlDaGlsZCIsIlJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24iLCJnZXROb2RlIiwiQ09OVEVOVF9UWVBFUyIsIlNUWUxFIiwiSFRNTCIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIiwiRE9DX0ZSQUdNRU5UX1RZUEUiLCJmcmllbmRseVN0cmluZ2lmeSIsImtleUVzY2FwZWQiLCJzdHlsZU11dGF0aW9uV2FybmluZyIsImNoZWNrQW5kV2FybkZvck11dGF0ZWRTdHlsZSIsInN0eWxlMSIsInN0eWxlMiIsIl90YWciLCJhc3NlcnRWYWxpZFByb3BzIiwidm9pZEVsZW1lbnRUYWdzIiwib25Gb2N1c0luIiwib25Gb2N1c091dCIsImVucXVldWVQdXRMaXN0ZW5lciIsImNvbnRhaW5lckluZm8iLCJpc0RvY3VtZW50RnJhZ21lbnQiLCJfbm9kZSIsIl9vd25lckRvY3VtZW50IiwibGlzdGVuZXJUb1B1dCIsImlucHV0UG9zdE1vdW50IiwicG9zdE1vdW50V3JhcHBlciIsInRleHRhcmVhUG9zdE1vdW50Iiwib3B0aW9uUG9zdE1vdW50Iiwic2V0QW5kVmFsaWRhdGVDb250ZW50Q2hpbGREZXYiLCJoYXNFeGlzdGluZ0NvbnRlbnQiLCJfY29udGVudERlYnVnSUQiLCJjb250ZW50RGVidWdJRCIsIl9hbmNlc3RvckluZm8iLCJtZWRpYUV2ZW50cyIsInRyYWNrSW5wdXRWYWx1ZSIsInRyYXBCdWJibGVkRXZlbnRzTG9jYWwiLCJwb3N0VXBkYXRlU2VsZWN0V3JhcHBlciIsIm9taXR0ZWRDbG9zZVRhZ3MiLCJuZXdsaW5lRWF0aW5nVGFncyIsImxpc3RpbmciLCJWQUxJRF9UQUdfUkVHRVgiLCJ2YWxpZGF0ZWRUYWdDYWNoZSIsInZhbGlkYXRlRGFuZ2Vyb3VzVGFnIiwiaXNDdXN0b21Db21wb25lbnQiLCJnbG9iYWxJZENvdW50ZXIiLCJfbmFtZXNwYWNlVVJJIiwiX3ByZXZpb3VzU3R5bGUiLCJfcHJldmlvdXNTdHlsZUNvcHkiLCJNaXhpbiIsIl9pZENvdW50ZXIiLCJtb3VudEltYWdlIiwiY3JlYXRlRWxlbWVudE5TIiwiX3VwZGF0ZURPTVByb3BlcnRpZXMiLCJsYXp5VHJlZSIsIl9jcmVhdGVJbml0aWFsQ2hpbGRyZW4iLCJ0YWdPcGVuIiwiX2NyZWF0ZU9wZW5UYWdNYXJrdXBBbmRQdXRMaXN0ZW5lcnMiLCJ0YWdDb250ZW50IiwiX2NyZWF0ZUNvbnRlbnRNYXJrdXAiLCJhdXRvRm9jdXMiLCJmb2N1c0RPTUNvbXBvbmVudCIsInByb3BLZXkiLCJjcmVhdGVNYXJrdXBGb3JTdHlsZXMiLCJyZW5kZXJUb1N0YXRpY01hcmt1cCIsIl9faHRtbCIsImNvbnRlbnRUb1VzZSIsImNoaWxkcmVuVG9Vc2UiLCJtb3VudEltYWdlcyIsIm1vdW50Q2hpbGRyZW4iLCJsYXN0UHJvcHMiLCJfdXBkYXRlRE9NQ2hpbGRyZW4iLCJ1cGRhdGVXcmFwcGVyIiwic3R5bGVOYW1lIiwic3R5bGVVcGRhdGVzIiwibGFzdFN0eWxlIiwibmV4dFByb3AiLCJsYXN0UHJvcCIsInNldFZhbHVlRm9yU3R5bGVzIiwibGFzdENvbnRlbnQiLCJuZXh0Q29udGVudCIsImxhc3RIdG1sIiwibmV4dEh0bWwiLCJsYXN0Q2hpbGRyZW4iLCJuZXh0Q2hpbGRyZW4iLCJsYXN0SGFzQ29udGVudE9ySHRtbCIsIm5leHRIYXNDb250ZW50T3JIdG1sIiwidXBkYXRlQ2hpbGRyZW4iLCJ1cGRhdGVUZXh0Q29udGVudCIsInVwZGF0ZU1hcmt1cCIsInVubW91bnRDaGlsZHJlbiIsImNhbWVsaXplU3R5bGVOYW1lIiwiZGFuZ2Vyb3VzU3R5bGVWYWx1ZSIsImh5cGhlbmF0ZVN0eWxlTmFtZSIsIm1lbW9pemVTdHJpbmdPbmx5IiwicHJvY2Vzc1N0eWxlTmFtZSIsImhhc1Nob3J0aGFuZFByb3BlcnR5QnVnIiwic3R5bGVGbG9hdEFjY2Vzc29yIiwidGVtcFN0eWxlIiwiY3NzRmxvYXQiLCJiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4iLCJiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4iLCJ3YXJuZWRTdHlsZU5hbWVzIiwid2FybmVkU3R5bGVWYWx1ZXMiLCJ3YXJuZWRGb3JOYU5WYWx1ZSIsIndhcm5IeXBoZW5hdGVkU3R5bGVOYW1lIiwiY2hlY2tSZW5kZXJNZXNzYWdlIiwid2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lIiwid2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uIiwid2FyblN0eWxlVmFsdWVJc05hTiIsIndhcm5WYWxpZFN0eWxlIiwic2VyaWFsaXplZCIsImlzQ3VzdG9tUHJvcGVydHkiLCJzdHlsZVZhbHVlIiwic2V0UHJvcGVydHkiLCJleHBhbnNpb24iLCJpbmRpdmlkdWFsU3R5bGVOYW1lIiwiY2FtZWxpemUiLCJtc1BhdHRlcm4iLCJfaHlwaGVuUGF0dGVybiIsImNoYXJhY3RlciIsInN0eWxlV2FybmluZ3MiLCJpc0VtcHR5IiwiaXNOb25OdW1lcmljIiwid2FybmVkIiwiaHlwaGVuYXRlIiwiX3VwcGVyY2FzZVBhdHRlcm4iLCJjYWNoZSIsInJ1bkV2ZW50UXVldWVJbkJhdGNoIiwibWFrZVByZWZpeE1hcCIsInN0eWxlUHJvcCIsInZlbmRvclByZWZpeGVzIiwiYW5pbWF0aW9uZW5kIiwiYW5pbWF0aW9uaXRlcmF0aW9uIiwiYW5pbWF0aW9uc3RhcnQiLCJ0cmFuc2l0aW9uZW5kIiwicHJlZml4ZWRFdmVudE5hbWVzIiwiYW5pbWF0aW9uIiwidHJhbnNpdGlvbiIsInByZWZpeE1hcCIsImRpZFdhcm5DaGVja2VkTGluayIsImRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQiLCJkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkIiwiZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCIsImZvcmNlVXBkYXRlSWZNb3VudGVkIiwiaXNDb250cm9sbGVkIiwidXNlc0NoZWNrZWQiLCJob3N0UHJvcHMiLCJkZWZhdWx0Q2hlY2tlZCIsImluaXRpYWxDaGVja2VkIiwidmFsdWVBc051bWJlciIsInJvb3ROb2RlIiwicXVlcnlSb290IiwicXVlcnlTZWxlY3RvckFsbCIsIm90aGVyTm9kZSIsIm90aGVySW5zdGFuY2UiLCJkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuIiwiZmxhdHRlbkNoaWxkcmVuIiwic2VsZWN0VmFsdWUiLCJzZWxlY3RQYXJlbnQiLCJkaWRXYXJuVmFsRGVmYXVsdFZhbCIsIm5ld1ZhbHVlIiwiUmVhY3RDaGlsZFJlY29uY2lsZXIiLCJtYWtlSW5zZXJ0TWFya3VwIiwibWFrZU1vdmUiLCJtYWtlUmVtb3ZlIiwibWFrZVNldE1hcmt1cCIsIm1ha2VUZXh0Q29udGVudCIsInByb2Nlc3NRdWV1ZSIsInVwZGF0ZVF1ZXVlIiwic2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24iLCJnZXREZWJ1Z0lEIiwiX3JlY29uY2lsZXJJbnN0YW50aWF0ZUNoaWxkcmVuIiwibmVzdGVkQ2hpbGRyZW4iLCJzZWxmRGVidWdJRCIsImluc3RhbnRpYXRlQ2hpbGRyZW4iLCJfcmVjb25jaWxlclVwZGF0ZUNoaWxkcmVuIiwicHJldkNoaWxkcmVuIiwibmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMiLCJyZW1vdmVkTm9kZXMiLCJuZXh0TWFya3VwIiwiX3VwZGF0ZUNoaWxkcmVuIiwibmV4dEluZGV4IiwibmV4dE1vdW50SW5kZXgiLCJsYXN0UGxhY2VkTm9kZSIsInByZXZDaGlsZCIsIl9tb3VudENoaWxkQXRJbmRleCIsIl91bm1vdW50Q2hpbGQiLCJyZW5kZXJlZENoaWxkcmVuIiwiY3JlYXRlQ2hpbGQiLCJpbnN0YW50aWF0ZUNoaWxkIiwiY2hpbGRJbnN0YW5jZXMiLCJrZXlVbmlxdWUiLCJuZXN0ZWRDaGlsZE5vZGVzIiwiY2hpbGRJbnN0cyIsIm5leHRDaGlsZEluc3RhbmNlIiwibmV4dENoaWxkTW91bnRJbWFnZSIsInJlbmRlcmVkQ2hpbGQiLCJDb21wb3NpdGVUeXBlcyIsIkltcHVyZUNsYXNzIiwiUHVyZUNsYXNzIiwiU3RhdGVsZXNzRnVuY3Rpb25hbCIsIlN0YXRlbGVzc0NvbXBvbmVudCIsIndhcm5JZkludmFsaWRFbGVtZW50Iiwic2hvdWxkQ29uc3RydWN0IiwiaXNQdXJlQ29tcG9uZW50IiwibWVhc3VyZUxpZmVDeWNsZVBlcmYiLCJuZXh0TW91bnRJRCIsIl9jb21wb3NpdGVUeXBlIiwiX2NhbGxlZENvbXBvbmVudFdpbGxVbm1vdW50IiwicHVibGljUHJvcHMiLCJwdWJsaWNDb250ZXh0IiwiX3Byb2Nlc3NDb250ZXh0IiwiZ2V0VXBkYXRlUXVldWUiLCJkb0NvbnN0cnVjdCIsIl9jb25zdHJ1Y3RDb21wb25lbnQiLCJyZW5kZXJlZEVsZW1lbnQiLCJwcm9wc011dGF0ZWQiLCJjb21wb25lbnREaWRVbm1vdW50IiwidW5zdGFibGVfaGFuZGxlRXJyb3IiLCJwZXJmb3JtSW5pdGlhbE1vdW50V2l0aEVycm9ySGFuZGxpbmciLCJwZXJmb3JtSW5pdGlhbE1vdW50IiwiX2NvbnN0cnVjdENvbXBvbmVudFdpdGhvdXRPd25lciIsIl9wcm9jZXNzUGVuZGluZ1N0YXRlIiwiX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCIsIl9tYXNrQ29udGV4dCIsIm1hc2tlZENvbnRleHQiLCJjb250ZXh0TmFtZSIsIl9jaGVja0NvbnRleHRUeXBlcyIsImN1cnJlbnRDb250ZXh0IiwicHJldkNvbnRleHQiLCJwcmV2UGFyZW50RWxlbWVudCIsIm5leHRQYXJlbnRFbGVtZW50IiwicHJldlVubWFza2VkQ29udGV4dCIsIm5leHRVbm1hc2tlZENvbnRleHQiLCJ3aWxsUmVjZWl2ZSIsInByZXZQcm9wcyIsIm5leHRTdGF0ZSIsInNob3VsZFVwZGF0ZSIsIl9wZXJmb3JtQ29tcG9uZW50VXBkYXRlIiwicGFydGlhbCIsInVubWFza2VkQ29udGV4dCIsImhhc0NvbXBvbmVudERpZFVwZGF0ZSIsInByZXZTdGF0ZSIsIl91cGRhdGVSZW5kZXJlZENvbXBvbmVudCIsInByZXZDb21wb25lbnRJbnN0YW5jZSIsInByZXZSZW5kZXJlZEVsZW1lbnQiLCJuZXh0UmVuZGVyZWRFbGVtZW50Iiwib2xkSG9zdE5vZGUiLCJfcmVwbGFjZU5vZGVXaXRoTWFya3VwIiwiX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dCIsInB1YmxpY0NvbXBvbmVudEluc3RhbmNlIiwibmV4dERlYnVnSUQiLCJmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCIsIlJlYWN0U2VydmVyVXBkYXRlUXVldWUiLCJub29wQ2FsbGJhY2tRdWV1ZSIsImRvbUlEIiwiY3JlYXRlQ29tbWVudCIsImluc3RBIiwiaW5zdEIiLCJkZXB0aEEiLCJ0ZW1wQSIsImRlcHRoQiIsInRlbXBCIiwicGF0aEZyb20iLCJwYXRoVG8iLCJfc3RyaW5nVGV4dCIsIl9jbG9zaW5nQ29tbWVudCIsIl9jb21tZW50Tm9kZXMiLCJvcGVuaW5nVmFsdWUiLCJjbG9zaW5nVmFsdWUiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiZXNjYXBlZFRleHQiLCJuZXh0VGV4dCIsIm5leHRTdHJpbmdUZXh0IiwiY29tbWVudE5vZGVzIiwiUkVTRVRfQkFUQ0hFRF9VUERBVEVTIiwiRkxVU0hfQkFUQ0hFRF9VUERBVEVTIiwiUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uIiwiYWxyZWFkeUJhdGNoaW5nVXBkYXRlcyIsImdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uIiwiZmluZFBhcmVudCIsIlRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyIsImFuY2VzdG9ycyIsImhhbmRsZVRvcExldmVsSW1wbCIsImFuY2VzdG9yIiwiX2hhbmRsZVRvcExldmVsIiwic2Nyb2xsVmFsdWVNb25pdG9yIiwiX2VuYWJsZWQiLCJzY3JvbGxhYmxlIiwiV2luZG93IiwicGFnZVhPZmZzZXQiLCJzY3JvbGxMZWZ0IiwicGFnZVlPZmZzZXQiLCJzY3JvbGxUb3AiLCJTRUxFQ1RJT05fUkVTVE9SQVRJT04iLCJFVkVOVF9TVVBQUkVTU0lPTiIsImN1cnJlbnRseUVuYWJsZWQiLCJwcmV2aW91c2x5RW5hYmxlZCIsIk9OX0RPTV9SRUFEWV9RVUVVRUlORyIsInJlYWN0TW91bnRSZWFkeSIsImdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQiLCJpc0NvbGxhcHNlZCIsImFuY2hvck5vZGUiLCJhbmNob3JPZmZzZXQiLCJmb2N1c09mZnNldCIsImdldElFT2Zmc2V0cyIsInNlbGVjdGVkUmFuZ2UiLCJzZWxlY3RlZExlbmd0aCIsImZyb21TdGFydCIsImR1cGxpY2F0ZSIsIm1vdmVUb0VsZW1lbnRUZXh0Iiwic2V0RW5kUG9pbnQiLCJzdGFydE9mZnNldCIsImVuZE9mZnNldCIsImdldE1vZGVybk9mZnNldHMiLCJyYW5nZUNvdW50IiwiY3VycmVudFJhbmdlIiwiZ2V0UmFuZ2VBdCIsInN0YXJ0Q29udGFpbmVyIiwiZW5kQ29udGFpbmVyIiwiaXNTZWxlY3Rpb25Db2xsYXBzZWQiLCJyYW5nZUxlbmd0aCIsInRlbXBSYW5nZSIsImNsb25lUmFuZ2UiLCJzZWxlY3ROb2RlQ29udGVudHMiLCJzZXRFbmQiLCJpc1RlbXBSYW5nZUNvbGxhcHNlZCIsImRldGVjdGlvblJhbmdlIiwic2V0U3RhcnQiLCJpc0JhY2t3YXJkIiwiY29sbGFwc2VkIiwic2V0SUVPZmZzZXRzIiwic2V0TW9kZXJuT2Zmc2V0cyIsImV4dGVuZCIsInRlbXAiLCJzdGFydE1hcmtlciIsImVuZE1hcmtlciIsInJlbW92ZUFsbFJhbmdlcyIsImFkZFJhbmdlIiwidXNlSUVPZmZzZXRzIiwiZ2V0TGVhZk5vZGUiLCJnZXRTaWJsaW5nTm9kZSIsIm5vZGVTdGFydCIsIm5vZGVFbmQiLCJpc1RleHROb2RlIiwib3V0ZXJOb2RlIiwiaW5uZXJOb2RlIiwiY29udGFpbnMiLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsIk5vZGUiLCJOUyIsInhsaW5rIiwieG1sIiwiQVRUUlMiLCJhY2NlbnRIZWlnaHQiLCJhY2N1bXVsYXRlIiwiYWRkaXRpdmUiLCJhbGlnbm1lbnRCYXNlbGluZSIsImFsbG93UmVvcmRlciIsImFscGhhYmV0aWMiLCJhbXBsaXR1ZGUiLCJhcmFiaWNGb3JtIiwiYXNjZW50IiwiYXR0cmlidXRlVHlwZSIsImF1dG9SZXZlcnNlIiwiYXppbXV0aCIsImJhc2VGcmVxdWVuY3kiLCJiYXNlUHJvZmlsZSIsImJhc2VsaW5lU2hpZnQiLCJiYm94IiwiYmlhcyIsImJ5IiwiY2FsY01vZGUiLCJjYXBIZWlnaHQiLCJjbGlwIiwiY2xpcFJ1bGUiLCJjbGlwUGF0aFVuaXRzIiwiY29sb3JJbnRlcnBvbGF0aW9uIiwiY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycyIsImNvbG9yUHJvZmlsZSIsImNvbG9yUmVuZGVyaW5nIiwiY29udGVudFNjcmlwdFR5cGUiLCJjb250ZW50U3R5bGVUeXBlIiwiY3Vyc29yIiwiY3giLCJjeSIsImRlY2VsZXJhdGUiLCJkZXNjZW50IiwiZGlmZnVzZUNvbnN0YW50IiwiZGlyZWN0aW9uIiwiZGl2aXNvciIsImRvbWluYW50QmFzZWxpbmUiLCJkdXIiLCJkeCIsImR5IiwiZWRnZU1vZGUiLCJlbGV2YXRpb24iLCJlbmFibGVCYWNrZ3JvdW5kIiwiZXhwb25lbnQiLCJleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkIiwiZmlsbFJ1bGUiLCJmaWx0ZXJSZXMiLCJmaWx0ZXJVbml0cyIsImZsb29kQ29sb3IiLCJmb2N1c2FibGUiLCJmb250U2l6ZUFkanVzdCIsImZvbnRTdHJldGNoIiwiZngiLCJmeSIsImcxIiwiZzIiLCJnbHlwaE5hbWUiLCJnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCIsImdseXBoT3JpZW50YXRpb25WZXJ0aWNhbCIsImdseXBoUmVmIiwiZ3JhZGllbnRUcmFuc2Zvcm0iLCJncmFkaWVudFVuaXRzIiwiaGFuZ2luZyIsImhvcml6QWR2WCIsImhvcml6T3JpZ2luWCIsImlkZW9ncmFwaGljIiwiaW1hZ2VSZW5kZXJpbmciLCJpbjIiLCJpbnRlcmNlcHQiLCJrMSIsImsyIiwiazMiLCJrNCIsImtlcm5lbE1hdHJpeCIsImtlcm5lbFVuaXRMZW5ndGgiLCJrZXJuaW5nIiwia2V5UG9pbnRzIiwia2V5U3BsaW5lcyIsImtleVRpbWVzIiwibGVuZ3RoQWRqdXN0IiwibGV0dGVyU3BhY2luZyIsImxpZ2h0aW5nQ29sb3IiLCJsaW1pdGluZ0NvbmVBbmdsZSIsImxvY2FsIiwibWFya2VyRW5kIiwibWFya2VyTWlkIiwibWFya2VyU3RhcnQiLCJtYXJrZXJIZWlnaHQiLCJtYXJrZXJVbml0cyIsIm1hcmtlcldpZHRoIiwibWFza0NvbnRlbnRVbml0cyIsIm1hc2tVbml0cyIsIm1hdGhlbWF0aWNhbCIsIm1vZGUiLCJudW1PY3RhdmVzIiwib3BlcmF0b3IiLCJvcmllbnQiLCJvcmllbnRhdGlvbiIsIm9yaWdpbiIsIm92ZXJsaW5lUG9zaXRpb24iLCJvdmVybGluZVRoaWNrbmVzcyIsInBhaW50T3JkZXIiLCJwYW5vc2UxIiwicGF0aExlbmd0aCIsInBhdHRlcm5Db250ZW50VW5pdHMiLCJwYXR0ZXJuVHJhbnNmb3JtIiwicGF0dGVyblVuaXRzIiwicG9pbnRlckV2ZW50cyIsInBvaW50cyIsInBvaW50c0F0WCIsInBvaW50c0F0WSIsInBvaW50c0F0WiIsInByZXNlcnZlQWxwaGEiLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIiwicHJpbWl0aXZlVW5pdHMiLCJyYWRpdXMiLCJyZWZYIiwicmVmWSIsInJlbmRlcmluZ0ludGVudCIsInJlcGVhdENvdW50IiwicmVwZWF0RHVyIiwicmVxdWlyZWRFeHRlbnNpb25zIiwicmVxdWlyZWRGZWF0dXJlcyIsInJlc3RhcnQiLCJyb3RhdGUiLCJyeSIsInNlZWQiLCJzaGFwZVJlbmRlcmluZyIsInNsb3BlIiwic3BhY2luZyIsInNwZWN1bGFyQ29uc3RhbnQiLCJzcGVjdWxhckV4cG9uZW50Iiwic3BlZWQiLCJzcHJlYWRNZXRob2QiLCJzdGREZXZpYXRpb24iLCJzdGVtaCIsInN0ZW12Iiwic3RpdGNoVGlsZXMiLCJzdG9wQ29sb3IiLCJzdHJpa2V0aHJvdWdoUG9zaXRpb24iLCJzdHJpa2V0aHJvdWdoVGhpY2tuZXNzIiwic3Ryb2tlIiwic3Ryb2tlTGluZWNhcCIsInN0cm9rZUxpbmVqb2luIiwic3VyZmFjZVNjYWxlIiwic3lzdGVtTGFuZ3VhZ2UiLCJ0YWJsZVZhbHVlcyIsInRhcmdldFgiLCJ0YXJnZXRZIiwidGV4dEFuY2hvciIsInRleHREZWNvcmF0aW9uIiwidGV4dFJlbmRlcmluZyIsInRleHRMZW5ndGgiLCJ0cmFuc2Zvcm0iLCJ1MiIsInVuZGVybGluZVBvc2l0aW9uIiwidW5kZXJsaW5lVGhpY2tuZXNzIiwidW5pY29kZUJpZGkiLCJ1bmljb2RlUmFuZ2UiLCJ1bml0c1BlckVtIiwidkFscGhhYmV0aWMiLCJ2SGFuZ2luZyIsInZJZGVvZ3JhcGhpYyIsInZNYXRoZW1hdGljYWwiLCJ2ZWN0b3JFZmZlY3QiLCJ2ZXJ0QWR2WSIsInZlcnRPcmlnaW5YIiwidmVydE9yaWdpblkiLCJ2aWV3Qm94Iiwidmlld1RhcmdldCIsInZpc2liaWxpdHkiLCJ3aWR0aHMiLCJ3b3JkU3BhY2luZyIsIndyaXRpbmdNb2RlIiwieEhlaWdodCIsInhDaGFubmVsU2VsZWN0b3IiLCJ4bGlua0FjdHVhdGUiLCJ4bGlua0FyY3JvbGUiLCJ4bGlua0hyZWYiLCJ4bGlua1JvbGUiLCJ4bGlua1Nob3ciLCJ4bGlua1RpdGxlIiwieGxpbmtUeXBlIiwieG1sQmFzZSIsInhtbG5zIiwieG1sbnNYbGluayIsInhtbExhbmciLCJ4bWxTcGFjZSIsInkyIiwieUNoYW5uZWxTZWxlY3RvciIsInpvb21BbmRQYW4iLCJza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQiLCJsYXN0U2VsZWN0aW9uIiwibW91c2VEb3duIiwiaGFzTGlzdGVuZXIiLCJib3VuZGluZ1RvcCIsImJvdW5kaW5nTGVmdCIsImNvbnN0cnVjdFNlbGVjdEV2ZW50IiwiY3VycmVudFNlbGVjdGlvbiIsIlN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50IiwiU3ludGhldGljQ2xpcGJvYXJkRXZlbnQiLCJTeW50aGV0aWNGb2N1c0V2ZW50IiwiU3ludGhldGljS2V5Ym9hcmRFdmVudCIsIlN5bnRoZXRpY0RyYWdFdmVudCIsIlN5bnRoZXRpY1RvdWNoRXZlbnQiLCJTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQiLCJTeW50aGV0aWNXaGVlbEV2ZW50IiwidG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnIiwiY2FwaXRhbGl6ZWRFdmVudCIsIm9uRXZlbnQiLCJ0b3BFdmVudCIsIm9uQ2xpY2tMaXN0ZW5lcnMiLCJFdmVudENvbnN0cnVjdG9yIiwiQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UiLCJhbmltYXRpb25OYW1lIiwiZWxhcHNlZFRpbWUiLCJwc2V1ZG9FbGVtZW50IiwiQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UiLCJjbGlwYm9hcmREYXRhIiwiRm9jdXNFdmVudEludGVyZmFjZSIsImdldEV2ZW50S2V5IiwiS2V5Ym9hcmRFdmVudEludGVyZmFjZSIsImxvY2FsZSIsIm5vcm1hbGl6ZUtleSIsIkVzYyIsIlNwYWNlYmFyIiwiTGVmdCIsIlVwIiwiUmlnaHQiLCJEb3duIiwiRGVsIiwiV2luIiwiTWVudSIsIkFwcHMiLCJTY3JvbGwiLCJNb3pQcmludGFibGVLZXkiLCJ0cmFuc2xhdGVUb0tleSIsIkRyYWdFdmVudEludGVyZmFjZSIsImRhdGFUcmFuc2ZlciIsIlRvdWNoRXZlbnRJbnRlcmZhY2UiLCJ0b3VjaGVzIiwidGFyZ2V0VG91Y2hlcyIsImNoYW5nZWRUb3VjaGVzIiwiVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlIiwiV2hlZWxFdmVudEludGVyZmFjZSIsImRlbHRhWCIsIndoZWVsRGVsdGFYIiwiZGVsdGFZIiwid2hlZWxEZWx0YVkiLCJ3aGVlbERlbHRhIiwiZGVsdGFaIiwiZGVsdGFNb2RlIiwidG9wTGV2ZWxXcmFwcGVyIiwidXNlRmliZXIiLCJhZGxlcjMyIiwiVEFHX0VORCIsIkNPTU1FTlRfU1RBUlQiLCJhZGRDaGVja3N1bVRvTWFya3VwIiwiZXhpc3RpbmdDaGVja3N1bSIsIm1hcmt1cENoZWNrc3VtIiwiTU9EIiwiY29tcG9uZW50T3JFbGVtZW50IiwicmVhY3RQcm9wcyIsIndhcm5lZFByb3BlcnRpZXMiLCJ2YWxpZGF0ZVByb3BlcnR5Iiwic3RhbmRhcmROYW1lIiwid2FyblVua25vd25Qcm9wZXJ0aWVzIiwidW5rbm93blByb3BzIiwiaXNWYWxpZCIsInVua25vd25Qcm9wU3RyaW5nIiwiaGFuZGxlRWxlbWVudCIsImRpZFdhcm5WYWx1ZU51bGwiLCJyQVJJQSIsIndhcm5JbnZhbGlkQVJJQVByb3BzIiwiaW52YWxpZFByb3BzIiwiZGlkV2FybkFib3V0UmVjZWl2aW5nU3RvcmUiLCJ3YXJuQWJvdXRSZWNlaXZpbmdTdG9yZSIsIl9Qcm92aWRlciRjaGlsZENvbnRleCIsInN1YktleSIsInNoaW0iLCJnZXRTaGltIiwiUkVBQ1RfU1RBVElDUyIsIktOT1dOX1NUQVRJQ1MiLCJjYWxsZXIiLCJhcml0eSIsIm9iamVjdFByb3RvdHlwZSIsImhvaXN0Tm9uUmVhY3RTdGF0aWNzIiwidGFyZ2V0Q29tcG9uZW50Iiwic291cmNlQ29tcG9uZW50IiwiYmxhY2tsaXN0IiwiaW5oZXJpdGVkQ29tcG9uZW50IiwiQ0xFQVJFRCIsIm51bGxMaXN0ZW5lcnMiLCJjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24iLCJhZGROZXN0ZWRTdWIiLCJkZWZhdWx0IiwiY3JlYXRlQ29ubmVjdCIsInN0cmljdEVxdWFsIiwiX3JlZiRjb25uZWN0SE9DIiwiY29ubmVjdEhPQyIsIl9yZWYkbWFwU3RhdGVUb1Byb3BzRiIsIm1hcFN0YXRlVG9Qcm9wc0ZhY3RvcmllcyIsIl9yZWYkbWFwRGlzcGF0Y2hUb1BybyIsIm1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcmllcyIsIl9yZWYkbWVyZ2VQcm9wc0ZhY3RvciIsIm1lcmdlUHJvcHNGYWN0b3JpZXMiLCJfcmVmJHNlbGVjdG9yRmFjdG9yeSIsIm1hcFN0YXRlVG9Qcm9wcyIsIm1hcERpc3BhdGNoVG9Qcm9wcyIsIm1lcmdlUHJvcHMiLCJfcmVmMiRwdXJlIiwicHVyZSIsIl9yZWYyJGFyZVN0YXRlc0VxdWFsIiwiYXJlU3RhdGVzRXF1YWwiLCJfcmVmMiRhcmVPd25Qcm9wc0VxdWEiLCJhcmVPd25Qcm9wc0VxdWFsIiwiX3JlZjIkYXJlU3RhdGVQcm9wc0VxIiwiYXJlU3RhdGVQcm9wc0VxdWFsIiwiX3JlZjIkYXJlTWVyZ2VkUHJvcHNFIiwiYXJlTWVyZ2VkUHJvcHNFcXVhbCIsImV4dHJhT3B0aW9ucyIsImluaXRNYXBTdGF0ZVRvUHJvcHMiLCJpbml0TWFwRGlzcGF0Y2hUb1Byb3BzIiwiaW5pdE1lcmdlUHJvcHMiLCJ3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNGdW5jdGlvbiIsIndoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc01pc3NpbmciLCJ3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNPYmplY3QiLCJudWxsVGFnIiwidW5kZWZpbmVkVGFnIiwic3ltVG9TdHJpbmdUYWciLCJiYXNlR2V0VGFnIiwiZnJlZVNlbGYiLCJmcmVlR2xvYmFsIiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJnZXRSYXdUYWciLCJpc093biIsInVubWFza2VkIiwib2JqZWN0VG9TdHJpbmciLCJnZXRQcm90b3R5cGUiLCJvdmVyQXJnIiwiaXNPYmplY3RMaWtlIiwiX3BvbnlmaWxsIiwiX3BvbnlmaWxsMiIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfX2VzTW9kdWxlIiwic3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsIiwiX1N5bWJvbCIsImdldFVuZGVmaW5lZFN0YXRlRXJyb3JNZXNzYWdlIiwiYWN0aW9uVHlwZSIsImFjdGlvbk5hbWUiLCJnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlIiwiaW5wdXRTdGF0ZSIsInJlZHVjZXJzIiwidW5leHBlY3RlZEtleUNhY2hlIiwicmVkdWNlcktleXMiLCJhcmd1bWVudE5hbWUiLCJ1bmV4cGVjdGVkS2V5cyIsImFzc2VydFJlZHVjZXJTaGFwZSIsImZpbmFsUmVkdWNlcnMiLCJmaW5hbFJlZHVjZXJLZXlzIiwic2hhcGVBc3NlcnRpb25FcnJvciIsImNvbWJpbmF0aW9uIiwid2FybmluZ01lc3NhZ2UiLCJoYXNDaGFuZ2VkIiwicHJldmlvdXNTdGF0ZUZvcktleSIsIm5leHRTdGF0ZUZvcktleSIsImVycm9yTWVzc2FnZSIsImJpbmRBY3Rpb25DcmVhdG9yIiwiYWN0aW9uQ3JlYXRvciIsImFjdGlvbkNyZWF0b3JzIiwiYm91bmRBY3Rpb25DcmVhdG9ycyIsIm1pZGRsZXdhcmVzIiwiX2Rpc3BhdGNoIiwibWlkZGxld2FyZUFQSSIsIm1pZGRsZXdhcmUiLCJ3aGVuTWFwU3RhdGVUb1Byb3BzSXNGdW5jdGlvbiIsIndoZW5NYXBTdGF0ZVRvUHJvcHNJc01pc3NpbmciLCJkZWZhdWx0TWVyZ2VQcm9wcyIsIndyYXBNZXJnZVByb3BzRnVuYyIsIndoZW5NZXJnZVByb3BzSXNGdW5jdGlvbiIsIndoZW5NZXJnZVByb3BzSXNPbWl0dGVkIiwic3RhdGVQcm9wcyIsImRpc3BhdGNoUHJvcHMiLCJpbml0TWVyZ2VQcm9wc1Byb3h5IiwiaGFzUnVuT25jZSIsIm1lcmdlZFByb3BzIiwibWVyZ2VQcm9wc1Byb3h5IiwibmV4dE1lcmdlZFByb3BzIiwiaW1wdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeSIsInB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5IiwiZmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeSIsImltcHVyZUZpbmFsUHJvcHNTZWxlY3RvciIsImhhc1J1bkF0TGVhc3RPbmNlIiwiaGFuZGxlRmlyc3RDYWxsIiwiZmlyc3RTdGF0ZSIsImZpcnN0T3duUHJvcHMiLCJoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlIiwiaGFuZGxlTmV3UHJvcHMiLCJoYW5kbGVOZXdTdGF0ZSIsIm5leHRTdGF0ZVByb3BzIiwic3RhdGVQcm9wc0NoYW5nZWQiLCJoYW5kbGVTdWJzZXF1ZW50Q2FsbHMiLCJuZXh0T3duUHJvcHMiLCJwcm9wc0NoYW5nZWQiLCJzdGF0ZUNoYW5nZWQiLCJwdXJlRmluYWxQcm9wc1NlbGVjdG9yIiwidmVyaWZ5U3Vic2VsZWN0b3JzIiwidmVyaWZ5IiwiY29uZmlndXJlU3RvcmUiLCJuZXh0Um9vdFJlZHVjZXIiLCJjcmVhdGVUaHVua01pZGRsZXdhcmUiLCJleHRyYUFyZ3VtZW50IiwidGh1bmsiLCJ3aXRoRXh0cmFBcmd1bWVudCIsInBsYXlsb2FkIiwiQ291bnRlckFjdGlvbnMiLCJDb3VudGVyIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUEyRDtBQUMzRDtBQUNBO0FBQ0EsV0FBRzs7QUFFSCxvREFBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxlQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSTtBQUNKOzs7O0FBSUE7QUFDQSxzREFBOEM7QUFDOUM7QUFDQTtBQUNBLG9DQUE0QjtBQUM1QixxQ0FBNkI7QUFDN0IseUNBQWlDOztBQUVqQywrQ0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxxQ0FBNkI7QUFDN0IscUNBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxhQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGFBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUFpQiw4QkFBOEI7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSTtBQUNKOztBQUVBLDREQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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R0FBdkksRUFBNEksR0FBNUksRUFBaUosR0FBakosRUFBc0osR0FBdEosRUFBMkosR0FBM0osRUFBZ0ssR0FBaEssRUFBcUssR0FBckssRUFBMEssR0FBMUssRUFBK0ssR0FBL0ssRUFBb0wsR0FBcEwsRUFBeUwsR0FBekwsRUFBOEwsR0FBOUwsRUFBbU0sR0FBbk0sRUFBd00sR0FBeE0sRUFBNk0sR0FBN00sRUFBa04sR0FBbE4sRUFBdU4sR0FBdk4sRUFBNE4sR0FBNU4sRUFBaU8sR0FBak8sRUFBc08sR0FBdE8sRUFBMk8sR0FBM08sRUFBZ1AsR0FBaFAsRUFBcVAsR0FBclAsRUFBMFAsR0FBMVAsRUFBK1AsR0FBL1AsRUFBb1EsR0FBcFEsRUFBeVEsR0FBelEsRUFBOFEsR0FBOVEsRUFBbVIsR0FBblIsRUFBd1IsR0FBeFIsRUFBNlIsR0FBN1IsRUFBa1MsR0FBbFMsRUFBdVMsR0FBdlMsRUFBNFMsR0FBNVMsRUFBaVQsR0FBalQsRUFBc1QsR0FBdFQsRUFBMlQsR0FBM1QsRUFBZ1UsR0FBaFUsRUFBcVUsR0FBclUsRUFBMFUsR0FBMVUsRUFBK1UsR0FBL1UsRUFBb1YsR0FBcFYsRUFBeVYsR0FBelYsRUFBOFYsR0FBOVYsRUFBbVcsR0FBblcsRUFBd1csR0FBeFcsRUFBNlcsR0FBN1csRUFBa1gsR0FBbFgsRUFBdVgsR0FBdlgsRUFBNFgsR0FBNVgsRUFBaVksR0FBalksRUFBc1ksR0FBdFksRUFBMlksR0FBM1ksRUFBZ1osR0FBaFosRUFBcVosR0FBclosRUFBMFosR0FBMVosRUFBK1osR0FBL1osRUFBb2EsR0FBcGEsRUFBeWEsR0FBemEsRUFBOGEsR0FBOWEsRUFBbWIsR0FBbmIsRUFBd2IsR0FBeGIsRUFBNmIsR0FBN2IsRUFBa2MsR0FBbGMsRUFBdWMsR0FBdmMsRUFBNGMsR0FBNWMsRUFBaWQsR0FBamQsRUFBc2QsR0FBdGQsRUFBMmQsR0FBM2QsRUFBZ2UsR0FBaGUsRUFBcWUsRUFBcmUsRUFBeWUsRUFBemUsRUFBNmUsRUFBN2UsRUFBaWYsRUFBamYsRUFBcWYsR0FBcmYsRUFBMGYs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LG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0EsbUJBQUFBLENBQVEsR0FBUjtBQUNBLG1CQUFBQSxDQUFRLEdBQVI7QUFDQSxtQkFBQUEsQ0FBUSxHQUFSO0FBQ0FpQyxPQUFPWixPQUFQLEdBQWlCLG1CQUFBckIsQ0FBUSxFQUFSLENBQWpCLEM7Ozs7Ozs7QUNwTUE7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RCxRQUFELElBQWM7QUFDdkMsU0FBTywrQkFBbUI0OUQsY0FBbkIsRUFBbUM1OUQsUUFBbkMsQ0FBUDtBQUNELENBRkQ7O2tCQUllLHlCQUFRZzNELGVBQVIsRUFBeUJDLGtCQUF6QixvQjs7Ozs7Ozs7Ozs7OztBQ2JmOzs7O0FBQ0E7Ozs7OztBQUVBLE1BQU00RyxVQUFVLENBQUMsRUFBQ3IzRCxTQUFELEVBQVlDLFNBQVosRUFBdUJDLGNBQXZCLEVBQXVDQyxjQUF2QyxFQUF1RHI4QixPQUF2RCxFQUFELEtBQ2Q7QUFBQTtBQUFBO0FBQUE7QUFDYUEsU0FEYjtBQUFBO0FBRUcsS0FGSDtBQUdFO0FBQUE7QUFBQSxNQUFRLFNBQVNrOEIsU0FBakI7QUFBQTtBQUFBLEdBSEY7QUFJRyxLQUpIO0FBS0U7QUFBQTtBQUFBLE1BQVEsU0FBU0MsU0FBakI7QUFBQTtBQUFBLEdBTEY7QUFNRyxLQU5IO0FBT0U7QUFBQTtBQUFBLE1BQVEsU0FBU0MsY0FBakI7QUFBQTtBQUFBLEdBUEY7QUFRRyxLQVJIO0FBU0U7QUFBQTtBQUFBLE1BQVEsU0FBU0MsY0FBakI7QUFBQTtBQUFBO0FBVEYsQ0FERjs7QUFjQWszRCxRQUFRam5GLFNBQVIsR0FBb0I7QUFDbEI0dkIsYUFBVyxvQkFBVXowQixJQUFWLENBQWVpWCxVQURSO0FBRWxCeWQsYUFBVyxvQkFBVTEwQixJQUFWLENBQWVpWCxVQUZSO0FBR2xCMGQsa0JBQWdCLG9CQUFVMzBCLElBQVYsQ0FBZWlYLFVBSGI7QUFJbEIyZCxrQkFBZ0Isb0JBQVU1MEIsSUFBVixDQUFlaVgsVUFKYjtBQUtsQjFlLFdBQVMsb0JBQVU2WSxNQUFWLENBQWlCNkY7QUFMUixDQUFwQjs7a0JBUWU2MEUsTyIsImZpbGUiOiJidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHRmdW5jdGlvbiBob3REaXNwb3NlQ2h1bmsoY2h1bmtJZCkge1xuIFx0XHRkZWxldGUgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdO1xuIFx0fVxuIFx0dmFyIHBhcmVudEhvdFVwZGF0ZUNhbGxiYWNrID0gdGhpc1tcIndlYnBhY2tIb3RVcGRhdGVcIl07XG4gXHR0aGlzW1wid2VicGFja0hvdFVwZGF0ZVwiXSA9IFxyXG4gXHRmdW5jdGlvbiB3ZWJwYWNrSG90VXBkYXRlQ2FsbGJhY2soY2h1bmtJZCwgbW9yZU1vZHVsZXMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcdGhvdEFkZFVwZGF0ZUNodW5rKGNodW5rSWQsIG1vcmVNb2R1bGVzKTtcclxuIFx0XHRpZihwYXJlbnRIb3RVcGRhdGVDYWxsYmFjaykgcGFyZW50SG90VXBkYXRlQ2FsbGJhY2soY2h1bmtJZCwgbW9yZU1vZHVsZXMpO1xyXG4gXHR9IDtcclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdERvd25sb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdFx0dmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XHJcbiBcdFx0dmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XHJcbiBcdFx0c2NyaXB0LnR5cGUgPSBcInRleHQvamF2YXNjcmlwdFwiO1xyXG4gXHRcdHNjcmlwdC5jaGFyc2V0ID0gXCJ1dGYtOFwiO1xyXG4gXHRcdHNjcmlwdC5zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBcIlwiICsgY2h1bmtJZCArIFwiLlwiICsgaG90Q3VycmVudEhhc2ggKyBcIi5ob3QtdXBkYXRlLmpzXCI7XHJcbiBcdFx0aGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3REb3dubG9hZE1hbmlmZXN0KHJlcXVlc3RUaW1lb3V0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHRyZXF1ZXN0VGltZW91dCA9IHJlcXVlc3RUaW1lb3V0IHx8IDEwMDAwO1xyXG4gXHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuIFx0XHRcdGlmKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCA9PT0gXCJ1bmRlZmluZWRcIilcclxuIFx0XHRcdFx0cmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJObyBicm93c2VyIHN1cHBvcnRcIikpO1xyXG4gXHRcdFx0dHJ5IHtcclxuIFx0XHRcdFx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuIFx0XHRcdFx0dmFyIHJlcXVlc3RQYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgXCJcIiArIGhvdEN1cnJlbnRIYXNoICsgXCIuaG90LXVwZGF0ZS5qc29uXCI7XHJcbiBcdFx0XHRcdHJlcXVlc3Qub3BlbihcIkdFVFwiLCByZXF1ZXN0UGF0aCwgdHJ1ZSk7XHJcbiBcdFx0XHRcdHJlcXVlc3QudGltZW91dCA9IHJlcXVlc3RUaW1lb3V0O1xyXG4gXHRcdFx0XHRyZXF1ZXN0LnNlbmQobnVsbCk7XHJcbiBcdFx0XHR9IGNhdGNoKGVycikge1xyXG4gXHRcdFx0XHRyZXR1cm4gcmVqZWN0KGVycik7XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRyZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xyXG4gXHRcdFx0XHRpZihyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHJldHVybjtcclxuIFx0XHRcdFx0aWYocmVxdWVzdC5zdGF0dXMgPT09IDApIHtcclxuIFx0XHRcdFx0XHQvLyB0aW1lb3V0XHJcbiBcdFx0XHRcdFx0cmVqZWN0KG5ldyBFcnJvcihcIk1hbmlmZXN0IHJlcXVlc3QgdG8gXCIgKyByZXF1ZXN0UGF0aCArIFwiIHRpbWVkIG91dC5cIikpO1xyXG4gXHRcdFx0XHR9IGVsc2UgaWYocmVxdWVzdC5zdGF0dXMgPT09IDQwNCkge1xyXG4gXHRcdFx0XHRcdC8vIG5vIHVwZGF0ZSBhdmFpbGFibGVcclxuIFx0XHRcdFx0XHRyZXNvbHZlKCk7XHJcbiBcdFx0XHRcdH0gZWxzZSBpZihyZXF1ZXN0LnN0YXR1cyAhPT0gMjAwICYmIHJlcXVlc3Quc3RhdHVzICE9PSAzMDQpIHtcclxuIFx0XHRcdFx0XHQvLyBvdGhlciBmYWlsdXJlXHJcbiBcdFx0XHRcdFx0cmVqZWN0KG5ldyBFcnJvcihcIk1hbmlmZXN0IHJlcXVlc3QgdG8gXCIgKyByZXF1ZXN0UGF0aCArIFwiIGZhaWxlZC5cIikpO1xyXG4gXHRcdFx0XHR9IGVsc2Uge1xyXG4gXHRcdFx0XHRcdC8vIHN1Y2Nlc3NcclxuIFx0XHRcdFx0XHR0cnkge1xyXG4gXHRcdFx0XHRcdFx0dmFyIHVwZGF0ZSA9IEpTT04ucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQpO1xyXG4gXHRcdFx0XHRcdH0gY2F0Y2goZSkge1xyXG4gXHRcdFx0XHRcdFx0cmVqZWN0KGUpO1xyXG4gXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRyZXNvbHZlKHVwZGF0ZSk7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH07XHJcbiBcdFx0fSk7XHJcbiBcdH1cclxuXG4gXHRcclxuIFx0XHJcbiBcdHZhciBob3RBcHBseU9uVXBkYXRlID0gdHJ1ZTtcclxuIFx0dmFyIGhvdEN1cnJlbnRIYXNoID0gXCI1ZDQxZDY4NWNlZWNjNWE1MGIzZFwiOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdHZhciBob3RSZXF1ZXN0VGltZW91dCA9IDEwMDAwO1xyXG4gXHR2YXIgaG90Q3VycmVudE1vZHVsZURhdGEgPSB7fTtcclxuIFx0dmFyIGhvdEN1cnJlbnRDaGlsZE1vZHVsZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHR2YXIgaG90Q3VycmVudFBhcmVudHMgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHR2YXIgaG90Q3VycmVudFBhcmVudHNUZW1wID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdENyZWF0ZVJlcXVpcmUobW9kdWxlSWQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcdHZhciBtZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xyXG4gXHRcdGlmKCFtZSkgcmV0dXJuIF9fd2VicGFja19yZXF1aXJlX187XHJcbiBcdFx0dmFyIGZuID0gZnVuY3Rpb24ocmVxdWVzdCkge1xyXG4gXHRcdFx0aWYobWUuaG90LmFjdGl2ZSkge1xyXG4gXHRcdFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW3JlcXVlc3RdKSB7XHJcbiBcdFx0XHRcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XS5wYXJlbnRzLmluZGV4T2YobW9kdWxlSWQpIDwgMClcclxuIFx0XHRcdFx0XHRcdGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0ucGFyZW50cy5wdXNoKG1vZHVsZUlkKTtcclxuIFx0XHRcdFx0fSBlbHNlIHtcclxuIFx0XHRcdFx0XHRob3RDdXJyZW50UGFyZW50cyA9IFttb2R1bGVJZF07XHJcbiBcdFx0XHRcdFx0aG90Q3VycmVudENoaWxkTW9kdWxlID0gcmVxdWVzdDtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRpZihtZS5jaGlsZHJlbi5pbmRleE9mKHJlcXVlc3QpIDwgMClcclxuIFx0XHRcdFx0XHRtZS5jaGlsZHJlbi5wdXNoKHJlcXVlc3QpO1xyXG4gXHRcdFx0fSBlbHNlIHtcclxuIFx0XHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gdW5leHBlY3RlZCByZXF1aXJlKFwiICsgcmVxdWVzdCArIFwiKSBmcm9tIGRpc3Bvc2VkIG1vZHVsZSBcIiArIG1vZHVsZUlkKTtcclxuIFx0XHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBbXTtcclxuIFx0XHRcdH1cclxuIFx0XHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKHJlcXVlc3QpO1xyXG4gXHRcdH07XHJcbiBcdFx0dmFyIE9iamVjdEZhY3RvcnkgPSBmdW5jdGlvbiBPYmplY3RGYWN0b3J5KG5hbWUpIHtcclxuIFx0XHRcdHJldHVybiB7XHJcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuIFx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuIFx0XHRcdFx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfX1tuYW1lXTtcclxuIFx0XHRcdFx0fSxcclxuIFx0XHRcdFx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gXHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX19bbmFtZV0gPSB2YWx1ZTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fTtcclxuIFx0XHR9O1xyXG4gXHRcdGZvcih2YXIgbmFtZSBpbiBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX193ZWJwYWNrX3JlcXVpcmVfXywgbmFtZSkgJiYgbmFtZSAhPT0gXCJlXCIpIHtcclxuIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBuYW1lLCBPYmplY3RGYWN0b3J5KG5hbWUpKTtcclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFx0Zm4uZSA9IGZ1bmN0aW9uKGNodW5rSWQpIHtcclxuIFx0XHRcdGlmKGhvdFN0YXR1cyA9PT0gXCJyZWFkeVwiKVxyXG4gXHRcdFx0XHRob3RTZXRTdGF0dXMoXCJwcmVwYXJlXCIpO1xyXG4gXHRcdFx0aG90Q2h1bmtzTG9hZGluZysrO1xyXG4gXHRcdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18uZShjaHVua0lkKS50aGVuKGZpbmlzaENodW5rTG9hZGluZywgZnVuY3Rpb24oZXJyKSB7XHJcbiBcdFx0XHRcdGZpbmlzaENodW5rTG9hZGluZygpO1xyXG4gXHRcdFx0XHR0aHJvdyBlcnI7XHJcbiBcdFx0XHR9KTtcclxuIFx0XHJcbiBcdFx0XHRmdW5jdGlvbiBmaW5pc2hDaHVua0xvYWRpbmcoKSB7XHJcbiBcdFx0XHRcdGhvdENodW5rc0xvYWRpbmctLTtcclxuIFx0XHRcdFx0aWYoaG90U3RhdHVzID09PSBcInByZXBhcmVcIikge1xyXG4gXHRcdFx0XHRcdGlmKCFob3RXYWl0aW5nRmlsZXNNYXBbY2h1bmtJZF0pIHtcclxuIFx0XHRcdFx0XHRcdGhvdEVuc3VyZVVwZGF0ZUNodW5rKGNodW5rSWQpO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRpZihob3RDaHVua3NMb2FkaW5nID09PSAwICYmIGhvdFdhaXRpbmdGaWxlcyA9PT0gMCkge1xyXG4gXHRcdFx0XHRcdFx0aG90VXBkYXRlRG93bmxvYWRlZCgpO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcdH07XHJcbiBcdFx0cmV0dXJuIGZuO1xyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RDcmVhdGVNb2R1bGUobW9kdWxlSWQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcdHZhciBob3QgPSB7XHJcbiBcdFx0XHQvLyBwcml2YXRlIHN0dWZmXHJcbiBcdFx0XHRfYWNjZXB0ZWREZXBlbmRlbmNpZXM6IHt9LFxyXG4gXHRcdFx0X2RlY2xpbmVkRGVwZW5kZW5jaWVzOiB7fSxcclxuIFx0XHRcdF9zZWxmQWNjZXB0ZWQ6IGZhbHNlLFxyXG4gXHRcdFx0X3NlbGZEZWNsaW5lZDogZmFsc2UsXHJcbiBcdFx0XHRfZGlzcG9zZUhhbmRsZXJzOiBbXSxcclxuIFx0XHRcdF9tYWluOiBob3RDdXJyZW50Q2hpbGRNb2R1bGUgIT09IG1vZHVsZUlkLFxyXG4gXHRcclxuIFx0XHRcdC8vIE1vZHVsZSBBUElcclxuIFx0XHRcdGFjdGl2ZTogdHJ1ZSxcclxuIFx0XHRcdGFjY2VwdDogZnVuY3Rpb24oZGVwLCBjYWxsYmFjaykge1xyXG4gXHRcdFx0XHRpZih0eXBlb2YgZGVwID09PSBcInVuZGVmaW5lZFwiKVxyXG4gXHRcdFx0XHRcdGhvdC5fc2VsZkFjY2VwdGVkID0gdHJ1ZTtcclxuIFx0XHRcdFx0ZWxzZSBpZih0eXBlb2YgZGVwID09PSBcImZ1bmN0aW9uXCIpXHJcbiBcdFx0XHRcdFx0aG90Ll9zZWxmQWNjZXB0ZWQgPSBkZXA7XHJcbiBcdFx0XHRcdGVsc2UgaWYodHlwZW9mIGRlcCA9PT0gXCJvYmplY3RcIilcclxuIFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZGVwLmxlbmd0aDsgaSsrKVxyXG4gXHRcdFx0XHRcdFx0aG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBbaV1dID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcclxuIFx0XHRcdFx0ZWxzZVxyXG4gXHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XHJcbiBcdFx0XHR9LFxyXG4gXHRcdFx0ZGVjbGluZTogZnVuY3Rpb24oZGVwKSB7XHJcbiBcdFx0XHRcdGlmKHR5cGVvZiBkZXAgPT09IFwidW5kZWZpbmVkXCIpXHJcbiBcdFx0XHRcdFx0aG90Ll9zZWxmRGVjbGluZWQgPSB0cnVlO1xyXG4gXHRcdFx0XHRlbHNlIGlmKHR5cGVvZiBkZXAgPT09IFwib2JqZWN0XCIpXHJcbiBcdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGRlcC5sZW5ndGg7IGkrKylcclxuIFx0XHRcdFx0XHRcdGhvdC5fZGVjbGluZWREZXBlbmRlbmNpZXNbZGVwW2ldXSA9IHRydWU7XHJcbiBcdFx0XHRcdGVsc2VcclxuIFx0XHRcdFx0XHRob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW2RlcF0gPSB0cnVlO1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdGRpc3Bvc2U6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiBcdFx0XHRcdGhvdC5fZGlzcG9zZUhhbmRsZXJzLnB1c2goY2FsbGJhY2spO1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdGFkZERpc3Bvc2VIYW5kbGVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gXHRcdFx0XHRob3QuX2Rpc3Bvc2VIYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcclxuIFx0XHRcdH0sXHJcbiBcdFx0XHRyZW1vdmVEaXNwb3NlSGFuZGxlcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuIFx0XHRcdFx0dmFyIGlkeCA9IGhvdC5fZGlzcG9zZUhhbmRsZXJzLmluZGV4T2YoY2FsbGJhY2spO1xyXG4gXHRcdFx0XHRpZihpZHggPj0gMCkgaG90Ll9kaXNwb3NlSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XHJcbiBcdFx0XHR9LFxyXG4gXHRcclxuIFx0XHRcdC8vIE1hbmFnZW1lbnQgQVBJXHJcbiBcdFx0XHRjaGVjazogaG90Q2hlY2ssXHJcbiBcdFx0XHRhcHBseTogaG90QXBwbHksXHJcbiBcdFx0XHRzdGF0dXM6IGZ1bmN0aW9uKGwpIHtcclxuIFx0XHRcdFx0aWYoIWwpIHJldHVybiBob3RTdGF0dXM7XHJcbiBcdFx0XHRcdGhvdFN0YXR1c0hhbmRsZXJzLnB1c2gobCk7XHJcbiBcdFx0XHR9LFxyXG4gXHRcdFx0YWRkU3RhdHVzSGFuZGxlcjogZnVuY3Rpb24obCkge1xyXG4gXHRcdFx0XHRob3RTdGF0dXNIYW5kbGVycy5wdXNoKGwpO1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdHJlbW92ZVN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uKGwpIHtcclxuIFx0XHRcdFx0dmFyIGlkeCA9IGhvdFN0YXR1c0hhbmRsZXJzLmluZGV4T2YobCk7XHJcbiBcdFx0XHRcdGlmKGlkeCA+PSAwKSBob3RTdGF0dXNIYW5kbGVycy5zcGxpY2UoaWR4LCAxKTtcclxuIFx0XHRcdH0sXHJcbiBcdFxyXG4gXHRcdFx0Ly9pbmhlcml0IGZyb20gcHJldmlvdXMgZGlzcG9zZSBjYWxsXHJcbiBcdFx0XHRkYXRhOiBob3RDdXJyZW50TW9kdWxlRGF0YVttb2R1bGVJZF1cclxuIFx0XHR9O1xyXG4gXHRcdGhvdEN1cnJlbnRDaGlsZE1vZHVsZSA9IHVuZGVmaW5lZDtcclxuIFx0XHRyZXR1cm4gaG90O1xyXG4gXHR9XHJcbiBcdFxyXG4gXHR2YXIgaG90U3RhdHVzSGFuZGxlcnMgPSBbXTtcclxuIFx0dmFyIGhvdFN0YXR1cyA9IFwiaWRsZVwiO1xyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90U2V0U3RhdHVzKG5ld1N0YXR1cykge1xyXG4gXHRcdGhvdFN0YXR1cyA9IG5ld1N0YXR1cztcclxuIFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgaG90U3RhdHVzSGFuZGxlcnMubGVuZ3RoOyBpKyspXHJcbiBcdFx0XHRob3RTdGF0dXNIYW5kbGVyc1tpXS5jYWxsKG51bGwsIG5ld1N0YXR1cyk7XHJcbiBcdH1cclxuIFx0XHJcbiBcdC8vIHdoaWxlIGRvd25sb2FkaW5nXHJcbiBcdHZhciBob3RXYWl0aW5nRmlsZXMgPSAwO1xyXG4gXHR2YXIgaG90Q2h1bmtzTG9hZGluZyA9IDA7XHJcbiBcdHZhciBob3RXYWl0aW5nRmlsZXNNYXAgPSB7fTtcclxuIFx0dmFyIGhvdFJlcXVlc3RlZEZpbGVzTWFwID0ge307XHJcbiBcdHZhciBob3RBdmFpbGFibGVGaWxlc01hcCA9IHt9O1xyXG4gXHR2YXIgaG90RGVmZXJyZWQ7XHJcbiBcdFxyXG4gXHQvLyBUaGUgdXBkYXRlIGluZm9cclxuIFx0dmFyIGhvdFVwZGF0ZSwgaG90VXBkYXRlTmV3SGFzaDtcclxuIFx0XHJcbiBcdGZ1bmN0aW9uIHRvTW9kdWxlSWQoaWQpIHtcclxuIFx0XHR2YXIgaXNOdW1iZXIgPSAoK2lkKSArIFwiXCIgPT09IGlkO1xyXG4gXHRcdHJldHVybiBpc051bWJlciA/ICtpZCA6IGlkO1xyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RDaGVjayhhcHBseSkge1xyXG4gXHRcdGlmKGhvdFN0YXR1cyAhPT0gXCJpZGxlXCIpIHRocm93IG5ldyBFcnJvcihcImNoZWNrKCkgaXMgb25seSBhbGxvd2VkIGluIGlkbGUgc3RhdHVzXCIpO1xyXG4gXHRcdGhvdEFwcGx5T25VcGRhdGUgPSBhcHBseTtcclxuIFx0XHRob3RTZXRTdGF0dXMoXCJjaGVja1wiKTtcclxuIFx0XHRyZXR1cm4gaG90RG93bmxvYWRNYW5pZmVzdChob3RSZXF1ZXN0VGltZW91dCkudGhlbihmdW5jdGlvbih1cGRhdGUpIHtcclxuIFx0XHRcdGlmKCF1cGRhdGUpIHtcclxuIFx0XHRcdFx0aG90U2V0U3RhdHVzKFwiaWRsZVwiKTtcclxuIFx0XHRcdFx0cmV0dXJuIG51bGw7XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRob3RSZXF1ZXN0ZWRGaWxlc01hcCA9IHt9O1xyXG4gXHRcdFx0aG90V2FpdGluZ0ZpbGVzTWFwID0ge307XHJcbiBcdFx0XHRob3RBdmFpbGFibGVGaWxlc01hcCA9IHVwZGF0ZS5jO1xyXG4gXHRcdFx0aG90VXBkYXRlTmV3SGFzaCA9IHVwZGF0ZS5oO1xyXG4gXHRcclxuIFx0XHRcdGhvdFNldFN0YXR1cyhcInByZXBhcmVcIik7XHJcbiBcdFx0XHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gXHRcdFx0XHRob3REZWZlcnJlZCA9IHtcclxuIFx0XHRcdFx0XHRyZXNvbHZlOiByZXNvbHZlLFxyXG4gXHRcdFx0XHRcdHJlamVjdDogcmVqZWN0XHJcbiBcdFx0XHRcdH07XHJcbiBcdFx0XHR9KTtcclxuIFx0XHRcdGhvdFVwZGF0ZSA9IHt9O1xyXG4gXHRcdFx0dmFyIGNodW5rSWQgPSAwO1xyXG4gXHRcdFx0eyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxvbmUtYmxvY2tzXHJcbiBcdFx0XHRcdC8qZ2xvYmFscyBjaHVua0lkICovXHJcbiBcdFx0XHRcdGhvdEVuc3VyZVVwZGF0ZUNodW5rKGNodW5rSWQpO1xyXG4gXHRcdFx0fVxyXG4gXHRcdFx0aWYoaG90U3RhdHVzID09PSBcInByZXBhcmVcIiAmJiBob3RDaHVua3NMb2FkaW5nID09PSAwICYmIGhvdFdhaXRpbmdGaWxlcyA9PT0gMCkge1xyXG4gXHRcdFx0XHRob3RVcGRhdGVEb3dubG9hZGVkKCk7XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRyZXR1cm4gcHJvbWlzZTtcclxuIFx0XHR9KTtcclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90QWRkVXBkYXRlQ2h1bmsoY2h1bmtJZCwgbW9yZU1vZHVsZXMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcdGlmKCFob3RBdmFpbGFibGVGaWxlc01hcFtjaHVua0lkXSB8fCAhaG90UmVxdWVzdGVkRmlsZXNNYXBbY2h1bmtJZF0pXHJcbiBcdFx0XHRyZXR1cm47XHJcbiBcdFx0aG90UmVxdWVzdGVkRmlsZXNNYXBbY2h1bmtJZF0gPSBmYWxzZTtcclxuIFx0XHRmb3IodmFyIG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xyXG4gXHRcdFx0XHRob3RVcGRhdGVbbW9kdWxlSWRdID0gbW9yZU1vZHVsZXNbbW9kdWxlSWRdO1xyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHRpZigtLWhvdFdhaXRpbmdGaWxlcyA9PT0gMCAmJiBob3RDaHVua3NMb2FkaW5nID09PSAwKSB7XHJcbiBcdFx0XHRob3RVcGRhdGVEb3dubG9hZGVkKCk7XHJcbiBcdFx0fVxyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKSB7XHJcbiBcdFx0aWYoIWhvdEF2YWlsYWJsZUZpbGVzTWFwW2NodW5rSWRdKSB7XHJcbiBcdFx0XHRob3RXYWl0aW5nRmlsZXNNYXBbY2h1bmtJZF0gPSB0cnVlO1xyXG4gXHRcdH0gZWxzZSB7XHJcbiBcdFx0XHRob3RSZXF1ZXN0ZWRGaWxlc01hcFtjaHVua0lkXSA9IHRydWU7XHJcbiBcdFx0XHRob3RXYWl0aW5nRmlsZXMrKztcclxuIFx0XHRcdGhvdERvd25sb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCk7XHJcbiBcdFx0fVxyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RVcGRhdGVEb3dubG9hZGVkKCkge1xyXG4gXHRcdGhvdFNldFN0YXR1cyhcInJlYWR5XCIpO1xyXG4gXHRcdHZhciBkZWZlcnJlZCA9IGhvdERlZmVycmVkO1xyXG4gXHRcdGhvdERlZmVycmVkID0gbnVsbDtcclxuIFx0XHRpZighZGVmZXJyZWQpIHJldHVybjtcclxuIFx0XHRpZihob3RBcHBseU9uVXBkYXRlKSB7XHJcbiBcdFx0XHQvLyBXcmFwIGRlZmVycmVkIG9iamVjdCBpbiBQcm9taXNlIHRvIG1hcmsgaXQgYXMgYSB3ZWxsLWhhbmRsZWQgUHJvbWlzZSB0b1xyXG4gXHRcdFx0Ly8gYXZvaWQgdHJpZ2dlcmluZyB1bmNhdWdodCBleGNlcHRpb24gd2FybmluZyBpbiBDaHJvbWUuXHJcbiBcdFx0XHQvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDY1NjY2XHJcbiBcdFx0XHRQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xyXG4gXHRcdFx0XHRyZXR1cm4gaG90QXBwbHkoaG90QXBwbHlPblVwZGF0ZSk7XHJcbiBcdFx0XHR9KS50aGVuKFxyXG4gXHRcdFx0XHRmdW5jdGlvbihyZXN1bHQpIHtcclxuIFx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XHJcbiBcdFx0XHRcdH0sXHJcbiBcdFx0XHRcdGZ1bmN0aW9uKGVycikge1xyXG4gXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdChlcnIpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHQpO1xyXG4gXHRcdH0gZWxzZSB7XHJcbiBcdFx0XHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW107XHJcbiBcdFx0XHRmb3IodmFyIGlkIGluIGhvdFVwZGF0ZSkge1xyXG4gXHRcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaG90VXBkYXRlLCBpZCkpIHtcclxuIFx0XHRcdFx0XHRvdXRkYXRlZE1vZHVsZXMucHVzaCh0b01vZHVsZUlkKGlkKSk7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHRcdGRlZmVycmVkLnJlc29sdmUob3V0ZGF0ZWRNb2R1bGVzKTtcclxuIFx0XHR9XHJcbiBcdH1cclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdEFwcGx5KG9wdGlvbnMpIHtcclxuIFx0XHRpZihob3RTdGF0dXMgIT09IFwicmVhZHlcIikgdGhyb3cgbmV3IEVycm9yKFwiYXBwbHkoKSBpcyBvbmx5IGFsbG93ZWQgaW4gcmVhZHkgc3RhdHVzXCIpO1xyXG4gXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gXHRcclxuIFx0XHR2YXIgY2I7XHJcbiBcdFx0dmFyIGk7XHJcbiBcdFx0dmFyIGo7XHJcbiBcdFx0dmFyIG1vZHVsZTtcclxuIFx0XHR2YXIgbW9kdWxlSWQ7XHJcbiBcdFxyXG4gXHRcdGZ1bmN0aW9uIGdldEFmZmVjdGVkU3R1ZmYodXBkYXRlTW9kdWxlSWQpIHtcclxuIFx0XHRcdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbdXBkYXRlTW9kdWxlSWRdO1xyXG4gXHRcdFx0dmFyIG91dGRhdGVkRGVwZW5kZW5jaWVzID0ge307XHJcbiBcdFxyXG4gXHRcdFx0dmFyIHF1ZXVlID0gb3V0ZGF0ZWRNb2R1bGVzLnNsaWNlKCkubWFwKGZ1bmN0aW9uKGlkKSB7XHJcbiBcdFx0XHRcdHJldHVybiB7XHJcbiBcdFx0XHRcdFx0Y2hhaW46IFtpZF0sXHJcbiBcdFx0XHRcdFx0aWQ6IGlkXHJcbiBcdFx0XHRcdH07XHJcbiBcdFx0XHR9KTtcclxuIFx0XHRcdHdoaWxlKHF1ZXVlLmxlbmd0aCA+IDApIHtcclxuIFx0XHRcdFx0dmFyIHF1ZXVlSXRlbSA9IHF1ZXVlLnBvcCgpO1xyXG4gXHRcdFx0XHR2YXIgbW9kdWxlSWQgPSBxdWV1ZUl0ZW0uaWQ7XHJcbiBcdFx0XHRcdHZhciBjaGFpbiA9IHF1ZXVlSXRlbS5jaGFpbjtcclxuIFx0XHRcdFx0bW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRcdGlmKCFtb2R1bGUgfHwgbW9kdWxlLmhvdC5fc2VsZkFjY2VwdGVkKVxyXG4gXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG4gXHRcdFx0XHRpZihtb2R1bGUuaG90Ll9zZWxmRGVjbGluZWQpIHtcclxuIFx0XHRcdFx0XHRyZXR1cm4ge1xyXG4gXHRcdFx0XHRcdFx0dHlwZTogXCJzZWxmLWRlY2xpbmVkXCIsXHJcbiBcdFx0XHRcdFx0XHRjaGFpbjogY2hhaW4sXHJcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcclxuIFx0XHRcdFx0XHR9O1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdGlmKG1vZHVsZS5ob3QuX21haW4pIHtcclxuIFx0XHRcdFx0XHRyZXR1cm4ge1xyXG4gXHRcdFx0XHRcdFx0dHlwZTogXCJ1bmFjY2VwdGVkXCIsXHJcbiBcdFx0XHRcdFx0XHRjaGFpbjogY2hhaW4sXHJcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcclxuIFx0XHRcdFx0XHR9O1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtb2R1bGUucGFyZW50cy5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0XHRcdHZhciBwYXJlbnRJZCA9IG1vZHVsZS5wYXJlbnRzW2ldO1xyXG4gXHRcdFx0XHRcdHZhciBwYXJlbnQgPSBpbnN0YWxsZWRNb2R1bGVzW3BhcmVudElkXTtcclxuIFx0XHRcdFx0XHRpZighcGFyZW50KSBjb250aW51ZTtcclxuIFx0XHRcdFx0XHRpZihwYXJlbnQuaG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pIHtcclxuIFx0XHRcdFx0XHRcdHJldHVybiB7XHJcbiBcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZGVjbGluZWRcIixcclxuIFx0XHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLmNvbmNhdChbcGFyZW50SWRdKSxcclxuIFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxyXG4gXHRcdFx0XHRcdFx0XHRwYXJlbnRJZDogcGFyZW50SWRcclxuIFx0XHRcdFx0XHRcdH07XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdGlmKG91dGRhdGVkTW9kdWxlcy5pbmRleE9mKHBhcmVudElkKSA+PSAwKSBjb250aW51ZTtcclxuIFx0XHRcdFx0XHRpZihwYXJlbnQuaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pIHtcclxuIFx0XHRcdFx0XHRcdGlmKCFvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0pXHJcbiBcdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXSA9IFtdO1xyXG4gXHRcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdLCBbbW9kdWxlSWRdKTtcclxuIFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRkZWxldGUgb3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdO1xyXG4gXHRcdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5wdXNoKHBhcmVudElkKTtcclxuIFx0XHRcdFx0XHRxdWV1ZS5wdXNoKHtcclxuIFx0XHRcdFx0XHRcdGNoYWluOiBjaGFpbi5jb25jYXQoW3BhcmVudElkXSksXHJcbiBcdFx0XHRcdFx0XHRpZDogcGFyZW50SWRcclxuIFx0XHRcdFx0XHR9KTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcclxuIFx0XHRcdHJldHVybiB7XHJcbiBcdFx0XHRcdHR5cGU6IFwiYWNjZXB0ZWRcIixcclxuIFx0XHRcdFx0bW9kdWxlSWQ6IHVwZGF0ZU1vZHVsZUlkLFxyXG4gXHRcdFx0XHRvdXRkYXRlZE1vZHVsZXM6IG91dGRhdGVkTW9kdWxlcyxcclxuIFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXM6IG91dGRhdGVkRGVwZW5kZW5jaWVzXHJcbiBcdFx0XHR9O1xyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0ZnVuY3Rpb24gYWRkQWxsVG9TZXQoYSwgYikge1xyXG4gXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcclxuIFx0XHRcdFx0dmFyIGl0ZW0gPSBiW2ldO1xyXG4gXHRcdFx0XHRpZihhLmluZGV4T2YoaXRlbSkgPCAwKVxyXG4gXHRcdFx0XHRcdGEucHVzaChpdGVtKTtcclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIGF0IGJlZ2luIGFsbCB1cGRhdGVzIG1vZHVsZXMgYXJlIG91dGRhdGVkXHJcbiBcdFx0Ly8gdGhlIFwib3V0ZGF0ZWRcIiBzdGF0dXMgY2FuIHByb3BhZ2F0ZSB0byBwYXJlbnRzIGlmIHRoZXkgZG9uJ3QgYWNjZXB0IHRoZSBjaGlsZHJlblxyXG4gXHRcdHZhciBvdXRkYXRlZERlcGVuZGVuY2llcyA9IHt9O1xyXG4gXHRcdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbXTtcclxuIFx0XHR2YXIgYXBwbGllZFVwZGF0ZSA9IHt9O1xyXG4gXHRcclxuIFx0XHR2YXIgd2FyblVuZXhwZWN0ZWRSZXF1aXJlID0gZnVuY3Rpb24gd2FyblVuZXhwZWN0ZWRSZXF1aXJlKCkge1xyXG4gXHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gdW5leHBlY3RlZCByZXF1aXJlKFwiICsgcmVzdWx0Lm1vZHVsZUlkICsgXCIpIHRvIGRpc3Bvc2VkIG1vZHVsZVwiKTtcclxuIFx0XHR9O1xyXG4gXHRcclxuIFx0XHRmb3IodmFyIGlkIGluIGhvdFVwZGF0ZSkge1xyXG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhvdFVwZGF0ZSwgaWQpKSB7XHJcbiBcdFx0XHRcdG1vZHVsZUlkID0gdG9Nb2R1bGVJZChpZCk7XHJcbiBcdFx0XHRcdHZhciByZXN1bHQ7XHJcbiBcdFx0XHRcdGlmKGhvdFVwZGF0ZVtpZF0pIHtcclxuIFx0XHRcdFx0XHRyZXN1bHQgPSBnZXRBZmZlY3RlZFN0dWZmKG1vZHVsZUlkKTtcclxuIFx0XHRcdFx0fSBlbHNlIHtcclxuIFx0XHRcdFx0XHRyZXN1bHQgPSB7XHJcbiBcdFx0XHRcdFx0XHR0eXBlOiBcImRpc3Bvc2VkXCIsXHJcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZDogaWRcclxuIFx0XHRcdFx0XHR9O1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdHZhciBhYm9ydEVycm9yID0gZmFsc2U7XHJcbiBcdFx0XHRcdHZhciBkb0FwcGx5ID0gZmFsc2U7XHJcbiBcdFx0XHRcdHZhciBkb0Rpc3Bvc2UgPSBmYWxzZTtcclxuIFx0XHRcdFx0dmFyIGNoYWluSW5mbyA9IFwiXCI7XHJcbiBcdFx0XHRcdGlmKHJlc3VsdC5jaGFpbikge1xyXG4gXHRcdFx0XHRcdGNoYWluSW5mbyA9IFwiXFxuVXBkYXRlIHByb3BhZ2F0aW9uOiBcIiArIHJlc3VsdC5jaGFpbi5qb2luKFwiIC0+IFwiKTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRzd2l0Y2gocmVzdWx0LnR5cGUpIHtcclxuIFx0XHRcdFx0XHRjYXNlIFwic2VsZi1kZWNsaW5lZFwiOlxyXG4gXHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkRlY2xpbmVkKVxyXG4gXHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRGVjbGluZWQocmVzdWx0KTtcclxuIFx0XHRcdFx0XHRcdGlmKCFvcHRpb25zLmlnbm9yZURlY2xpbmVkKVxyXG4gXHRcdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFwiQWJvcnRlZCBiZWNhdXNlIG9mIHNlbGYgZGVjbGluZTogXCIgKyByZXN1bHQubW9kdWxlSWQgKyBjaGFpbkluZm8pO1xyXG4gXHRcdFx0XHRcdFx0YnJlYWs7XHJcbiBcdFx0XHRcdFx0Y2FzZSBcImRlY2xpbmVkXCI6XHJcbiBcdFx0XHRcdFx0XHRpZihvcHRpb25zLm9uRGVjbGluZWQpXHJcbiBcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25EZWNsaW5lZChyZXN1bHQpO1xyXG4gXHRcdFx0XHRcdFx0aWYoIW9wdGlvbnMuaWdub3JlRGVjbGluZWQpXHJcbiBcdFx0XHRcdFx0XHRcdGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoXCJBYm9ydGVkIGJlY2F1c2Ugb2YgZGVjbGluZWQgZGVwZW5kZW5jeTogXCIgKyByZXN1bHQubW9kdWxlSWQgKyBcIiBpbiBcIiArIHJlc3VsdC5wYXJlbnRJZCArIGNoYWluSW5mbyk7XHJcbiBcdFx0XHRcdFx0XHRicmVhaztcclxuIFx0XHRcdFx0XHRjYXNlIFwidW5hY2NlcHRlZFwiOlxyXG4gXHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vblVuYWNjZXB0ZWQpXHJcbiBcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25VbmFjY2VwdGVkKHJlc3VsdCk7XHJcbiBcdFx0XHRcdFx0XHRpZighb3B0aW9ucy5pZ25vcmVVbmFjY2VwdGVkKVxyXG4gXHRcdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFwiQWJvcnRlZCBiZWNhdXNlIFwiICsgbW9kdWxlSWQgKyBcIiBpcyBub3QgYWNjZXB0ZWRcIiArIGNoYWluSW5mbyk7XHJcbiBcdFx0XHRcdFx0XHRicmVhaztcclxuIFx0XHRcdFx0XHRjYXNlIFwiYWNjZXB0ZWRcIjpcclxuIFx0XHRcdFx0XHRcdGlmKG9wdGlvbnMub25BY2NlcHRlZClcclxuIFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkFjY2VwdGVkKHJlc3VsdCk7XHJcbiBcdFx0XHRcdFx0XHRkb0FwcGx5ID0gdHJ1ZTtcclxuIFx0XHRcdFx0XHRcdGJyZWFrO1xyXG4gXHRcdFx0XHRcdGNhc2UgXCJkaXNwb3NlZFwiOlxyXG4gXHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkRpc3Bvc2VkKVxyXG4gXHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRGlzcG9zZWQocmVzdWx0KTtcclxuIFx0XHRcdFx0XHRcdGRvRGlzcG9zZSA9IHRydWU7XHJcbiBcdFx0XHRcdFx0XHRicmVhaztcclxuIFx0XHRcdFx0XHRkZWZhdWx0OlxyXG4gXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5leGNlcHRpb24gdHlwZSBcIiArIHJlc3VsdC50eXBlKTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRpZihhYm9ydEVycm9yKSB7XHJcbiBcdFx0XHRcdFx0aG90U2V0U3RhdHVzKFwiYWJvcnRcIik7XHJcbiBcdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KGFib3J0RXJyb3IpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdGlmKGRvQXBwbHkpIHtcclxuIFx0XHRcdFx0XHRhcHBsaWVkVXBkYXRlW21vZHVsZUlkXSA9IGhvdFVwZGF0ZVttb2R1bGVJZF07XHJcbiBcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWRNb2R1bGVzLCByZXN1bHQub3V0ZGF0ZWRNb2R1bGVzKTtcclxuIFx0XHRcdFx0XHRmb3IobW9kdWxlSWQgaW4gcmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XHJcbiBcdFx0XHRcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzLCBtb2R1bGVJZCkpIHtcclxuIFx0XHRcdFx0XHRcdFx0aWYoIW91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSlcclxuIFx0XHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0gPSBbXTtcclxuIFx0XHRcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdLCByZXN1bHQub3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKTtcclxuIFx0XHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdFx0aWYoZG9EaXNwb3NlKSB7XHJcbiBcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWRNb2R1bGVzLCBbcmVzdWx0Lm1vZHVsZUlkXSk7XHJcbiBcdFx0XHRcdFx0YXBwbGllZFVwZGF0ZVttb2R1bGVJZF0gPSB3YXJuVW5leHBlY3RlZFJlcXVpcmU7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIFN0b3JlIHNlbGYgYWNjZXB0ZWQgb3V0ZGF0ZWQgbW9kdWxlcyB0byByZXF1aXJlIHRoZW0gbGF0ZXIgYnkgdGhlIG1vZHVsZSBzeXN0ZW1cclxuIFx0XHR2YXIgb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzID0gW107XHJcbiBcdFx0Zm9yKGkgPSAwOyBpIDwgb3V0ZGF0ZWRNb2R1bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiBcdFx0XHRtb2R1bGVJZCA9IG91dGRhdGVkTW9kdWxlc1tpXTtcclxuIFx0XHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdICYmIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmhvdC5fc2VsZkFjY2VwdGVkKVxyXG4gXHRcdFx0XHRvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXMucHVzaCh7XHJcbiBcdFx0XHRcdFx0bW9kdWxlOiBtb2R1bGVJZCxcclxuIFx0XHRcdFx0XHRlcnJvckhhbmRsZXI6IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmhvdC5fc2VsZkFjY2VwdGVkXHJcbiBcdFx0XHRcdH0pO1xyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gTm93IGluIFwiZGlzcG9zZVwiIHBoYXNlXHJcbiBcdFx0aG90U2V0U3RhdHVzKFwiZGlzcG9zZVwiKTtcclxuIFx0XHRPYmplY3Qua2V5cyhob3RBdmFpbGFibGVGaWxlc01hcCkuZm9yRWFjaChmdW5jdGlvbihjaHVua0lkKSB7XHJcbiBcdFx0XHRpZihob3RBdmFpbGFibGVGaWxlc01hcFtjaHVua0lkXSA9PT0gZmFsc2UpIHtcclxuIFx0XHRcdFx0aG90RGlzcG9zZUNodW5rKGNodW5rSWQpO1xyXG4gXHRcdFx0fVxyXG4gXHRcdH0pO1xyXG4gXHRcclxuIFx0XHR2YXIgaWR4O1xyXG4gXHRcdHZhciBxdWV1ZSA9IG91dGRhdGVkTW9kdWxlcy5zbGljZSgpO1xyXG4gXHRcdHdoaWxlKHF1ZXVlLmxlbmd0aCA+IDApIHtcclxuIFx0XHRcdG1vZHVsZUlkID0gcXVldWUucG9wKCk7XHJcbiBcdFx0XHRtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcclxuIFx0XHRcdGlmKCFtb2R1bGUpIGNvbnRpbnVlO1xyXG4gXHRcclxuIFx0XHRcdHZhciBkYXRhID0ge307XHJcbiBcdFxyXG4gXHRcdFx0Ly8gQ2FsbCBkaXNwb3NlIGhhbmRsZXJzXHJcbiBcdFx0XHR2YXIgZGlzcG9zZUhhbmRsZXJzID0gbW9kdWxlLmhvdC5fZGlzcG9zZUhhbmRsZXJzO1xyXG4gXHRcdFx0Zm9yKGogPSAwOyBqIDwgZGlzcG9zZUhhbmRsZXJzLmxlbmd0aDsgaisrKSB7XHJcbiBcdFx0XHRcdGNiID0gZGlzcG9zZUhhbmRsZXJzW2pdO1xyXG4gXHRcdFx0XHRjYihkYXRhKTtcclxuIFx0XHRcdH1cclxuIFx0XHRcdGhvdEN1cnJlbnRNb2R1bGVEYXRhW21vZHVsZUlkXSA9IGRhdGE7XHJcbiBcdFxyXG4gXHRcdFx0Ly8gZGlzYWJsZSBtb2R1bGUgKHRoaXMgZGlzYWJsZXMgcmVxdWlyZXMgZnJvbSB0aGlzIG1vZHVsZSlcclxuIFx0XHRcdG1vZHVsZS5ob3QuYWN0aXZlID0gZmFsc2U7XHJcbiBcdFxyXG4gXHRcdFx0Ly8gcmVtb3ZlIG1vZHVsZSBmcm9tIGNhY2hlXHJcbiBcdFx0XHRkZWxldGUgaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFxyXG4gXHRcdFx0Ly8gd2hlbiBkaXNwb3NpbmcgdGhlcmUgaXMgbm8gbmVlZCB0byBjYWxsIGRpc3Bvc2UgaGFuZGxlclxyXG4gXHRcdFx0ZGVsZXRlIG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXTtcclxuIFx0XHJcbiBcdFx0XHQvLyByZW1vdmUgXCJwYXJlbnRzXCIgcmVmZXJlbmNlcyBmcm9tIGFsbCBjaGlsZHJlblxyXG4gXHRcdFx0Zm9yKGogPSAwOyBqIDwgbW9kdWxlLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XHJcbiBcdFx0XHRcdHZhciBjaGlsZCA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlLmNoaWxkcmVuW2pdXTtcclxuIFx0XHRcdFx0aWYoIWNoaWxkKSBjb250aW51ZTtcclxuIFx0XHRcdFx0aWR4ID0gY2hpbGQucGFyZW50cy5pbmRleE9mKG1vZHVsZUlkKTtcclxuIFx0XHRcdFx0aWYoaWR4ID49IDApIHtcclxuIFx0XHRcdFx0XHRjaGlsZC5wYXJlbnRzLnNwbGljZShpZHgsIDEpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyByZW1vdmUgb3V0ZGF0ZWQgZGVwZW5kZW5jeSBmcm9tIG1vZHVsZSBjaGlsZHJlblxyXG4gXHRcdHZhciBkZXBlbmRlbmN5O1xyXG4gXHRcdHZhciBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcztcclxuIFx0XHRmb3IobW9kdWxlSWQgaW4gb3V0ZGF0ZWREZXBlbmRlbmNpZXMpIHtcclxuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvdXRkYXRlZERlcGVuZGVuY2llcywgbW9kdWxlSWQpKSB7XHJcbiBcdFx0XHRcdG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xyXG4gXHRcdFx0XHRpZihtb2R1bGUpIHtcclxuIFx0XHRcdFx0XHRtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyA9IG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXTtcclxuIFx0XHRcdFx0XHRmb3IoaiA9IDA7IGogPCBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcy5sZW5ndGg7IGorKykge1xyXG4gXHRcdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2pdO1xyXG4gXHRcdFx0XHRcdFx0aWR4ID0gbW9kdWxlLmNoaWxkcmVuLmluZGV4T2YoZGVwZW5kZW5jeSk7XHJcbiBcdFx0XHRcdFx0XHRpZihpZHggPj0gMCkgbW9kdWxlLmNoaWxkcmVuLnNwbGljZShpZHgsIDEpO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gTm90IGluIFwiYXBwbHlcIiBwaGFzZVxyXG4gXHRcdGhvdFNldFN0YXR1cyhcImFwcGx5XCIpO1xyXG4gXHRcclxuIFx0XHRob3RDdXJyZW50SGFzaCA9IGhvdFVwZGF0ZU5ld0hhc2g7XHJcbiBcdFxyXG4gXHRcdC8vIGluc2VydCBuZXcgY29kZVxyXG4gXHRcdGZvcihtb2R1bGVJZCBpbiBhcHBsaWVkVXBkYXRlKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXBwbGllZFVwZGF0ZSwgbW9kdWxlSWQpKSB7XHJcbiBcdFx0XHRcdG1vZHVsZXNbbW9kdWxlSWRdID0gYXBwbGllZFVwZGF0ZVttb2R1bGVJZF07XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBjYWxsIGFjY2VwdCBoYW5kbGVyc1xyXG4gXHRcdHZhciBlcnJvciA9IG51bGw7XHJcbiBcdFx0Zm9yKG1vZHVsZUlkIGluIG91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3V0ZGF0ZWREZXBlbmRlbmNpZXMsIG1vZHVsZUlkKSkge1xyXG4gXHRcdFx0XHRtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcclxuIFx0XHRcdFx0aWYobW9kdWxlKSB7XHJcbiBcdFx0XHRcdFx0bW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRcdFx0dmFyIGNhbGxiYWNrcyA9IFtdO1xyXG4gXHRcdFx0XHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiBcdFx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXNbaV07XHJcbiBcdFx0XHRcdFx0XHRjYiA9IG1vZHVsZS5ob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW2RlcGVuZGVuY3ldO1xyXG4gXHRcdFx0XHRcdFx0aWYoY2IpIHtcclxuIFx0XHRcdFx0XHRcdFx0aWYoY2FsbGJhY2tzLmluZGV4T2YoY2IpID49IDApIGNvbnRpbnVlO1xyXG4gXHRcdFx0XHRcdFx0XHRjYWxsYmFja3MucHVzaChjYik7XHJcbiBcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdGZvcihpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0XHRcdFx0Y2IgPSBjYWxsYmFja3NbaV07XHJcbiBcdFx0XHRcdFx0XHR0cnkge1xyXG4gXHRcdFx0XHRcdFx0XHRjYihtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyk7XHJcbiBcdFx0XHRcdFx0XHR9IGNhdGNoKGVycikge1xyXG4gXHRcdFx0XHRcdFx0XHRpZihvcHRpb25zLm9uRXJyb3JlZCkge1xyXG4gXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcclxuIFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYWNjZXB0LWVycm9yZWRcIixcclxuIFx0XHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcclxuIFx0XHRcdFx0XHRcdFx0XHRcdGRlcGVuZGVuY3lJZDogbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXNbaV0sXHJcbiBcdFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyXHJcbiBcdFx0XHRcdFx0XHRcdFx0fSk7XHJcbiBcdFx0XHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRcdFx0aWYoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xyXG4gXHRcdFx0XHRcdFx0XHRcdGlmKCFlcnJvcilcclxuIFx0XHRcdFx0XHRcdFx0XHRcdGVycm9yID0gZXJyO1xyXG4gXHRcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBMb2FkIHNlbGYgYWNjZXB0ZWQgbW9kdWxlc1xyXG4gXHRcdGZvcihpID0gMDsgaSA8IG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0dmFyIGl0ZW0gPSBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXNbaV07XHJcbiBcdFx0XHRtb2R1bGVJZCA9IGl0ZW0ubW9kdWxlO1xyXG4gXHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBbbW9kdWxlSWRdO1xyXG4gXHRcdFx0dHJ5IHtcclxuIFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCk7XHJcbiBcdFx0XHR9IGNhdGNoKGVycikge1xyXG4gXHRcdFx0XHRpZih0eXBlb2YgaXRlbS5lcnJvckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gXHRcdFx0XHRcdHRyeSB7XHJcbiBcdFx0XHRcdFx0XHRpdGVtLmVycm9ySGFuZGxlcihlcnIpO1xyXG4gXHRcdFx0XHRcdH0gY2F0Y2goZXJyMikge1xyXG4gXHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkVycm9yZWQpIHtcclxuIFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xyXG4gXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic2VsZi1hY2NlcHQtZXJyb3ItaGFuZGxlci1lcnJvcmVkXCIsXHJcbiBcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxyXG4gXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnIyLFxyXG4gXHRcdFx0XHRcdFx0XHRcdG9yZ2luYWxFcnJvcjogZXJyXHJcbiBcdFx0XHRcdFx0XHRcdH0pO1xyXG4gXHRcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdFx0aWYoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xyXG4gXHRcdFx0XHRcdFx0XHRpZighZXJyb3IpXHJcbiBcdFx0XHRcdFx0XHRcdFx0ZXJyb3IgPSBlcnIyO1xyXG4gXHRcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdFx0aWYoIWVycm9yKVxyXG4gXHRcdFx0XHRcdFx0XHRlcnJvciA9IGVycjtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdH0gZWxzZSB7XHJcbiBcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkVycm9yZWQpIHtcclxuIFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcclxuIFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzZWxmLWFjY2VwdC1lcnJvcmVkXCIsXHJcbiBcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcclxuIFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVyclxyXG4gXHRcdFx0XHRcdFx0fSk7XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdGlmKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcclxuIFx0XHRcdFx0XHRcdGlmKCFlcnJvcilcclxuIFx0XHRcdFx0XHRcdFx0ZXJyb3IgPSBlcnI7XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBoYW5kbGUgZXJyb3JzIGluIGFjY2VwdCBoYW5kbGVycyBhbmQgc2VsZiBhY2NlcHRlZCBtb2R1bGUgbG9hZFxyXG4gXHRcdGlmKGVycm9yKSB7XHJcbiBcdFx0XHRob3RTZXRTdGF0dXMoXCJmYWlsXCIpO1xyXG4gXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdGhvdFNldFN0YXR1cyhcImlkbGVcIik7XHJcbiBcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcclxuIFx0XHRcdHJlc29sdmUob3V0ZGF0ZWRNb2R1bGVzKTtcclxuIFx0XHR9KTtcclxuIFx0fVxyXG5cbiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGhvdDogaG90Q3JlYXRlTW9kdWxlKG1vZHVsZUlkKSxcbiBcdFx0XHRwYXJlbnRzOiAoaG90Q3VycmVudFBhcmVudHNUZW1wID0gaG90Q3VycmVudFBhcmVudHMsIGhvdEN1cnJlbnRQYXJlbnRzID0gW10sIGhvdEN1cnJlbnRQYXJlbnRzVGVtcCksXG4gXHRcdFx0Y2hpbGRyZW46IFtdXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIGhvdENyZWF0ZVJlcXVpcmUobW9kdWxlSWQpKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvc3RhdGljL1wiO1xuXG4gXHQvLyBfX3dlYnBhY2tfaGFzaF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmggPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhvdEN1cnJlbnRIYXNoOyB9O1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBob3RDcmVhdGVSZXF1aXJlKDIyNCkoX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMjI0KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA1ZDQxZDY4NWNlZWNjNWE1MGIzZCIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIHx8IChnbG9iYWxbbmFtZV0gPSB7fSkgOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KTtcbiAgdmFyIGtleSwgb3duLCBvdXQsIGV4cDtcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgaWYgKHRhcmdldCkgcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7XG4gICAgLy8gZXhwb3J0XG4gICAgaWYgKGV4cG9ydHNba2V5XSAhPSBvdXQpIGhpZGUoZXhwb3J0cywga2V5LCBleHApO1xuICAgIGlmIChJU19QUk9UTyAmJiBleHBQcm90b1trZXldICE9IG91dCkgZXhwUHJvdG9ba2V5XSA9IG91dDtcbiAgfVxufTtcbmdsb2JhbC5jb3JlID0gY29yZTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qcyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGVtcHR5RnVuY3Rpb247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG4gICAgICByZXR1cm47IC8vIElnbm9yZSBDb21wb3NpdGVDb21wb25lbnQgcHJvcHR5cGUgY2hlY2suXG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qcyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogV0FSTklORzogRE8gTk9UIG1hbnVhbGx5IHJlcXVpcmUgdGhpcyBtb2R1bGUuXG4gKiBUaGlzIGlzIGEgcmVwbGFjZW1lbnQgZm9yIGBpbnZhcmlhbnQoLi4uKWAgdXNlZCBieSB0aGUgZXJyb3IgY29kZSBzeXN0ZW1cbiAqIGFuZCB3aWxsIF9vbmx5XyBiZSByZXF1aXJlZCBieSB0aGUgY29ycmVzcG9uZGluZyBiYWJlbCBwYXNzLlxuICogSXQgYWx3YXlzIHRocm93cy5cbiAqL1xuXG5mdW5jdGlvbiByZWFjdFByb2RJbnZhcmlhbnQoY29kZSkge1xuICB2YXIgYXJnQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcblxuICB2YXIgbWVzc2FnZSA9ICdNaW5pZmllZCBSZWFjdCBlcnJvciAjJyArIGNvZGUgKyAnOyB2aXNpdCAnICsgJ2h0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PScgKyBjb2RlO1xuXG4gIGZvciAodmFyIGFyZ0lkeCA9IDA7IGFyZ0lkeCA8IGFyZ0NvdW50OyBhcmdJZHgrKykge1xuICAgIG1lc3NhZ2UgKz0gJyZhcmdzW109JyArIGVuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbYXJnSWR4ICsgMV0pO1xuICB9XG5cbiAgbWVzc2FnZSArPSAnIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCcgKyAnIGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLic7XG5cbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgcmVhY3RQcm9kSW52YXJpYW50J3Mgb3duIGZyYW1lXG5cbiAgdGhyb3cgZXJyb3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVhY3RQcm9kSW52YXJpYW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL3JlYWN0UHJvZEludmFyaWFudC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzIiwiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanMiLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWxlbmd0aC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudEZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudEZsYWdzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIEFUVFJfTkFNRSA9IERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FO1xudmFyIEZsYWdzID0gUmVhY3RET01Db21wb25lbnRGbGFncztcblxudmFyIGludGVybmFsSW5zdGFuY2VLZXkgPSAnX19yZWFjdEludGVybmFsSW5zdGFuY2UkJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgZ2l2ZW4gbm9kZSBzaG91bGQgYmUgY2FjaGVkLlxuICovXG5mdW5jdGlvbiBzaG91bGRQcmVjYWNoZU5vZGUobm9kZSwgbm9kZUlEKSB7XG4gIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAxICYmIG5vZGUuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgPT09IFN0cmluZyhub2RlSUQpIHx8IG5vZGUubm9kZVR5cGUgPT09IDggJiYgbm9kZS5ub2RlVmFsdWUgPT09ICcgcmVhY3QtdGV4dDogJyArIG5vZGVJRCArICcgJyB8fCBub2RlLm5vZGVUeXBlID09PSA4ICYmIG5vZGUubm9kZVZhbHVlID09PSAnIHJlYWN0LWVtcHR5OiAnICsgbm9kZUlEICsgJyAnO1xufVxuXG4vKipcbiAqIERyaWxsIGRvd24gKHRocm91Z2ggY29tcG9zaXRlcyBhbmQgZW1wdHkgY29tcG9uZW50cykgdW50aWwgd2UgZ2V0IGEgaG9zdCBvclxuICogaG9zdCB0ZXh0IGNvbXBvbmVudC5cbiAqXG4gKiBUaGlzIGlzIHByZXR0eSBwb2x5bW9ycGhpYyBidXQgdW5hdm9pZGFibGUgd2l0aCB0aGUgY3VycmVudCBzdHJ1Y3R1cmUgd2UgaGF2ZVxuICogZm9yIGBfcmVuZGVyZWRDaGlsZHJlbmAuXG4gKi9cbmZ1bmN0aW9uIGdldFJlbmRlcmVkSG9zdE9yVGV4dEZyb21Db21wb25lbnQoY29tcG9uZW50KSB7XG4gIHZhciByZW5kZXJlZDtcbiAgd2hpbGUgKHJlbmRlcmVkID0gY29tcG9uZW50Ll9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgIGNvbXBvbmVudCA9IHJlbmRlcmVkO1xuICB9XG4gIHJldHVybiBjb21wb25lbnQ7XG59XG5cbi8qKlxuICogUG9wdWxhdGUgYF9ob3N0Tm9kZWAgb24gdGhlIHJlbmRlcmVkIGhvc3QvdGV4dCBjb21wb25lbnQgd2l0aCB0aGUgZ2l2ZW5cbiAqIERPTSBub2RlLiBUaGUgcGFzc2VkIGBpbnN0YCBjYW4gYmUgYSBjb21wb3NpdGUuXG4gKi9cbmZ1bmN0aW9uIHByZWNhY2hlTm9kZShpbnN0LCBub2RlKSB7XG4gIHZhciBob3N0SW5zdCA9IGdldFJlbmRlcmVkSG9zdE9yVGV4dEZyb21Db21wb25lbnQoaW5zdCk7XG4gIGhvc3RJbnN0Ll9ob3N0Tm9kZSA9IG5vZGU7XG4gIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBob3N0SW5zdDtcbn1cblxuZnVuY3Rpb24gdW5jYWNoZU5vZGUoaW5zdCkge1xuICB2YXIgbm9kZSA9IGluc3QuX2hvc3ROb2RlO1xuICBpZiAobm9kZSkge1xuICAgIGRlbGV0ZSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICAgIGluc3QuX2hvc3ROb2RlID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFBvcHVsYXRlIGBfaG9zdE5vZGVgIG9uIGVhY2ggY2hpbGQgb2YgYGluc3RgLCBhc3N1bWluZyB0aGF0IHRoZSBjaGlsZHJlblxuICogbWF0Y2ggdXAgd2l0aCB0aGUgRE9NIChlbGVtZW50KSBjaGlsZHJlbiBvZiBgbm9kZWAuXG4gKlxuICogV2UgY2FjaGUgZW50aXJlIGxldmVscyBhdCBvbmNlIHRvIGF2b2lkIGFuIG5eMiBwcm9ibGVtIHdoZXJlIHdlIGFjY2VzcyB0aGVcbiAqIGNoaWxkcmVuIG9mIGEgbm9kZSBzZXF1ZW50aWFsbHkgYW5kIGhhdmUgdG8gd2FsayBmcm9tIHRoZSBzdGFydCB0byBvdXIgdGFyZ2V0XG4gKiBub2RlIGV2ZXJ5IHRpbWUuXG4gKlxuICogU2luY2Ugd2UgdXBkYXRlIGBfcmVuZGVyZWRDaGlsZHJlbmAgYW5kIHRoZSBhY3R1YWwgRE9NIGF0IChzbGlnaHRseSlcbiAqIGRpZmZlcmVudCB0aW1lcywgd2UgY291bGQgcmFjZSBoZXJlIGFuZCBzZWUgYSBuZXdlciBgX3JlbmRlcmVkQ2hpbGRyZW5gIHRoYW5cbiAqIHRoZSBET00gbm9kZXMgd2Ugc2VlLiBUbyBhdm9pZCB0aGlzLCBSZWFjdE11bHRpQ2hpbGQgY2FsbHNcbiAqIGBwcmVwYXJlVG9NYW5hZ2VDaGlsZHJlbmAgYmVmb3JlIHdlIGNoYW5nZSBgX3JlbmRlcmVkQ2hpbGRyZW5gLCBhdCB3aGljaFxuICogdGltZSB0aGUgY29udGFpbmVyJ3MgY2hpbGQgbm9kZXMgYXJlIGFsd2F5cyBjYWNoZWQgKHVudGlsIGl0IHVubW91bnRzKS5cbiAqL1xuZnVuY3Rpb24gcHJlY2FjaGVDaGlsZE5vZGVzKGluc3QsIG5vZGUpIHtcbiAgaWYgKGluc3QuX2ZsYWdzICYgRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2Rlcykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2hpbGRyZW4gPSBpbnN0Ll9yZW5kZXJlZENoaWxkcmVuO1xuICB2YXIgY2hpbGROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICBvdXRlcjogZm9yICh2YXIgbmFtZSBpbiBjaGlsZHJlbikge1xuICAgIGlmICghY2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgY2hpbGRJbnN0ID0gY2hpbGRyZW5bbmFtZV07XG4gICAgdmFyIGNoaWxkSUQgPSBnZXRSZW5kZXJlZEhvc3RPclRleHRGcm9tQ29tcG9uZW50KGNoaWxkSW5zdCkuX2RvbUlEO1xuICAgIGlmIChjaGlsZElEID09PSAwKSB7XG4gICAgICAvLyBXZSdyZSBjdXJyZW50bHkgdW5tb3VudGluZyB0aGlzIGNoaWxkIGluIFJlYWN0TXVsdGlDaGlsZDsgc2tpcCBpdC5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBXZSBhc3N1bWUgdGhlIGNoaWxkIG5vZGVzIGFyZSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgY2hpbGQgaW5zdGFuY2VzLlxuICAgIGZvciAoOyBjaGlsZE5vZGUgIT09IG51bGw7IGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZykge1xuICAgICAgaWYgKHNob3VsZFByZWNhY2hlTm9kZShjaGlsZE5vZGUsIGNoaWxkSUQpKSB7XG4gICAgICAgIHByZWNhY2hlTm9kZShjaGlsZEluc3QsIGNoaWxkTm9kZSk7XG4gICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIERPTSBjaGlsZHJlbiB3aXRob3V0IGZpbmRpbmcgYW4gSUQgbWF0Y2guXG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIGVsZW1lbnQgd2l0aCBJRCAlcy4nLCBjaGlsZElEKSA6IF9wcm9kSW52YXJpYW50KCczMicsIGNoaWxkSUQpIDogdm9pZCAwO1xuICB9XG4gIGluc3QuX2ZsYWdzIHw9IEZsYWdzLmhhc0NhY2hlZENoaWxkTm9kZXM7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBjbG9zZXN0IFJlYWN0RE9NQ29tcG9uZW50IG9yXG4gKiBSZWFjdERPTVRleHRDb21wb25lbnQgaW5zdGFuY2UgYW5jZXN0b3IuXG4gKi9cbmZ1bmN0aW9uIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcbiAgaWYgKG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICByZXR1cm4gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhbiBhbmNlc3RvciB3aG9zZSBpbnN0YW5jZSB3ZSBoYXZlIGNhY2hlZC5cbiAgdmFyIHBhcmVudHMgPSBbXTtcbiAgd2hpbGUgKCFub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKSB7XG4gICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRvcCBvZiB0aGUgdHJlZS4gVGhpcyBub2RlIG11c3Qgbm90IGJlIHBhcnQgb2YgYSBSZWFjdCB0cmVlIChvciBpc1xuICAgICAgLy8gdW5tb3VudGVkLCBwb3RlbnRpYWxseSkuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgY2xvc2VzdDtcbiAgdmFyIGluc3Q7XG4gIGZvciAoOyBub2RlICYmIChpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSk7IG5vZGUgPSBwYXJlbnRzLnBvcCgpKSB7XG4gICAgY2xvc2VzdCA9IGluc3Q7XG4gICAgaWYgKHBhcmVudHMubGVuZ3RoKSB7XG4gICAgICBwcmVjYWNoZUNoaWxkTm9kZXMoaW5zdCwgbm9kZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNsb3Nlc3Q7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqIGluc3RhbmNlLCBvciBudWxsIGlmIHRoZSBub2RlIHdhcyBub3QgcmVuZGVyZWQgYnkgdGhpcyBSZWFjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKSB7XG4gIHZhciBpbnN0ID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobm9kZSk7XG4gIGlmIChpbnN0ICE9IG51bGwgJiYgaW5zdC5faG9zdE5vZGUgPT09IG5vZGUpIHtcbiAgICByZXR1cm4gaW5zdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGEgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50LCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmdcbiAqIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBnZXROb2RlRnJvbUluc3RhbmNlKGluc3QpIHtcbiAgLy8gV2l0aG91dCB0aGlzIGZpcnN0IGludmFyaWFudCwgcGFzc2luZyBhIG5vbi1ET00tY29tcG9uZW50IHRyaWdnZXJzIHRoZSBuZXh0XG4gIC8vIGludmFyaWFudCBmb3IgYSBtaXNzaW5nIHBhcmVudCwgd2hpY2ggaXMgc3VwZXIgY29uZnVzaW5nLlxuICAhKGluc3QuX2hvc3ROb2RlICE9PSB1bmRlZmluZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzMnKSA6IHZvaWQgMDtcblxuICBpZiAoaW5zdC5faG9zdE5vZGUpIHtcbiAgICByZXR1cm4gaW5zdC5faG9zdE5vZGU7XG4gIH1cblxuICAvLyBXYWxrIHVwIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYW4gYW5jZXN0b3Igd2hvc2UgRE9NIG5vZGUgd2UgaGF2ZSBjYWNoZWQuXG4gIHZhciBwYXJlbnRzID0gW107XG4gIHdoaWxlICghaW5zdC5faG9zdE5vZGUpIHtcbiAgICBwYXJlbnRzLnB1c2goaW5zdCk7XG4gICAgIWluc3QuX2hvc3RQYXJlbnQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QgRE9NIHRyZWUgcm9vdCBzaG91bGQgYWx3YXlzIGhhdmUgYSBub2RlIHJlZmVyZW5jZS4nKSA6IF9wcm9kSW52YXJpYW50KCczNCcpIDogdm9pZCAwO1xuICAgIGluc3QgPSBpbnN0Ll9ob3N0UGFyZW50O1xuICB9XG5cbiAgLy8gTm93IHBhcmVudHMgY29udGFpbnMgZWFjaCBhbmNlc3RvciB0aGF0IGRvZXMgKm5vdCogaGF2ZSBhIGNhY2hlZCBuYXRpdmVcbiAgLy8gbm9kZSwgYW5kIGBpbnN0YCBpcyB0aGUgZGVlcGVzdCBhbmNlc3RvciB0aGF0IGRvZXMuXG4gIGZvciAoOyBwYXJlbnRzLmxlbmd0aDsgaW5zdCA9IHBhcmVudHMucG9wKCkpIHtcbiAgICBwcmVjYWNoZUNoaWxkTm9kZXMoaW5zdCwgaW5zdC5faG9zdE5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIGluc3QuX2hvc3ROb2RlO1xufVxuXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0ge1xuICBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZTogZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gIGdldEluc3RhbmNlRnJvbU5vZGU6IGdldEluc3RhbmNlRnJvbU5vZGUsXG4gIGdldE5vZGVGcm9tSW5zdGFuY2U6IGdldE5vZGVGcm9tSW5zdGFuY2UsXG4gIHByZWNhY2hlQ2hpbGROb2RlczogcHJlY2FjaGVDaGlsZE5vZGVzLFxuICBwcmVjYWNoZU5vZGU6IHByZWNhY2hlTm9kZSxcbiAgdW5jYWNoZU5vZGU6IHVuY2FjaGVOb2RlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTUNvbXBvbmVudFRyZWUuanMiLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxuLyoqXG4gKiBTaW1wbGUsIGxpZ2h0d2VpZ2h0IG1vZHVsZSBhc3Npc3Rpbmcgd2l0aCB0aGUgZGV0ZWN0aW9uIGFuZCBjb250ZXh0IG9mXG4gKiBXb3JrZXIuIEhlbHBzIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBhbmQgYWxsb3dzIGNvZGUgdG8gcmVhc29uIGFib3V0XG4gKiB3aGV0aGVyIG9yIG5vdCB0aGV5IGFyZSBpbiBhIFdvcmtlciwgZXZlbiBpZiB0aGV5IG5ldmVyIGluY2x1ZGUgdGhlIG1haW5cbiAqIGBSZWFjdFdvcmtlcmAgZGVwZW5kZW5jeS5cbiAqL1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0ge1xuXG4gIGNhblVzZURPTTogY2FuVXNlRE9NLFxuXG4gIGNhblVzZVdvcmtlcnM6IHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnLFxuXG4gIGNhblVzZUV2ZW50TGlzdGVuZXJzOiBjYW5Vc2VET00gJiYgISEod2luZG93LmFkZEV2ZW50TGlzdGVuZXIgfHwgd2luZG93LmF0dGFjaEV2ZW50KSxcblxuICBjYW5Vc2VWaWV3cG9ydDogY2FuVXNlRE9NICYmICEhd2luZG93LnNjcmVlbixcblxuICBpc0luV29ya2VyOiAhY2FuVXNlRE9NIC8vIEZvciBub3csIHRoaXMgaXMgdHJ1ZSAtIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGlkZS5qcyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFNSQyA9IHJlcXVpcmUoJy4vX3VpZCcpKCdzcmMnKTtcbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyICR0b1N0cmluZyA9IEZ1bmN0aW9uW1RPX1NUUklOR107XG52YXIgVFBMID0gKCcnICsgJHRvU3RyaW5nKS5zcGxpdChUT19TVFJJTkcpO1xuXG5yZXF1aXJlKCcuL19jb3JlJykuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoaXQpO1xufTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsLCBzYWZlKSB7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgJ25hbWUnKSB8fCBoaWRlKHZhbCwgJ25hbWUnLCBrZXkpO1xuICBpZiAoT1trZXldID09PSB2YWwpIHJldHVybjtcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsIFNSQykgfHwgaGlkZSh2YWwsIFNSQywgT1trZXldID8gJycgKyBPW2tleV0gOiBUUEwuam9pbihTdHJpbmcoa2V5KSkpO1xuICBpZiAoTyA9PT0gZ2xvYmFsKSB7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2UgaWYgKCFzYWZlKSB7XG4gICAgZGVsZXRlIE9ba2V5XTtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfSBlbHNlIGlmIChPW2tleV0pIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH1cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzW1NSQ10gfHwgJHRvU3RyaW5nLmNhbGwodGhpcyk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciBxdW90ID0gL1wiL2c7XG4vLyBCLjIuMy4yLjEgQ3JlYXRlSFRNTChzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSlcbnZhciBjcmVhdGVIVE1MID0gZnVuY3Rpb24gKHN0cmluZywgdGFnLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gIHZhciBTID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSk7XG4gIHZhciBwMSA9ICc8JyArIHRhZztcbiAgaWYgKGF0dHJpYnV0ZSAhPT0gJycpIHAxICs9ICcgJyArIGF0dHJpYnV0ZSArICc9XCInICsgU3RyaW5nKHZhbHVlKS5yZXBsYWNlKHF1b3QsICcmcXVvdDsnKSArICdcIic7XG4gIHJldHVybiBwMSArICc+JyArIFMgKyAnPC8nICsgdGFnICsgJz4nO1xufTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUsIGV4ZWMpIHtcbiAgdmFyIE8gPSB7fTtcbiAgT1tOQU1FXSA9IGV4ZWMoY3JlYXRlSFRNTCk7XG4gICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZXN0ID0gJydbTkFNRV0oJ1wiJyk7XG4gICAgcmV0dXJuIHRlc3QgIT09IHRlc3QudG9Mb3dlckNhc2UoKSB8fCB0ZXN0LnNwbGl0KCdcIicpLmxlbmd0aCA+IDM7XG4gIH0pLCAnU3RyaW5nJywgTyk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWh0bWwuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGlzTmF0aXZlKGZuKSB7XG4gIC8vIEJhc2VkIG9uIGlzTmF0aXZlKCkgZnJvbSBMb2Rhc2hcbiAgdmFyIGZ1bmNUb1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICsgZnVuY1RvU3RyaW5nXG4gIC8vIFRha2UgYW4gZXhhbXBsZSBuYXRpdmUgZnVuY3Rpb24gc291cmNlIGZvciBjb21wYXJpc29uXG4gIC5jYWxsKGhhc093blByb3BlcnR5XG4gIC8vIFN0cmlwIHJlZ2V4IGNoYXJhY3RlcnMgc28gd2UgY2FuIHVzZSBpdCBmb3IgcmVnZXhcbiAgKS5yZXBsYWNlKC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZywgJ1xcXFwkJidcbiAgLy8gUmVtb3ZlIGhhc093blByb3BlcnR5IGZyb20gdGhlIHRlbXBsYXRlIHRvIG1ha2UgaXQgZ2VuZXJpY1xuICApLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnKTtcbiAgdHJ5IHtcbiAgICB2YXIgc291cmNlID0gZnVuY1RvU3RyaW5nLmNhbGwoZm4pO1xuICAgIHJldHVybiByZUlzTmF0aXZlLnRlc3Qoc291cmNlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbnZhciBjYW5Vc2VDb2xsZWN0aW9ucyA9XG4vLyBBcnJheS5mcm9tXG50eXBlb2YgQXJyYXkuZnJvbSA9PT0gJ2Z1bmN0aW9uJyAmJlxuLy8gTWFwXG50eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nICYmIGlzTmF0aXZlKE1hcCkgJiZcbi8vIE1hcC5wcm90b3R5cGUua2V5c1xuTWFwLnByb3RvdHlwZSAhPSBudWxsICYmIHR5cGVvZiBNYXAucHJvdG90eXBlLmtleXMgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoTWFwLnByb3RvdHlwZS5rZXlzKSAmJlxuLy8gU2V0XG50eXBlb2YgU2V0ID09PSAnZnVuY3Rpb24nICYmIGlzTmF0aXZlKFNldCkgJiZcbi8vIFNldC5wcm90b3R5cGUua2V5c1xuU2V0LnByb3RvdHlwZSAhPSBudWxsICYmIHR5cGVvZiBTZXQucHJvdG90eXBlLmtleXMgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoU2V0LnByb3RvdHlwZS5rZXlzKTtcblxudmFyIHNldEl0ZW07XG52YXIgZ2V0SXRlbTtcbnZhciByZW1vdmVJdGVtO1xudmFyIGdldEl0ZW1JRHM7XG52YXIgYWRkUm9vdDtcbnZhciByZW1vdmVSb290O1xudmFyIGdldFJvb3RJRHM7XG5cbmlmIChjYW5Vc2VDb2xsZWN0aW9ucykge1xuICB2YXIgaXRlbU1hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIHJvb3RJRFNldCA9IG5ldyBTZXQoKTtcblxuICBzZXRJdGVtID0gZnVuY3Rpb24gKGlkLCBpdGVtKSB7XG4gICAgaXRlbU1hcC5zZXQoaWQsIGl0ZW0pO1xuICB9O1xuICBnZXRJdGVtID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIGl0ZW1NYXAuZ2V0KGlkKTtcbiAgfTtcbiAgcmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIChpZCkge1xuICAgIGl0ZW1NYXBbJ2RlbGV0ZSddKGlkKTtcbiAgfTtcbiAgZ2V0SXRlbUlEcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShpdGVtTWFwLmtleXMoKSk7XG4gIH07XG5cbiAgYWRkUm9vdCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHJvb3RJRFNldC5hZGQoaWQpO1xuICB9O1xuICByZW1vdmVSb290ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgcm9vdElEU2V0WydkZWxldGUnXShpZCk7XG4gIH07XG4gIGdldFJvb3RJRHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ocm9vdElEU2V0LmtleXMoKSk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgaXRlbUJ5S2V5ID0ge307XG4gIHZhciByb290QnlLZXkgPSB7fTtcblxuICAvLyBVc2Ugbm9uLW51bWVyaWMga2V5cyB0byBwcmV2ZW50IFY4IHBlcmZvcm1hbmNlIGlzc3VlczpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzIzMlxuICB2YXIgZ2V0S2V5RnJvbUlEID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuICcuJyArIGlkO1xuICB9O1xuICB2YXIgZ2V0SURGcm9tS2V5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBwYXJzZUludChrZXkuc3Vic3RyKDEpLCAxMCk7XG4gIH07XG5cbiAgc2V0SXRlbSA9IGZ1bmN0aW9uIChpZCwgaXRlbSkge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIGl0ZW1CeUtleVtrZXldID0gaXRlbTtcbiAgfTtcbiAgZ2V0SXRlbSA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIHJldHVybiBpdGVtQnlLZXlba2V5XTtcbiAgfTtcbiAgcmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIGRlbGV0ZSBpdGVtQnlLZXlba2V5XTtcbiAgfTtcbiAgZ2V0SXRlbUlEcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoaXRlbUJ5S2V5KS5tYXAoZ2V0SURGcm9tS2V5KTtcbiAgfTtcblxuICBhZGRSb290ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgcm9vdEJ5S2V5W2tleV0gPSB0cnVlO1xuICB9O1xuICByZW1vdmVSb290ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgZGVsZXRlIHJvb3RCeUtleVtrZXldO1xuICB9O1xuICBnZXRSb290SURzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhyb290QnlLZXkpLm1hcChnZXRJREZyb21LZXkpO1xuICB9O1xufVxuXG52YXIgdW5tb3VudGVkSURzID0gW107XG5cbmZ1bmN0aW9uIHB1cmdlRGVlcChpZCkge1xuICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICBpZiAoaXRlbSkge1xuICAgIHZhciBjaGlsZElEcyA9IGl0ZW0uY2hpbGRJRHM7XG5cbiAgICByZW1vdmVJdGVtKGlkKTtcbiAgICBjaGlsZElEcy5mb3JFYWNoKHB1cmdlRGVlcCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSkge1xuICByZXR1cm4gJ1xcbiAgICBpbiAnICsgKG5hbWUgfHwgJ1Vua25vd24nKSArIChzb3VyY2UgPyAnIChhdCAnICsgc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKSArICc6JyArIHNvdXJjZS5saW5lTnVtYmVyICsgJyknIDogb3duZXJOYW1lID8gJyAoY3JlYXRlZCBieSAnICsgb3duZXJOYW1lICsgJyknIDogJycpO1xufVxuXG5mdW5jdGlvbiBnZXREaXNwbGF5TmFtZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gJyNlbXB0eSc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiAnI3RleHQnO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQudHlwZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxlbWVudC50eXBlLmRpc3BsYXlOYW1lIHx8IGVsZW1lbnQudHlwZS5uYW1lIHx8ICdVbmtub3duJztcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXNjcmliZUlEKGlkKSB7XG4gIHZhciBuYW1lID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShpZCk7XG4gIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcbiAgdmFyIG93bmVySUQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldE93bmVySUQoaWQpO1xuICB2YXIgb3duZXJOYW1lO1xuICBpZiAob3duZXJJRCkge1xuICAgIG93bmVyTmFtZSA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RGlzcGxheU5hbWUob3duZXJJRCk7XG4gIH1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZWxlbWVudCwgJ1JlYWN0Q29tcG9uZW50VHJlZUhvb2s6IE1pc3NpbmcgUmVhY3QgZWxlbWVudCBmb3IgZGVidWdJRCAlcyB3aGVuICcgKyAnYnVpbGRpbmcgc3RhY2snLCBpZCkgOiB2b2lkIDA7XG4gIHJldHVybiBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIGVsZW1lbnQgJiYgZWxlbWVudC5fc291cmNlLCBvd25lck5hbWUpO1xufVxuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHtcbiAgb25TZXRDaGlsZHJlbjogZnVuY3Rpb24gKGlkLCBuZXh0Q2hpbGRJRHMpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgICFpdGVtID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0l0ZW0gbXVzdCBoYXZlIGJlZW4gc2V0JykgOiBfcHJvZEludmFyaWFudCgnMTQ0JykgOiB2b2lkIDA7XG4gICAgaXRlbS5jaGlsZElEcyA9IG5leHRDaGlsZElEcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV4dENoaWxkSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dENoaWxkSUQgPSBuZXh0Q2hpbGRJRHNbaV07XG4gICAgICB2YXIgbmV4dENoaWxkID0gZ2V0SXRlbShuZXh0Q2hpbGRJRCk7XG4gICAgICAhbmV4dENoaWxkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGhvb2sgZXZlbnRzIHRvIGZpcmUgZm9yIHRoZSBjaGlsZCBiZWZvcmUgaXRzIHBhcmVudCBpbmNsdWRlcyBpdCBpbiBvblNldENoaWxkcmVuKCkuJykgOiBfcHJvZEludmFyaWFudCgnMTQwJykgOiB2b2lkIDA7XG4gICAgICAhKG5leHRDaGlsZC5jaGlsZElEcyAhPSBudWxsIHx8IHR5cGVvZiBuZXh0Q2hpbGQuZWxlbWVudCAhPT0gJ29iamVjdCcgfHwgbmV4dENoaWxkLmVsZW1lbnQgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgb25TZXRDaGlsZHJlbigpIHRvIGZpcmUgZm9yIGEgY29udGFpbmVyIGNoaWxkIGJlZm9yZSBpdHMgcGFyZW50IGluY2x1ZGVzIGl0IGluIG9uU2V0Q2hpbGRyZW4oKS4nKSA6IF9wcm9kSW52YXJpYW50KCcxNDEnKSA6IHZvaWQgMDtcbiAgICAgICFuZXh0Q2hpbGQuaXNNb3VudGVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIG9uTW91bnRDb21wb25lbnQoKSB0byBmaXJlIGZvciB0aGUgY2hpbGQgYmVmb3JlIGl0cyBwYXJlbnQgaW5jbHVkZXMgaXQgaW4gb25TZXRDaGlsZHJlbigpLicpIDogX3Byb2RJbnZhcmlhbnQoJzcxJykgOiB2b2lkIDA7XG4gICAgICBpZiAobmV4dENoaWxkLnBhcmVudElEID09IG51bGwpIHtcbiAgICAgICAgbmV4dENoaWxkLnBhcmVudElEID0gaWQ7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkbid0IGJlIG5lY2Vzc2FyeSBidXQgbW91bnRpbmcgYSBuZXcgcm9vdCBkdXJpbmcgaW5cbiAgICAgICAgLy8gY29tcG9uZW50V2lsbE1vdW50IGN1cnJlbnRseSBjYXVzZXMgbm90LXlldC1tb3VudGVkIGNvbXBvbmVudHMgdG9cbiAgICAgICAgLy8gYmUgcHVyZ2VkIGZyb20gb3VyIHRyZWUgZGF0YSBzbyB0aGVpciBwYXJlbnQgaWQgaXMgbWlzc2luZy5cbiAgICAgIH1cbiAgICAgICEobmV4dENoaWxkLnBhcmVudElEID09PSBpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgb25CZWZvcmVNb3VudENvbXBvbmVudCgpIHBhcmVudCBhbmQgb25TZXRDaGlsZHJlbigpIHRvIGJlIGNvbnNpc3RlbnQgKCVzIGhhcyBwYXJlbnRzICVzIGFuZCAlcykuJywgbmV4dENoaWxkSUQsIG5leHRDaGlsZC5wYXJlbnRJRCwgaWQpIDogX3Byb2RJbnZhcmlhbnQoJzE0MicsIG5leHRDaGlsZElELCBuZXh0Q2hpbGQucGFyZW50SUQsIGlkKSA6IHZvaWQgMDtcbiAgICB9XG4gIH0sXG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCwgZWxlbWVudCwgcGFyZW50SUQpIHtcbiAgICB2YXIgaXRlbSA9IHtcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICBwYXJlbnRJRDogcGFyZW50SUQsXG4gICAgICB0ZXh0OiBudWxsLFxuICAgICAgY2hpbGRJRHM6IFtdLFxuICAgICAgaXNNb3VudGVkOiBmYWxzZSxcbiAgICAgIHVwZGF0ZUNvdW50OiAwXG4gICAgfTtcbiAgICBzZXRJdGVtKGlkLCBpdGVtKTtcbiAgfSxcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCwgZWxlbWVudCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgaWYgKCFpdGVtIHx8ICFpdGVtLmlzTW91bnRlZCkge1xuICAgICAgLy8gV2UgbWF5IGVuZCB1cCBoZXJlIGFzIGEgcmVzdWx0IG9mIHNldFN0YXRlKCkgaW4gY29tcG9uZW50V2lsbFVubW91bnQoKS5cbiAgICAgIC8vIEluIHRoaXMgY2FzZSwgaWdub3JlIHRoZSBlbGVtZW50LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpdGVtLmVsZW1lbnQgPSBlbGVtZW50O1xuICB9LFxuICBvbk1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgICFpdGVtID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0l0ZW0gbXVzdCBoYXZlIGJlZW4gc2V0JykgOiBfcHJvZEludmFyaWFudCgnMTQ0JykgOiB2b2lkIDA7XG4gICAgaXRlbS5pc01vdW50ZWQgPSB0cnVlO1xuICAgIHZhciBpc1Jvb3QgPSBpdGVtLnBhcmVudElEID09PSAwO1xuICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgIGFkZFJvb3QoaWQpO1xuICAgIH1cbiAgfSxcbiAgb25VcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgaWYgKCFpdGVtIHx8ICFpdGVtLmlzTW91bnRlZCkge1xuICAgICAgLy8gV2UgbWF5IGVuZCB1cCBoZXJlIGFzIGEgcmVzdWx0IG9mIHNldFN0YXRlKCkgaW4gY29tcG9uZW50V2lsbFVubW91bnQoKS5cbiAgICAgIC8vIEluIHRoaXMgY2FzZSwgaWdub3JlIHRoZSBlbGVtZW50LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpdGVtLnVwZGF0ZUNvdW50Kys7XG4gIH0sXG4gIG9uVW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiBpdCBleGlzdHMuXG4gICAgICAvLyBgaXRlbWAgbWlnaHQgbm90IGV4aXN0IGlmIGl0IGlzIGluc2lkZSBhbiBlcnJvciBib3VuZGFyeSwgYW5kIGEgc2libGluZ1xuICAgICAgLy8gZXJyb3IgYm91bmRhcnkgY2hpbGQgdGhyZXcgd2hpbGUgbW91bnRpbmcuIFRoZW4gdGhpcyBpbnN0YW5jZSBuZXZlclxuICAgICAgLy8gZ290IGEgY2hhbmNlIHRvIG1vdW50LCBidXQgaXQgc3RpbGwgZ2V0cyBhbiB1bm1vdW50aW5nIGV2ZW50IGR1cmluZ1xuICAgICAgLy8gdGhlIGVycm9yIGJvdW5kYXJ5IGNsZWFudXAuXG4gICAgICBpdGVtLmlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgdmFyIGlzUm9vdCA9IGl0ZW0ucGFyZW50SUQgPT09IDA7XG4gICAgICBpZiAoaXNSb290KSB7XG4gICAgICAgIHJlbW92ZVJvb3QoaWQpO1xuICAgICAgfVxuICAgIH1cbiAgICB1bm1vdW50ZWRJRHMucHVzaChpZCk7XG4gIH0sXG4gIHB1cmdlVW5tb3VudGVkQ29tcG9uZW50czogZnVuY3Rpb24gKCkge1xuICAgIGlmIChSZWFjdENvbXBvbmVudFRyZWVIb29rLl9wcmV2ZW50UHVyZ2luZykge1xuICAgICAgLy8gU2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgdGVzdGluZy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVubW91bnRlZElEcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkID0gdW5tb3VudGVkSURzW2ldO1xuICAgICAgcHVyZ2VEZWVwKGlkKTtcbiAgICB9XG4gICAgdW5tb3VudGVkSURzLmxlbmd0aCA9IDA7XG4gIH0sXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0uaXNNb3VudGVkIDogZmFsc2U7XG4gIH0sXG4gIGdldEN1cnJlbnRTdGFja0FkZGVuZHVtOiBmdW5jdGlvbiAodG9wRWxlbWVudCkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgaWYgKHRvcEVsZW1lbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0RGlzcGxheU5hbWUodG9wRWxlbWVudCk7XG4gICAgICB2YXIgb3duZXIgPSB0b3BFbGVtZW50Ll9vd25lcjtcbiAgICAgIGluZm8gKz0gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCB0b3BFbGVtZW50Ll9zb3VyY2UsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSk7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRPd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgdmFyIGlkID0gY3VycmVudE93bmVyICYmIGN1cnJlbnRPd25lci5fZGVidWdJRDtcblxuICAgIGluZm8gKz0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChpZCk7XG4gICAgcmV0dXJuIGluZm87XG4gIH0sXG4gIGdldFN0YWNrQWRkZW5kdW1CeUlEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIHdoaWxlIChpZCkge1xuICAgICAgaW5mbyArPSBkZXNjcmliZUlEKGlkKTtcbiAgICAgIGlkID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRQYXJlbnRJRChpZCk7XG4gICAgfVxuICAgIHJldHVybiBpbmZvO1xuICB9LFxuICBnZXRDaGlsZElEczogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0uY2hpbGRJRHMgOiBbXTtcbiAgfSxcbiAgZ2V0RGlzcGxheU5hbWU6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0RGlzcGxheU5hbWUoZWxlbWVudCk7XG4gIH0sXG4gIGdldEVsZW1lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmVsZW1lbnQgOiBudWxsO1xuICB9LFxuICBnZXRPd25lcklEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XG4gICAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50Ll9vd25lcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50Ll9vd25lci5fZGVidWdJRDtcbiAgfSxcbiAgZ2V0UGFyZW50SUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLnBhcmVudElEIDogbnVsbDtcbiAgfSxcbiAgZ2V0U291cmNlOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIHZhciBlbGVtZW50ID0gaXRlbSA/IGl0ZW0uZWxlbWVudCA6IG51bGw7XG4gICAgdmFyIHNvdXJjZSA9IGVsZW1lbnQgIT0gbnVsbCA/IGVsZW1lbnQuX3NvdXJjZSA6IG51bGw7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfSxcbiAgZ2V0VGV4dDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gJycgKyBlbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sXG4gIGdldFVwZGF0ZUNvdW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS51cGRhdGVDb3VudCA6IDA7XG4gIH0sXG5cblxuICBnZXRSb290SURzOiBnZXRSb290SURzLFxuICBnZXRSZWdpc3RlcmVkSURzOiBnZXRJdGVtSURzLFxuXG4gIHB1c2hOb25TdGFuZGFyZFdhcm5pbmdTdGFjazogZnVuY3Rpb24gKGlzQ3JlYXRpbmdFbGVtZW50LCBjdXJyZW50U291cmNlKSB7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlLnJlYWN0U3RhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIgY3VycmVudE93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB2YXIgaWQgPSBjdXJyZW50T3duZXIgJiYgY3VycmVudE93bmVyLl9kZWJ1Z0lEO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChpc0NyZWF0aW5nRWxlbWVudCkge1xuICAgICAgICBzdGFjay5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBpZCA/IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RGlzcGxheU5hbWUoaWQpIDogbnVsbCxcbiAgICAgICAgICBmaWxlTmFtZTogY3VycmVudFNvdXJjZSA/IGN1cnJlbnRTb3VyY2UuZmlsZU5hbWUgOiBudWxsLFxuICAgICAgICAgIGxpbmVOdW1iZXI6IGN1cnJlbnRTb3VyY2UgPyBjdXJyZW50U291cmNlLmxpbmVOdW1iZXIgOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoaWQpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICAgICAgICB2YXIgcGFyZW50SUQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFBhcmVudElEKGlkKTtcbiAgICAgICAgdmFyIG93bmVySUQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldE93bmVySUQoaWQpO1xuICAgICAgICB2YXIgb3duZXJOYW1lID0gb3duZXJJRCA/IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RGlzcGxheU5hbWUob3duZXJJRCkgOiBudWxsO1xuICAgICAgICB2YXIgc291cmNlID0gZWxlbWVudCAmJiBlbGVtZW50Ll9zb3VyY2U7XG4gICAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICAgIG5hbWU6IG93bmVyTmFtZSxcbiAgICAgICAgICBmaWxlTmFtZTogc291cmNlID8gc291cmNlLmZpbGVOYW1lIDogbnVsbCxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBzb3VyY2UgPyBzb3VyY2UubGluZU51bWJlciA6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIGlkID0gcGFyZW50SUQ7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBJbnRlcm5hbCBzdGF0ZSBpcyBtZXNzZWQgdXAuXG4gICAgICAvLyBTdG9wIGJ1aWxkaW5nIHRoZSBzdGFjayAoaXQncyBqdXN0IGEgbmljZSB0byBoYXZlKS5cbiAgICB9XG5cbiAgICBjb25zb2xlLnJlYWN0U3RhY2soc3RhY2spO1xuICB9LFxuICBwb3BOb25TdGFuZGFyZFdhcm5pbmdTdGFjazogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgY29uc29sZS5yZWFjdFN0YWNrRW5kICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnNvbGUucmVhY3RTdGFja0VuZCgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rLmpzIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJ2YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gVHJ1c3QgdGhlIGRldmVsb3BlciB0byBvbmx5IHVzZSBSZWFjdEluc3RydW1lbnRhdGlvbiB3aXRoIGEgX19ERVZfXyBjaGVja1xuXG52YXIgZGVidWdUb29sID0gbnVsbDtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0RGVidWdUb29sID0gcmVxdWlyZSgnLi9SZWFjdERlYnVnVG9vbCcpO1xuICBkZWJ1Z1Rvb2wgPSBSZWFjdERlYnVnVG9vbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IGRlYnVnVG9vbDogZGVidWdUb29sIH07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RJbnN0cnVtZW50YXRpb24uanMiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanMiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2YuanMiLCIndXNlIHN0cmljdCc7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtZXRob2QsIGFyZykge1xuICByZXR1cm4gISFtZXRob2QgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNhbGxcbiAgICBhcmcgPyBtZXRob2QuY2FsbChudWxsLCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sIDEpIDogbWV0aG9kLmNhbGwobnVsbCk7XG4gIH0pO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmljdC1tZXRob2QuanMiLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi41LjEnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29yZS5qcyIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBleGVjKSB7XG4gIHZhciBmbiA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXTtcbiAgdmFyIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qtc2FwLmpzIiwiLy8gMCAtPiBBcnJheSNmb3JFYWNoXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFzYyA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUWVBFLCAkY3JlYXRlKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgdmFyIGNyZWF0ZSA9ICRjcmVhdGUgfHwgYXNjO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XG4gICAgdmFyIHNlbGYgPSBJT2JqZWN0KE8pO1xuICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsLCByZXM7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG4gICAgICBpZiAoVFlQRSkge1xuICAgICAgICBpZiAoSVNfTUFQKSByZXN1bHRbaW5kZXhdID0gcmVzOyAgIC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXMpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZiAoSVNfRVZFUlkpIHJldHVybiBmYWxzZTsgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1tZXRob2RzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDdXJyZW50T3duZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKCcuL0NhbGxiYWNrUXVldWUnKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RGZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBkaXJ0eUNvbXBvbmVudHMgPSBbXTtcbnZhciB1cGRhdGVCYXRjaE51bWJlciA9IDA7XG52YXIgYXNhcENhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xudmFyIGFzYXBFbnF1ZXVlZCA9IGZhbHNlO1xuXG52YXIgYmF0Y2hpbmdTdHJhdGVneSA9IG51bGw7XG5cbmZ1bmN0aW9uIGVuc3VyZUluamVjdGVkKCkge1xuICAhKFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uICYmIGJhdGNoaW5nU3RyYXRlZ3kpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBpbmplY3QgYSByZWNvbmNpbGUgdHJhbnNhY3Rpb24gY2xhc3MgYW5kIGJhdGNoaW5nIHN0cmF0ZWd5JykgOiBfcHJvZEludmFyaWFudCgnMTIzJykgOiB2b2lkIDA7XG59XG5cbnZhciBORVNURURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gZGlydHlDb21wb25lbnRzLmxlbmd0aDtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggIT09IGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIEFkZGl0aW9uYWwgdXBkYXRlcyB3ZXJlIGVucXVldWVkIGJ5IGNvbXBvbmVudERpZFVwZGF0ZSBoYW5kbGVycyBvclxuICAgICAgLy8gc2ltaWxhcjsgYmVmb3JlIG91ciBvd24gVVBEQVRFX1FVRVVFSU5HIHdyYXBwZXIgY2xvc2VzLCB3ZSB3YW50IHRvIHJ1blxuICAgICAgLy8gdGhlc2UgbmV3IHVwZGF0ZXMgc28gdGhhdCBpZiBBJ3MgY29tcG9uZW50RGlkVXBkYXRlIGNhbGxzIHNldFN0YXRlIG9uXG4gICAgICAvLyBCLCBCIHdpbGwgdXBkYXRlIGJlZm9yZSB0aGUgY2FsbGJhY2sgQSdzIHVwZGF0ZXIgcHJvdmlkZWQgd2hlbiBjYWxsaW5nXG4gICAgICAvLyBzZXRTdGF0ZS5cbiAgICAgIGRpcnR5Q29tcG9uZW50cy5zcGxpY2UoMCwgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGgpO1xuICAgICAgZmx1c2hCYXRjaGVkVXBkYXRlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBVUERBVEVfUVVFVUVJTkcgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUucmVzZXQoKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUubm90aWZ5QWxsKCk7XG4gIH1cbn07XG5cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtORVNURURfVVBEQVRFUywgVVBEQVRFX1FVRVVFSU5HXTtcblxuZnVuY3Rpb24gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbigpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IG51bGw7XG4gIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKCk7XG4gIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoXG4gIC8qIHVzZUNyZWF0ZUVsZW1lbnQgKi90cnVlKTtcbn1cblxuX2Fzc2lnbihSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24sIHtcbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBudWxsO1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLmNhbGxiYWNrUXVldWUpO1xuICAgIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IG51bGw7XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucmVsZWFzZSh0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uID0gbnVsbDtcbiAgfSxcblxuICBwZXJmb3JtOiBmdW5jdGlvbiAobWV0aG9kLCBzY29wZSwgYSkge1xuICAgIC8vIEVzc2VudGlhbGx5IGNhbGxzIGB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLnBlcmZvcm0obWV0aG9kLCBzY29wZSwgYSlgXG4gICAgLy8gd2l0aCB0aGlzIHRyYW5zYWN0aW9uJ3Mgd3JhcHBlcnMgYXJvdW5kIGl0LlxuICAgIHJldHVybiBUcmFuc2FjdGlvbi5wZXJmb3JtLmNhbGwodGhpcywgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbi5wZXJmb3JtLCB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLCBtZXRob2QsIHNjb3BlLCBhKTtcbiAgfVxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uKTtcblxuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpIHtcbiAgZW5zdXJlSW5qZWN0ZWQoKTtcbiAgcmV0dXJuIGJhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpO1xufVxuXG4vKipcbiAqIEFycmF5IGNvbXBhcmF0b3IgZm9yIFJlYWN0Q29tcG9uZW50cyBieSBtb3VudCBvcmRlcmluZy5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjMSBmaXJzdCBjb21wb25lbnQgeW91J3JlIGNvbXBhcmluZ1xuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gYzIgc2Vjb25kIGNvbXBvbmVudCB5b3UncmUgY29tcGFyaW5nXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFJldHVybiB2YWx1ZSB1c2FibGUgYnkgQXJyYXkucHJvdG90eXBlLnNvcnQoKS5cbiAqL1xuZnVuY3Rpb24gbW91bnRPcmRlckNvbXBhcmF0b3IoYzEsIGMyKSB7XG4gIHJldHVybiBjMS5fbW91bnRPcmRlciAtIGMyLl9tb3VudE9yZGVyO1xufVxuXG5mdW5jdGlvbiBydW5CYXRjaGVkVXBkYXRlcyh0cmFuc2FjdGlvbikge1xuICB2YXIgbGVuID0gdHJhbnNhY3Rpb24uZGlydHlDb21wb25lbnRzTGVuZ3RoO1xuICAhKGxlbiA9PT0gZGlydHlDb21wb25lbnRzLmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgZmx1c2ggdHJhbnNhY3Rpb25cXCdzIHN0b3JlZCBkaXJ0eS1jb21wb25lbnRzIGxlbmd0aCAoJXMpIHRvIG1hdGNoIGRpcnR5LWNvbXBvbmVudHMgYXJyYXkgbGVuZ3RoICglcykuJywgbGVuLCBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSA6IF9wcm9kSW52YXJpYW50KCcxMjQnLCBsZW4sIGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIDogdm9pZCAwO1xuXG4gIC8vIFNpbmNlIHJlY29uY2lsaW5nIGEgY29tcG9uZW50IGhpZ2hlciBpbiB0aGUgb3duZXIgaGllcmFyY2h5IHVzdWFsbHkgKG5vdFxuICAvLyBhbHdheXMgLS0gc2VlIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpKSB3aWxsIHJlY29uY2lsZSBjaGlsZHJlbiwgcmVjb25jaWxlXG4gIC8vIHRoZW0gYmVmb3JlIHRoZWlyIGNoaWxkcmVuIGJ5IHNvcnRpbmcgdGhlIGFycmF5LlxuICBkaXJ0eUNvbXBvbmVudHMuc29ydChtb3VudE9yZGVyQ29tcGFyYXRvcik7XG5cbiAgLy8gQW55IHVwZGF0ZXMgZW5xdWV1ZWQgd2hpbGUgcmVjb25jaWxpbmcgbXVzdCBiZSBwZXJmb3JtZWQgYWZ0ZXIgdGhpcyBlbnRpcmVcbiAgLy8gYmF0Y2guIE90aGVyd2lzZSwgaWYgZGlydHlDb21wb25lbnRzIGlzIFtBLCBCXSB3aGVyZSBBIGhhcyBjaGlsZHJlbiBCIGFuZFxuICAvLyBDLCBCIGNvdWxkIHVwZGF0ZSB0d2ljZSBpbiBhIHNpbmdsZSBiYXRjaCBpZiBDJ3MgcmVuZGVyIGVucXVldWVzIGFuIHVwZGF0ZVxuICAvLyB0byBCIChzaW5jZSBCIHdvdWxkIGhhdmUgYWxyZWFkeSB1cGRhdGVkLCB3ZSBzaG91bGQgc2tpcCBpdCwgYW5kIHRoZSBvbmx5XG4gIC8vIHdheSB3ZSBjYW4ga25vdyB0byBkbyBzbyBpcyBieSBjaGVja2luZyB0aGUgYmF0Y2ggY291bnRlcikuXG4gIHVwZGF0ZUJhdGNoTnVtYmVyKys7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIC8vIElmIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBiZWZvcmUgcGVuZGluZyBjaGFuZ2VzIGFwcGx5LCBpdCB3aWxsIHN0aWxsXG4gICAgLy8gYmUgaGVyZSwgYnV0IHdlIGFzc3VtZSB0aGF0IGl0IGhhcyBjbGVhcmVkIGl0cyBfcGVuZGluZ0NhbGxiYWNrcyBhbmRcbiAgICAvLyB0aGF0IHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSBpcyBhIG5vb3AuXG4gICAgdmFyIGNvbXBvbmVudCA9IGRpcnR5Q29tcG9uZW50c1tpXTtcblxuICAgIC8vIElmIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSBoYXBwZW5zIHRvIGVucXVldWUgYW55IG5ldyB1cGRhdGVzLCB3ZVxuICAgIC8vIHNob3VsZG4ndCBleGVjdXRlIHRoZSBjYWxsYmFja3MgdW50aWwgdGhlIG5leHQgcmVuZGVyIGhhcHBlbnMsIHNvXG4gICAgLy8gc3Rhc2ggdGhlIGNhbGxiYWNrcyBmaXJzdFxuICAgIHZhciBjYWxsYmFja3MgPSBjb21wb25lbnQuX3BlbmRpbmdDYWxsYmFja3M7XG4gICAgY29tcG9uZW50Ll9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcblxuICAgIHZhciBtYXJrZXJOYW1lO1xuICAgIGlmIChSZWFjdEZlYXR1cmVGbGFncy5sb2dUb3BMZXZlbFJlbmRlcnMpIHtcbiAgICAgIHZhciBuYW1lZENvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgIC8vIER1Y2sgdHlwZSBUb3BMZXZlbFdyYXBwZXIuIFRoaXMgaXMgcHJvYmFibHkgYWx3YXlzIHRydWUuXG4gICAgICBpZiAoY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC50eXBlLmlzUmVhY3RUb3BMZXZlbFdyYXBwZXIpIHtcbiAgICAgICAgbmFtZWRDb21wb25lbnQgPSBjb21wb25lbnQuX3JlbmRlcmVkQ29tcG9uZW50O1xuICAgICAgfVxuICAgICAgbWFya2VyTmFtZSA9ICdSZWFjdCB1cGRhdGU6ICcgKyBuYW1lZENvbXBvbmVudC5nZXROYW1lKCk7XG4gICAgICBjb25zb2xlLnRpbWUobWFya2VyTmFtZSk7XG4gICAgfVxuXG4gICAgUmVhY3RSZWNvbmNpbGVyLnBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeShjb21wb25lbnQsIHRyYW5zYWN0aW9uLnJlY29uY2lsZVRyYW5zYWN0aW9uLCB1cGRhdGVCYXRjaE51bWJlcik7XG5cbiAgICBpZiAobWFya2VyTmFtZSkge1xuICAgICAgY29uc29sZS50aW1lRW5kKG1hcmtlck5hbWUpO1xuICAgIH1cblxuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2FsbGJhY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmNhbGxiYWNrUXVldWUuZW5xdWV1ZShjYWxsYmFja3Nbal0sIGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGZsdXNoQmF0Y2hlZFVwZGF0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ncyB3cmFwcGVycyB3aWxsIGNsZWFyIHRoZSBkaXJ0eUNvbXBvbmVudHNcbiAgLy8gYXJyYXkgYW5kIHBlcmZvcm0gYW55IHVwZGF0ZXMgZW5xdWV1ZWQgYnkgbW91bnQtcmVhZHkgaGFuZGxlcnMgKGkuZS4sXG4gIC8vIGNvbXBvbmVudERpZFVwZGF0ZSkgYnV0IHdlIG5lZWQgdG8gY2hlY2sgaGVyZSB0b28gaW4gb3JkZXIgdG8gY2F0Y2hcbiAgLy8gdXBkYXRlcyBlbnF1ZXVlZCBieSBzZXRTdGF0ZSBjYWxsYmFja3MgYW5kIGFzYXAgY2FsbHMuXG4gIHdoaWxlIChkaXJ0eUNvbXBvbmVudHMubGVuZ3RoIHx8IGFzYXBFbnF1ZXVlZCkge1xuICAgIGlmIChkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgdHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLmdldFBvb2xlZCgpO1xuICAgICAgdHJhbnNhY3Rpb24ucGVyZm9ybShydW5CYXRjaGVkVXBkYXRlcywgbnVsbCwgdHJhbnNhY3Rpb24pO1xuICAgICAgUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoYXNhcEVucXVldWVkKSB7XG4gICAgICBhc2FwRW5xdWV1ZWQgPSBmYWxzZTtcbiAgICAgIHZhciBxdWV1ZSA9IGFzYXBDYWxsYmFja1F1ZXVlO1xuICAgICAgYXNhcENhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xuICAgICAgcXVldWUubm90aWZ5QWxsKCk7XG4gICAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UocXVldWUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBNYXJrIGEgY29tcG9uZW50IGFzIG5lZWRpbmcgYSByZXJlbmRlciwgYWRkaW5nIGFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIGFcbiAqIGxpc3Qgb2YgZnVuY3Rpb25zIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQgb25jZSB0aGUgcmVyZW5kZXIgb2NjdXJzLlxuICovXG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGNvbXBvbmVudCkge1xuICBlbnN1cmVJbmplY3RlZCgpO1xuXG4gIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLiAoVGhpcyBpcyBjYWxsZWQgYnkgZWFjaCB0b3AtbGV2ZWwgdXBkYXRlXG4gIC8vIGZ1bmN0aW9uLCBsaWtlIHNldFN0YXRlLCBmb3JjZVVwZGF0ZSwgZXRjLjsgY3JlYXRpb24gYW5kXG4gIC8vIGRlc3RydWN0aW9uIG9mIHRvcC1sZXZlbCBjb21wb25lbnRzIGlzIGd1YXJkZWQgaW4gUmVhY3RNb3VudC4pXG5cbiAgaWYgKCFiYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyhlbnF1ZXVlVXBkYXRlLCBjb21wb25lbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGRpcnR5Q29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gIGlmIChjb21wb25lbnQuX3VwZGF0ZUJhdGNoTnVtYmVyID09IG51bGwpIHtcbiAgICBjb21wb25lbnQuX3VwZGF0ZUJhdGNoTnVtYmVyID0gdXBkYXRlQmF0Y2hOdW1iZXIgKyAxO1xuICB9XG59XG5cbi8qKlxuICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRvIGJlIHJ1biBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJhdGNoaW5nIGN5Y2xlLiBUaHJvd3NcbiAqIGlmIG5vIHVwZGF0ZXMgYXJlIGN1cnJlbnRseSBiZWluZyBwZXJmb3JtZWQuXG4gKi9cbmZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgIWJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzLmFzYXA6IENhblxcJ3QgZW5xdWV1ZSBhbiBhc2FwIGNhbGxiYWNrIGluIGEgY29udGV4dCB3aGVyZXVwZGF0ZXMgYXJlIG5vdCBiZWluZyBiYXRjaGVkLicpIDogX3Byb2RJbnZhcmlhbnQoJzEyNScpIDogdm9pZCAwO1xuICBhc2FwQ2FsbGJhY2tRdWV1ZS5lbnF1ZXVlKGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgYXNhcEVucXVldWVkID0gdHJ1ZTtcbn1cblxudmFyIFJlYWN0VXBkYXRlc0luamVjdGlvbiA9IHtcbiAgaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb246IGZ1bmN0aW9uIChSZWNvbmNpbGVUcmFuc2FjdGlvbikge1xuICAgICFSZWNvbmNpbGVUcmFuc2FjdGlvbiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhIHJlY29uY2lsZSB0cmFuc2FjdGlvbiBjbGFzcycpIDogX3Byb2RJbnZhcmlhbnQoJzEyNicpIDogdm9pZCAwO1xuICAgIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uID0gUmVjb25jaWxlVHJhbnNhY3Rpb247XG4gIH0sXG5cbiAgaW5qZWN0QmF0Y2hpbmdTdHJhdGVneTogZnVuY3Rpb24gKF9iYXRjaGluZ1N0cmF0ZWd5KSB7XG4gICAgIV9iYXRjaGluZ1N0cmF0ZWd5ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgYmF0Y2hpbmcgc3RyYXRlZ3knKSA6IF9wcm9kSW52YXJpYW50KCcxMjcnKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBfYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGVkVXBkYXRlcygpIGZ1bmN0aW9uJykgOiBfcHJvZEludmFyaWFudCgnMTI4JykgOiB2b2lkIDA7XG4gICAgISh0eXBlb2YgX2JhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPT09ICdib29sZWFuJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYW4gaXNCYXRjaGluZ1VwZGF0ZXMgYm9vbGVhbiBhdHRyaWJ1dGUnKSA6IF9wcm9kSW52YXJpYW50KCcxMjknKSA6IHZvaWQgMDtcbiAgICBiYXRjaGluZ1N0cmF0ZWd5ID0gX2JhdGNoaW5nU3RyYXRlZ3k7XG4gIH1cbn07XG5cbnZhciBSZWFjdFVwZGF0ZXMgPSB7XG4gIC8qKlxuICAgKiBSZWFjdCByZWZlcmVuY2VzIGBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uYCB1c2luZyB0aGlzIHByb3BlcnR5IGluIG9yZGVyXG4gICAqIHRvIGFsbG93IGRlcGVuZGVuY3kgaW5qZWN0aW9uLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb246IG51bGwsXG5cbiAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuICBlbnF1ZXVlVXBkYXRlOiBlbnF1ZXVlVXBkYXRlLFxuICBmbHVzaEJhdGNoZWRVcGRhdGVzOiBmbHVzaEJhdGNoZWRVcGRhdGVzLFxuICBpbmplY3Rpb246IFJlYWN0VXBkYXRlc0luamVjdGlvbixcbiAgYXNhcDogYXNhcFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFVwZGF0ZXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RVcGRhdGVzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuaWYgKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykpIHtcbiAgdmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG4gIHZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbiAgdmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbiAgdmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiAgdmFyICR0eXBlZCA9IHJlcXVpcmUoJy4vX3R5cGVkJyk7XG4gIHZhciAkYnVmZmVyID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJyk7XG4gIHZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbiAgdmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xuICB2YXIgcHJvcGVydHlEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuICB2YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbiAgdmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG4gIHZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG4gIHZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuICB2YXIgdG9JbmRleCA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG4gIHZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xuICB2YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbiAgdmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xuICB2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbiAgdmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4gIHZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuICB2YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG4gIHZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG4gIHZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbiAgdmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG4gIHZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuICB2YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG4gIHZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbiAgdmFyIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpO1xuICB2YXIgY3JlYXRlQXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJyk7XG4gIHZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG4gIHZhciBBcnJheUl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG4gIHZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbiAgdmFyICRpdGVyRGV0ZWN0ID0gcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKTtcbiAgdmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpO1xuICB2YXIgYXJyYXlGaWxsID0gcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpO1xuICB2YXIgYXJyYXlDb3B5V2l0aGluID0gcmVxdWlyZSgnLi9fYXJyYXktY29weS13aXRoaW4nKTtcbiAgdmFyICREUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuICB2YXIgJEdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xuICB2YXIgZFAgPSAkRFAuZjtcbiAgdmFyIGdPUEQgPSAkR09QRC5mO1xuICB2YXIgUmFuZ2VFcnJvciA9IGdsb2JhbC5SYW5nZUVycm9yO1xuICB2YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbiAgdmFyIFVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheTtcbiAgdmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG4gIHZhciBTSEFSRURfQlVGRkVSID0gJ1NoYXJlZCcgKyBBUlJBWV9CVUZGRVI7XG4gIHZhciBCWVRFU19QRVJfRUxFTUVOVCA9ICdCWVRFU19QRVJfRUxFTUVOVCc7XG4gIHZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheVtQUk9UT1RZUEVdO1xuICB2YXIgJEFycmF5QnVmZmVyID0gJGJ1ZmZlci5BcnJheUJ1ZmZlcjtcbiAgdmFyICREYXRhVmlldyA9ICRidWZmZXIuRGF0YVZpZXc7XG4gIHZhciBhcnJheUZvckVhY2ggPSBjcmVhdGVBcnJheU1ldGhvZCgwKTtcbiAgdmFyIGFycmF5RmlsdGVyID0gY3JlYXRlQXJyYXlNZXRob2QoMik7XG4gIHZhciBhcnJheVNvbWUgPSBjcmVhdGVBcnJheU1ldGhvZCgzKTtcbiAgdmFyIGFycmF5RXZlcnkgPSBjcmVhdGVBcnJheU1ldGhvZCg0KTtcbiAgdmFyIGFycmF5RmluZCA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpO1xuICB2YXIgYXJyYXlGaW5kSW5kZXggPSBjcmVhdGVBcnJheU1ldGhvZCg2KTtcbiAgdmFyIGFycmF5SW5jbHVkZXMgPSBjcmVhdGVBcnJheUluY2x1ZGVzKHRydWUpO1xuICB2YXIgYXJyYXlJbmRleE9mID0gY3JlYXRlQXJyYXlJbmNsdWRlcyhmYWxzZSk7XG4gIHZhciBhcnJheVZhbHVlcyA9IEFycmF5SXRlcmF0b3JzLnZhbHVlcztcbiAgdmFyIGFycmF5S2V5cyA9IEFycmF5SXRlcmF0b3JzLmtleXM7XG4gIHZhciBhcnJheUVudHJpZXMgPSBBcnJheUl0ZXJhdG9ycy5lbnRyaWVzO1xuICB2YXIgYXJyYXlMYXN0SW5kZXhPZiA9IEFycmF5UHJvdG8ubGFzdEluZGV4T2Y7XG4gIHZhciBhcnJheVJlZHVjZSA9IEFycmF5UHJvdG8ucmVkdWNlO1xuICB2YXIgYXJyYXlSZWR1Y2VSaWdodCA9IEFycmF5UHJvdG8ucmVkdWNlUmlnaHQ7XG4gIHZhciBhcnJheUpvaW4gPSBBcnJheVByb3RvLmpvaW47XG4gIHZhciBhcnJheVNvcnQgPSBBcnJheVByb3RvLnNvcnQ7XG4gIHZhciBhcnJheVNsaWNlID0gQXJyYXlQcm90by5zbGljZTtcbiAgdmFyIGFycmF5VG9TdHJpbmcgPSBBcnJheVByb3RvLnRvU3RyaW5nO1xuICB2YXIgYXJyYXlUb0xvY2FsZVN0cmluZyA9IEFycmF5UHJvdG8udG9Mb2NhbGVTdHJpbmc7XG4gIHZhciBJVEVSQVRPUiA9IHdrcygnaXRlcmF0b3InKTtcbiAgdmFyIFRBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbiAgdmFyIFRZUEVEX0NPTlNUUlVDVE9SID0gdWlkKCd0eXBlZF9jb25zdHJ1Y3RvcicpO1xuICB2YXIgREVGX0NPTlNUUlVDVE9SID0gdWlkKCdkZWZfY29uc3RydWN0b3InKTtcbiAgdmFyIEFMTF9DT05TVFJVQ1RPUlMgPSAkdHlwZWQuQ09OU1RSO1xuICB2YXIgVFlQRURfQVJSQVkgPSAkdHlwZWQuVFlQRUQ7XG4gIHZhciBWSUVXID0gJHR5cGVkLlZJRVc7XG4gIHZhciBXUk9OR19MRU5HVEggPSAnV3JvbmcgbGVuZ3RoISc7XG5cbiAgdmFyICRtYXAgPSBjcmVhdGVBcnJheU1ldGhvZCgxLCBmdW5jdGlvbiAoTywgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFsbG9jYXRlKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pLCBsZW5ndGgpO1xuICB9KTtcblxuICB2YXIgTElUVExFX0VORElBTiA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQxNkFycmF5KFsxXSkuYnVmZmVyKVswXSA9PT0gMTtcbiAgfSk7XG5cbiAgdmFyIEZPUkNFRF9TRVQgPSAhIVVpbnQ4QXJyYXkgJiYgISFVaW50OEFycmF5W1BST1RPVFlQRV0uc2V0ICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgVWludDhBcnJheSgxKS5zZXQoe30pO1xuICB9KTtcblxuICB2YXIgdG9PZmZzZXQgPSBmdW5jdGlvbiAoaXQsIEJZVEVTKSB7XG4gICAgdmFyIG9mZnNldCA9IHRvSW50ZWdlcihpdCk7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICUgQllURVMpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCEnKTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIGlmIChpc09iamVjdChpdCkgJiYgVFlQRURfQVJSQVkgaW4gaXQpIHJldHVybiBpdDtcbiAgICB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIHR5cGVkIGFycmF5IScpO1xuICB9O1xuXG4gIHZhciBhbGxvY2F0ZSA9IGZ1bmN0aW9uIChDLCBsZW5ndGgpIHtcbiAgICBpZiAoIShpc09iamVjdChDKSAmJiBUWVBFRF9DT05TVFJVQ1RPUiBpbiBDKSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJdCBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvciEnKTtcbiAgICB9IHJldHVybiBuZXcgQyhsZW5ndGgpO1xuICB9O1xuXG4gIHZhciBzcGVjaWVzRnJvbUxpc3QgPSBmdW5jdGlvbiAoTywgbGlzdCkge1xuICAgIHJldHVybiBmcm9tTGlzdChzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSwgbGlzdCk7XG4gIH07XG5cbiAgdmFyIGZyb21MaXN0ID0gZnVuY3Rpb24gKEMsIGxpc3QpIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gYWxsb2NhdGUoQywgbGVuZ3RoKTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHJlc3VsdFtpbmRleF0gPSBsaXN0W2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIGFkZEdldHRlciA9IGZ1bmN0aW9uIChpdCwga2V5LCBpbnRlcm5hbCkge1xuICAgIGRQKGl0LCBrZXksIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kW2ludGVybmFsXTsgfSB9KTtcbiAgfTtcblxuICB2YXIgJGZyb20gPSBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiAsIG1hcGZuLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdChzb3VyY2UpO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbWFwZm4gPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIGl0ZXJGbiA9IGdldEl0ZXJGbihPKTtcbiAgICB2YXIgaSwgbGVuZ3RoLCB2YWx1ZXMsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYgKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIWlzQXJyYXlJdGVyKGl0ZXJGbikpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgdmFsdWVzID0gW10sIGkgPSAwOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGkrKykge1xuICAgICAgICB2YWx1ZXMucHVzaChzdGVwLnZhbHVlKTtcbiAgICAgIH0gTyA9IHZhbHVlcztcbiAgICB9XG4gICAgaWYgKG1hcHBpbmcgJiYgYUxlbiA+IDIpIG1hcGZuID0gY3R4KG1hcGZuLCBhcmd1bWVudHNbMl0sIDIpO1xuICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKSwgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTsgbGVuZ3RoID4gaTsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBtYXBwaW5nID8gbWFwZm4oT1tpXSwgaSkgOiBPW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciAkb2YgPSBmdW5jdGlvbiBvZigvKiAuLi5pdGVtcyAqLykge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gaU9TIFNhZmFyaSA2LnggZmFpbHMgaGVyZVxuICB2YXIgVE9fTE9DQUxFX0JVRyA9ICEhVWludDhBcnJheSAmJiBmYWlscyhmdW5jdGlvbiAoKSB7IGFycmF5VG9Mb2NhbGVTdHJpbmcuY2FsbChuZXcgVWludDhBcnJheSgxKSk7IH0pO1xuXG4gIHZhciAkdG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZygpIHtcbiAgICByZXR1cm4gYXJyYXlUb0xvY2FsZVN0cmluZy5hcHBseShUT19MT0NBTEVfQlVHID8gYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpKSA6IHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHZhciBwcm90byA9IHtcbiAgICBjb3B5V2l0aGluOiBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldCwgc3RhcnQgLyogLCBlbmQgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUNvcHlXaXRoaW4uY2FsbCh2YWxpZGF0ZSh0aGlzKSwgdGFyZ2V0LCBzdGFydCwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlFdmVyeSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZmlsbDogZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiAsIHN0YXJ0LCBlbmQgKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5RmlsbC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5RmlsdGVyKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLFxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCkpO1xuICAgIH0sXG4gICAgZmluZDogZnVuY3Rpb24gZmluZChwcmVkaWNhdGUgLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlGaW5kKHZhbGlkYXRlKHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KHByZWRpY2F0ZSAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUZpbmRJbmRleCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICBhcnJheUZvckVhY2godmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCAqLykge1xuICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZih2YWxpZGF0ZSh0aGlzKSwgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUluY2x1ZGVzKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlKb2luLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5TGFzdEluZGV4T2YuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIG1hcChtYXBmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiAkbWFwKHZhbGlkYXRlKHRoaXMpLCBtYXBmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2UuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2VSaWdodC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIgbGVuZ3RoID0gdmFsaWRhdGUodGhhdCkubGVuZ3RoO1xuICAgICAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IobGVuZ3RoIC8gMik7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbWlkZGxlKSB7XG4gICAgICAgIHZhbHVlID0gdGhhdFtpbmRleF07XG4gICAgICAgIHRoYXRbaW5kZXgrK10gPSB0aGF0Wy0tbGVuZ3RoXTtcbiAgICAgICAgdGhhdFtsZW5ndGhdID0gdmFsdWU7XG4gICAgICB9IHJldHVybiB0aGF0O1xuICAgIH0sXG4gICAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIGFycmF5U29tZSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pIHtcbiAgICAgIHJldHVybiBhcnJheVNvcnQuY2FsbCh2YWxpZGF0ZSh0aGlzKSwgY29tcGFyZWZuKTtcbiAgICB9LFxuICAgIHN1YmFycmF5OiBmdW5jdGlvbiBzdWJhcnJheShiZWdpbiwgZW5kKSB7XG4gICAgICB2YXIgTyA9IHZhbGlkYXRlKHRoaXMpO1xuICAgICAgdmFyIGxlbmd0aCA9IE8ubGVuZ3RoO1xuICAgICAgdmFyICRiZWdpbiA9IHRvQWJzb2x1dGVJbmRleChiZWdpbiwgbGVuZ3RoKTtcbiAgICAgIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pKShcbiAgICAgICAgTy5idWZmZXIsXG4gICAgICAgIE8uYnl0ZU9mZnNldCArICRiZWdpbiAqIE8uQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIHRvTGVuZ3RoKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbmd0aCkpIC0gJGJlZ2luKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyICRzbGljZSA9IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5U2xpY2UuY2FsbCh2YWxpZGF0ZSh0aGlzKSwgc3RhcnQsIGVuZCkpO1xuICB9O1xuXG4gIHZhciAkc2V0ID0gZnVuY3Rpb24gc2V0KGFycmF5TGlrZSAvKiAsIG9mZnNldCAqLykge1xuICAgIHZhbGlkYXRlKHRoaXMpO1xuICAgIHZhciBvZmZzZXQgPSB0b09mZnNldChhcmd1bWVudHNbMV0sIDEpO1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICB2YXIgc3JjID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgoc3JjLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBpZiAobGVuICsgb2Zmc2V0ID4gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgd2hpbGUgKGluZGV4IDwgbGVuKSB0aGlzW29mZnNldCArIGluZGV4XSA9IHNyY1tpbmRleCsrXTtcbiAgfTtcblxuICB2YXIgJGl0ZXJhdG9ycyA9IHtcbiAgICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIGFycmF5RW50cmllcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9LFxuICAgIGtleXM6IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICByZXR1cm4gYXJyYXlLZXlzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH0sXG4gICAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICByZXR1cm4gYXJyYXlWYWx1ZXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc1RBSW5kZXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICByZXR1cm4gaXNPYmplY3QodGFyZ2V0KVxuICAgICAgJiYgdGFyZ2V0W1RZUEVEX0FSUkFZXVxuICAgICAgJiYgdHlwZW9mIGtleSAhPSAnc3ltYm9sJ1xuICAgICAgJiYga2V5IGluIHRhcmdldFxuICAgICAgJiYgU3RyaW5nKCtrZXkpID09IFN0cmluZyhrZXkpO1xuICB9O1xuICB2YXIgJGdldERlc2MgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcbiAgICByZXR1cm4gaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSlcbiAgICAgID8gcHJvcGVydHlEZXNjKDIsIHRhcmdldFtrZXldKVxuICAgICAgOiBnT1BEKHRhcmdldCwga2V5KTtcbiAgfTtcbiAgdmFyICRzZXREZXNjID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICBpZiAoaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSlcbiAgICAgICYmIGlzT2JqZWN0KGRlc2MpXG4gICAgICAmJiBoYXMoZGVzYywgJ3ZhbHVlJylcbiAgICAgICYmICFoYXMoZGVzYywgJ2dldCcpXG4gICAgICAmJiAhaGFzKGRlc2MsICdzZXQnKVxuICAgICAgLy8gVE9ETzogYWRkIHZhbGlkYXRpb24gZGVzY3JpcHRvciB3L28gY2FsbGluZyBhY2Nlc3NvcnNcbiAgICAgICYmICFkZXNjLmNvbmZpZ3VyYWJsZVxuICAgICAgJiYgKCFoYXMoZGVzYywgJ3dyaXRhYmxlJykgfHwgZGVzYy53cml0YWJsZSlcbiAgICAgICYmICghaGFzKGRlc2MsICdlbnVtZXJhYmxlJykgfHwgZGVzYy5lbnVtZXJhYmxlKVxuICAgICkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBkZXNjLnZhbHVlO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9IHJldHVybiBkUCh0YXJnZXQsIGtleSwgZGVzYyk7XG4gIH07XG5cbiAgaWYgKCFBTExfQ09OU1RSVUNUT1JTKSB7XG4gICAgJEdPUEQuZiA9ICRnZXREZXNjO1xuICAgICREUC5mID0gJHNldERlc2M7XG4gIH1cblxuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFBTExfQ09OU1RSVUNUT1JTLCAnT2JqZWN0Jywge1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldERlc2MsXG4gICAgZGVmaW5lUHJvcGVydHk6ICRzZXREZXNjXG4gIH0pO1xuXG4gIGlmIChmYWlscyhmdW5jdGlvbiAoKSB7IGFycmF5VG9TdHJpbmcuY2FsbCh7fSk7IH0pKSB7XG4gICAgYXJyYXlUb1N0cmluZyA9IGFycmF5VG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBhcnJheUpvaW4uY2FsbCh0aGlzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyICRUeXBlZEFycmF5UHJvdG90eXBlJCA9IHJlZGVmaW5lQWxsKHt9LCBwcm90byk7XG4gIHJlZGVmaW5lQWxsKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJGl0ZXJhdG9ycyk7XG4gIGhpZGUoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCBJVEVSQVRPUiwgJGl0ZXJhdG9ycy52YWx1ZXMpO1xuICByZWRlZmluZUFsbCgkVHlwZWRBcnJheVByb3RvdHlwZSQsIHtcbiAgICBzbGljZTogJHNsaWNlLFxuICAgIHNldDogJHNldCxcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkgeyAvKiBub29wICovIH0sXG4gICAgdG9TdHJpbmc6IGFycmF5VG9TdHJpbmcsXG4gICAgdG9Mb2NhbGVTdHJpbmc6ICR0b0xvY2FsZVN0cmluZ1xuICB9KTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J1ZmZlcicsICdiJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdieXRlT2Zmc2V0JywgJ28nKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J5dGVMZW5ndGgnLCAnbCcpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnbGVuZ3RoJywgJ2UnKTtcbiAgZFAoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCBUQUcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXNbVFlQRURfQVJSQVldOyB9XG4gIH0pO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50c1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIEJZVEVTLCB3cmFwcGVyLCBDTEFNUEVEKSB7XG4gICAgQ0xBTVBFRCA9ICEhQ0xBTVBFRDtcbiAgICB2YXIgTkFNRSA9IEtFWSArIChDTEFNUEVEID8gJ0NsYW1wZWQnIDogJycpICsgJ0FycmF5JztcbiAgICB2YXIgR0VUVEVSID0gJ2dldCcgKyBLRVk7XG4gICAgdmFyIFNFVFRFUiA9ICdzZXQnICsgS0VZO1xuICAgIHZhciBUeXBlZEFycmF5ID0gZ2xvYmFsW05BTUVdO1xuICAgIHZhciBCYXNlID0gVHlwZWRBcnJheSB8fCB7fTtcbiAgICB2YXIgVEFDID0gVHlwZWRBcnJheSAmJiBnZXRQcm90b3R5cGVPZihUeXBlZEFycmF5KTtcbiAgICB2YXIgRk9SQ0VEID0gIVR5cGVkQXJyYXkgfHwgISR0eXBlZC5BQlY7XG4gICAgdmFyIE8gPSB7fTtcbiAgICB2YXIgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXkgJiYgVHlwZWRBcnJheVtQUk9UT1RZUEVdO1xuICAgIHZhciBnZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgpIHtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIHJldHVybiBkYXRhLnZbR0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoYXQuX2Q7XG4gICAgICBpZiAoQ0xBTVBFRCkgdmFsdWUgPSAodmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKSkgPCAwID8gMCA6IHZhbHVlID4gMHhmZiA/IDB4ZmYgOiB2YWx1ZSAmIDB4ZmY7XG4gICAgICBkYXRhLnZbU0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCB2YWx1ZSwgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgYWRkRWxlbWVudCA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xuICAgICAgZFAodGhhdCwgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldHRlcih0aGlzLCBpbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHNldHRlcih0aGlzLCBpbmRleCwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIHtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSwgJ19kJyk7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICB2YXIgYnVmZmVyLCBieXRlTGVuZ3RoLCBsZW5ndGgsIGtsYXNzO1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgICAgbGVuZ3RoID0gdG9JbmRleChkYXRhKTtcbiAgICAgICAgICBieXRlTGVuZ3RoID0gbGVuZ3RoICogQllURVM7XG4gICAgICAgICAgYnVmZmVyID0gbmV3ICRBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKSB7XG4gICAgICAgICAgYnVmZmVyID0gZGF0YTtcbiAgICAgICAgICBvZmZzZXQgPSB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUyk7XG4gICAgICAgICAgdmFyICRsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgaWYgKCRsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCRsZW4gJSBCWVRFUykgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9ICRsZW4gLSBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCA8IDApIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9IHRvTGVuZ3RoKCRsZW5ndGgpICogQllURVM7XG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCArIG9mZnNldCA+ICRsZW4pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoID0gYnl0ZUxlbmd0aCAvIEJZVEVTO1xuICAgICAgICB9IGVsc2UgaWYgKFRZUEVEX0FSUkFZIGluIGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZSh0aGF0LCAnX2QnLCB7XG4gICAgICAgICAgYjogYnVmZmVyLFxuICAgICAgICAgIG86IG9mZnNldCxcbiAgICAgICAgICBsOiBieXRlTGVuZ3RoLFxuICAgICAgICAgIGU6IGxlbmd0aCxcbiAgICAgICAgICB2OiBuZXcgJERhdGFWaWV3KGJ1ZmZlcilcbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkgYWRkRWxlbWVudCh0aGF0LCBpbmRleCsrKTtcbiAgICAgIH0pO1xuICAgICAgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IGNyZWF0ZSgkVHlwZWRBcnJheVByb3RvdHlwZSQpO1xuICAgICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCAnY29uc3RydWN0b3InLCBUeXBlZEFycmF5KTtcbiAgICB9IGVsc2UgaWYgKCFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBUeXBlZEFycmF5KDEpO1xuICAgIH0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBuZXcgVHlwZWRBcnJheSgtMSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfSkgfHwgISRpdGVyRGV0ZWN0KGZ1bmN0aW9uIChpdGVyKSB7XG4gICAgICBuZXcgVHlwZWRBcnJheSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkobnVsbCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICBuZXcgVHlwZWRBcnJheSgxLjUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkoaXRlcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfSwgdHJ1ZSkpIHtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSk7XG4gICAgICAgIHZhciBrbGFzcztcbiAgICAgICAgLy8gYHdzYCBtb2R1bGUgYnVnLCB0ZW1wb3JhcmlseSByZW1vdmUgdmFsaWRhdGlvbiBsZW5ndGggZm9yIFVpbnQ4QXJyYXlcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvcHVsbC82NDVcbiAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkgcmV0dXJuIG5ldyBCYXNlKHRvSW5kZXgoZGF0YSkpO1xuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mICRBcnJheUJ1ZmZlciB8fCAoa2xhc3MgPSBjbGFzc29mKGRhdGEpKSA9PSBBUlJBWV9CVUZGRVIgfHwga2xhc3MgPT0gU0hBUkVEX0JVRkZFUikge1xuICAgICAgICAgIHJldHVybiAkbGVuZ3RoICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpLCAkbGVuZ3RoKVxuICAgICAgICAgICAgOiAkb2Zmc2V0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyBuZXcgQmFzZShkYXRhLCB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUykpXG4gICAgICAgICAgICAgIDogbmV3IEJhc2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFRZUEVEX0FSUkFZIGluIGRhdGEpIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIGFycmF5Rm9yRWFjaChUQUMgIT09IEZ1bmN0aW9uLnByb3RvdHlwZSA/IGdPUE4oQmFzZSkuY29uY2F0KGdPUE4oVEFDKSkgOiBnT1BOKEJhc2UpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiBUeXBlZEFycmF5KSkgaGlkZShUeXBlZEFycmF5LCBrZXksIEJhc2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IFR5cGVkQXJyYXlQcm90b3R5cGU7XG4gICAgICBpZiAoIUxJQlJBUlkpIFR5cGVkQXJyYXlQcm90b3R5cGUuY29uc3RydWN0b3IgPSBUeXBlZEFycmF5O1xuICAgIH1cbiAgICB2YXIgJG5hdGl2ZUl0ZXJhdG9yID0gVHlwZWRBcnJheVByb3RvdHlwZVtJVEVSQVRPUl07XG4gICAgdmFyIENPUlJFQ1RfSVRFUl9OQU1FID0gISEkbmF0aXZlSXRlcmF0b3JcbiAgICAgICYmICgkbmF0aXZlSXRlcmF0b3IubmFtZSA9PSAndmFsdWVzJyB8fCAkbmF0aXZlSXRlcmF0b3IubmFtZSA9PSB1bmRlZmluZWQpO1xuICAgIHZhciAkaXRlcmF0b3IgPSAkaXRlcmF0b3JzLnZhbHVlcztcbiAgICBoaWRlKFR5cGVkQXJyYXksIFRZUEVEX0NPTlNUUlVDVE9SLCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRZUEVEX0FSUkFZLCBOQU1FKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgREVGX0NPTlNUUlVDVE9SLCBUeXBlZEFycmF5KTtcblxuICAgIGlmIChDTEFNUEVEID8gbmV3IFR5cGVkQXJyYXkoMSlbVEFHXSAhPSBOQU1FIDogIShUQUcgaW4gVHlwZWRBcnJheVByb3RvdHlwZSkpIHtcbiAgICAgIGRQKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRBRywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5BTUU7IH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIE9bTkFNRV0gPSBUeXBlZEFycmF5O1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoVHlwZWRBcnJheSAhPSBCYXNlKSwgTyk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUywgTkFNRSwge1xuICAgICAgQllURVNfUEVSX0VMRU1FTlQ6IEJZVEVTXG4gICAgfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgQmFzZS5vZi5jYWxsKFR5cGVkQXJyYXksIDEpOyB9KSwgTkFNRSwge1xuICAgICAgZnJvbTogJGZyb20sXG4gICAgICBvZjogJG9mXG4gICAgfSk7XG5cbiAgICBpZiAoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSkgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBCWVRFU19QRVJfRUxFTUVOVCwgQllURVMpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAsIE5BTUUsIHByb3RvKTtcblxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFRF9TRVQsIE5BTUUsIHsgc2V0OiAkc2V0IH0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhQ09SUkVDVF9JVEVSX05BTUUsIE5BTUUsICRpdGVyYXRvcnMpO1xuXG4gICAgaWYgKCFMSUJSQVJZICYmIFR5cGVkQXJyYXlQcm90b3R5cGUudG9TdHJpbmcgIT0gYXJyYXlUb1N0cmluZykgVHlwZWRBcnJheVByb3RvdHlwZS50b1N0cmluZyA9IGFycmF5VG9TdHJpbmc7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIG5ldyBUeXBlZEFycmF5KDEpLnNsaWNlKCk7XG4gICAgfSksIE5BTUUsIHsgc2xpY2U6ICRzbGljZSB9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbMSwgMl0udG9Mb2NhbGVTdHJpbmcoKSAhPSBuZXcgVHlwZWRBcnJheShbMSwgMl0pLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcuY2FsbChbMSwgMl0pO1xuICAgIH0pKSwgTkFNRSwgeyB0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nIH0pO1xuXG4gICAgSXRlcmF0b3JzW05BTUVdID0gQ09SUkVDVF9JVEVSX05BTUUgPyAkbmF0aXZlSXRlcmF0b3IgOiAkaXRlcmF0b3I7XG4gICAgaWYgKCFMSUJSQVJZICYmICFDT1JSRUNUX0lURVJfTkFNRSkgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBJVEVSQVRPUiwgJGl0ZXJhdG9yKTtcbiAgfTtcbn0gZWxzZSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLWFycmF5LmpzIiwidmFyIE1hcCA9IHJlcXVpcmUoJy4vZXM2Lm1hcCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnbWV0YWRhdGEnKTtcbnZhciBzdG9yZSA9IHNoYXJlZC5zdG9yZSB8fCAoc2hhcmVkLnN0b3JlID0gbmV3IChyZXF1aXJlKCcuL2VzNi53ZWFrLW1hcCcpKSgpKTtcblxudmFyIGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRLZXksIGNyZWF0ZSkge1xuICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBzdG9yZS5nZXQodGFyZ2V0KTtcbiAgaWYgKCF0YXJnZXRNZXRhZGF0YSkge1xuICAgIGlmICghY3JlYXRlKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHN0b3JlLnNldCh0YXJnZXQsIHRhcmdldE1ldGFkYXRhID0gbmV3IE1hcCgpKTtcbiAgfVxuICB2YXIga2V5TWV0YWRhdGEgPSB0YXJnZXRNZXRhZGF0YS5nZXQodGFyZ2V0S2V5KTtcbiAgaWYgKCFrZXlNZXRhZGF0YSkge1xuICAgIGlmICghY3JlYXRlKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHRhcmdldE1ldGFkYXRhLnNldCh0YXJnZXRLZXksIGtleU1ldGFkYXRhID0gbmV3IE1hcCgpKTtcbiAgfSByZXR1cm4ga2V5TWV0YWRhdGE7XG59O1xudmFyIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBmdW5jdGlvbiAoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCBmYWxzZSk7XG4gIHJldHVybiBtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBtZXRhZGF0YU1hcC5oYXMoTWV0YWRhdGFLZXkpO1xufTtcbnZhciBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gZnVuY3Rpb24gKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgZmFsc2UpO1xuICByZXR1cm4gbWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG1ldGFkYXRhTWFwLmdldChNZXRhZGF0YUtleSk7XG59O1xudmFyIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSBmdW5jdGlvbiAoTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUsIE8sIFApIHtcbiAgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCB0cnVlKS5zZXQoTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUpO1xufTtcbnZhciBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldEtleSkge1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKHRhcmdldCwgdGFyZ2V0S2V5LCBmYWxzZSk7XG4gIHZhciBrZXlzID0gW107XG4gIGlmIChtZXRhZGF0YU1hcCkgbWV0YWRhdGFNYXAuZm9yRWFjaChmdW5jdGlvbiAoXywga2V5KSB7IGtleXMucHVzaChrZXkpOyB9KTtcbiAgcmV0dXJuIGtleXM7XG59O1xudmFyIHRvTWV0YUtleSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6IFN0cmluZyhpdCk7XG59O1xudmFyIGV4cCA9IGZ1bmN0aW9uIChPKSB7XG4gICRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIE8pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0b3JlOiBzdG9yZSxcbiAgbWFwOiBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwLFxuICBoYXM6IG9yZGluYXJ5SGFzT3duTWV0YWRhdGEsXG4gIGdldDogb3JkaW5hcnlHZXRPd25NZXRhZGF0YSxcbiAgc2V0OiBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhLFxuICBrZXlzOiBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyxcbiAga2V5OiB0b01ldGFLZXksXG4gIGV4cDogZXhwXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWV0YWRhdGEuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSBmYWxzZTtcbnZhciBpc1Byb3h5U3VwcG9ydGVkID0gdHlwZW9mIFByb3h5ID09PSAnZnVuY3Rpb24nO1xuXG52YXIgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMgPSBbJ2Rpc3BhdGNoQ29uZmlnJywgJ190YXJnZXRJbnN0JywgJ25hdGl2ZUV2ZW50JywgJ2lzRGVmYXVsdFByZXZlbnRlZCcsICdpc1Byb3BhZ2F0aW9uU3RvcHBlZCcsICdfZGlzcGF0Y2hMaXN0ZW5lcnMnLCAnX2Rpc3BhdGNoSW5zdGFuY2VzJ107XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBFdmVudEludGVyZmFjZSA9IHtcbiAgdHlwZTogbnVsbCxcbiAgdGFyZ2V0OiBudWxsLFxuICAvLyBjdXJyZW50VGFyZ2V0IGlzIHNldCB3aGVuIGRpc3BhdGNoaW5nOyBubyB1c2UgaW4gY29weWluZyBpdCBoZXJlXG4gIGN1cnJlbnRUYXJnZXQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsLFxuICBldmVudFBoYXNlOiBudWxsLFxuICBidWJibGVzOiBudWxsLFxuICBjYW5jZWxhYmxlOiBudWxsLFxuICB0aW1lU3RhbXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbiAgfSxcbiAgZGVmYXVsdFByZXZlbnRlZDogbnVsbCxcbiAgaXNUcnVzdGVkOiBudWxsXG59O1xuXG4vKipcbiAqIFN5bnRoZXRpYyBldmVudHMgYXJlIGRpc3BhdGNoZWQgYnkgZXZlbnQgcGx1Z2lucywgdHlwaWNhbGx5IGluIHJlc3BvbnNlIHRvIGFcbiAqIHRvcC1sZXZlbCBldmVudCBkZWxlZ2F0aW9uIGhhbmRsZXIuXG4gKlxuICogVGhlc2Ugc3lzdGVtcyBzaG91bGQgZ2VuZXJhbGx5IHVzZSBwb29saW5nIHRvIHJlZHVjZSB0aGUgZnJlcXVlbmN5IG9mIGdhcmJhZ2VcbiAqIGNvbGxlY3Rpb24uIFRoZSBzeXN0ZW0gc2hvdWxkIGNoZWNrIGBpc1BlcnNpc3RlbnRgIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZVxuICogZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGludG8gdGhlIHBvb2wgYWZ0ZXIgYmVpbmcgZGlzcGF0Y2hlZC4gVXNlcnMgdGhhdFxuICogbmVlZCBhIHBlcnNpc3RlZCBldmVudCBzaG91bGQgaW52b2tlIGBwZXJzaXN0YC5cbiAqXG4gKiBTeW50aGV0aWMgZXZlbnRzIChhbmQgc3ViY2xhc3NlcykgaW1wbGVtZW50IHRoZSBET00gTGV2ZWwgMyBFdmVudHMgQVBJIGJ5XG4gKiBub3JtYWxpemluZyBicm93c2VyIHF1aXJrcy4gU3ViY2xhc3NlcyBkbyBub3QgbmVjZXNzYXJpbHkgaGF2ZSB0byBpbXBsZW1lbnQgYVxuICogRE9NIGludGVyZmFjZTsgY3VzdG9tIGFwcGxpY2F0aW9uLXNwZWNpZmljIGV2ZW50cyBjYW4gYWxzbyBzdWJjbGFzcyB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0SW5zdCBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IG5hdGl2ZUV2ZW50VGFyZ2V0IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNFdmVudChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gdGhlc2UgaGF2ZSBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgZGVsZXRlIHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgZGVsZXRlIHRoaXMucHJldmVudERlZmF1bHQ7XG4gICAgZGVsZXRlIHRoaXMuc3RvcFByb3BhZ2F0aW9uO1xuICB9XG5cbiAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IGRpc3BhdGNoQ29uZmlnO1xuICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXG4gIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGRlbGV0ZSB0aGlzW3Byb3BOYW1lXTsgLy8gdGhpcyBoYXMgYSBnZXR0ZXIvc2V0dGVyIGZvciB3YXJuaW5nc1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplID0gSW50ZXJmYWNlW3Byb3BOYW1lXTtcbiAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG5vcm1hbGl6ZShuYXRpdmVFdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ3RhcmdldCcpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbmF0aXZlRXZlbnRbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBkZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlID09PSBmYWxzZTtcbiAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xuICB9XG4gIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG4gIHJldHVybiB0aGlzO1xufVxuXG5fYXNzaWduKFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZSwge1xuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHZhbGlkLXR5cGVvZlxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LnJldHVyblZhbHVlICE9PSAndW5rbm93bicpIHtcbiAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdmFsaWQtdHlwZW9mXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQuY2FuY2VsQnViYmxlICE9PSAndW5rbm93bicpIHtcbiAgICAgIC8vIFRoZSBDaGFuZ2VFdmVudFBsdWdpbiByZWdpc3RlcnMgYSBcInByb3BlcnR5Y2hhbmdlXCIgZXZlbnQgZm9yXG4gICAgICAvLyBJRS4gVGhpcyBldmVudCBkb2VzIG5vdCBzdXBwb3J0IGJ1YmJsaW5nIG9yIGNhbmNlbGxpbmcsIGFuZFxuICAgICAgLy8gYW55IHJlZmVyZW5jZXMgdG8gY2FuY2VsQnViYmxlIHRocm93IFwiTWVtYmVyIG5vdCBmb3VuZFwiLiAgQVxuICAgICAgLy8gdHlwZW9mIGNoZWNrIG9mIFwidW5rbm93blwiIGNpcmN1bXZlbnRzIHRoaXMgaXNzdWUgKGFuZCBpcyBhbHNvXG4gICAgICAvLyBJRSBzcGVjaWZpYykuXG4gICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogV2UgcmVsZWFzZSBhbGwgZGlzcGF0Y2hlZCBgU3ludGhldGljRXZlbnRgcyBhZnRlciBlYWNoIGV2ZW50IGxvb3AsIGFkZGluZ1xuICAgKiB0aGVtIGJhY2sgaW50byB0aGUgcG9vbC4gVGhpcyBhbGxvd3MgYSB3YXkgdG8gaG9sZCBvbnRvIGEgcmVmZXJlbmNlIHRoYXRcbiAgICogd29uJ3QgYmUgYWRkZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKi9cbiAgcGVyc2lzdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNQZXJzaXN0ZW50ID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBzaG91bGQgbm90IGJlIHJlbGVhc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1BlcnNpc3RlbnQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgYGRlc3RydWN0b3JgIG9uIGVhY2ggaW5zdGFuY2UgaXQgcmVsZWFzZXMuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHByb3BOYW1lLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBJbnRlcmZhY2VbcHJvcE5hbWVdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXNbc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXNbaV1dID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmF0aXZlRXZlbnQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCduYXRpdmVFdmVudCcsIG51bGwpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHJldmVudERlZmF1bHQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdwcmV2ZW50RGVmYXVsdCcsIGVtcHR5RnVuY3Rpb24pKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RvcFByb3BhZ2F0aW9uJywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignc3RvcFByb3BhZ2F0aW9uJywgZW1wdHlGdW5jdGlvbikpO1xuICAgIH1cbiAgfVxufSk7XG5cblN5bnRoZXRpY0V2ZW50LkludGVyZmFjZSA9IEV2ZW50SW50ZXJmYWNlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBpZiAoaXNQcm94eVN1cHBvcnRlZCkge1xuICAgIC8qZXNsaW50LWRpc2FibGUgbm8tZnVuYy1hc3NpZ24gKi9cbiAgICBTeW50aGV0aWNFdmVudCA9IG5ldyBQcm94eShTeW50aGV0aWNFdmVudCwge1xuICAgICAgY29uc3RydWN0OiBmdW5jdGlvbiAodGFyZ2V0LCBhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5KHRhcmdldCwgT2JqZWN0LmNyZWF0ZSh0YXJnZXQucHJvdG90eXBlKSwgYXJncyk7XG4gICAgICB9LFxuICAgICAgYXBwbHk6IGZ1bmN0aW9uIChjb25zdHJ1Y3RvciwgdGhhdCwgYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KGNvbnN0cnVjdG9yLmFwcGx5KHRoYXQsIGFyZ3MpLCB7XG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHByb3AgIT09ICdpc1BlcnNpc3RlbnQnICYmICF0YXJnZXQuY29uc3RydWN0b3IuSW50ZXJmYWNlLmhhc093blByb3BlcnR5KHByb3ApICYmIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5IHx8IHRhcmdldC5pc1BlcnNpc3RlbnQoKSwgXCJUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdSdyZSBcIiArIFwic2VlaW5nIHRoaXMsIHlvdSdyZSBhZGRpbmcgYSBuZXcgcHJvcGVydHkgaW4gdGhlIHN5bnRoZXRpYyBldmVudCBvYmplY3QuIFwiICsgJ1RoZSBwcm9wZXJ0eSBpcyBuZXZlciByZWxlYXNlZC4gU2VlICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICBkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyplc2xpbnQtZW5hYmxlIG5vLWZ1bmMtYXNzaWduICovXG4gIH1cbn1cbi8qKlxuICogSGVscGVyIHRvIHJlZHVjZSBib2lsZXJwbGF0ZSB3aGVuIGNyZWF0aW5nIHN1YmNsYXNzZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3NcbiAqIEBwYXJhbSB7P29iamVjdH0gSW50ZXJmYWNlXG4gKi9cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyA9IGZ1bmN0aW9uIChDbGFzcywgSW50ZXJmYWNlKSB7XG4gIHZhciBTdXBlciA9IHRoaXM7XG5cbiAgdmFyIEUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgRS5wcm90b3R5cGUgPSBTdXBlci5wcm90b3R5cGU7XG4gIHZhciBwcm90b3R5cGUgPSBuZXcgRSgpO1xuXG4gIF9hc3NpZ24ocHJvdG90eXBlLCBDbGFzcy5wcm90b3R5cGUpO1xuICBDbGFzcy5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gIENsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENsYXNzO1xuXG4gIENsYXNzLkludGVyZmFjZSA9IF9hc3NpZ24oe30sIFN1cGVyLkludGVyZmFjZSwgSW50ZXJmYWNlKTtcbiAgQ2xhc3MuYXVnbWVudENsYXNzID0gU3VwZXIuYXVnbWVudENsYXNzO1xuXG4gIFBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhDbGFzcywgUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyKTtcbn07XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhTeW50aGV0aWNFdmVudCwgUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNFdmVudDtcblxuLyoqXG4gICogSGVscGVyIHRvIG51bGxpZnkgc3ludGhldGljRXZlbnQgaW5zdGFuY2UgcHJvcGVydGllcyB3aGVuIGRlc3RydWN0aW5nXG4gICpcbiAgKiBAcGFyYW0ge29iamVjdH0gU3ludGhldGljRXZlbnRcbiAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWVcbiAgKiBAcmV0dXJuIHtvYmplY3R9IGRlZmluZVByb3BlcnR5IG9iamVjdFxuICAqL1xuZnVuY3Rpb24gZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgZ2V0VmFsKSB7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIGdldFZhbCA9PT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgc2V0OiBzZXQsXG4gICAgZ2V0OiBnZXRcbiAgfTtcblxuICBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnc2V0dGluZyB0aGUgbWV0aG9kJyA6ICdzZXR0aW5nIHRoZSBwcm9wZXJ0eSc7XG4gICAgd2FybihhY3Rpb24sICdUaGlzIGlzIGVmZmVjdGl2ZWx5IGEgbm8tb3AnKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0KCkge1xuICAgIHZhciBhY3Rpb24gPSBpc0Z1bmN0aW9uID8gJ2FjY2Vzc2luZyB0aGUgbWV0aG9kJyA6ICdhY2Nlc3NpbmcgdGhlIHByb3BlcnR5JztcbiAgICB2YXIgcmVzdWx0ID0gaXNGdW5jdGlvbiA/ICdUaGlzIGlzIGEgbm8tb3AgZnVuY3Rpb24nIDogJ1RoaXMgaXMgc2V0IHRvIG51bGwnO1xuICAgIHdhcm4oYWN0aW9uLCByZXN1bHQpO1xuICAgIHJldHVybiBnZXRWYWw7XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuKGFjdGlvbiwgcmVzdWx0KSB7XG4gICAgdmFyIHdhcm5pbmdDb25kaXRpb24gPSBmYWxzZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh3YXJuaW5nQ29uZGl0aW9uLCBcIlRoaXMgc3ludGhldGljIGV2ZW50IGlzIHJldXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91J3JlIHNlZWluZyB0aGlzLCBcIiArIFwieW91J3JlICVzIGAlc2Agb24gYSByZWxlYXNlZC9udWxsaWZpZWQgc3ludGhldGljIGV2ZW50LiAlcy4gXCIgKyAnSWYgeW91IG11c3Qga2VlcCB0aGUgb3JpZ2luYWwgc3ludGhldGljIGV2ZW50IGFyb3VuZCwgdXNlIGV2ZW50LnBlcnNpc3QoKS4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGFjdGlvbiwgcHJvcE5hbWUsIHJlc3VsdCkgOiB2b2lkIDA7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNFdmVudC5qcyIsInZhciBNRVRBID0gcmVxdWlyZSgnLi9fdWlkJykoJ21ldGEnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHNldERlc2MgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGlkID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZSRUVaRSA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgc2V0RGVzYyhpdCwgTUVUQSwgeyB2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gfSk7XG59O1xudmFyIGZhc3RLZXkgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIGhhc2ggd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQV0udztcbn07XG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKSBzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogTUVUQSxcbiAgTkVFRDogZmFsc2UsXG4gIGZhc3RLZXk6IGZhc3RLZXksXG4gIGdldFdlYWs6IGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21ldGEuanMiLCIvLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgVU5TQ09QQUJMRVMgPSByZXF1aXJlKCcuL193a3MnKSgndW5zY29wYWJsZXMnKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuaWYgKEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkgcmVxdWlyZSgnLi9faGlkZScpKEFycmF5UHJvdG8sIFVOU0NPUEFCTEVTLCB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgQXJyYXlQcm90b1tVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG5mdW5jdGlvbiBjaGVja01hc2sodmFsdWUsIGJpdG1hc2spIHtcbiAgcmV0dXJuICh2YWx1ZSAmIGJpdG1hc2spID09PSBiaXRtYXNrO1xufVxuXG52YXIgRE9NUHJvcGVydHlJbmplY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbm9ybWFsaXplZCwgY2FtZWxjYXNlZCBwcm9wZXJ0eSBuYW1lcyB0byBhIGNvbmZpZ3VyYXRpb24gdGhhdFxuICAgKiBzcGVjaWZpZXMgaG93IHRoZSBhc3NvY2lhdGVkIERPTSBwcm9wZXJ0eSBzaG91bGQgYmUgYWNjZXNzZWQgb3IgcmVuZGVyZWQuXG4gICAqL1xuICBNVVNUX1VTRV9QUk9QRVJUWTogMHgxLFxuICBIQVNfQk9PTEVBTl9WQUxVRTogMHg0LFxuICBIQVNfTlVNRVJJQ19WQUxVRTogMHg4LFxuICBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTogMHgxMCB8IDB4OCxcbiAgSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTogMHgyMCxcblxuICAvKipcbiAgICogSW5qZWN0IHNvbWUgc3BlY2lhbGl6ZWQga25vd2xlZGdlIGFib3V0IHRoZSBET00uIFRoaXMgdGFrZXMgYSBjb25maWcgb2JqZWN0XG4gICAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiBpc0N1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gdGhhdCBnaXZlbiBhbiBhdHRyaWJ1dGUgbmFtZSB3aWxsIHJldHVybiB0cnVlXG4gICAqIGlmIGl0IGNhbiBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00gdmVyYmF0aW0uIFVzZWZ1bCBmb3IgZGF0YS0qIG9yIGFyaWEtKlxuICAgKiBhdHRyaWJ1dGVzIHdoZXJlIGl0J3MgaW1wb3NzaWJsZSB0byBlbnVtZXJhdGUgYWxsIG9mIHRoZSBwb3NzaWJsZVxuICAgKiBhdHRyaWJ1dGUgbmFtZXMsXG4gICAqXG4gICAqIFByb3BlcnRpZXM6IG9iamVjdCBtYXBwaW5nIERPTSBwcm9wZXJ0eSBuYW1lIHRvIG9uZSBvZiB0aGVcbiAgICogRE9NUHJvcGVydHlJbmplY3Rpb24gY29uc3RhbnRzIG9yIG51bGwuIElmIHlvdXIgYXR0cmlidXRlIGlzbid0IGluIGhlcmUsXG4gICAqIGl0IHdvbid0IGdldCB3cml0dGVuIHRvIHRoZSBET00uXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzOiBvYmplY3QgbWFwcGluZyBSZWFjdCBhdHRyaWJ1dGUgbmFtZSB0byB0aGUgRE9NXG4gICAqIGF0dHJpYnV0ZSBuYW1lLiBBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2UgdGhlICoqbG93ZXJjYXNlKipcbiAgICogbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01BdHRyaWJ1dGVOYW1lc3BhY2VzOiBvYmplY3QgbWFwcGluZyBSZWFjdCBhdHRyaWJ1dGUgbmFtZSB0byB0aGUgRE9NXG4gICAqIGF0dHJpYnV0ZSBuYW1lc3BhY2UgVVJMLiAoQXR0cmlidXRlIG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIG5vIG5hbWVzcGFjZS4pXG4gICAqXG4gICAqIERPTVByb3BlcnR5TmFtZXM6IHNpbWlsYXIgdG8gRE9NQXR0cmlidXRlTmFtZXMgYnV0IGZvciBET00gcHJvcGVydGllcy5cbiAgICogUHJvcGVydHkgbmFtZXMgbm90IHNwZWNpZmllZCB1c2UgdGhlIG5vcm1hbGl6ZWQgbmFtZS5cbiAgICpcbiAgICogRE9NTXV0YXRpb25NZXRob2RzOiBQcm9wZXJ0aWVzIHRoYXQgcmVxdWlyZSBzcGVjaWFsIG11dGF0aW9uIG1ldGhvZHMuIElmXG4gICAqIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLCB0aGUgbXV0YXRpb24gbWV0aG9kIHNob3VsZCB1bnNldCB0aGUgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkb21Qcm9wZXJ0eUNvbmZpZyB0aGUgY29uZmlnIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAgICovXG4gIGluamVjdERPTVByb3BlcnR5Q29uZmlnOiBmdW5jdGlvbiAoZG9tUHJvcGVydHlDb25maWcpIHtcbiAgICB2YXIgSW5qZWN0aW9uID0gRE9NUHJvcGVydHlJbmplY3Rpb247XG4gICAgdmFyIFByb3BlcnRpZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5Qcm9wZXJ0aWVzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lc3BhY2VzID0gZG9tUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXNwYWNlcyB8fCB7fTtcbiAgICB2YXIgRE9NQXR0cmlidXRlTmFtZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lcyB8fCB7fTtcbiAgICB2YXIgRE9NUHJvcGVydHlOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTVByb3BlcnR5TmFtZXMgfHwge307XG4gICAgdmFyIERPTU11dGF0aW9uTWV0aG9kcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTU11dGF0aW9uTWV0aG9kcyB8fCB7fTtcblxuICAgIGlmIChkb21Qcm9wZXJ0eUNvbmZpZy5pc0N1c3RvbUF0dHJpYnV0ZSkge1xuICAgICAgRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zLnB1c2goZG9tUHJvcGVydHlDb25maWcuaXNDdXN0b21BdHRyaWJ1dGUpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIFByb3BlcnRpZXMpIHtcbiAgICAgICEhRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnaW5qZWN0RE9NUHJvcGVydHlDb25maWcoLi4uKTogWW91XFwncmUgdHJ5aW5nIHRvIGluamVjdCBET00gcHJvcGVydHkgXFwnJXNcXCcgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBpbmplY3RlZC4gWW91IG1heSBiZSBhY2NpZGVudGFsbHkgaW5qZWN0aW5nIHRoZSBzYW1lIERPTSBwcm9wZXJ0eSBjb25maWcgdHdpY2UsIG9yIHlvdSBtYXkgYmUgaW5qZWN0aW5nIHR3byBjb25maWdzIHRoYXQgaGF2ZSBjb25mbGljdGluZyBwcm9wZXJ0eSBuYW1lcy4nLCBwcm9wTmFtZSkgOiBfcHJvZEludmFyaWFudCgnNDgnLCBwcm9wTmFtZSkgOiB2b2lkIDA7XG5cbiAgICAgIHZhciBsb3dlckNhc2VkID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBwcm9wQ29uZmlnID0gUHJvcGVydGllc1twcm9wTmFtZV07XG5cbiAgICAgIHZhciBwcm9wZXJ0eUluZm8gPSB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IGxvd2VyQ2FzZWQsXG4gICAgICAgIGF0dHJpYnV0ZU5hbWVzcGFjZTogbnVsbCxcbiAgICAgICAgcHJvcGVydHlOYW1lOiBwcm9wTmFtZSxcbiAgICAgICAgbXV0YXRpb25NZXRob2Q6IG51bGwsXG5cbiAgICAgICAgbXVzdFVzZVByb3BlcnR5OiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZKSxcbiAgICAgICAgaGFzQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFKSxcbiAgICAgICAgaGFzTnVtZXJpY1ZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFKSxcbiAgICAgICAgaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUpXG4gICAgICB9O1xuICAgICAgIShwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICsgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSArIHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlIDw9IDEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0RPTVByb3BlcnR5OiBWYWx1ZSBjYW4gYmUgb25lIG9mIGJvb2xlYW4sIG92ZXJsb2FkZWQgYm9vbGVhbiwgb3IgbnVtZXJpYyB2YWx1ZSwgYnV0IG5vdCBhIGNvbWJpbmF0aW9uOiAlcycsIHByb3BOYW1lKSA6IF9wcm9kSW52YXJpYW50KCc1MCcsIHByb3BOYW1lKSA6IHZvaWQgMDtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbbG93ZXJDYXNlZF0gPSBwcm9wTmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKERPTUF0dHJpYnV0ZU5hbWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IERPTUF0dHJpYnV0ZU5hbWVzW3Byb3BOYW1lXTtcbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2F0dHJpYnV0ZU5hbWVdID0gcHJvcE5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBET01BdHRyaWJ1dGVOYW1lc3BhY2VzW3Byb3BOYW1lXTtcbiAgICAgIH1cblxuICAgICAgaWYgKERPTVByb3BlcnR5TmFtZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWUgPSBET01Qcm9wZXJ0eU5hbWVzW3Byb3BOYW1lXTtcbiAgICAgIH1cblxuICAgICAgaWYgKERPTU11dGF0aW9uTWV0aG9kcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kID0gRE9NTXV0YXRpb25NZXRob2RzW3Byb3BOYW1lXTtcbiAgICAgIH1cblxuICAgICAgRE9NUHJvcGVydHkucHJvcGVydGllc1twcm9wTmFtZV0gPSBwcm9wZXJ0eUluZm87XG4gICAgfVxuICB9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG52YXIgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiA9ICc6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEJztcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIERPTVByb3BlcnR5IGV4cG9ydHMgbG9va3VwIG9iamVjdHMgdGhhdCBjYW4gYmUgdXNlZCBsaWtlIGZ1bmN0aW9uczpcbiAqXG4gKiAgID4gRE9NUHJvcGVydHkuaXNWYWxpZFsnaWQnXVxuICogICB0cnVlXG4gKiAgID4gRE9NUHJvcGVydHkuaXNWYWxpZFsnZm9vYmFyJ11cbiAqICAgdW5kZWZpbmVkXG4gKlxuICogQWx0aG91Z2ggdGhpcyBtYXkgYmUgY29uZnVzaW5nLCBpdCBwZXJmb3JtcyBiZXR0ZXIgaW4gZ2VuZXJhbC5cbiAqXG4gKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2tleS1leGlzdHNcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20va2V5LW1pc3NpbmdcbiAqL1xudmFyIERPTVByb3BlcnR5ID0ge1xuICBJRF9BVFRSSUJVVEVfTkFNRTogJ2RhdGEtcmVhY3RpZCcsXG4gIFJPT1RfQVRUUklCVVRFX05BTUU6ICdkYXRhLXJlYWN0cm9vdCcsXG5cbiAgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUjogQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUixcbiAgQVRUUklCVVRFX05BTUVfQ0hBUjogQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICdcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MCcsXG5cbiAgLyoqXG4gICAqIE1hcCBmcm9tIHByb3BlcnR5IFwic3RhbmRhcmQgbmFtZVwiIHRvIGFuIG9iamVjdCB3aXRoIGluZm8gYWJvdXQgaG93IHRvIHNldFxuICAgKiB0aGUgcHJvcGVydHkgaW4gdGhlIERPTS4gRWFjaCBvYmplY3QgY29udGFpbnM6XG4gICAqXG4gICAqIGF0dHJpYnV0ZU5hbWU6XG4gICAqICAgVXNlZCB3aGVuIHJlbmRlcmluZyBtYXJrdXAgb3Igd2l0aCBgKkF0dHJpYnV0ZSgpYC5cbiAgICogYXR0cmlidXRlTmFtZXNwYWNlXG4gICAqIHByb3BlcnR5TmFtZTpcbiAgICogICBVc2VkIG9uIERPTSBub2RlIGluc3RhbmNlcy4gKFRoaXMgaW5jbHVkZXMgcHJvcGVydGllcyB0aGF0IG11dGF0ZSBkdWUgdG9cbiAgICogICBleHRlcm5hbCBmYWN0b3JzLilcbiAgICogbXV0YXRpb25NZXRob2Q6XG4gICAqICAgSWYgbm9uLW51bGwsIHVzZWQgaW5zdGVhZCBvZiB0aGUgcHJvcGVydHkgb3IgYHNldEF0dHJpYnV0ZSgpYCBhZnRlclxuICAgKiAgIGluaXRpYWwgcmVuZGVyLlxuICAgKiBtdXN0VXNlUHJvcGVydHk6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBhY2Nlc3NlZCBhbmQgbXV0YXRlZCBhcyBhbiBvYmplY3QgcHJvcGVydHkuXG4gICAqIGhhc0Jvb2xlYW5WYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAgICogaGFzTnVtZXJpY1ZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIG51bWVyaWMgYW5kIHNob3VsZCBiZVxuICAgKiAgIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlXG4gICAqICAgbnVtZXJpYyBhbmQgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxuICAgKiAgIFJlbW92ZWQgd2hlbiBzdHJpY3RseSBlcXVhbCB0byBmYWxzZTsgcHJlc2VudCB3aXRob3V0IGEgdmFsdWUgd2hlblxuICAgKiAgIHN0cmljdGx5IGVxdWFsIHRvIHRydWU7IHByZXNlbnQgd2l0aCBhIHZhbHVlIG90aGVyd2lzZS5cbiAgICovXG4gIHByb3BlcnRpZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbG93ZXJjYXNlIHByb3BlcnR5IG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLCB1c2VkXG4gICAqIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBwcm9wZXJ0aWVzLiBBdmFpbGFibGUgb25seSBpbiBfX0RFVl9fLlxuICAgKlxuICAgKiBhdXRvZm9jdXMgaXMgcHJlZGVmaW5lZCwgYmVjYXVzZSBhZGRpbmcgaXQgdG8gdGhlIHByb3BlcnR5IHdoaXRlbGlzdFxuICAgKiBjYXVzZXMgdW5pbnRlbmRlZCBzaWRlIGVmZmVjdHMuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHsgYXV0b2ZvY3VzOiAnYXV0b0ZvY3VzJyB9IDogbnVsbCxcblxuICAvKipcbiAgICogQWxsIG9mIHRoZSBpc0N1c3RvbUF0dHJpYnV0ZSgpIGZ1bmN0aW9ucyB0aGF0IGhhdmUgYmVlbiBpbmplY3RlZC5cbiAgICovXG4gIF9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9uczogW10sXG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGEgcHJvcGVydHkgbmFtZSBpcyBhIGN1c3RvbSBhdHRyaWJ1dGUuXG4gICAqIEBtZXRob2RcbiAgICovXG4gIGlzQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXNDdXN0b21BdHRyaWJ1dGVGbiA9IERPTVByb3BlcnR5Ll9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9uc1tpXTtcbiAgICAgIGlmIChpc0N1c3RvbUF0dHJpYnV0ZUZuKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiBET01Qcm9wZXJ0eUluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01Qcm9wZXJ0eTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9ET01Qcm9wZXJ0eS5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwidmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL191aWQuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbGlicmFyeS5qcyIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanMiLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgdmFyIEMgPSBnbG9iYWxbS0VZXTtcbiAgaWYgKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pIGRQLmYoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBCUkVBSyA9IHt9O1xudmFyIFJFVFVSTiA9IHt9O1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKSB7XG4gIHZhciBpdGVyRm4gPSBJVEVSQVRPUiA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKTtcbiAgdmFyIGYgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYgKGlzQXJyYXlJdGVyKGl0ZXJGbikpIGZvciAobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7KSB7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5leHBvcnRzLkJSRUFLID0gQlJFQUs7XG5leHBvcnRzLlJFVFVSTiA9IFJFVFVSTjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Zvci1vZi5qcyIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgc2FmZSkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSByZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0sIHNhZmUpO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50U3ltYm9sJyk7XG5cbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG5cbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biwgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9O1xuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgbm8gaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvdyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG5cbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG5cbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9O1xuXG4gICAgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogc2VsZlxuICAgICAgfSk7XG4gICAgICAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgIGVsZW1lbnQuX3NlbGYgPSBzZWxmO1xuICAgICAgZWxlbWVudC5fc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jcmVhdGVlbGVtZW50XG4gKi9cblJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIHByb3BzID0ge307XG5cbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7XG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHMuJCR0eXBlb2YgPT09ICd1bmRlZmluZWQnIHx8IHByb3BzLiQkdHlwZW9mICE9PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBSZWFjdEVsZW1lbnRzIG9mIGEgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jcmVhdGVmYWN0b3J5XG4gKi9cblJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgdmFyIGZhY3RvcnkgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsIHR5cGUpO1xuICAvLyBFeHBvc2UgdGhlIHR5cGUgb24gdGhlIGZhY3RvcnkgYW5kIHRoZSBwcm90b3R5cGUgc28gdGhhdCBpdCBjYW4gYmVcbiAgLy8gZWFzaWx5IGFjY2Vzc2VkIG9uIGVsZW1lbnRzLiBFLmcuIGA8Rm9vIC8+LnR5cGUgPT09IEZvb2AuXG4gIC8vIFRoaXMgc2hvdWxkIG5vdCBiZSBuYW1lZCBgY29uc3RydWN0b3JgIHNpbmNlIHRoaXMgbWF5IG5vdCBiZSB0aGUgZnVuY3Rpb25cbiAgLy8gdGhhdCBjcmVhdGVkIHRoZSBlbGVtZW50LCBhbmQgaXQgbWF5IG5vdCBldmVuIGJlIGEgY29uc3RydWN0b3IuXG4gIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICBmYWN0b3J5LnR5cGUgPSB0eXBlO1xuICByZXR1cm4gZmFjdG9yeTtcbn07XG5cblJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VLZXkgPSBmdW5jdGlvbiAob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG5cbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59O1xuXG4vKipcbiAqIENsb25lIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IHVzaW5nIGVsZW1lbnQgYXMgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNsb25lZWxlbWVudFxuICovXG5SZWFjdEVsZW1lbnQuY2xvbmVFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcbiAgdmFyIHByb3BzID0gX2Fzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmO1xuICAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcblxuICAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xufTtcblxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmlzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIGNvbXBvbmVudC5cbiAqIEBmaW5hbFxuICovXG5SZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RWxlbWVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RWxlbWVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFN0YXRpYyBwb29sZXJzLiBTZXZlcmFsIGN1c3RvbSB2ZXJzaW9ucyBmb3IgZWFjaCBwb3RlbnRpYWwgbnVtYmVyIG9mXG4gKiBhcmd1bWVudHMuIEEgY29tcGxldGVseSBnZW5lcmljIHBvb2xlciBpcyBlYXN5IHRvIGltcGxlbWVudCwgYnV0IHdvdWxkXG4gKiByZXF1aXJlIGFjY2Vzc2luZyB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0LiBJbiBlYWNoIG9mIHRoZXNlLCBgdGhpc2AgcmVmZXJzIHRvXG4gKiB0aGUgQ2xhc3MgaXRzZWxmLCBub3QgYW4gaW5zdGFuY2UuIElmIGFueSBvdGhlcnMgYXJlIG5lZWRlZCwgc2ltcGx5IGFkZCB0aGVtXG4gKiBoZXJlLCBvciBpbiB0aGVpciBvd24gZmlsZXMuXG4gKi9cbnZhciBvbmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChjb3B5RmllbGRzRnJvbSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBjb3B5RmllbGRzRnJvbSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoY29weUZpZWxkc0Zyb20pO1xuICB9XG59O1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMik7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyKTtcbiAgfVxufTtcblxudmFyIHRocmVlQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMykge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzKTtcbiAgfVxufTtcblxudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMywgYTQpO1xuICB9XG59O1xuXG52YXIgc3RhbmRhcmRSZWxlYXNlciA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICAhKGluc3RhbmNlIGluc3RhbmNlb2YgS2xhc3MpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyeWluZyB0byByZWxlYXNlIGFuIGluc3RhbmNlIGludG8gYSBwb29sIG9mIGEgZGlmZmVyZW50IHR5cGUuJykgOiBfcHJvZEludmFyaWFudCgnMjUnKSA6IHZvaWQgMDtcbiAgaW5zdGFuY2UuZGVzdHJ1Y3RvcigpO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCA8IEtsYXNzLnBvb2xTaXplKSB7XG4gICAgS2xhc3MuaW5zdGFuY2VQb29sLnB1c2goaW5zdGFuY2UpO1xuICB9XG59O1xuXG52YXIgREVGQVVMVF9QT09MX1NJWkUgPSAxMDtcbnZhciBERUZBVUxUX1BPT0xFUiA9IG9uZUFyZ3VtZW50UG9vbGVyO1xuXG4vKipcbiAqIEF1Z21lbnRzIGBDb3B5Q29uc3RydWN0b3JgIHRvIGJlIGEgcG9vbGFibGUgY2xhc3MsIGF1Z21lbnRpbmcgb25seSB0aGUgY2xhc3NcbiAqIGl0c2VsZiAoc3RhdGljYWxseSkgbm90IGFkZGluZyBhbnkgcHJvdG90eXBpY2FsIGZpZWxkcy4gQW55IENvcHlDb25zdHJ1Y3RvclxuICogeW91IGdpdmUgdGhpcyBtYXkgaGF2ZSBhIGBwb29sU2l6ZWAgcHJvcGVydHksIGFuZCB3aWxsIGxvb2sgZm9yIGFcbiAqIHByb3RvdHlwaWNhbCBgZGVzdHJ1Y3RvcmAgb24gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IENvcHlDb25zdHJ1Y3RvciBDb25zdHJ1Y3RvciB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcG9vbGVyIEN1c3RvbWl6YWJsZSBwb29sZXIuXG4gKi9cbnZhciBhZGRQb29saW5nVG8gPSBmdW5jdGlvbiAoQ29weUNvbnN0cnVjdG9yLCBwb29sZXIpIHtcbiAgLy8gQ2FzdGluZyBhcyBhbnkgc28gdGhhdCBmbG93IGlnbm9yZXMgdGhlIGFjdHVhbCBpbXBsZW1lbnRhdGlvbiBhbmQgdHJ1c3RzXG4gIC8vIGl0IHRvIG1hdGNoIHRoZSB0eXBlIHdlIGRlY2xhcmVkXG4gIHZhciBOZXdLbGFzcyA9IENvcHlDb25zdHJ1Y3RvcjtcbiAgTmV3S2xhc3MuaW5zdGFuY2VQb29sID0gW107XG4gIE5ld0tsYXNzLmdldFBvb2xlZCA9IHBvb2xlciB8fCBERUZBVUxUX1BPT0xFUjtcbiAgaWYgKCFOZXdLbGFzcy5wb29sU2l6ZSkge1xuICAgIE5ld0tsYXNzLnBvb2xTaXplID0gREVGQVVMVF9QT09MX1NJWkU7XG4gIH1cbiAgTmV3S2xhc3MucmVsZWFzZSA9IHN0YW5kYXJkUmVsZWFzZXI7XG4gIHJldHVybiBOZXdLbGFzcztcbn07XG5cbnZhciBQb29sZWRDbGFzcyA9IHtcbiAgYWRkUG9vbGluZ1RvOiBhZGRQb29saW5nVG8sXG4gIG9uZUFyZ3VtZW50UG9vbGVyOiBvbmVBcmd1bWVudFBvb2xlcixcbiAgdHdvQXJndW1lbnRQb29sZXI6IHR3b0FyZ3VtZW50UG9vbGVyLFxuICB0aHJlZUFyZ3VtZW50UG9vbGVyOiB0aHJlZUFyZ3VtZW50UG9vbGVyLFxuICBmb3VyQXJndW1lbnRQb29sZXI6IGZvdXJBcmd1bWVudFBvb2xlclxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb29sZWRDbGFzcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9Qb29sZWRDbGFzcy5qcyIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgdGFnLCBzdGF0KSB7XG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSBkZWYoaXQsIFRBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWcgfSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIHNwYWNlcyA9IHJlcXVpcmUoJy4vX3N0cmluZy13cycpO1xudmFyIHNwYWNlID0gJ1snICsgc3BhY2VzICsgJ10nO1xudmFyIG5vbiA9ICdcXHUyMDBiXFx1MDA4NSc7XG52YXIgbHRyaW0gPSBSZWdFeHAoJ14nICsgc3BhY2UgKyBzcGFjZSArICcqJyk7XG52YXIgcnRyaW0gPSBSZWdFeHAoc3BhY2UgKyBzcGFjZSArICcqJCcpO1xuXG52YXIgZXhwb3J0ZXIgPSBmdW5jdGlvbiAoS0VZLCBleGVjLCBBTElBUykge1xuICB2YXIgZXhwID0ge307XG4gIHZhciBGT1JDRSA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISFzcGFjZXNbS0VZXSgpIHx8IG5vbltLRVldKCkgIT0gbm9uO1xuICB9KTtcbiAgdmFyIGZuID0gZXhwW0tFWV0gPSBGT1JDRSA/IGV4ZWModHJpbSkgOiBzcGFjZXNbS0VZXTtcbiAgaWYgKEFMSUFTKSBleHBbQUxJQVNdID0gZm47XG4gICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0UsICdTdHJpbmcnLCBleHApO1xufTtcblxuLy8gMSAtPiBTdHJpbmcjdHJpbUxlZnRcbi8vIDIgLT4gU3RyaW5nI3RyaW1SaWdodFxuLy8gMyAtPiBTdHJpbmcjdHJpbVxudmFyIHRyaW0gPSBleHBvcnRlci50cmltID0gZnVuY3Rpb24gKHN0cmluZywgVFlQRSkge1xuICBzdHJpbmcgPSBTdHJpbmcoZGVmaW5lZChzdHJpbmcpKTtcbiAgaWYgKFRZUEUgJiAxKSBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShsdHJpbSwgJycpO1xuICBpZiAoVFlQRSAmIDIpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJ0cmltLCAnJyk7XG4gIHJldHVybiBzdHJpbmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXRyaW0uanMiLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgVFlQRSkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSB8fCBpdC5fdCAhPT0gVFlQRSkgdGhyb3cgVHlwZUVycm9yKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3ZhbGlkYXRlLWNvbGxlY3Rpb24uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0QmFzZUNsYXNzZXMgPSByZXF1aXJlKCcuL1JlYWN0QmFzZUNsYXNzZXMnKTtcbnZhciBSZWFjdENoaWxkcmVuID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkcmVuJyk7XG52YXIgUmVhY3RET01GYWN0b3JpZXMgPSByZXF1aXJlKCcuL1JlYWN0RE9NRmFjdG9yaWVzJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXMnKTtcbnZhciBSZWFjdFZlcnNpb24gPSByZXF1aXJlKCcuL1JlYWN0VmVyc2lvbicpO1xuXG52YXIgY3JlYXRlUmVhY3RDbGFzcyA9IHJlcXVpcmUoJy4vY3JlYXRlQ2xhc3MnKTtcbnZhciBvbmx5Q2hpbGQgPSByZXF1aXJlKCcuL29ubHlDaGlsZCcpO1xuXG52YXIgY3JlYXRlRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50O1xudmFyIGNyZWF0ZUZhY3RvcnkgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeTtcbnZhciBjbG9uZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY2xvbmVFbGVtZW50O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgbG93UHJpb3JpdHlXYXJuaW5nID0gcmVxdWlyZSgnLi9sb3dQcmlvcml0eVdhcm5pbmcnKTtcbiAgdmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xuICB2YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3InKTtcbiAgdmFyIGRpZFdhcm5Qcm9wVHlwZXNEZXByZWNhdGVkID0gZmFsc2U7XG4gIGNyZWF0ZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRWxlbWVudDtcbiAgY3JlYXRlRmFjdG9yeSA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVGYWN0b3J5O1xuICBjbG9uZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY2xvbmVFbGVtZW50O1xufVxuXG52YXIgX19zcHJlYWQgPSBfYXNzaWduO1xudmFyIGNyZWF0ZU1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gIHJldHVybiBtaXhpbjtcbn07XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciB3YXJuZWRGb3JTcHJlYWQgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZEZvckNyZWF0ZU1peGluID0gZmFsc2U7XG4gIF9fc3ByZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIGxvd1ByaW9yaXR5V2FybmluZyh3YXJuZWRGb3JTcHJlYWQsICdSZWFjdC5fX3NwcmVhZCBpcyBkZXByZWNhdGVkIGFuZCBzaG91bGQgbm90IGJlIHVzZWQuIFVzZSAnICsgJ09iamVjdC5hc3NpZ24gZGlyZWN0bHkgb3IgYW5vdGhlciBoZWxwZXIgZnVuY3Rpb24gd2l0aCBzaW1pbGFyICcgKyAnc2VtYW50aWNzLiBZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIHlvdXIgY29tcGlsZXIuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtc3ByZWFkLWRlcHJlY2F0aW9uIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gICAgd2FybmVkRm9yU3ByZWFkID0gdHJ1ZTtcbiAgICByZXR1cm4gX2Fzc2lnbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIGNyZWF0ZU1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgbG93UHJpb3JpdHlXYXJuaW5nKHdhcm5lZEZvckNyZWF0ZU1peGluLCAnUmVhY3QuY3JlYXRlTWl4aW4gaXMgZGVwcmVjYXRlZCBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkLiAnICsgJ0luIFJlYWN0IHYxNi4wLCBpdCB3aWxsIGJlIHJlbW92ZWQuICcgKyAnWW91IGNhbiB1c2UgdGhpcyBtaXhpbiBkaXJlY3RseSBpbnN0ZWFkLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL2NyZWF0ZW1peGluLXdhcy1uZXZlci1pbXBsZW1lbnRlZCBmb3IgbW9yZSBpbmZvLicpO1xuICAgIHdhcm5lZEZvckNyZWF0ZU1peGluID0gdHJ1ZTtcbiAgICByZXR1cm4gbWl4aW47XG4gIH07XG59XG5cbnZhciBSZWFjdCA9IHtcbiAgLy8gTW9kZXJuXG5cbiAgQ2hpbGRyZW46IHtcbiAgICBtYXA6IFJlYWN0Q2hpbGRyZW4ubWFwLFxuICAgIGZvckVhY2g6IFJlYWN0Q2hpbGRyZW4uZm9yRWFjaCxcbiAgICBjb3VudDogUmVhY3RDaGlsZHJlbi5jb3VudCxcbiAgICB0b0FycmF5OiBSZWFjdENoaWxkcmVuLnRvQXJyYXksXG4gICAgb25seTogb25seUNoaWxkXG4gIH0sXG5cbiAgQ29tcG9uZW50OiBSZWFjdEJhc2VDbGFzc2VzLkNvbXBvbmVudCxcbiAgUHVyZUNvbXBvbmVudDogUmVhY3RCYXNlQ2xhc3Nlcy5QdXJlQ29tcG9uZW50LFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQsXG4gIGNsb25lRWxlbWVudDogY2xvbmVFbGVtZW50LFxuICBpc1ZhbGlkRWxlbWVudDogUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50LFxuXG4gIC8vIENsYXNzaWNcblxuICBQcm9wVHlwZXM6IFJlYWN0UHJvcFR5cGVzLFxuICBjcmVhdGVDbGFzczogY3JlYXRlUmVhY3RDbGFzcyxcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeSxcbiAgY3JlYXRlTWl4aW46IGNyZWF0ZU1peGluLFxuXG4gIC8vIFRoaXMgbG9va3MgRE9NIHNwZWNpZmljIGJ1dCB0aGVzZSBhcmUgYWN0dWFsbHkgaXNvbW9ycGhpYyBoZWxwZXJzXG4gIC8vIHNpbmNlIHRoZXkgYXJlIGp1c3QgZ2VuZXJhdGluZyBET00gc3RyaW5ncy5cbiAgRE9NOiBSZWFjdERPTUZhY3RvcmllcyxcblxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG5cbiAgLy8gRGVwcmVjYXRlZCBob29rIGZvciBKU1ggc3ByZWFkLCBkb24ndCB1c2UgdGhpcyBmb3IgYW55dGhpbmcuXG4gIF9fc3ByZWFkOiBfX3NwcmVhZFxufTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHdhcm5lZEZvckNyZWF0ZUNsYXNzID0gZmFsc2U7XG4gIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFjdCwgJ1Byb3BUeXBlcycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmcoZGlkV2FyblByb3BUeXBlc0RlcHJlY2F0ZWQsICdBY2Nlc3NpbmcgUHJvcFR5cGVzIHZpYSB0aGUgbWFpbiBSZWFjdCBwYWNrYWdlIGlzIGRlcHJlY2F0ZWQsJyArICcgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAgUmVhY3QgdjE2LjAuJyArICcgVXNlIHRoZSBsYXRlc3QgYXZhaWxhYmxlIHYxNS4qIHByb3AtdHlwZXMgcGFja2FnZSBmcm9tIG5wbSBpbnN0ZWFkLicgKyAnIEZvciBpbmZvIG9uIHVzYWdlLCBjb21wYXRpYmlsaXR5LCBtaWdyYXRpb24gYW5kIG1vcmUsIHNlZSAnICsgJ2h0dHBzOi8vZmIubWUvcHJvcC10eXBlcy1kb2NzJyk7XG4gICAgICAgIGRpZFdhcm5Qcm9wVHlwZXNEZXByZWNhdGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWN0LCAnY3JlYXRlQ2xhc3MnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nKHdhcm5lZEZvckNyZWF0ZUNsYXNzLCAnQWNjZXNzaW5nIGNyZWF0ZUNsYXNzIHZpYSB0aGUgbWFpbiBSZWFjdCBwYWNrYWdlIGlzIGRlcHJlY2F0ZWQsJyArICcgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCB2MTYuMC4nICsgXCIgVXNlIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcyBpbnN0ZWFkLiBJZiB5b3UncmUgbm90IHlldCBcIiArICdyZWFkeSB0byBtaWdyYXRlLCBjcmVhdGUtcmVhY3QtY2xhc3MgdjE1LiogaXMgYXZhaWxhYmxlICcgKyAnb24gbnBtIGFzIGEgdGVtcG9yYXJ5LCBkcm9wLWluIHJlcGxhY2VtZW50LiAnICsgJ0ZvciBtb3JlIGluZm8gc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtY3JlYXRlLWNsYXNzJyk7XG4gICAgICAgIHdhcm5lZEZvckNyZWF0ZUNsYXNzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlYWN0Q2xhc3M7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBSZWFjdC5ET00gZmFjdG9yaWVzIGFyZSBkZXByZWNhdGVkLiBXcmFwIHRoZXNlIG1ldGhvZHMgc28gdGhhdFxuICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgUmVhY3QuRE9NIG5hbWVzcGFjZSBhbmQgYWxlcnQgdXNlcnMgdG8gc3dpdGNoXG4gIC8vIHRvIHRoZSBgcmVhY3QtZG9tLWZhY3Rvcmllc2AgcGFja2FnZS5cbiAgUmVhY3QuRE9NID0ge307XG4gIHZhciB3YXJuZWRGb3JGYWN0b3JpZXMgPSBmYWxzZTtcbiAgT2JqZWN0LmtleXMoUmVhY3RET01GYWN0b3JpZXMpLmZvckVhY2goZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICBSZWFjdC5ET01bZmFjdG9yeV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXdhcm5lZEZvckZhY3Rvcmllcykge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmcoZmFsc2UsICdBY2Nlc3NpbmcgZmFjdG9yaWVzIGxpa2UgUmVhY3QuRE9NLiVzIGhhcyBiZWVuIGRlcHJlY2F0ZWQgJyArICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIHYxNi4wKy4gVXNlIHRoZSAnICsgJ3JlYWN0LWRvbS1mYWN0b3JpZXMgcGFja2FnZSBpbnN0ZWFkLiAnICsgJyBWZXJzaW9uIDEuMCBwcm92aWRlcyBhIGRyb3AtaW4gcmVwbGFjZW1lbnQuJyArICcgRm9yIG1vcmUgaW5mbywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtZG9tLWZhY3RvcmllcycsIGZhY3RvcnkpO1xuICAgICAgICB3YXJuZWRGb3JGYWN0b3JpZXMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJlYWN0RE9NRmFjdG9yaWVzW2ZhY3RvcnldLmFwcGx5KFJlYWN0RE9NRmFjdG9yaWVzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3QuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBXQVJOSU5HOiBETyBOT1QgbWFudWFsbHkgcmVxdWlyZSB0aGlzIG1vZHVsZS5cbiAqIFRoaXMgaXMgYSByZXBsYWNlbWVudCBmb3IgYGludmFyaWFudCguLi4pYCB1c2VkIGJ5IHRoZSBlcnJvciBjb2RlIHN5c3RlbVxuICogYW5kIHdpbGwgX29ubHlfIGJlIHJlcXVpcmVkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIGJhYmVsIHBhc3MuXG4gKiBJdCBhbHdheXMgdGhyb3dzLlxuICovXG5cbmZ1bmN0aW9uIHJlYWN0UHJvZEludmFyaWFudChjb2RlKSB7XG4gIHZhciBhcmdDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuXG4gIHZhciBtZXNzYWdlID0gJ01pbmlmaWVkIFJlYWN0IGVycm9yICMnICsgY29kZSArICc7IHZpc2l0ICcgKyAnaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnQ9JyArIGNvZGU7XG5cbiAgZm9yICh2YXIgYXJnSWR4ID0gMDsgYXJnSWR4IDwgYXJnQ291bnQ7IGFyZ0lkeCsrKSB7XG4gICAgbWVzc2FnZSArPSAnJmFyZ3NbXT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1thcmdJZHggKyAxXSk7XG4gIH1cblxuICBtZXNzYWdlICs9ICcgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50JyArICcgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJztcblxuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCByZWFjdFByb2RJbnZhcmlhbnQncyBvd24gZnJhbWVcblxuICB0aHJvdyBlcnJvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWFjdFByb2RJbnZhcmlhbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9yZWFjdFByb2RJbnZhcmlhbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSZWYgPSByZXF1aXJlKCcuL1JlYWN0UmVmJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEhlbHBlciB0byBjYWxsIFJlYWN0UmVmLmF0dGFjaFJlZnMgd2l0aCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQsIHNwbGl0IG91dFxuICogdG8gYXZvaWQgYWxsb2NhdGlvbnMgaW4gdGhlIHRyYW5zYWN0aW9uIG1vdW50LXJlYWR5IHF1ZXVlLlxuICovXG5mdW5jdGlvbiBhdHRhY2hSZWZzKCkge1xuICBSZWFjdFJlZi5hdHRhY2hSZWZzKHRoaXMsIHRoaXMuX2N1cnJlbnRFbGVtZW50KTtcbn1cblxudmFyIFJlYWN0UmVjb25jaWxlciA9IHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBjb21wb25lbnQsIHJlbmRlcnMgbWFya3VwLCBhbmQgcmVnaXN0ZXJzIGV2ZW50IGxpc3RlbmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW50ZXJuYWxJbnN0YW5jZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHs/b2JqZWN0fSB0aGUgY29udGFpbmluZyBob3N0IGNvbXBvbmVudCBpbnN0YW5jZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IGluZm8gYWJvdXQgdGhlIGhvc3QgY29udGFpbmVyXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IFJlbmRlcmVkIG1hcmt1cCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgdHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBwYXJlbnREZWJ1Z0lEKSAvLyAwIGluIHByb2R1Y3Rpb24gYW5kIGZvciByb290c1xuICB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZU1vdW50Q29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQsIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LCBwYXJlbnREZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG1hcmt1cCA9IGludGVybmFsSW5zdGFuY2UubW91bnRDb21wb25lbnQodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBwYXJlbnREZWJ1Z0lEKTtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQucmVmICE9IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoYXR0YWNoUmVmcywgaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Nb3VudENvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZhbHVlIHRoYXQgY2FuIGJlIHBhc3NlZCB0b1xuICAgKiBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cC5cbiAgICovXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnRlcm5hbEluc3RhbmNlLmdldEhvc3ROb2RlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFueSByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IGBtb3VudENvbXBvbmVudGAuXG4gICAqXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBzYWZlbHkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlVW5tb3VudENvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgUmVhY3RSZWYuZGV0YWNoUmVmcyhpbnRlcm5hbEluc3RhbmNlLCBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCk7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS51bm1vdW50Q29tcG9uZW50KHNhZmVseSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVubW91bnRDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYSBjb21wb25lbnQgdXNpbmcgYSBuZXcgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW50ZXJuYWxJbnN0YW5jZVxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcblxuICAgIGlmIChuZXh0RWxlbWVudCA9PT0gcHJldkVsZW1lbnQgJiYgY29udGV4dCA9PT0gaW50ZXJuYWxJbnN0YW5jZS5fY29udGV4dCkge1xuICAgICAgLy8gU2luY2UgZWxlbWVudHMgYXJlIGltbXV0YWJsZSBhZnRlciB0aGUgb3duZXIgaXMgcmVuZGVyZWQsXG4gICAgICAvLyB3ZSBjYW4gZG8gYSBjaGVhcCBpZGVudGl0eSBjb21wYXJlIGhlcmUgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgaXMgYVxuICAgICAgLy8gc3VwZXJmbHVvdXMgcmVjb25jaWxlLiBJdCdzIHBvc3NpYmxlIGZvciBzdGF0ZSB0byBiZSBtdXRhYmxlIGJ1dCBzdWNoXG4gICAgICAvLyBjaGFuZ2Ugc2hvdWxkIHRyaWdnZXIgYW4gdXBkYXRlIG9mIHRoZSBvd25lciB3aGljaCB3b3VsZCByZWNyZWF0ZVxuICAgICAgLy8gdGhlIGVsZW1lbnQuIFdlIGV4cGxpY2l0bHkgY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYW4gb3duZXIgc2luY2VcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgZm9yIGFuIGVsZW1lbnQgY3JlYXRlZCBvdXRzaWRlIGEgY29tcG9zaXRlIHRvIGJlXG4gICAgICAvLyBkZWVwbHkgbXV0YXRlZCBhbmQgcmV1c2VkLlxuXG4gICAgICAvLyBUT0RPOiBCYWlsaW5nIG91dCBlYXJseSBpcyBqdXN0IGEgcGVyZiBvcHRpbWl6YXRpb24gcmlnaHQ/XG4gICAgICAvLyBUT0RPOiBSZW1vdmluZyB0aGUgcmV0dXJuIHN0YXRlbWVudCBzaG91bGQgYWZmZWN0IGNvcnJlY3RuZXNzP1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVcGRhdGVDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCwgbmV4dEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZWZzQ2hhbmdlZCA9IFJlYWN0UmVmLnNob3VsZFVwZGF0ZVJlZnMocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KTtcblxuICAgIGlmIChyZWZzQ2hhbmdlZCkge1xuICAgICAgUmVhY3RSZWYuZGV0YWNoUmVmcyhpbnRlcm5hbEluc3RhbmNlLCBwcmV2RWxlbWVudCk7XG4gICAgfVxuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5yZWNlaXZlQ29tcG9uZW50KG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG5cbiAgICBpZiAocmVmc0NoYW5nZWQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQucmVmICE9IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoYXR0YWNoUmVmcywgaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZsdXNoIGFueSBkaXJ0eSBjaGFuZ2VzIGluIGEgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCB0cmFuc2FjdGlvbiwgdXBkYXRlQmF0Y2hOdW1iZXIpIHtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fdXBkYXRlQmF0Y2hOdW1iZXIgIT09IHVwZGF0ZUJhdGNoTnVtYmVyKSB7XG4gICAgICAvLyBUaGUgY29tcG9uZW50J3MgZW5xdWV1ZWQgYmF0Y2ggbnVtYmVyIHNob3VsZCBhbHdheXMgYmUgdGhlIGN1cnJlbnRcbiAgICAgIC8vIGJhdGNoIG9yIHRoZSBmb2xsb3dpbmcgb25lLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaW50ZXJuYWxJbnN0YW5jZS5fdXBkYXRlQmF0Y2hOdW1iZXIgPT0gbnVsbCB8fCBpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlciA9PT0gdXBkYXRlQmF0Y2hOdW1iZXIgKyAxLCAncGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5OiBVbmV4cGVjdGVkIGJhdGNoIG51bWJlciAoY3VycmVudCAlcywgJyArICdwZW5kaW5nICVzKScsIHVwZGF0ZUJhdGNoTnVtYmVyLCBpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlcikgOiB2b2lkIDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVcGRhdGVDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCwgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnRlcm5hbEluc3RhbmNlLnBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSh0cmFuc2FjdGlvbik7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSZWNvbmNpbGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0UmVjb25jaWxlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01OYW1lc3BhY2VzID0gcmVxdWlyZSgnLi9ET01OYW1lc3BhY2VzJyk7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcblxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSByZXF1aXJlKCcuL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24nKTtcbnZhciBzZXRUZXh0Q29udGVudCA9IHJlcXVpcmUoJy4vc2V0VGV4dENvbnRlbnQnKTtcblxudmFyIEVMRU1FTlRfTk9ERV9UWVBFID0gMTtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgPSAxMTtcblxuLyoqXG4gKiBJbiBJRSAoOC0xMSkgYW5kIEVkZ2UsIGFwcGVuZGluZyBub2RlcyB3aXRoIG5vIGNoaWxkcmVuIGlzIGRyYW1hdGljYWxseVxuICogZmFzdGVyIHRoYW4gYXBwZW5kaW5nIGEgZnVsbCBzdWJ0cmVlLCBzbyB3ZSBlc3NlbnRpYWxseSBxdWV1ZSB1cCB0aGVcbiAqIC5hcHBlbmRDaGlsZCBjYWxscyBoZXJlIGFuZCBhcHBseSB0aGVtIHNvIGVhY2ggbm9kZSBpcyBhZGRlZCB0byBpdHMgcGFyZW50XG4gKiBiZWZvcmUgYW55IGNoaWxkcmVuIGFyZSBhZGRlZC5cbiAqXG4gKiBJbiBvdGhlciBicm93c2VycywgZG9pbmcgc28gaXMgc2xvd2VyIG9yIG5ldXRyYWwgY29tcGFyZWQgdG8gdGhlIG90aGVyIG9yZGVyXG4gKiAoaW4gRmlyZWZveCwgdHdpY2UgYXMgc2xvdykgc28gd2Ugb25seSBkbyB0aGlzIGludmVyc2lvbiBpbiBJRS5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NwaWN5ai9pbm5lcmh0bWwtdnMtY3JlYXRlZWxlbWVudC12cy1jbG9uZW5vZGUuXG4gKi9cbnZhciBlbmFibGVMYXp5ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yLnVzZXJBZ2VudCA9PT0gJ3N0cmluZycgJiYgL1xcYkVkZ2VcXC9cXGQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbmZ1bmN0aW9uIGluc2VydFRyZWVDaGlsZHJlbih0cmVlKSB7XG4gIGlmICghZW5hYmxlTGF6eSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbm9kZSA9IHRyZWUubm9kZTtcbiAgdmFyIGNoaWxkcmVuID0gdHJlZS5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGluc2VydFRyZWVCZWZvcmUobm9kZSwgY2hpbGRyZW5baV0sIG51bGwpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0cmVlLmh0bWwgIT0gbnVsbCkge1xuICAgIHNldElubmVySFRNTChub2RlLCB0cmVlLmh0bWwpO1xuICB9IGVsc2UgaWYgKHRyZWUudGV4dCAhPSBudWxsKSB7XG4gICAgc2V0VGV4dENvbnRlbnQobm9kZSwgdHJlZS50ZXh0KTtcbiAgfVxufVxuXG52YXIgaW5zZXJ0VHJlZUJlZm9yZSA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKHBhcmVudE5vZGUsIHRyZWUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgLy8gRG9jdW1lbnRGcmFnbWVudHMgYXJlbid0IGFjdHVhbGx5IHBhcnQgb2YgdGhlIERPTSBhZnRlciBpbnNlcnRpb24gc29cbiAgLy8gYXBwZW5kaW5nIGNoaWxkcmVuIHdvbid0IHVwZGF0ZSB0aGUgRE9NLiBXZSBuZWVkIHRvIGVuc3VyZSB0aGUgZnJhZ21lbnRcbiAgLy8gaXMgcHJvcGVybHkgcG9wdWxhdGVkIGZpcnN0LCBicmVha2luZyBvdXQgb2Ygb3VyIGxhenkgYXBwcm9hY2ggZm9yIGp1c3RcbiAgLy8gdGhpcyBsZXZlbC4gQWxzbywgc29tZSA8b2JqZWN0PiBwbHVnaW5zIChsaWtlIEZsYXNoIFBsYXllcikgd2lsbCByZWFkXG4gIC8vIDxwYXJhbT4gbm9kZXMgaW1tZWRpYXRlbHkgdXBvbiBpbnNlcnRpb24gaW50byB0aGUgRE9NLCBzbyA8b2JqZWN0PlxuICAvLyBtdXN0IGFsc28gYmUgcG9wdWxhdGVkIHByaW9yIHRvIGluc2VydGlvbiBpbnRvIHRoZSBET00uXG4gIGlmICh0cmVlLm5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSB8fCB0cmVlLm5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFICYmIHRyZWUubm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb2JqZWN0JyAmJiAodHJlZS5ub2RlLm5hbWVzcGFjZVVSSSA9PSBudWxsIHx8IHRyZWUubm9kZS5uYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuaHRtbCkpIHtcbiAgICBpbnNlcnRUcmVlQ2hpbGRyZW4odHJlZSk7XG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodHJlZS5ub2RlLCByZWZlcmVuY2VOb2RlKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0cmVlLm5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICAgIGluc2VydFRyZWVDaGlsZHJlbih0cmVlKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHJlcGxhY2VDaGlsZFdpdGhUcmVlKG9sZE5vZGUsIG5ld1RyZWUpIHtcbiAgb2xkTm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdUcmVlLm5vZGUsIG9sZE5vZGUpO1xuICBpbnNlcnRUcmVlQ2hpbGRyZW4obmV3VHJlZSk7XG59XG5cbmZ1bmN0aW9uIHF1ZXVlQ2hpbGQocGFyZW50VHJlZSwgY2hpbGRUcmVlKSB7XG4gIGlmIChlbmFibGVMYXp5KSB7XG4gICAgcGFyZW50VHJlZS5jaGlsZHJlbi5wdXNoKGNoaWxkVHJlZSk7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50VHJlZS5ub2RlLmFwcGVuZENoaWxkKGNoaWxkVHJlZS5ub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBxdWV1ZUhUTUwodHJlZSwgaHRtbCkge1xuICBpZiAoZW5hYmxlTGF6eSkge1xuICAgIHRyZWUuaHRtbCA9IGh0bWw7XG4gIH0gZWxzZSB7XG4gICAgc2V0SW5uZXJIVE1MKHRyZWUubm9kZSwgaHRtbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcXVldWVUZXh0KHRyZWUsIHRleHQpIHtcbiAgaWYgKGVuYWJsZUxhenkpIHtcbiAgICB0cmVlLnRleHQgPSB0ZXh0O1xuICB9IGVsc2Uge1xuICAgIHNldFRleHRDb250ZW50KHRyZWUubm9kZSwgdGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0aGlzLm5vZGUubm9kZU5hbWU7XG59XG5cbmZ1bmN0aW9uIERPTUxhenlUcmVlKG5vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiBub2RlLFxuICAgIGNoaWxkcmVuOiBbXSxcbiAgICBodG1sOiBudWxsLFxuICAgIHRleHQ6IG51bGwsXG4gICAgdG9TdHJpbmc6IHRvU3RyaW5nXG4gIH07XG59XG5cbkRPTUxhenlUcmVlLmluc2VydFRyZWVCZWZvcmUgPSBpbnNlcnRUcmVlQmVmb3JlO1xuRE9NTGF6eVRyZWUucmVwbGFjZUNoaWxkV2l0aFRyZWUgPSByZXBsYWNlQ2hpbGRXaXRoVHJlZTtcbkRPTUxhenlUcmVlLnF1ZXVlQ2hpbGQgPSBxdWV1ZUNoaWxkO1xuRE9NTGF6eVRyZWUucXVldWVIVE1MID0gcXVldWVIVE1MO1xuRE9NTGF6eVRyZWUucXVldWVUZXh0ID0gcXVldWVUZXh0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTUxhenlUcmVlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0RPTUxhenlUcmVlLmpzIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lvYmplY3QuanMiLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanMiLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBBUkcgPSBjb2YoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jbGFzc29mLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luVXRpbHMnKTtcblxudmFyIGFjY3VtdWxhdGVJbnRvID0gcmVxdWlyZSgnLi9hY2N1bXVsYXRlSW50bycpO1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IHJlcXVpcmUoJy4vZm9yRWFjaEFjY3VtdWxhdGVkJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGdldExpc3RlbmVyID0gRXZlbnRQbHVnaW5IdWIuZ2V0TGlzdGVuZXI7XG5cbi8qKlxuICogU29tZSBldmVudCB0eXBlcyBoYXZlIGEgbm90aW9uIG9mIGRpZmZlcmVudCByZWdpc3RyYXRpb24gbmFtZXMgZm9yIGRpZmZlcmVudFxuICogXCJwaGFzZXNcIiBvZiBwcm9wYWdhdGlvbi4gVGhpcyBmaW5kcyBsaXN0ZW5lcnMgYnkgYSBnaXZlbiBwaGFzZS5cbiAqL1xuZnVuY3Rpb24gbGlzdGVuZXJBdFBoYXNlKGluc3QsIGV2ZW50LCBwcm9wYWdhdGlvblBoYXNlKSB7XG4gIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcHJvcGFnYXRpb25QaGFzZV07XG4gIHJldHVybiBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbn1cblxuLyoqXG4gKiBUYWdzIGEgYFN5bnRoZXRpY0V2ZW50YCB3aXRoIGRpc3BhdGNoZWQgbGlzdGVuZXJzLiBDcmVhdGluZyB0aGlzIGZ1bmN0aW9uXG4gKiBoZXJlLCBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gYmluZCBvciBjcmVhdGUgZnVuY3Rpb25zIGZvciBlYWNoIGV2ZW50LlxuICogTXV0YXRpbmcgdGhlIGV2ZW50J3MgbWVtYmVycyBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gY3JlYXRlIGEgd3JhcHBpbmdcbiAqIFwiZGlzcGF0Y2hcIiBvYmplY3QgdGhhdCBwYWlycyB0aGUgZXZlbnQgd2l0aCB0aGUgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMoaW5zdCwgcGhhc2UsIGV2ZW50KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaW5zdCwgJ0Rpc3BhdGNoaW5nIGluc3QgbXVzdCBub3QgYmUgbnVsbCcpIDogdm9pZCAwO1xuICB9XG4gIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcGhhc2UpO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICB9XG59XG5cbi8qKlxuICogQ29sbGVjdCBkaXNwYXRjaGVzIChtdXN0IGJlIGVudGlyZWx5IGNvbGxlY3RlZCBiZWZvcmUgZGlzcGF0Y2hpbmcgLSBzZWUgdW5pdFxuICogdGVzdHMpLiBMYXppbHkgYWxsb2NhdGUgdGhlIGFycmF5IHRvIGNvbnNlcnZlIG1lbW9yeS4gIFdlIG11c3QgbG9vcCB0aHJvdWdoXG4gKiBlYWNoIGV2ZW50IGFuZCBwZXJmb3JtIHRoZSB0cmF2ZXJzYWwgZm9yIGVhY2ggb25lLiBXZSBjYW5ub3QgcGVyZm9ybSBhXG4gKiBzaW5nbGUgdHJhdmVyc2FsIGZvciB0aGUgZW50aXJlIGNvbGxlY3Rpb24gb2YgZXZlbnRzIGJlY2F1c2UgZWFjaCBldmVudCBtYXlcbiAqIGhhdmUgYSBkaWZmZXJlbnQgdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIEV2ZW50UGx1Z2luVXRpbHMudHJhdmVyc2VUd29QaGFzZShldmVudC5fdGFyZ2V0SW5zdCwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogU2FtZSBhcyBgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZWAsIGJ1dCBza2lwcyBvdmVyIHRoZSB0YXJnZXRJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgdmFyIHRhcmdldEluc3QgPSBldmVudC5fdGFyZ2V0SW5zdDtcbiAgICB2YXIgcGFyZW50SW5zdCA9IHRhcmdldEluc3QgPyBFdmVudFBsdWdpblV0aWxzLmdldFBhcmVudEluc3RhbmNlKHRhcmdldEluc3QpIDogbnVsbDtcbiAgICBFdmVudFBsdWdpblV0aWxzLnRyYXZlcnNlVHdvUGhhc2UocGFyZW50SW5zdCwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgd2l0aG91dCByZWdhcmQgdG8gZGlyZWN0aW9uLCBkb2VzIG5vdCBsb29rIGZvciBwaGFzZWRcbiAqIHJlZ2lzdHJhdGlvbiBuYW1lcy4gU2FtZSBhcyBgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGVgIGJ1dCB3aXRob3V0XG4gKiByZXF1aXJpbmcgdGhhdCB0aGUgYGRpc3BhdGNoTWFya2VyYCBiZSB0aGUgc2FtZSBhcyB0aGUgZGlzcGF0Y2hlZCBJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpc3BhdGNoZXMoaW5zdCwgaWdub3JlZERpcmVjdGlvbiwgZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgdmFyIGxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcywgaW5zdCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgZGlzcGF0Y2hlcyBvbiBhbiBgU3ludGhldGljRXZlbnRgLCBidXQgb25seSBmb3IgdGhlXG4gKiBgZGlzcGF0Y2hNYXJrZXJgLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhldmVudC5fdGFyZ2V0SW5zdCwgbnVsbCwgZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldChldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tLCB0bykge1xuICBFdmVudFBsdWdpblV0aWxzLnRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgYWNjdW11bGF0ZURpc3BhdGNoZXMsIGxlYXZlLCBlbnRlcik7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbi8qKlxuICogQSBzbWFsbCBzZXQgb2YgcHJvcGFnYXRpb24gcGF0dGVybnMsIGVhY2ggb2Ygd2hpY2ggd2lsbCBhY2NlcHQgYSBzbWFsbCBhbW91bnRcbiAqIG9mIGluZm9ybWF0aW9uLCBhbmQgZ2VuZXJhdGUgYSBzZXQgb2YgXCJkaXNwYXRjaCByZWFkeSBldmVudCBvYmplY3RzXCIgLSB3aGljaFxuICogYXJlIHNldHMgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gYW5ub3RhdGVkIHdpdGggYSBzZXQgb2YgZGlzcGF0Y2hlZFxuICogbGlzdGVuZXIgZnVuY3Rpb25zL2lkcy4gVGhlIEFQSSBpcyBkZXNpZ25lZCB0aGlzIHdheSB0byBkaXNjb3VyYWdlIHRoZXNlXG4gKiBwcm9wYWdhdGlvbiBzdHJhdGVnaWVzIGZyb20gYWN0dWFsbHkgZXhlY3V0aW5nIHRoZSBkaXNwYXRjaGVzLCBzaW5jZSB3ZVxuICogYWx3YXlzIHdhbnQgdG8gY29sbGVjdCB0aGUgZW50aXJlIHNldCBvZiBkaXNwYXRjaGVzIGJlZm9yZSBleGVjdXRpbmcgZXZlbnQgYVxuICogc2luZ2xlIG9uZS5cbiAqXG4gKiBAY29uc3RydWN0b3IgRXZlbnRQcm9wYWdhdG9yc1xuICovXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHtcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlczogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyxcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQ6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0LFxuICBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlczogYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMsXG4gIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlczogYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UHJvcGFnYXRvcnM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRXZlbnRQcm9wYWdhdG9ycy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblJlZ2lzdHJ5Jyk7XG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5VdGlscycpO1xudmFyIFJlYWN0RXJyb3JVdGlscyA9IHJlcXVpcmUoJy4vUmVhY3RFcnJvclV0aWxzJyk7XG5cbnZhciBhY2N1bXVsYXRlSW50byA9IHJlcXVpcmUoJy4vYWNjdW11bGF0ZUludG8nKTtcbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSByZXF1aXJlKCcuL2ZvckVhY2hBY2N1bXVsYXRlZCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEludGVybmFsIHN0b3JlIGZvciBldmVudCBsaXN0ZW5lcnNcbiAqL1xudmFyIGxpc3RlbmVyQmFuayA9IHt9O1xuXG4vKipcbiAqIEludGVybmFsIHF1ZXVlIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWNjdW11bGF0ZWQgdGhlaXIgZGlzcGF0Y2hlcyBhbmQgYXJlXG4gKiB3YWl0aW5nIHRvIGhhdmUgdGhlaXIgZGlzcGF0Y2hlcyBleGVjdXRlZC5cbiAqL1xudmFyIGV2ZW50UXVldWUgPSBudWxsO1xuXG4vKipcbiAqIERpc3BhdGNoZXMgYW4gZXZlbnQgYW5kIHJlbGVhc2VzIGl0IGJhY2sgaW50byB0aGUgcG9vbCwgdW5sZXNzIHBlcnNpc3RlbnQuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBldmVudCBTeW50aGV0aWMgZXZlbnQgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxuICogQHByaXZhdGVcbiAqL1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZSA9IGZ1bmN0aW9uIChldmVudCwgc2ltdWxhdGVkKSB7XG4gIGlmIChldmVudCkge1xuICAgIEV2ZW50UGx1Z2luVXRpbHMuZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpO1xuXG4gICAgaWYgKCFldmVudC5pc1BlcnNpc3RlbnQoKSkge1xuICAgICAgZXZlbnQuY29uc3RydWN0b3IucmVsZWFzZShldmVudCk7XG4gICAgfVxuICB9XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgdHJ1ZSk7XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCBmYWxzZSk7XG59O1xuXG52YXIgZ2V0RGljdGlvbmFyeUtleSA9IGZ1bmN0aW9uIChpbnN0KSB7XG4gIC8vIFByZXZlbnRzIFY4IHBlcmZvcm1hbmNlIGlzc3VlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MjMyXG4gIHJldHVybiAnLicgKyBpbnN0Ll9yb290Tm9kZUlEO1xufTtcblxuZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZSh0YWcpIHtcbiAgcmV0dXJuIHRhZyA9PT0gJ2J1dHRvbicgfHwgdGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3NlbGVjdCcgfHwgdGFnID09PSAndGV4dGFyZWEnO1xufVxuXG5mdW5jdGlvbiBzaG91bGRQcmV2ZW50TW91c2VFdmVudChuYW1lLCB0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdvbkNsaWNrJzpcbiAgICBjYXNlICdvbkNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGljayc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGlja0NhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VEb3duJzpcbiAgICBjYXNlICdvbk1vdXNlRG93bkNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlJzpcbiAgICBjYXNlICdvbk1vdXNlTW92ZUNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VVcCc6XG4gICAgY2FzZSAnb25Nb3VzZVVwQ2FwdHVyZSc6XG4gICAgICByZXR1cm4gISEocHJvcHMuZGlzYWJsZWQgJiYgaXNJbnRlcmFjdGl2ZSh0eXBlKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYSB1bmlmaWVkIGludGVyZmFjZSBmb3IgZXZlbnQgcGx1Z2lucyB0byBiZSBpbnN0YWxsZWQgYW5kIGNvbmZpZ3VyZWQuXG4gKlxuICogRXZlbnQgcGx1Z2lucyBjYW4gaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIGBleHRyYWN0RXZlbnRzYCB7ZnVuY3Rpb24oc3RyaW5nLCBET01FdmVudFRhcmdldCwgc3RyaW5nLCBvYmplY3QpOiAqfVxuICogICAgIFJlcXVpcmVkLiBXaGVuIGEgdG9wLWxldmVsIGV2ZW50IGlzIGZpcmVkLCB0aGlzIG1ldGhvZCBpcyBleHBlY3RlZCB0b1xuICogICAgIGV4dHJhY3Qgc3ludGhldGljIGV2ZW50cyB0aGF0IHdpbGwgaW4gdHVybiBiZSBxdWV1ZWQgYW5kIGRpc3BhdGNoZWQuXG4gKlxuICogICBgZXZlbnRUeXBlc2Age29iamVjdH1cbiAqICAgICBPcHRpb25hbCwgcGx1Z2lucyB0aGF0IGZpcmUgZXZlbnRzIG11c3QgcHVibGlzaCBhIG1hcHBpbmcgb2YgcmVnaXN0cmF0aW9uXG4gKiAgICAgbmFtZXMgdGhhdCBhcmUgdXNlZCB0byByZWdpc3RlciBsaXN0ZW5lcnMuIFZhbHVlcyBvZiB0aGlzIG1hcHBpbmcgbXVzdFxuICogICAgIGJlIG9iamVjdHMgdGhhdCBjb250YWluIGByZWdpc3RyYXRpb25OYW1lYCBvciBgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNgLlxuICpcbiAqICAgYGV4ZWN1dGVEaXNwYXRjaGAge2Z1bmN0aW9uKG9iamVjdCwgZnVuY3Rpb24sIHN0cmluZyl9XG4gKiAgICAgT3B0aW9uYWwsIGFsbG93cyBwbHVnaW5zIHRvIG92ZXJyaWRlIGhvdyBhbiBldmVudCBnZXRzIGRpc3BhdGNoZWQuIEJ5XG4gKiAgICAgZGVmYXVsdCwgdGhlIGxpc3RlbmVyIGlzIHNpbXBseSBpbnZva2VkLlxuICpcbiAqIEVhY2ggcGx1Z2luIHRoYXQgaXMgaW5qZWN0ZWQgaW50byBgRXZlbnRzUGx1Z2luSHViYCBpcyBpbW1lZGlhdGVseSBvcGVyYWJsZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBFdmVudFBsdWdpbkh1YiA9IHtcbiAgLyoqXG4gICAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gICAqL1xuICBpbmplY3Rpb246IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogRXZlbnRQbHVnaW5SZWdpc3RyeS5pbmplY3RFdmVudFBsdWdpbk9yZGVyLFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAgICovXG4gICAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZVxuICB9LFxuXG4gIC8qKlxuICAgKiBTdG9yZXMgYGxpc3RlbmVyYCBhdCBgbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2tleV1gLiBJcyBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIFRoZSBjYWxsYmFjayB0byBzdG9yZS5cbiAgICovXG4gIHB1dExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAhKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgJXMgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgdHlwZSAlcycsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lcikgOiBfcHJvZEludmFyaWFudCgnOTQnLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpIDogdm9pZCAwO1xuXG4gICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdIHx8IChsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV0gPSB7fSk7XG4gICAgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVba2V5XSA9IGxpc3RlbmVyO1xuXG4gICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUuZGlkUHV0TGlzdGVuZXIpIHtcbiAgICAgIFBsdWdpbk1vZHVsZS5kaWRQdXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn0gVGhlIHN0b3JlZCBjYWxsYmFjay5cbiAgICovXG4gIGdldExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIC8vIFRPRE86IHNob3VsZFByZXZlbnRNb3VzZUV2ZW50IGlzIERPTS1zcGVjaWZpYyBhbmQgZGVmaW5pdGVseSBzaG91bGQgbm90XG4gICAgLy8gbGl2ZSBoZXJlOyBuZWVkcyB0byBiZSBtb3ZlZCB0byBhIGJldHRlciBwbGFjZSBzb29uXG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIGlmIChzaG91bGRQcmV2ZW50TW91c2VFdmVudChyZWdpc3RyYXRpb25OYW1lLCBpbnN0Ll9jdXJyZW50RWxlbWVudC50eXBlLCBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICByZXR1cm4gYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgJiYgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVba2V5XTtcbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhIGxpc3RlbmVyIGZyb20gdGhlIHJlZ2lzdHJhdGlvbiBiYW5rLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqL1xuICBkZWxldGVMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIpIHtcbiAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIG5ldmVyIGJlIG51bGwgLS0gd2hlbiBpcyBpdD9cbiAgICBpZiAoYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgICAgZGVsZXRlIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2tleV07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBET00gZWxlbWVudCB3aXRoIHRoZSBzdXBwbGllZCBJRC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAgICovXG4gIGRlbGV0ZUFsbExpc3RlbmVyczogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICBmb3IgKHZhciByZWdpc3RyYXRpb25OYW1lIGluIGxpc3RlbmVyQmFuaykge1xuICAgICAgaWYgKCFsaXN0ZW5lckJhbmsuaGFzT3duUHJvcGVydHkocmVnaXN0cmF0aW9uTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2tleV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKSB7XG4gICAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1ba2V5XTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFsbG93cyByZWdpc3RlcmVkIHBsdWdpbnMgYW4gb3Bwb3J0dW5pdHkgdG8gZXh0cmFjdCBldmVudHMgZnJvbSB0b3AtbGV2ZWxcbiAgICogbmF0aXZlIGJyb3dzZXIgZXZlbnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZXZlbnRzO1xuICAgIHZhciBwbHVnaW5zID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gTm90IGV2ZXJ5IHBsdWdpbiBpbiB0aGUgb3JkZXJpbmcgbWF5IGJlIGxvYWRlZCBhdCBydW50aW1lLlxuICAgICAgdmFyIHBvc3NpYmxlUGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICAgIGlmIChwb3NzaWJsZVBsdWdpbikge1xuICAgICAgICB2YXIgZXh0cmFjdGVkRXZlbnRzID0gcG9zc2libGVQbHVnaW4uZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgIGlmIChleHRyYWN0ZWRFdmVudHMpIHtcbiAgICAgICAgICBldmVudHMgPSBhY2N1bXVsYXRlSW50byhldmVudHMsIGV4dHJhY3RlZEV2ZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50cztcbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBzeW50aGV0aWMgZXZlbnQgdGhhdCBzaG91bGQgYmUgZGlzcGF0Y2hlZCB3aGVuXG4gICAqIGBwcm9jZXNzRXZlbnRRdWV1ZWAgaXMgaW52b2tlZC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBldmVudHMgQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUV2ZW50czogZnVuY3Rpb24gKGV2ZW50cykge1xuICAgIGlmIChldmVudHMpIHtcbiAgICAgIGV2ZW50UXVldWUgPSBhY2N1bXVsYXRlSW50byhldmVudFF1ZXVlLCBldmVudHMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbGwgc3ludGhldGljIGV2ZW50cyBvbiB0aGUgZXZlbnQgcXVldWUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvY2Vzc0V2ZW50UXVldWU6IGZ1bmN0aW9uIChzaW11bGF0ZWQpIHtcbiAgICAvLyBTZXQgYGV2ZW50UXVldWVgIHRvIG51bGwgYmVmb3JlIHByb2Nlc3NpbmcgaXQgc28gdGhhdCB3ZSBjYW4gdGVsbCBpZiBtb3JlXG4gICAgLy8gZXZlbnRzIGdldCBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nLlxuICAgIHZhciBwcm9jZXNzaW5nRXZlbnRRdWV1ZSA9IGV2ZW50UXVldWU7XG4gICAgZXZlbnRRdWV1ZSA9IG51bGw7XG4gICAgaWYgKHNpbXVsYXRlZCkge1xuICAgICAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsKTtcbiAgICB9XG4gICAgISFldmVudFF1ZXVlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3Byb2Nlc3NFdmVudFF1ZXVlKCk6IEFkZGl0aW9uYWwgZXZlbnRzIHdlcmUgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZyBhbiBldmVudCBxdWV1ZS4gU3VwcG9ydCBmb3IgdGhpcyBoYXMgbm90IHlldCBiZWVuIGltcGxlbWVudGVkLicpIDogX3Byb2RJbnZhcmlhbnQoJzk1JykgOiB2b2lkIDA7XG4gICAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gICAgUmVhY3RFcnJvclV0aWxzLnJldGhyb3dDYXVnaHRFcnJvcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGVzZSBhcmUgbmVlZGVkIGZvciB0ZXN0cyBvbmx5LiBEbyBub3QgdXNlIVxuICAgKi9cbiAgX19wdXJnZTogZnVuY3Rpb24gKCkge1xuICAgIGxpc3RlbmVyQmFuayA9IHt9O1xuICB9LFxuXG4gIF9fZ2V0TGlzdGVuZXJCYW5rOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQmFuaztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpbkh1YjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9FdmVudFBsdWdpbkh1Yi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVUlFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0ge1xuICB2aWV3OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudmlldykge1xuICAgICAgcmV0dXJuIGV2ZW50LnZpZXc7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICBpZiAodGFyZ2V0LndpbmRvdyA9PT0gdGFyZ2V0KSB7XG4gICAgICAvLyB0YXJnZXQgaXMgYSB3aW5kb3cgb2JqZWN0XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIHZhciBkb2MgPSB0YXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgaWYgKGRvYykge1xuICAgICAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgfSxcbiAgZGV0YWlsOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuZGV0YWlsIHx8IDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNVSUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1VJRXZlbnQsIFVJRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1VJRXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvU3ludGhldGljVUlFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKi9cblxuLy8gVE9ETzogUmVwbGFjZSB0aGlzIHdpdGggRVM2OiB2YXIgUmVhY3RJbnN0YW5jZU1hcCA9IG5ldyBNYXAoKTtcblxudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSB7XG4gIC8qKlxuICAgKiBUaGlzIEFQSSBzaG91bGQgYmUgY2FsbGVkIGBkZWxldGVgIGJ1dCB3ZSdkIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGFsd2F5c1xuICAgKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICAgKiBzdXBwb3J0ZWQgd2UgY2FuIHJlbmFtZSBpdC5cbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGtleSkge1xuICAgIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZTtcbiAgfSxcblxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgIT09IHVuZGVmaW5lZDtcbiAgfSxcblxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgPSB2YWx1ZTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEluc3RhbmNlTWFwO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0SW5zdGFuY2VNYXAuanMiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qcyIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LmpzIiwiLy8gNy4yLjggSXNSZWdFeHAoYXJndW1lbnQpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBNQVRDSCA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY29mKGl0KSA9PSAnUmVnRXhwJyk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtcmVnZXhwLmpzIiwidmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24gKCkgeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xufSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIHNraXBDbG9zaW5nKSB7XG4gIGlmICghc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBbN107XG4gICAgdmFyIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4geyBkb25lOiBzYWZlID0gdHJ1ZSB9OyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gYW5PYmplY3QodGhpcyk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoYXQuZ2xvYmFsKSByZXN1bHQgKz0gJ2cnO1xuICBpZiAodGhhdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuICBpZiAodGhhdC5tdWx0aWxpbmUpIHJlc3VsdCArPSAnbSc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnN0aWNreSkgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mbGFncy5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBsZW5ndGgsIGV4ZWMpIHtcbiAgdmFyIFNZTUJPTCA9IHdrcyhLRVkpO1xuICB2YXIgZm5zID0gZXhlYyhkZWZpbmVkLCBTWU1CT0wsICcnW0tFWV0pO1xuICB2YXIgc3RyZm4gPSBmbnNbMF07XG4gIHZhciByeGZuID0gZm5zWzFdO1xuICBpZiAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KSkge1xuICAgIHJlZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgc3RyZm4pO1xuICAgIGhpZGUoUmVnRXhwLnByb3RvdHlwZSwgU1lNQk9MLCBsZW5ndGggPT0gMlxuICAgICAgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKVxuICAgICAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF0oc3RyaW5nLCBsaW1pdClcbiAgICAgID8gZnVuY3Rpb24gKHN0cmluZywgYXJnKSB7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzLCBhcmcpOyB9XG4gICAgICAvLyAyMS4yLjUuNiBSZWdFeHAucHJvdG90eXBlW0BAbWF0Y2hdKHN0cmluZylcbiAgICAgIC8vIDIxLjIuNS45IFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdKHN0cmluZylcbiAgICAgIDogZnVuY3Rpb24gKHN0cmluZykgeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcyk7IH1cbiAgICApO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qcyIsIi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywgRCkge1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yO1xuICB2YXIgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogYUZ1bmN0aW9uKFMpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciAkaXRlckRldGVjdCA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0Jyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSykge1xuICB2YXIgQmFzZSA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIEMgPSBCYXNlO1xuICB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xuICB2YXIgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlO1xuICB2YXIgTyA9IHt9O1xuICB2YXIgZml4TWV0aG9kID0gZnVuY3Rpb24gKEtFWSkge1xuICAgIHZhciBmbiA9IHByb3RvW0tFWV07XG4gICAgcmVkZWZpbmUocHJvdG8sIEtFWSxcbiAgICAgIEtFWSA9PSAnZGVsZXRlJyA/IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnaGFzJyA/IGZ1bmN0aW9uIGhhcyhhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnZ2V0JyA/IGZ1bmN0aW9uIGdldChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IHVuZGVmaW5lZCA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQoYSkgeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7IHJldHVybiB0aGlzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gc2V0KGEsIGIpIHsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEsIGIpOyByZXR1cm4gdGhpczsgfVxuICAgICk7XG4gIH07XG4gIGlmICh0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpIHtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIG1ldGEuTkVFRCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAvLyBlYXJseSBpbXBsZW1lbnRhdGlvbnMgbm90IHN1cHBvcnRzIGNoYWluaW5nXG4gICAgdmFyIEhBU05UX0NIQUlOSU5HID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZTtcbiAgICAvLyBWOCB+ICBDaHJvbWl1bSA0MC0gd2Vhay1jb2xsZWN0aW9ucyB0aHJvd3Mgb24gcHJpbWl0aXZlcywgYnV0IHNob3VsZCByZXR1cm4gZmFsc2VcbiAgICB2YXIgVEhST1dTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IGluc3RhbmNlLmhhcygxKTsgfSk7XG4gICAgLy8gbW9zdCBlYXJseSBpbXBsZW1lbnRhdGlvbnMgZG9lc24ndCBzdXBwb3J0cyBpdGVyYWJsZXMsIG1vc3QgbW9kZXJuIC0gbm90IGNsb3NlIGl0IGNvcnJlY3RseVxuICAgIHZhciBBQ0NFUFRfSVRFUkFCTEVTID0gJGl0ZXJEZXRlY3QoZnVuY3Rpb24gKGl0ZXIpIHsgbmV3IEMoaXRlcik7IH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxuICAgIHZhciBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVjggfiBDaHJvbWl1bSA0Mi0gZmFpbHMgb25seSB3aXRoIDUrIGVsZW1lbnRzXG4gICAgICB2YXIgJGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAgIHZhciBpbmRleCA9IDU7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkgJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xuICAgICAgcmV0dXJuICEkaW5zdGFuY2UuaGFzKC0wKTtcbiAgICB9KTtcbiAgICBpZiAoIUFDQ0VQVF9JVEVSQUJMRVMpIHtcbiAgICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0YXJnZXQsIGl0ZXJhYmxlKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGFyZ2V0LCBDLCBOQU1FKTtcbiAgICAgICAgdmFyIHRoYXQgPSBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSgpLCB0YXJnZXQsIEMpO1xuICAgICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgfSk7XG4gICAgICBDLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgcHJvdG8uY29uc3RydWN0b3IgPSBDO1xuICAgIH1cbiAgICBpZiAoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTykge1xuICAgICAgZml4TWV0aG9kKCdkZWxldGUnKTtcbiAgICAgIGZpeE1ldGhvZCgnaGFzJyk7XG4gICAgICBJU19NQVAgJiYgZml4TWV0aG9kKCdnZXQnKTtcbiAgICB9XG4gICAgaWYgKEJVR0dZX1pFUk8gfHwgSEFTTlRfQ0hBSU5JTkcpIGZpeE1ldGhvZChBRERFUik7XG4gICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcbiAgICBpZiAoSVNfV0VBSyAmJiBwcm90by5jbGVhcikgZGVsZXRlIHByb3RvLmNsZWFyO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEMgIT0gQmFzZSksIE8pO1xuXG4gIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24uanMiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBUWVBFRCA9IHVpZCgndHlwZWRfYXJyYXknKTtcbnZhciBWSUVXID0gdWlkKCd2aWV3Jyk7XG52YXIgQUJWID0gISEoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGdsb2JhbC5EYXRhVmlldyk7XG52YXIgQ09OU1RSID0gQUJWO1xudmFyIGkgPSAwO1xudmFyIGwgPSA5O1xudmFyIFR5cGVkO1xuXG52YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9ycyA9IChcbiAgJ0ludDhBcnJheSxVaW50OEFycmF5LFVpbnQ4Q2xhbXBlZEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5J1xuKS5zcGxpdCgnLCcpO1xuXG53aGlsZSAoaSA8IGwpIHtcbiAgaWYgKFR5cGVkID0gZ2xvYmFsW1R5cGVkQXJyYXlDb25zdHJ1Y3RvcnNbaSsrXV0pIHtcbiAgICBoaWRlKFR5cGVkLnByb3RvdHlwZSwgVFlQRUQsIHRydWUpO1xuICAgIGhpZGUoVHlwZWQucHJvdG90eXBlLCBWSUVXLCB0cnVlKTtcbiAgfSBlbHNlIENPTlNUUiA9IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQUJWOiBBQlYsXG4gIENPTlNUUjogQ09OU1RSLFxuICBUWVBFRDogVFlQRUQsXG4gIFZJRVc6IFZJRVdcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIEZvcmNlZCByZXBsYWNlbWVudCBwcm90b3R5cGUgYWNjZXNzb3JzIG1ldGhvZHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fbGlicmFyeScpIHx8ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEsgPSBNYXRoLnJhbmRvbSgpO1xuICAvLyBJbiBGRiB0aHJvd3Mgb25seSBkZWZpbmUgbWV0aG9kc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWYsIG5vLXVzZWxlc3MtY2FsbFxuICBfX2RlZmluZVNldHRlcl9fLmNhbGwobnVsbCwgSywgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbiAgZGVsZXRlIHJlcXVpcmUoJy4vX2dsb2JhbCcpW0tdO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZm9yY2VkLXBhbS5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTExFQ1RJT04pIHtcbiAgJGV4cG9ydCgkZXhwb3J0LlMsIENPTExFQ1RJT04sIHsgb2Y6IGZ1bmN0aW9uIG9mKCkge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBBID0gQXJyYXkobGVuZ3RoKTtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIEFbbGVuZ3RoXSA9IGFyZ3VtZW50c1tsZW5ndGhdO1xuICAgIHJldHVybiBuZXcgdGhpcyhBKTtcbiAgfSB9KTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtY29sbGVjdGlvbi1vZi5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTExFQ1RJT04pIHtcbiAgJGV4cG9ydCgkZXhwb3J0LlMsIENPTExFQ1RJT04sIHsgZnJvbTogZnVuY3Rpb24gZnJvbShzb3VyY2UgLyogLCBtYXBGbiwgdGhpc0FyZyAqLykge1xuICAgIHZhciBtYXBGbiA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgbWFwcGluZywgQSwgbiwgY2I7XG4gICAgYUZ1bmN0aW9uKHRoaXMpO1xuICAgIG1hcHBpbmcgPSBtYXBGbiAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChtYXBwaW5nKSBhRnVuY3Rpb24obWFwRm4pO1xuICAgIGlmIChzb3VyY2UgPT0gdW5kZWZpbmVkKSByZXR1cm4gbmV3IHRoaXMoKTtcbiAgICBBID0gW107XG4gICAgaWYgKG1hcHBpbmcpIHtcbiAgICAgIG4gPSAwO1xuICAgICAgY2IgPSBjdHgobWFwRm4sIGFyZ3VtZW50c1syXSwgMik7XG4gICAgICBmb3JPZihzb3VyY2UsIGZhbHNlLCBmdW5jdGlvbiAobmV4dEl0ZW0pIHtcbiAgICAgICAgQS5wdXNoKGNiKG5leHRJdGVtLCBuKyspKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JPZihzb3VyY2UsIGZhbHNlLCBBLnB1c2gsIEEpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHRoaXMoQSk7XG4gIH0gfSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LWNvbGxlY3Rpb24tZnJvbS5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9SZWFjdCcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L3JlYWN0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSBmYWxzZTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHRyeSB7XG4gICAgLy8gJEZsb3dGaXhNZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7fSB9KTtcbiAgICBjYW5EZWZpbmVQcm9wZXJ0eSA9IHRydWU7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBJRSB3aWxsIGZhaWwgb24gZGVmaW5lUHJvcGVydHlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbkRlZmluZVByb3BlcnR5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvY2FuRGVmaW5lUHJvcGVydHkuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5T2JqZWN0O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEluamVjdGFibGUgb3JkZXJpbmcgb2YgZXZlbnQgcGx1Z2lucy5cbiAqL1xudmFyIGV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuXG4vKipcbiAqIEluamVjdGFibGUgbWFwcGluZyBmcm9tIG5hbWVzIHRvIGV2ZW50IHBsdWdpbiBtb2R1bGVzLlxuICovXG52YXIgbmFtZXNUb1BsdWdpbnMgPSB7fTtcblxuLyoqXG4gKiBSZWNvbXB1dGVzIHRoZSBwbHVnaW4gbGlzdCB1c2luZyB0aGUgaW5qZWN0ZWQgcGx1Z2lucyBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCkge1xuICBpZiAoIWV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAvLyBXYWl0IHVudGlsIGFuIGBldmVudFBsdWdpbk9yZGVyYCBpcyBpbmplY3RlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICB2YXIgcGx1Z2luSW5kZXggPSBldmVudFBsdWdpbk9yZGVyLmluZGV4T2YocGx1Z2luTmFtZSk7XG4gICAgIShwbHVnaW5JbmRleCA+IC0xKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbnMgdGhhdCBkbyBub3QgZXhpc3QgaW4gdGhlIHBsdWdpbiBvcmRlcmluZywgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IF9wcm9kSW52YXJpYW50KCc5NicsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIGlmIChFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnNbcGx1Z2luSW5kZXhdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgIXBsdWdpbk1vZHVsZS5leHRyYWN0RXZlbnRzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50IHBsdWdpbnMgbXVzdCBpbXBsZW1lbnQgYW4gYGV4dHJhY3RFdmVudHNgIG1ldGhvZCwgYnV0IGAlc2AgZG9lcyBub3QuJywgcGx1Z2luTmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTcnLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnNbcGx1Z2luSW5kZXhdID0gcGx1Z2luTW9kdWxlO1xuICAgIHZhciBwdWJsaXNoZWRFdmVudHMgPSBwbHVnaW5Nb2R1bGUuZXZlbnRUeXBlcztcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gcHVibGlzaGVkRXZlbnRzKSB7XG4gICAgICAhcHVibGlzaEV2ZW50Rm9yUGx1Z2luKHB1Ymxpc2hlZEV2ZW50c1tldmVudE5hbWVdLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQgYCVzYCBmb3IgcGx1Z2luIGAlc2AuJywgZXZlbnROYW1lLCBwbHVnaW5OYW1lKSA6IF9wcm9kSW52YXJpYW50KCc5OCcsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGFuIGV2ZW50IHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYnkgdGhlIHN1cHBsaWVkIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgRGlzcGF0Y2ggY29uZmlndXJhdGlvbiBmb3IgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hFdmVudEZvclBsdWdpbihkaXNwYXRjaENvbmZpZywgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSBldmVudCBuYW1lLCBgJXNgLicsIGV2ZW50TmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTknLCBldmVudE5hbWUpIDogdm9pZCAwO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdID0gZGlzcGF0Y2hDb25maWc7XG5cbiAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzID0gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7XG4gIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIGZvciAodmFyIHBoYXNlTmFtZSBpbiBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlTmFtZSkpIHtcbiAgICAgICAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUgPSBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZU5hbWVdO1xuICAgICAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShwaGFzZWRSZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhIHJlZ2lzdHJhdGlvbiBuYW1lIHRoYXQgaXMgdXNlZCB0byBpZGVudGlmeSBkaXNwYXRjaGVkIGV2ZW50cyBhbmRcbiAqIGNhbiBiZSB1c2VkIHdpdGggYEV2ZW50UGx1Z2luSHViLnB1dExpc3RlbmVyYCB0byByZWdpc3RlciBsaXN0ZW5lcnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgUmVnaXN0cmF0aW9uIG5hbWUgdG8gYWRkLlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShyZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAhIUV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lIHJlZ2lzdHJhdGlvbiBuYW1lLCBgJXNgLicsIHJlZ2lzdHJhdGlvbk5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzEwMCcsIHJlZ2lzdHJhdGlvbk5hbWUpIDogdm9pZCAwO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBwbHVnaW5Nb2R1bGUuZXZlbnRUeXBlc1tldmVudE5hbWVdLmRlcGVuZGVuY2llcztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IHJlZ2lzdHJhdGlvbk5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdID0gcmVnaXN0cmF0aW9uTmFtZTtcblxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25Eb3VibGVDbGljaycpIHtcbiAgICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5vbmRibGNsaWNrID0gcmVnaXN0cmF0aW9uTmFtZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgcGx1Z2lucyBzbyB0aGF0IHRoZXkgY2FuIGV4dHJhY3QgYW5kIGRpc3BhdGNoIGV2ZW50cy5cbiAqXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yn1cbiAqL1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSB7XG4gIC8qKlxuICAgKiBPcmRlcmVkIGxpc3Qgb2YgaW5qZWN0ZWQgcGx1Z2lucy5cbiAgICovXG4gIHBsdWdpbnM6IFtdLFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gZXZlbnQgbmFtZSB0byBkaXNwYXRjaCBjb25maWdcbiAgICovXG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBwbHVnaW4gbW9kdWxlXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSByZWdpc3RyYXRpb24gbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sXG4gICAqIHVzZWQgdG8gd2FybiBpbiB0aGUgY2FzZSBvZiBtaXNzaW5nIGV2ZW50IGhhbmRsZXJzLiBBdmFpbGFibGVcbiAgICogb25seSBpbiBfX0RFVl9fLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHt9IDogbnVsbCxcbiAgLy8gVHJ1c3QgdGhlIGRldmVsb3BlciB0byBvbmx5IHVzZSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIGluIF9fREVWX19cblxuICAvKipcbiAgICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICAgKiB0byBiZSBkZWNvdXBsZWQgZnJvbSBpbmplY3Rpb24gb2YgdGhlIGFjdHVhbCBwbHVnaW5zIHNvIHRoYXQgb3JkZXJpbmcgaXNcbiAgICogYWx3YXlzIGRldGVybWluaXN0aWMgcmVnYXJkbGVzcyBvZiBwYWNrYWdpbmcsIG9uLXRoZS1mbHkgaW5qZWN0aW9uLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBmdW5jdGlvbiAoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKSB7XG4gICAgISFldmVudFBsdWdpbk9yZGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiBvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiBfcHJvZEludmFyaWFudCgnMTAxJykgOiB2b2lkIDA7XG4gICAgLy8gQ2xvbmUgdGhlIG9yZGVyaW5nIHNvIGl0IGNhbm5vdCBiZSBkeW5hbWljYWxseSBtdXRhdGVkLlxuICAgIGV2ZW50UGx1Z2luT3JkZXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpO1xuICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluamVjdHMgcGx1Z2lucyB0byBiZSB1c2VkIGJ5IGBFdmVudFBsdWdpbkh1YmAuIFRoZSBwbHVnaW4gbmFtZXMgbXVzdCBiZVxuICAgKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICAgKlxuICAgKiBQbHVnaW5zIGNhbiBiZSBpbmplY3RlZCBhcyBwYXJ0IG9mIHBhZ2UgaW5pdGlhbGl6YXRpb24gb3Igb24tdGhlLWZseS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBmdW5jdGlvbiAoaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBpc09yZGVyaW5nRGlydHkgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgICAgIGlmICghaW5qZWN0ZWROYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgICAgaWYgKCFuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSB8fCBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSAhPT0gcGx1Z2luTW9kdWxlKSB7XG4gICAgICAgICEhbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCB0d28gZGlmZmVyZW50IGV2ZW50IHBsdWdpbnMgdXNpbmcgdGhlIHNhbWUgbmFtZSwgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IF9wcm9kSW52YXJpYW50KCcxMDInLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPSBwbHVnaW5Nb2R1bGU7XG4gICAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMb29rcyB1cCB0aGUgcGx1Z2luIGZvciB0aGUgc3VwcGxpZWQgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBBIHN5bnRoZXRpYyBldmVudC5cbiAgICogQHJldHVybiB7P29iamVjdH0gVGhlIHBsdWdpbiB0aGF0IGNyZWF0ZWQgdGhlIHN1cHBsaWVkIGV2ZW50LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFBsdWdpbk1vZHVsZUZvckV2ZW50OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSBldmVudC5kaXNwYXRjaENvbmZpZztcbiAgICBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgICAgcmV0dXJuIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZV0gfHwgbnVsbDtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHB1bGxpbmcgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgb3V0IG9mIGRpc3BhdGNoQ29uZmlnIGhlbHBzIEZsb3cgc2VlXG4gICAgICAvLyB0aGF0IGl0IGlzIG5vdCB1bmRlZmluZWQuXG4gICAgICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgPSBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztcblxuICAgICAgZm9yICh2YXIgcGhhc2UgaW4gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgICAgaWYgKCFwaGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1twaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZV1dO1xuICAgICAgICBpZiAocGx1Z2luTW9kdWxlKSB7XG4gICAgICAgICAgcmV0dXJuIHBsdWdpbk1vZHVsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgdW5pdCB0ZXN0aW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0RXZlbnRQbHVnaW5zOiBmdW5jdGlvbiAoKSB7XG4gICAgZXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG4gICAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgICAgaWYgKG5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zLmxlbmd0aCA9IDA7XG5cbiAgICB2YXIgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncykge1xuICAgICAgaWYgKGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xuICAgIGZvciAodmFyIHJlZ2lzdHJhdGlvbk5hbWUgaW4gcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMpIHtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShyZWdpc3RyYXRpb25OYW1lKSkge1xuICAgICAgICBkZWxldGUgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzO1xuICAgICAgZm9yICh2YXIgbG93ZXJDYXNlZE5hbWUgaW4gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgICBpZiAocG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgICAgICBkZWxldGUgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5SZWdpc3RyeTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9FdmVudFBsdWdpblJlZ2lzdHJ5LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBPQlNFUlZFRF9FUlJPUiA9IHt9O1xuXG4vKipcbiAqIGBUcmFuc2FjdGlvbmAgY3JlYXRlcyBhIGJsYWNrIGJveCB0aGF0IGlzIGFibGUgdG8gd3JhcCBhbnkgbWV0aG9kIHN1Y2ggdGhhdFxuICogY2VydGFpbiBpbnZhcmlhbnRzIGFyZSBtYWludGFpbmVkIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIG1ldGhvZCBpcyBpbnZva2VkXG4gKiAoRXZlbiBpZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIHdoaWxlIGludm9raW5nIHRoZSB3cmFwcGVkIG1ldGhvZCkuIFdob2V2ZXJcbiAqIGluc3RhbnRpYXRlcyBhIHRyYW5zYWN0aW9uIGNhbiBwcm92aWRlIGVuZm9yY2VycyBvZiB0aGUgaW52YXJpYW50cyBhdFxuICogY3JlYXRpb24gdGltZS4gVGhlIGBUcmFuc2FjdGlvbmAgY2xhc3MgaXRzZWxmIHdpbGwgc3VwcGx5IG9uZSBhZGRpdGlvbmFsXG4gKiBhdXRvbWF0aWMgaW52YXJpYW50IGZvciB5b3UgLSB0aGUgaW52YXJpYW50IHRoYXQgYW55IHRyYW5zYWN0aW9uIGluc3RhbmNlXG4gKiBzaG91bGQgbm90IGJlIHJ1biB3aGlsZSBpdCBpcyBhbHJlYWR5IGJlaW5nIHJ1bi4gWW91IHdvdWxkIHR5cGljYWxseSBjcmVhdGUgYVxuICogc2luZ2xlIGluc3RhbmNlIG9mIGEgYFRyYW5zYWN0aW9uYCBmb3IgcmV1c2UgbXVsdGlwbGUgdGltZXMsIHRoYXQgcG90ZW50aWFsbHlcbiAqIGlzIHVzZWQgdG8gd3JhcCBzZXZlcmFsIGRpZmZlcmVudCBtZXRob2RzLiBXcmFwcGVycyBhcmUgZXh0cmVtZWx5IHNpbXBsZSAtXG4gKiB0aGV5IG9ubHkgcmVxdWlyZSBpbXBsZW1lbnRpbmcgdHdvIG1ldGhvZHMuXG4gKlxuICogPHByZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVycyAoaW5qZWN0ZWQgYXQgY3JlYXRpb24gdGltZSlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICAgICAgICArXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLXwtLS0tLS0tLS0tLS0tLStcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICB2ICAgICAgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICAgICstLS0tLS0tLS0tLS0tLS0rICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICArLS18ICAgIHdyYXBwZXIxICAgfC0tLXwtLS0tKyAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgKy0tLS0tLS0tLS0tLS0tLSsgICB2ICAgIHwgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgICAgICAgKy0tLS0tLS0tLS0tLS0rICB8ICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICArLS0tLXwgICB3cmFwcGVyMiAgfC0tLS0tLS0tKyAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgfCAgICArLS0tLS0tLS0tLS0tLSsgIHwgICAgIHwgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgIHwgICAgICAgICAgICAgICAgICAgICB8ICAgICB8ICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB2ICAgICB2ICAgICAgICAgICAgICAgICAgICAgdiAgICAgdiAgIHwgd3JhcHBlclxuICogICAgICAgICAgICAgICAgICAgIHwgKy0tLSsgKy0tLSsgICArLS0tLS0tLS0tKyAgICstLS0rICstLS0rIHwgaW52YXJpYW50c1xuICogcGVyZm9ybShhbnlNZXRob2QpIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHwgbWFpbnRhaW5lZFxuICogKy0tLS0tLS0tLS0tLS0tLS0tPnwtfC0tLXwtfC0tLXwtLT58YW55TWV0aG9kfC0tLXwtLS18LXwtLS18LXwtLS0tLS0tLT5cbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICstLS0rICstLS0rICAgKy0tLS0tLS0tLSsgICArLS0tKyArLS0tKyB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgaW5pdGlhbGl6ZSAgICAgICAgICAgICAgICAgICAgY2xvc2UgICAgfFxuICogICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAqIDwvcHJlPlxuICpcbiAqIFVzZSBjYXNlczpcbiAqIC0gUHJlc2VydmluZyB0aGUgaW5wdXQgc2VsZWN0aW9uIHJhbmdlcyBiZWZvcmUvYWZ0ZXIgcmVjb25jaWxpYXRpb24uXG4gKiAgIFJlc3RvcmluZyBzZWxlY3Rpb24gZXZlbiBpbiB0aGUgZXZlbnQgb2YgYW4gdW5leHBlY3RlZCBlcnJvci5cbiAqIC0gRGVhY3RpdmF0aW5nIGV2ZW50cyB3aGlsZSByZWFycmFuZ2luZyB0aGUgRE9NLCBwcmV2ZW50aW5nIGJsdXJzL2ZvY3VzZXMsXG4gKiAgIHdoaWxlIGd1YXJhbnRlZWluZyB0aGF0IGFmdGVyd2FyZHMsIHRoZSBldmVudCBzeXN0ZW0gaXMgcmVhY3RpdmF0ZWQuXG4gKiAtIEZsdXNoaW5nIGEgcXVldWUgb2YgY29sbGVjdGVkIERPTSBtdXRhdGlvbnMgdG8gdGhlIG1haW4gVUkgdGhyZWFkIGFmdGVyIGFcbiAqICAgcmVjb25jaWxpYXRpb24gdGFrZXMgcGxhY2UgaW4gYSB3b3JrZXIgdGhyZWFkLlxuICogLSBJbnZva2luZyBhbnkgY29sbGVjdGVkIGBjb21wb25lbnREaWRVcGRhdGVgIGNhbGxiYWNrcyBhZnRlciByZW5kZXJpbmcgbmV3XG4gKiAgIGNvbnRlbnQuXG4gKiAtIChGdXR1cmUgdXNlIGNhc2UpOiBXcmFwcGluZyBwYXJ0aWN1bGFyIGZsdXNoZXMgb2YgdGhlIGBSZWFjdFdvcmtlcmAgcXVldWVcbiAqICAgdG8gcHJlc2VydmUgdGhlIGBzY3JvbGxUb3BgIChhbiBhdXRvbWF0aWMgc2Nyb2xsIGF3YXJlIERPTSkuXG4gKiAtIChGdXR1cmUgdXNlIGNhc2UpOiBMYXlvdXQgY2FsY3VsYXRpb25zIGJlZm9yZSBhbmQgYWZ0ZXIgRE9NIHVwZGF0ZXMuXG4gKlxuICogVHJhbnNhY3Rpb25hbCBwbHVnaW4gQVBJOlxuICogLSBBIG1vZHVsZSB0aGF0IGhhcyBhbiBgaW5pdGlhbGl6ZWAgbWV0aG9kIHRoYXQgcmV0dXJucyBhbnkgcHJlY29tcHV0YXRpb24uXG4gKiAtIGFuZCBhIGBjbG9zZWAgbWV0aG9kIHRoYXQgYWNjZXB0cyB0aGUgcHJlY29tcHV0YXRpb24uIGBjbG9zZWAgaXMgaW52b2tlZFxuICogICB3aGVuIHRoZSB3cmFwcGVkIHByb2Nlc3MgaXMgY29tcGxldGVkLCBvciBoYXMgZmFpbGVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8VHJhbnNhY3Rpb25hbFdyYXBwZXI+fSB0cmFuc2FjdGlvbldyYXBwZXIgV3JhcHBlciBtb2R1bGVzXG4gKiB0aGF0IGltcGxlbWVudCBgaW5pdGlhbGl6ZWAgYW5kIGBjbG9zZWAuXG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn0gU2luZ2xlIHRyYW5zYWN0aW9uIGZvciByZXVzZSBpbiB0aHJlYWQuXG4gKlxuICogQGNsYXNzIFRyYW5zYWN0aW9uXG4gKi9cbnZhciBUcmFuc2FjdGlvbkltcGwgPSB7XG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoaXMgaW5zdGFuY2Ugc28gdGhhdCBpdCBpcyBwcmVwYXJlZCBmb3IgY29sbGVjdGluZyBtZXRyaWNzLiBEb2VzXG4gICAqIHNvIHN1Y2ggdGhhdCB0aGlzIHNldHVwIG1ldGhvZCBtYXkgYmUgdXNlZCBvbiBhbiBpbnN0YW5jZSB0aGF0IGlzIGFscmVhZHlcbiAgICogaW5pdGlhbGl6ZWQsIGluIGEgd2F5IHRoYXQgZG9lcyBub3QgY29uc3VtZSBhZGRpdGlvbmFsIG1lbW9yeSB1cG9uIHJldXNlLlxuICAgKiBUaGF0IGNhbiBiZSB1c2VmdWwgaWYgeW91IGRlY2lkZSB0byBtYWtlIHlvdXIgc3ViY2xhc3Mgb2YgdGhpcyBtaXhpbiBhXG4gICAqIFwiUG9vbGVkQ2xhc3NcIi5cbiAgICovXG4gIHJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy5nZXRUcmFuc2FjdGlvbldyYXBwZXJzKCk7XG4gICAgaWYgKHRoaXMud3JhcHBlckluaXREYXRhKSB7XG4gICAgICB0aGlzLndyYXBwZXJJbml0RGF0YS5sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndyYXBwZXJJbml0RGF0YSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgfSxcblxuICBfaXNJblRyYW5zYWN0aW9uOiBmYWxzZSxcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge0FycmF5PFRyYW5zYWN0aW9uV3JhcHBlcj59IEFycmF5IG9mIHRyYW5zYWN0aW9uIHdyYXBwZXJzLlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogbnVsbCxcblxuICBpc0luVHJhbnNhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9pc0luVHJhbnNhY3Rpb247XG4gIH0sXG5cbiAgLyogZXNsaW50LWRpc2FibGUgc3BhY2UtYmVmb3JlLWZ1bmN0aW9uLXBhcmVuICovXG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHRoZSBmdW5jdGlvbiB3aXRoaW4gYSBzYWZldHkgd2luZG93LiBVc2UgdGhpcyBmb3IgdGhlIHRvcCBsZXZlbFxuICAgKiBtZXRob2RzIHRoYXQgcmVzdWx0IGluIGxhcmdlIGFtb3VudHMgb2YgY29tcHV0YXRpb24vbXV0YXRpb25zIHRoYXQgd291bGRcbiAgICogbmVlZCB0byBiZSBzYWZldHkgY2hlY2tlZC4gVGhlIG9wdGlvbmFsIGFyZ3VtZW50cyBoZWxwcyBwcmV2ZW50IHRoZSBuZWVkXG4gICAqIHRvIGJpbmQgaW4gbWFueSBjYXNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIE1lbWJlciBvZiBzY29wZSB0byBjYWxsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgU2NvcGUgdG8gaW52b2tlIGZyb20uXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGEgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBiIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYyBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGQgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBlIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZiBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqXG4gICAqIEByZXR1cm4geyp9IFJldHVybiB2YWx1ZSBmcm9tIGBtZXRob2RgLlxuICAgKi9cbiAgcGVyZm9ybTogZnVuY3Rpb24gKG1ldGhvZCwgc2NvcGUsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIHNwYWNlLWJlZm9yZS1mdW5jdGlvbi1wYXJlbiAqL1xuICAgICEhdGhpcy5pc0luVHJhbnNhY3Rpb24oKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUcmFuc2FjdGlvbi5wZXJmb3JtKC4uLik6IENhbm5vdCBpbml0aWFsaXplIGEgdHJhbnNhY3Rpb24gd2hlbiB0aGVyZSBpcyBhbHJlYWR5IGFuIG91dHN0YW5kaW5nIHRyYW5zYWN0aW9uLicpIDogX3Byb2RJbnZhcmlhbnQoJzI3JykgOiB2b2lkIDA7XG4gICAgdmFyIGVycm9yVGhyb3duO1xuICAgIHZhciByZXQ7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IHRydWU7XG4gICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoXG4gICAgICAvLyBlcnJvclRocm93biBzZXQgdG8gdHJ1ZSBiZWZvcmUgc2V0dGluZyBpdCB0byBmYWxzZSBhZnRlciBjYWxsaW5nXG4gICAgICAvLyBjbG9zZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byB0cnVlIGluIHRoZSBmaW5hbGx5IGJsb2NrLCBpdCBtZWFuc1xuICAgICAgLy8gb25lIG9mIHRoZXNlIGNhbGxzIHRocmV3LlxuICAgICAgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgdGhpcy5pbml0aWFsaXplQWxsKDApO1xuICAgICAgcmV0ID0gbWV0aG9kLmNhbGwoc2NvcGUsIGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgLy8gSWYgYG1ldGhvZGAgdGhyb3dzLCBwcmVmZXIgdG8gc2hvdyB0aGF0IHN0YWNrIHRyYWNlIG92ZXIgYW55IHRocm93blxuICAgICAgICAgIC8vIGJ5IGludm9raW5nIGBjbG9zZUFsbGAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VBbGwoMCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNpbmNlIGBtZXRob2RgIGRpZG4ndCB0aHJvdywgd2UgZG9uJ3Qgd2FudCB0byBzaWxlbmNlIHRoZSBleGNlcHRpb25cbiAgICAgICAgICAvLyBoZXJlLlxuICAgICAgICAgIHRoaXMuY2xvc2VBbGwoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIGluaXRpYWxpemVBbGw6IGZ1bmN0aW9uIChzdGFydEluZGV4KSB7XG4gICAgdmFyIHRyYW5zYWN0aW9uV3JhcHBlcnMgPSB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnM7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCB0cmFuc2FjdGlvbldyYXBwZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IHRyYW5zYWN0aW9uV3JhcHBlcnNbaV07XG4gICAgICB0cnkge1xuICAgICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoIHRoZVxuICAgICAgICAvLyBPQlNFUlZFRF9FUlJPUiBzdGF0ZSBiZWZvcmUgb3ZlcndyaXRpbmcgaXQgd2l0aCB0aGUgcmVhbCByZXR1cm4gdmFsdWVcbiAgICAgICAgLy8gb2YgaW5pdGlhbGl6ZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byBPQlNFUlZFRF9FUlJPUiBpbiB0aGUgZmluYWxseVxuICAgICAgICAvLyBibG9jaywgaXQgbWVhbnMgd3JhcHBlci5pbml0aWFsaXplIHRocmV3LlxuICAgICAgICB0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9IE9CU0VSVkVEX0VSUk9SO1xuICAgICAgICB0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9IHdyYXBwZXIuaW5pdGlhbGl6ZSA/IHdyYXBwZXIuaW5pdGlhbGl6ZS5jYWxsKHRoaXMpIDogbnVsbDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9PT0gT0JTRVJWRURfRVJST1IpIHtcbiAgICAgICAgICAvLyBUaGUgaW5pdGlhbGl6ZXIgZm9yIHdyYXBwZXIgaSB0aHJldyBhbiBlcnJvcjsgaW5pdGlhbGl6ZSB0aGVcbiAgICAgICAgICAvLyByZW1haW5pbmcgd3JhcHBlcnMgYnV0IHNpbGVuY2UgYW55IGV4Y2VwdGlvbnMgZnJvbSB0aGVtIHRvIGVuc3VyZVxuICAgICAgICAgIC8vIHRoYXQgdGhlIGZpcnN0IGVycm9yIGlzIHRoZSBvbmUgdG8gYnViYmxlIHVwLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVBbGwoaSArIDEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlcyBlYWNoIG9mIGB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMuY2xvc2VbaV1gIGZ1bmN0aW9ucywgcGFzc2luZyBpbnRvXG4gICAqIHRoZW0gdGhlIHJlc3BlY3RpdmUgcmV0dXJuIHZhbHVlcyBvZiBgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzLmluaXRbaV1gXG4gICAqIChgY2xvc2VgcnMgdGhhdCBjb3JyZXNwb25kIHRvIGluaXRpYWxpemVycyB0aGF0IGZhaWxlZCB3aWxsIG5vdCBiZVxuICAgKiBpbnZva2VkKS5cbiAgICovXG4gIGNsb3NlQWxsOiBmdW5jdGlvbiAoc3RhcnRJbmRleCkge1xuICAgICF0aGlzLmlzSW5UcmFuc2FjdGlvbigpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyYW5zYWN0aW9uLmNsb3NlQWxsKCk6IENhbm5vdCBjbG9zZSB0cmFuc2FjdGlvbiB3aGVuIG5vbmUgYXJlIG9wZW4uJykgOiBfcHJvZEludmFyaWFudCgnMjgnKSA6IHZvaWQgMDtcbiAgICB2YXIgdHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycztcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IHRyYW5zYWN0aW9uV3JhcHBlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3cmFwcGVyID0gdHJhbnNhY3Rpb25XcmFwcGVyc1tpXTtcbiAgICAgIHZhciBpbml0RGF0YSA9IHRoaXMud3JhcHBlckluaXREYXRhW2ldO1xuICAgICAgdmFyIGVycm9yVGhyb3duO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aFxuICAgICAgICAvLyBlcnJvclRocm93biBzZXQgdG8gdHJ1ZSBiZWZvcmUgc2V0dGluZyBpdCB0byBmYWxzZSBhZnRlciBjYWxsaW5nXG4gICAgICAgIC8vIGNsb3NlIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIHRydWUgaW4gdGhlIGZpbmFsbHkgYmxvY2ssIGl0IG1lYW5zXG4gICAgICAgIC8vIHdyYXBwZXIuY2xvc2UgdGhyZXcuXG4gICAgICAgIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgaWYgKGluaXREYXRhICE9PSBPQlNFUlZFRF9FUlJPUiAmJiB3cmFwcGVyLmNsb3NlKSB7XG4gICAgICAgICAgd3JhcHBlci5jbG9zZS5jYWxsKHRoaXMsIGluaXREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgLy8gVGhlIGNsb3NlciBmb3Igd3JhcHBlciBpIHRocmV3IGFuIGVycm9yOyBjbG9zZSB0aGUgcmVtYWluaW5nXG4gICAgICAgICAgLy8gd3JhcHBlcnMgYnV0IHNpbGVuY2UgYW55IGV4Y2VwdGlvbnMgZnJvbSB0aGVtIHRvIGVuc3VyZSB0aGF0IHRoZVxuICAgICAgICAgIC8vIGZpcnN0IGVycm9yIGlzIHRoZSBvbmUgdG8gYnViYmxlIHVwLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQWxsKGkgKyAxKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMud3JhcHBlckluaXREYXRhLmxlbmd0aCA9IDA7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNhY3Rpb25JbXBsO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1RyYW5zYWN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcbnZhciBWaWV3cG9ydE1ldHJpY3MgPSByZXF1aXJlKCcuL1ZpZXdwb3J0TWV0cmljcycpO1xuXG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZSgnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIE1vdXNlRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgTW91c2VFdmVudEludGVyZmFjZSA9IHtcbiAgc2NyZWVuWDogbnVsbCxcbiAgc2NyZWVuWTogbnVsbCxcbiAgY2xpZW50WDogbnVsbCxcbiAgY2xpZW50WTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICBidXR0b246IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIFdlYmtpdCwgRmlyZWZveCwgSUU5K1xuICAgIC8vIHdoaWNoOiAgMSAyIDNcbiAgICAvLyBidXR0b246IDAgMSAyIChzdGFuZGFyZClcbiAgICB2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuICAgIGlmICgnd2hpY2gnIGluIGV2ZW50KSB7XG4gICAgICByZXR1cm4gYnV0dG9uO1xuICAgIH1cbiAgICAvLyBJRTw5XG4gICAgLy8gd2hpY2g6ICB1bmRlZmluZWRcbiAgICAvLyBidXR0b246IDAgMCAwXG4gICAgLy8gYnV0dG9uOiAxIDQgMiAob25tb3VzZXVwKVxuICAgIHJldHVybiBidXR0b24gPT09IDIgPyAyIDogYnV0dG9uID09PSA0ID8gMSA6IDA7XG4gIH0sXG4gIGJ1dHRvbnM6IG51bGwsXG4gIHJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IChldmVudC5mcm9tRWxlbWVudCA9PT0gZXZlbnQuc3JjRWxlbWVudCA/IGV2ZW50LnRvRWxlbWVudCA6IGV2ZW50LmZyb21FbGVtZW50KTtcbiAgfSxcbiAgLy8gXCJQcm9wcmlldGFyeVwiIEludGVyZmFjZS5cbiAgcGFnZVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAncGFnZVgnIGluIGV2ZW50ID8gZXZlbnQucGFnZVggOiBldmVudC5jbGllbnRYICsgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxMZWZ0O1xuICB9LFxuICBwYWdlWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdwYWdlWScgaW4gZXZlbnQgPyBldmVudC5wYWdlWSA6IGV2ZW50LmNsaWVudFkgKyBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbFRvcDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljTW91c2VFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljTW91c2VFdmVudCwgTW91c2VFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljTW91c2VFdmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNNb3VzZUV2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBET01OYW1lc3BhY2VzID0gcmVxdWlyZSgnLi9ET01OYW1lc3BhY2VzJyk7XG5cbnZhciBXSElURVNQQUNFX1RFU1QgPSAvXlsgXFxyXFxuXFx0XFxmXS87XG52YXIgTk9OVklTSUJMRV9URVNUID0gLzwoIS0tfGxpbmt8bm9zY3JpcHR8bWV0YXxzY3JpcHR8c3R5bGUpWyBcXHJcXG5cXHRcXGZcXC8+XS87XG5cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9jcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uJyk7XG5cbi8vIFNWRyB0ZW1wIGNvbnRhaW5lciBmb3IgSUUgbGFja2luZyBpbm5lckhUTUxcbnZhciByZXVzYWJsZVNWR0NvbnRhaW5lcjtcblxuLyoqXG4gKiBTZXQgdGhlIGlubmVySFRNTCBwcm9wZXJ0eSBvZiBhIG5vZGUsIGVuc3VyaW5nIHRoYXQgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWRcbiAqIGV2ZW4gaW4gSUU4LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0SW5uZXJIVE1MID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xuICAvLyBJRSBkb2VzIG5vdCBoYXZlIGlubmVySFRNTCBmb3IgU1ZHIG5vZGVzLCBzbyBpbnN0ZWFkIHdlIGluamVjdCB0aGVcbiAgLy8gbmV3IG1hcmt1cCBpbiBhIHRlbXAgbm9kZSBhbmQgdGhlbiBtb3ZlIHRoZSBjaGlsZCBub2RlcyBhY3Jvc3MgaW50b1xuICAvLyB0aGUgdGFyZ2V0IG5vZGVcbiAgaWYgKG5vZGUubmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLnN2ZyAmJiAhKCdpbm5lckhUTUwnIGluIG5vZGUpKSB7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIgPSByZXVzYWJsZVNWR0NvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZXVzYWJsZVNWR0NvbnRhaW5lci5pbm5lckhUTUwgPSAnPHN2Zz4nICsgaHRtbCArICc8L3N2Zz4nO1xuICAgIHZhciBzdmdOb2RlID0gcmV1c2FibGVTVkdDb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoc3ZnTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHN2Z05vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgfVxufSk7XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU4OiBXaGVuIHVwZGF0aW5nIGEganVzdCBjcmVhdGVkIG5vZGUgd2l0aCBpbm5lckhUTUwgb25seSBsZWFkaW5nXG4gIC8vIHdoaXRlc3BhY2UgaXMgcmVtb3ZlZC4gV2hlbiB1cGRhdGluZyBhbiBleGlzdGluZyBub2RlIHdpdGggaW5uZXJIVE1MXG4gIC8vIHdoaXRlc3BhY2UgaW4gcm9vdCBUZXh0Tm9kZXMgaXMgYWxzbyBjb2xsYXBzZWQuXG4gIC8vIEBzZWUgcXVpcmtzbW9kZS5vcmcvYnVncmVwb3J0cy9hcmNoaXZlcy8yMDA0LzExL2lubmVyaHRtbF9hbmRfdC5odG1sXG5cbiAgLy8gRmVhdHVyZSBkZXRlY3Rpb247IG9ubHkgSUU4IGlzIGtub3duIHRvIGJlaGF2ZSBpbXByb3Blcmx5IGxpa2UgdGhpcy5cbiAgdmFyIHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRlc3RFbGVtZW50LmlubmVySFRNTCA9ICcgJztcbiAgaWYgKHRlc3RFbGVtZW50LmlubmVySFRNTCA9PT0gJycpIHtcbiAgICBzZXRJbm5lckhUTUwgPSBmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xuICAgICAgLy8gTWFnaWMgdGhlb3J5OiBJRTggc3VwcG9zZWRseSBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIGFkZGVkIGFuZCB1cGRhdGVkXG4gICAgICAvLyBub2RlcyB3aGVuIHByb2Nlc3NpbmcgaW5uZXJIVE1MLCBpbm5lckhUTUwgb24gdXBkYXRlZCBub2RlcyBzdWZmZXJzXG4gICAgICAvLyBmcm9tIHdvcnNlIHdoaXRlc3BhY2UgYmVoYXZpb3IuIFJlLWFkZGluZyBhIG5vZGUgbGlrZSB0aGlzIHRyaWdnZXJzXG4gICAgICAvLyB0aGUgaW5pdGlhbCBhbmQgbW9yZSBmYXZvcmFibGUgd2hpdGVzcGFjZSBiZWhhdmlvci5cbiAgICAgIC8vIFRPRE86IFdoYXQgdG8gZG8gb24gYSBkZXRhY2hlZCBub2RlP1xuICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5vZGUsIG5vZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBhbHNvIGltcGxlbWVudCBhIHdvcmthcm91bmQgZm9yIG5vbi12aXNpYmxlIHRhZ3MgZGlzYXBwZWFyaW5nIGludG9cbiAgICAgIC8vIHRoaW4gYWlyIG9uIElFOCwgdGhpcyBvbmx5IGhhcHBlbnMgaWYgdGhlcmUgaXMgbm8gdmlzaWJsZSB0ZXh0XG4gICAgICAvLyBpbi1mcm9udCBvZiB0aGUgbm9uLXZpc2libGUgdGFncy4gUGlnZ3liYWNrIG9uIHRoZSB3aGl0ZXNwYWNlIGZpeFxuICAgICAgLy8gYW5kIHNpbXBseSBjaGVjayBpZiBhbnkgbm9uLXZpc2libGUgdGFncyBhcHBlYXIgaW4gdGhlIHNvdXJjZS5cbiAgICAgIGlmIChXSElURVNQQUNFX1RFU1QudGVzdChodG1sKSB8fCBodG1sWzBdID09PSAnPCcgJiYgTk9OVklTSUJMRV9URVNULnRlc3QoaHRtbCkpIHtcbiAgICAgICAgLy8gUmVjb3ZlciBsZWFkaW5nIHdoaXRlc3BhY2UgYnkgdGVtcG9yYXJpbHkgcHJlcGVuZGluZyBhbnkgY2hhcmFjdGVyLlxuICAgICAgICAvLyBcXHVGRUZGIGhhcyB0aGUgcG90ZW50aWFsIGFkdmFudGFnZSBvZiBiZWluZyB6ZXJvLXdpZHRoL2ludmlzaWJsZS5cbiAgICAgICAgLy8gVWdsaWZ5SlMgZHJvcHMgVStGRUZGIGNoYXJzIHdoZW4gcGFyc2luZywgc28gdXNlIFN0cmluZy5mcm9tQ2hhckNvZGVcbiAgICAgICAgLy8gaW4gaG9wZXMgdGhhdCB0aGlzIGlzIHByZXNlcnZlZCBldmVuIGlmIFwiXFx1RkVGRlwiIGlzIHRyYW5zZm9ybWVkIHRvXG4gICAgICAgIC8vIHRoZSBhY3R1YWwgVW5pY29kZSBjaGFyYWN0ZXIgKGJ5IEJhYmVsLCBmb3IgZXhhbXBsZSkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyL2Jsb2IvdjIuNC4yMC9saWIvcGFyc2UuanMjTDIxNlxuICAgICAgICBub2RlLmlubmVySFRNTCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhmZWZmKSArIGh0bWw7XG5cbiAgICAgICAgLy8gZGVsZXRlRGF0YSBsZWF2ZXMgYW4gZW1wdHkgYFRleHROb2RlYCB3aGljaCBvZmZzZXRzIHRoZSBpbmRleCBvZiBhbGxcbiAgICAgICAgLy8gY2hpbGRyZW4uIERlZmluaXRlbHkgd2FudCB0byBhdm9pZCB0aGlzLlxuICAgICAgICB2YXIgdGV4dE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICh0ZXh0Tm9kZS5kYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQodGV4dE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHROb2RlLmRlbGV0ZURhdGEoMCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRlc3RFbGVtZW50ID0gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRJbm5lckhUTUw7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvc2V0SW5uZXJIVE1MLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQmFzZWQgb24gdGhlIGVzY2FwZS1odG1sIGxpYnJhcnksIHdoaWNoIGlzIHVzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIGJlbG93OlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDEzIFRKIEhvbG93YXljaHVrXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQW5kcmVhcyBMdWJiZVxuICogQ29weXJpZ2h0IChjKSAyMDE1IFRpYW5jaGVuZyBcIlRpbW90aHlcIiBHdVxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4gKiAnU29mdHdhcmUnKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbiAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuICogdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxuICogSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcbiAqIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsXG4gKiBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRVxuICogU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gY29kZSBjb3BpZWQgYW5kIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWxcbi8qKlxuICogTW9kdWxlIHZhcmlhYmxlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIG1hdGNoSHRtbFJlZ0V4cCA9IC9bXCInJjw+XS87XG5cbi8qKlxuICogRXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyBpbiB0aGUgZ2l2ZW4gc3RyaW5nIG9mIGh0bWwuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBlc2NhcGUgZm9yIGluc2VydGluZyBpbnRvIEhUTUxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xuICB2YXIgc3RyID0gJycgKyBzdHJpbmc7XG4gIHZhciBtYXRjaCA9IG1hdGNoSHRtbFJlZ0V4cC5leGVjKHN0cik7XG5cbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICB2YXIgZXNjYXBlO1xuICB2YXIgaHRtbCA9ICcnO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEluZGV4ID0gMDtcblxuICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICBjYXNlIDM0OlxuICAgICAgICAvLyBcIlxuICAgICAgICBlc2NhcGUgPSAnJnF1b3Q7JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM4OlxuICAgICAgICAvLyAmXG4gICAgICAgIGVzY2FwZSA9ICcmYW1wOyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOTpcbiAgICAgICAgLy8gJ1xuICAgICAgICBlc2NhcGUgPSAnJiN4Mjc7JzsgLy8gbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbDsgdXNlZCB0byBiZSAnJiMzOSdcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDYwOlxuICAgICAgICAvLyA8XG4gICAgICAgIGVzY2FwZSA9ICcmbHQ7JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDYyOlxuICAgICAgICAvLyA+XG4gICAgICAgIGVzY2FwZSA9ICcmZ3Q7JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgaHRtbCArPSBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICBodG1sICs9IGVzY2FwZTtcbiAgfVxuXG4gIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xufVxuLy8gZW5kIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHRleHQgPT09ICdudW1iZXInKSB7XG4gICAgLy8gdGhpcyBzaG9ydGNpcmN1aXQgaGVscHMgcGVyZiBmb3IgdHlwZXMgdGhhdCB3ZSBrbm93IHdpbGwgbmV2ZXIgaGF2ZVxuICAgIC8vIHNwZWNpYWwgY2hhcmFjdGVycywgZXNwZWNpYWxseSBnaXZlbiB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBvZnRlblxuICAgIC8vIGZvciBudW1lcmljIGRvbSBpZHMuXG4gICAgcmV0dXJuICcnICsgdGV4dDtcbiAgfVxuICByZXR1cm4gZXNjYXBlSHRtbCh0ZXh0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiA9IHJlcXVpcmUoJy4vUmVhY3RFdmVudEVtaXR0ZXJNaXhpbicpO1xudmFyIFZpZXdwb3J0TWV0cmljcyA9IHJlcXVpcmUoJy4vVmlld3BvcnRNZXRyaWNzJyk7XG5cbnZhciBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSA9IHJlcXVpcmUoJy4vZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUnKTtcbnZhciBpc0V2ZW50U3VwcG9ydGVkID0gcmVxdWlyZSgnLi9pc0V2ZW50U3VwcG9ydGVkJyk7XG5cbi8qKlxuICogU3VtbWFyeSBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBldmVudCBoYW5kbGluZzpcbiAqXG4gKiAgLSBUb3AtbGV2ZWwgZGVsZWdhdGlvbiBpcyB1c2VkIHRvIHRyYXAgbW9zdCBuYXRpdmUgYnJvd3NlciBldmVudHMuIFRoaXNcbiAqICAgIG1heSBvbmx5IG9jY3VyIGluIHRoZSBtYWluIHRocmVhZCBhbmQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mXG4gKiAgICBSZWFjdEV2ZW50TGlzdGVuZXIsIHdoaWNoIGlzIGluamVjdGVkIGFuZCBjYW4gdGhlcmVmb3JlIHN1cHBvcnQgcGx1Z2dhYmxlXG4gKiAgICBldmVudCBzb3VyY2VzLiBUaGlzIGlzIHRoZSBvbmx5IHdvcmsgdGhhdCBvY2N1cnMgaW4gdGhlIG1haW4gdGhyZWFkLlxuICpcbiAqICAtIFdlIG5vcm1hbGl6ZSBhbmQgZGUtZHVwbGljYXRlIGV2ZW50cyB0byBhY2NvdW50IGZvciBicm93c2VyIHF1aXJrcy4gVGhpc1xuICogICAgbWF5IGJlIGRvbmUgaW4gdGhlIHdvcmtlciB0aHJlYWQuXG4gKlxuICogIC0gRm9yd2FyZCB0aGVzZSBuYXRpdmUgZXZlbnRzICh3aXRoIHRoZSBhc3NvY2lhdGVkIHRvcC1sZXZlbCB0eXBlIHVzZWQgdG9cbiAqICAgIHRyYXAgaXQpIHRvIGBFdmVudFBsdWdpbkh1YmAsIHdoaWNoIGluIHR1cm4gd2lsbCBhc2sgcGx1Z2lucyBpZiB0aGV5IHdhbnRcbiAqICAgIHRvIGV4dHJhY3QgYW55IHN5bnRoZXRpYyBldmVudHMuXG4gKlxuICogIC0gVGhlIGBFdmVudFBsdWdpbkh1YmAgd2lsbCB0aGVuIHByb2Nlc3MgZWFjaCBldmVudCBieSBhbm5vdGF0aW5nIHRoZW0gd2l0aFxuICogICAgXCJkaXNwYXRjaGVzXCIsIGEgc2VxdWVuY2Ugb2YgbGlzdGVuZXJzIGFuZCBJRHMgdGhhdCBjYXJlIGFib3V0IHRoYXQgZXZlbnQuXG4gKlxuICogIC0gVGhlIGBFdmVudFBsdWdpbkh1YmAgdGhlbiBkaXNwYXRjaGVzIHRoZSBldmVudHMuXG4gKlxuICogT3ZlcnZpZXcgb2YgUmVhY3QgYW5kIHRoZSBldmVudCBzeXN0ZW06XG4gKlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogfCAgICBET00gICAgIHwgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogICAgICAgfCAgICAgICAgICAgLlxuICogICAgICAgdiAgICAgICAgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogfCBSZWFjdEV2ZW50IHwgICAgLlxuICogfCAgTGlzdGVuZXIgIHwgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgKy0tLS0tLS0tK3xTaW1wbGVFdmVudHxcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICB8ICAgICAgICAgfFBsdWdpbiAgICAgfFxuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgIHYgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8ICAgICB8ICAgICAgfCAgICAuICAgICstLS0tLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG4gKiB8ICAgICArLS0tLS0tLS0tLS0uLS0tPnxFdmVudFBsdWdpbkh1YnwgICAgICAgICAgICAgICAgICAgIHwgICAgRXZlbnQgICB8XG4gKiB8ICAgICAgICAgICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLSsgIHwgUHJvcGFnYXRvcnN8XG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgIHxUYXBFdmVudCAgIHwgIHwtLS0tLS0tLS0tLS18XG4gKiB8ICBFbWl0dGVyICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHw8LS0tK3xQbHVnaW4gICAgIHwgIHxvdGhlciBwbHVnaW58XG4gKiB8ICAgICAgICAgICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLSsgIHwgIHV0aWxpdGllcyB8XG4gKiB8ICAgICArLS0tLS0tLS0tLS0uLS0tPnwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG4gKiB8ICAgICB8ICAgICAgfCAgICAuICAgICstLS0tLS0tLS0tLS0tLStcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgXiAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICB8ICAgICAgICB8RW50ZXIvTGVhdmV8XG4gKiAgICAgICArICAgICAgICAgICAuICAgICAgICAgICAgICAgICstLS0tLS0tK3xQbHVnaW4gICAgIHxcbiAqICstLS0tLS0tLS0tLS0tKyAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCBhcHBsaWNhdGlvbiB8ICAgLlxuICogfC0tLS0tLS0tLS0tLS18ICAgLlxuICogfCAgICAgICAgICAgICB8ICAgLlxuICogfCAgICAgICAgICAgICB8ICAgLlxuICogKy0tLS0tLS0tLS0tLS0rICAgLlxuICogICAgICAgICAgICAgICAgICAgLlxuICogICAgUmVhY3QgQ29yZSAgICAgLiAgR2VuZXJhbCBQdXJwb3NlIEV2ZW50IFBsdWdpbiBTeXN0ZW1cbiAqL1xuXG52YXIgaGFzRXZlbnRQYWdlWFk7XG52YXIgYWxyZWFkeUxpc3RlbmluZ1RvID0ge307XG52YXIgaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUgPSBmYWxzZTtcbnZhciByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIgPSAwO1xuXG4vLyBGb3IgZXZlbnRzIGxpa2UgJ3N1Ym1pdCcgd2hpY2ggZG9uJ3QgY29uc2lzdGVudGx5IGJ1YmJsZSAod2hpY2ggd2UgdHJhcCBhdCBhXG4vLyBsb3dlciBub2RlIHRoYW4gYGRvY3VtZW50YCksIGJpbmRpbmcgYXQgYGRvY3VtZW50YCB3b3VsZCBjYXVzZSBkdXBsaWNhdGVcbi8vIGV2ZW50cyBzbyB3ZSBkb24ndCBpbmNsdWRlIHRoZW0gaGVyZVxudmFyIHRvcEV2ZW50TWFwcGluZyA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcEFuaW1hdGlvbkVuZDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbmVuZCcpIHx8ICdhbmltYXRpb25lbmQnLFxuICB0b3BBbmltYXRpb25JdGVyYXRpb246IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25pdGVyYXRpb24nKSB8fCAnYW5pbWF0aW9uaXRlcmF0aW9uJyxcbiAgdG9wQW5pbWF0aW9uU3RhcnQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25zdGFydCcpIHx8ICdhbmltYXRpb25zdGFydCcsXG4gIHRvcEJsdXI6ICdibHVyJyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wQ2hhbmdlOiAnY2hhbmdlJyxcbiAgdG9wQ2xpY2s6ICdjbGljaycsXG4gIHRvcENvbXBvc2l0aW9uRW5kOiAnY29tcG9zaXRpb25lbmQnLFxuICB0b3BDb21wb3NpdGlvblN0YXJ0OiAnY29tcG9zaXRpb25zdGFydCcsXG4gIHRvcENvbXBvc2l0aW9uVXBkYXRlOiAnY29tcG9zaXRpb251cGRhdGUnLFxuICB0b3BDb250ZXh0TWVudTogJ2NvbnRleHRtZW51JyxcbiAgdG9wQ29weTogJ2NvcHknLFxuICB0b3BDdXQ6ICdjdXQnLFxuICB0b3BEb3VibGVDbGljazogJ2RibGNsaWNrJyxcbiAgdG9wRHJhZzogJ2RyYWcnLFxuICB0b3BEcmFnRW5kOiAnZHJhZ2VuZCcsXG4gIHRvcERyYWdFbnRlcjogJ2RyYWdlbnRlcicsXG4gIHRvcERyYWdFeGl0OiAnZHJhZ2V4aXQnLFxuICB0b3BEcmFnTGVhdmU6ICdkcmFnbGVhdmUnLFxuICB0b3BEcmFnT3ZlcjogJ2RyYWdvdmVyJyxcbiAgdG9wRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgdG9wRHJvcDogJ2Ryb3AnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcEZvY3VzOiAnZm9jdXMnLFxuICB0b3BJbnB1dDogJ2lucHV0JyxcbiAgdG9wS2V5RG93bjogJ2tleWRvd24nLFxuICB0b3BLZXlQcmVzczogJ2tleXByZXNzJyxcbiAgdG9wS2V5VXA6ICdrZXl1cCcsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcE1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gIHRvcE1vdXNlTW92ZTogJ21vdXNlbW92ZScsXG4gIHRvcE1vdXNlT3V0OiAnbW91c2VvdXQnLFxuICB0b3BNb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICB0b3BNb3VzZVVwOiAnbW91c2V1cCcsXG4gIHRvcFBhc3RlOiAncGFzdGUnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNjcm9sbDogJ3Njcm9sbCcsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiAnc2VsZWN0aW9uY2hhbmdlJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRleHRJbnB1dDogJ3RleHRJbnB1dCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVG91Y2hDYW5jZWw6ICd0b3VjaGNhbmNlbCcsXG4gIHRvcFRvdWNoRW5kOiAndG91Y2hlbmQnLFxuICB0b3BUb3VjaE1vdmU6ICd0b3VjaG1vdmUnLFxuICB0b3BUb3VjaFN0YXJ0OiAndG91Y2hzdGFydCcsXG4gIHRvcFRyYW5zaXRpb25FbmQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCd0cmFuc2l0aW9uZW5kJykgfHwgJ3RyYW5zaXRpb25lbmQnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZycsXG4gIHRvcFdoZWVsOiAnd2hlZWwnXG59O1xuXG4vKipcbiAqIFRvIGVuc3VyZSBubyBjb25mbGljdHMgd2l0aCBvdGhlciBwb3RlbnRpYWwgUmVhY3QgaW5zdGFuY2VzIG9uIHRoZSBwYWdlXG4gKi9cbnZhciB0b3BMaXN0ZW5lcnNJREtleSA9ICdfcmVhY3RMaXN0ZW5lcnNJRCcgKyBTdHJpbmcoTWF0aC5yYW5kb20oKSkuc2xpY2UoMik7XG5cbmZ1bmN0aW9uIGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpIHtcbiAgLy8gSW4gSUU4LCBgbW91bnRBdGAgaXMgYSBob3N0IG9iamVjdCBhbmQgZG9lc24ndCBoYXZlIGBoYXNPd25Qcm9wZXJ0eWBcbiAgLy8gZGlyZWN0bHkuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vdW50QXQsIHRvcExpc3RlbmVyc0lES2V5KSkge1xuICAgIG1vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldID0gcmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyKys7XG4gICAgYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXSA9IHt9O1xuICB9XG4gIHJldHVybiBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dO1xufVxuXG4vKipcbiAqIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGlzIHVzZWQgdG8gYXR0YWNoIHRvcC1sZXZlbCBldmVudCBsaXN0ZW5lcnMuIEZvclxuICogZXhhbXBsZTpcbiAqXG4gKiAgIEV2ZW50UGx1Z2luSHViLnB1dExpc3RlbmVyKCdteUlEJywgJ29uQ2xpY2snLCBteUZ1bmN0aW9uKTtcbiAqXG4gKiBUaGlzIHdvdWxkIGFsbG9jYXRlIGEgXCJyZWdpc3RyYXRpb25cIiBvZiBgKCdvbkNsaWNrJywgbXlGdW5jdGlvbilgIG9uICdteUlEJy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IF9hc3NpZ24oe30sIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4sIHtcbiAgLyoqXG4gICAqIEluamVjdGFibGUgZXZlbnQgYmFja2VuZFxuICAgKi9cbiAgUmVhY3RFdmVudExpc3RlbmVyOiBudWxsLFxuXG4gIGluamVjdGlvbjoge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBSZWFjdEV2ZW50TGlzdGVuZXJcbiAgICAgKi9cbiAgICBpbmplY3RSZWFjdEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChSZWFjdEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5zZXRIYW5kbGVUb3BMZXZlbChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaGFuZGxlVG9wTGV2ZWwpO1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lciA9IFJlYWN0RXZlbnRMaXN0ZW5lcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciBvciBub3QgYW55IGNyZWF0ZWQgY2FsbGJhY2tzIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgVHJ1ZSBpZiBjYWxsYmFja3Mgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXRFbmFibGVkOiBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgIGlmIChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyKSB7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnNldEVuYWJsZWQoZW5hYmxlZCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGNhbGxiYWNrcyBhcmUgZW5hYmxlZC5cbiAgICovXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIShSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyICYmIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuaXNFbmFibGVkKCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gICAqXG4gICAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAgICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAgICogZWxlbWVudC4gVGhlIHN5bXB0b21zIHdlcmUgdGhhdCBpZiB5b3VyIG1vdXNlIGlzIG5vdCBtb3Zpbmcgb3ZlciBzb21ldGhpbmdcbiAgICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gICAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAgICogcmVnaXN0ZXIgdGhlIGBtb3VzZW1vdmVgIG9uIHRoZSBkb2N1bWVudCBvYmplY3QsIHRoZW4gaXQgd2lsbCBvZiBjb3Vyc2VcbiAgICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gICAqIG1vdmVtZW50IHR5cGVzIG9mIGV2ZW50cyBhbmQgcG9zc2libHkgYWxsIGV2ZW50cy5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAgKlxuICAgKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gICAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50RG9jdW1lbnRIYW5kbGUgRG9jdW1lbnQgd2hpY2ggb3ducyB0aGUgY29udGFpbmVyXG4gICAqL1xuICBsaXN0ZW5UbzogZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbk5hbWUsIGNvbnRlbnREb2N1bWVudEhhbmRsZSkge1xuICAgIHZhciBtb3VudEF0ID0gY29udGVudERvY3VtZW50SGFuZGxlO1xuICAgIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICAgIHZhciBkZXBlbmRlbmNpZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BXaGVlbCcpIHtcbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnd2hlZWwnKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KCd0b3BXaGVlbCcsICd3aGVlbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudFN1cHBvcnRlZCgnbW91c2V3aGVlbCcpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcFdoZWVsJywgJ21vdXNld2hlZWwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmlyZWZveCBuZWVkcyB0byBjYXB0dXJlIGEgZGlmZmVyZW50IG1vdXNlIHNjcm9sbCBldmVudC5cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Rlc3RzL3Njcm9sbC5odG1sXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcFdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BTY3JvbGwnKSB7XG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ3Njcm9sbCcsIHRydWUpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KCd0b3BTY3JvbGwnLCAnc2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wU2Nyb2xsJywgJ3Njcm9sbCcsIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuV0lORE9XX0hBTkRMRSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BGb2N1cycgfHwgZGVwZW5kZW5jeSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2ZvY3VzJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQoJ3RvcEZvY3VzJywgJ2ZvY3VzJywgbW91bnRBdCk7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KCd0b3BCbHVyJywgJ2JsdXInLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2ZvY3VzaW4nKSkge1xuICAgICAgICAgICAgLy8gSUUgaGFzIGBmb2N1c2luYCBhbmQgYGZvY3Vzb3V0YCBldmVudHMgd2hpY2ggYnViYmxlLlxuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAwOC8wNC9kZWxlZ2F0aW5nX3RoZS5odG1sXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcEZvY3VzJywgJ2ZvY3VzaW4nLCBtb3VudEF0KTtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wQmx1cicsICdmb2N1c291dCcsIG1vdW50QXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHRvIG1ha2Ugc3VyZSBibHVyIGFuZCBmb2N1cyBldmVudCBsaXN0ZW5lcnMgYXJlIG9ubHkgYXR0YWNoZWQgb25jZVxuICAgICAgICAgIGlzTGlzdGVuaW5nLnRvcEJsdXIgPSB0cnVlO1xuICAgICAgICAgIGlzTGlzdGVuaW5nLnRvcEZvY3VzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0b3BFdmVudE1hcHBpbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkpIHtcbiAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoZGVwZW5kZW5jeSwgdG9wRXZlbnRNYXBwaW5nW2RlcGVuZGVuY3ldLCBtb3VudEF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdHJhcEJ1YmJsZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICByZXR1cm4gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpO1xuICB9LFxuXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHJldHVybiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQcm90ZWN0IGFnYWluc3QgZG9jdW1lbnQuY3JlYXRlRXZlbnQoKSByZXR1cm5pbmcgbnVsbFxuICAgKiBTb21lIHBvcHVwIGJsb2NrZXIgZXh0ZW5zaW9ucyBhcHBlYXIgdG8gZG8gdGhpczpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy82ODg3XG4gICAqL1xuICBzdXBwb3J0c0V2ZW50UGFnZVhZOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFkb2N1bWVudC5jcmVhdGVFdmVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZXYgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudCcpO1xuICAgIHJldHVybiBldiAhPSBudWxsICYmICdwYWdlWCcgaW4gZXY7XG4gIH0sXG5cbiAgLyoqXG4gICAqIExpc3RlbnMgdG8gd2luZG93IHNjcm9sbCBhbmQgcmVzaXplIGV2ZW50cy4gV2UgY2FjaGUgc2Nyb2xsIHZhbHVlcyBzbyB0aGF0XG4gICAqIGFwcGxpY2F0aW9uIGNvZGUgY2FuIGFjY2VzcyB0aGVtIHdpdGhvdXQgdHJpZ2dlcmluZyByZWZsb3dzLlxuICAgKlxuICAgKiBWaWV3cG9ydE1ldHJpY3MgaXMgb25seSB1c2VkIGJ5IFN5bnRoZXRpY01vdXNlL1RvdWNoRXZlbnQgYW5kIG9ubHkgd2hlblxuICAgKiBwYWdlWC9wYWdlWSBpc24ndCBzdXBwb3J0ZWQgKGxlZ2FjeSBicm93c2VycykuXG4gICAqXG4gICAqIE5PVEU6IFNjcm9sbCBldmVudHMgZG8gbm90IGJ1YmJsZS5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2RvbS9ldmVudHMvc2Nyb2xsLmh0bWxcbiAgICovXG4gIGVuc3VyZVNjcm9sbFZhbHVlTW9uaXRvcmluZzogZnVuY3Rpb24gKCkge1xuICAgIGlmIChoYXNFdmVudFBhZ2VYWSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBoYXNFdmVudFBhZ2VYWSA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zdXBwb3J0c0V2ZW50UGFnZVhZKCk7XG4gICAgfVxuICAgIGlmICghaGFzRXZlbnRQYWdlWFkgJiYgIWlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlKSB7XG4gICAgICB2YXIgcmVmcmVzaCA9IFZpZXdwb3J0TWV0cmljcy5yZWZyZXNoU2Nyb2xsVmFsdWVzO1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5tb25pdG9yU2Nyb2xsVmFsdWUocmVmcmVzaCk7XG4gICAgICBpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmpzIiwiaW1wb3J0IGNyZWF0ZVN0b3JlIGZyb20gJy4vY3JlYXRlU3RvcmUnO1xuaW1wb3J0IGNvbWJpbmVSZWR1Y2VycyBmcm9tICcuL2NvbWJpbmVSZWR1Y2Vycyc7XG5pbXBvcnQgYmluZEFjdGlvbkNyZWF0b3JzIGZyb20gJy4vYmluZEFjdGlvbkNyZWF0b3JzJztcbmltcG9ydCBhcHBseU1pZGRsZXdhcmUgZnJvbSAnLi9hcHBseU1pZGRsZXdhcmUnO1xuaW1wb3J0IGNvbXBvc2UgZnJvbSAnLi9jb21wb3NlJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJy4vdXRpbHMvd2FybmluZyc7XG5cbi8qXG4qIFRoaXMgaXMgYSBkdW1teSBmdW5jdGlvbiB0byBjaGVjayBpZiB0aGUgZnVuY3Rpb24gbmFtZSBoYXMgYmVlbiBhbHRlcmVkIGJ5IG1pbmlmaWNhdGlvbi5cbiogSWYgdGhlIGZ1bmN0aW9uIGhhcyBiZWVuIG1pbmlmaWVkIGFuZCBOT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLCB3YXJuIHRoZSB1c2VyLlxuKi9cbmZ1bmN0aW9uIGlzQ3J1c2hlZCgpIHt9XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBpc0NydXNoZWQubmFtZSA9PT0gJ3N0cmluZycgJiYgaXNDcnVzaGVkLm5hbWUgIT09ICdpc0NydXNoZWQnKSB7XG4gIHdhcm5pbmcoJ1lvdSBhcmUgY3VycmVudGx5IHVzaW5nIG1pbmlmaWVkIGNvZGUgb3V0c2lkZSBvZiBOT0RFX0VOViA9PT0gXFwncHJvZHVjdGlvblxcJy4gJyArICdUaGlzIG1lYW5zIHRoYXQgeW91IGFyZSBydW5uaW5nIGEgc2xvd2VyIGRldmVsb3BtZW50IGJ1aWxkIG9mIFJlZHV4LiAnICsgJ1lvdSBjYW4gdXNlIGxvb3NlLWVudmlmeSAoaHR0cHM6Ly9naXRodWIuY29tL3plcnRvc2gvbG9vc2UtZW52aWZ5KSBmb3IgYnJvd3NlcmlmeSAnICsgJ29yIERlZmluZVBsdWdpbiBmb3Igd2VicGFjayAoaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMDAzMDAzMSkgJyArICd0byBlbnN1cmUgeW91IGhhdmUgdGhlIGNvcnJlY3QgY29kZSBmb3IgeW91ciBwcm9kdWN0aW9uIGJ1aWxkLicpO1xufVxuXG5leHBvcnQgeyBjcmVhdGVTdG9yZSwgY29tYmluZVJlZHVjZXJzLCBiaW5kQWN0aW9uQ3JlYXRvcnMsIGFwcGx5TWlkZGxld2FyZSwgY29tcG9zZSB9O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWR1eC9lcy9pbmRleC5qcyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYgKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpIGRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHsgdmFsdWU6IHdrc0V4dC5mKG5hbWUpIH0pO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy1kZWZpbmUuanMiLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJ2YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faHRtbC5qcyIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoTywgcHJvdG8pIHtcbiAgYW5PYmplY3QoTyk7XG4gIGlmICghaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKSB0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbiAodGVzdCwgYnVnZ3ksIHNldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZiAoYnVnZ3kpIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1wcm90by5qcyIsIm1vZHVsZS5leHBvcnRzID0gJ1xceDA5XFx4MEFcXHgwQlxceDBDXFx4MERcXHgyMFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzJyArXG4gICdcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy13cy5qcyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgdGFyZ2V0LCBDKSB7XG4gIHZhciBTID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICB2YXIgUDtcbiAgaWYgKFMgIT09IEMgJiYgdHlwZW9mIFMgPT0gJ2Z1bmN0aW9uJyAmJiAoUCA9IFMucHJvdG90eXBlKSAhPT0gQy5wcm90b3R5cGUgJiYgaXNPYmplY3QoUCkgJiYgc2V0UHJvdG90eXBlT2YpIHtcbiAgICBzZXRQcm90b3R5cGVPZih0aGF0LCBQKTtcbiAgfSByZXR1cm4gdGhhdDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbmhlcml0LWlmLXJlcXVpcmVkLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGVhdChjb3VudCkge1xuICB2YXIgc3RyID0gU3RyaW5nKGRlZmluZWQodGhpcykpO1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBuID0gdG9JbnRlZ2VyKGNvdW50KTtcbiAgaWYgKG4gPCAwIHx8IG4gPT0gSW5maW5pdHkpIHRocm93IFJhbmdlRXJyb3IoXCJDb3VudCBjYW4ndCBiZSBuZWdhdGl2ZVwiKTtcbiAgZm9yICg7biA+IDA7IChuID4+Pj0gMSkgJiYgKHN0ciArPSBzdHIpKSBpZiAobiAmIDEpIHJlcyArPSBzdHI7XG4gIHJldHVybiByZXM7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXJlcGVhdC5qcyIsIi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uIHNpZ24oeCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHJldHVybiAoeCA9ICt4KSA9PSAwIHx8IHggIT0geCA/IHggOiB4IDwgMCA/IC0xIDogMTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLXNpZ24uanMiLCIvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxudmFyICRleHBtMSA9IE1hdGguZXhwbTE7XG5tb2R1bGUuZXhwb3J0cyA9ICghJGV4cG0xXG4gIC8vIE9sZCBGRiBidWdcbiAgfHwgJGV4cG0xKDEwKSA+IDIyMDI1LjQ2NTc5NDgwNjcxOSB8fCAkZXhwbTEoMTApIDwgMjIwMjUuNDY1Nzk0ODA2NzE2NTE2OFxuICAvLyBUb3IgQnJvd3NlciBidWdcbiAgfHwgJGV4cG0xKC0yZS0xNykgIT0gLTJlLTE3XG4pID8gZnVuY3Rpb24gZXhwbTEoeCkge1xuICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiB4ID4gLTFlLTYgJiYgeCA8IDFlLTYgPyB4ICsgeCAqIHggLyAyIDogTWF0aC5leHAoeCkgLSAxO1xufSA6ICRleHBtMTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtZXhwbTEuanMiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyICRpdGVyQ3JlYXRlID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBCVUdHWSA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKTsgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxudmFyIEZGX0lURVJBVE9SID0gJ0BAaXRlcmF0b3InO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgaWYgKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKSByZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUztcbiAgdmFyIFZBTFVFU19CVUcgPSBmYWxzZTtcbiAgdmFyIHByb3RvID0gQmFzZS5wcm90b3R5cGU7XG4gIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xuICB2YXIgJGRlZmF1bHQgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKTtcbiAgdmFyICRlbnRyaWVzID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZDtcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xuICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZiAoJGFueU5hdGl2ZSkge1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKCkpKTtcbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmICghTElCUkFSWSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkge1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gPSByZXR1cm5UaGlzO1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBkZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIi8vIGhlbHBlciBmb3IgU3RyaW5nI3tzdGFydHNXaXRoLCBlbmRzV2l0aCwgaW5jbHVkZXN9XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCBzZWFyY2hTdHJpbmcsIE5BTUUpIHtcbiAgaWYgKGlzUmVnRXhwKHNlYXJjaFN0cmluZykpIHRocm93IFR5cGVFcnJvcignU3RyaW5nIycgKyBOQU1FICsgXCIgZG9lc24ndCBhY2NlcHQgcmVnZXghXCIpO1xuICByZXR1cm4gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1jb250ZXh0LmpzIiwidmFyIE1BVENIID0gcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgdmFyIHJlID0gLy4vO1xuICB0cnkge1xuICAgICcvLi8nW0tFWV0ocmUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlW01BVENIXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuICEnLy4vJ1tLRVldKHJlKTtcbiAgICB9IGNhdGNoIChmKSB7IC8qIGVtcHR5ICovIH1cbiAgfSByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy1pcy1yZWdleHAuanMiLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgdmFsdWUpIHtcbiAgaWYgKGluZGV4IGluIG9iamVjdCkgJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanMiLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwiLy8gOS40LjIuMyBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKVxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwsIGxlbmd0aCkge1xuICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWwpKShsZW5ndGgpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzIiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyogLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKTtcbiAgd2hpbGUgKGVuZFBvcyA+IGluZGV4KSBPW2luZGV4KytdID0gdmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZpbGwuanMiLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJ2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgaW52b2tlID0gcmVxdWlyZSgnLi9faW52b2tlJyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4vX2h0bWwnKTtcbnZhciBjZWwgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHNldFRhc2sgPSBnbG9iYWwuc2V0SW1tZWRpYXRlO1xudmFyIGNsZWFyVGFzayA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZTtcbnZhciBNZXNzYWdlQ2hhbm5lbCA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbDtcbnZhciBEaXNwYXRjaCA9IGdsb2JhbC5EaXNwYXRjaDtcbnZhciBjb3VudGVyID0gMDtcbnZhciBxdWV1ZSA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgaWYgKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYgKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spIHtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIGkgPSAxO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYgKHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gU3BoZXJlIChKUyBnYW1lIGVuZ2luZSkgRGlzcGF0Y2ggQVBJXG4gIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIERpc3BhdGNoLm5vdyhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmIChNZXNzYWdlQ2hhbm5lbCkge1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSkge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190YXNrLmpzIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgT2JzZXJ2ZXIgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmIChpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSkgcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChoZWFkKSBub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQuZW50ZXIoKTtcbiAgfTtcblxuICAvLyBOb2RlLmpzXG4gIGlmIChpc05vZGUpIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXJcbiAgfSBlbHNlIGlmIChPYnNlcnZlcikge1xuICAgIHZhciB0b2dnbGUgPSB0cnVlO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYgKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKSB7XG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuY2FsbChnbG9iYWwpXG4gICAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIHZhciB0YXNrID0geyBmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCB9O1xuICAgIGlmIChsYXN0KSBsYXN0Lm5leHQgPSB0YXNrO1xuICAgIGlmICghaGVhZCkge1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9IGxhc3QgPSB0YXNrO1xuICB9O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21pY3JvdGFzay5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIDI1LjQuMS41IE5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG5mdW5jdGlvbiBQcm9taXNlQ2FwYWJpbGl0eShDKSB7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XG4gICAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ID0gYUZ1bmN0aW9uKHJlamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX25ldy1wcm9taXNlLWNhcGFiaWxpdHkuanMiLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgJHR5cGVkID0gcmVxdWlyZSgnLi9fdHlwZWQnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvSW5kZXggPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGFycmF5RmlsbCA9IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcbnZhciBEQVRBX1ZJRVcgPSAnRGF0YVZpZXcnO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIFdST05HX0xFTkdUSCA9ICdXcm9uZyBsZW5ndGghJztcbnZhciBXUk9OR19JTkRFWCA9ICdXcm9uZyBpbmRleCEnO1xudmFyICRBcnJheUJ1ZmZlciA9IGdsb2JhbFtBUlJBWV9CVUZGRVJdO1xudmFyICREYXRhVmlldyA9IGdsb2JhbFtEQVRBX1ZJRVddO1xudmFyIE1hdGggPSBnbG9iYWwuTWF0aDtcbnZhciBSYW5nZUVycm9yID0gZ2xvYmFsLlJhbmdlRXJyb3I7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93LXJlc3RyaWN0ZWQtbmFtZXNcbnZhciBJbmZpbml0eSA9IGdsb2JhbC5JbmZpbml0eTtcbnZhciBCYXNlQnVmZmVyID0gJEFycmF5QnVmZmVyO1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBsb2cgPSBNYXRoLmxvZztcbnZhciBMTjIgPSBNYXRoLkxOMjtcbnZhciBCVUZGRVIgPSAnYnVmZmVyJztcbnZhciBCWVRFX0xFTkdUSCA9ICdieXRlTGVuZ3RoJztcbnZhciBCWVRFX09GRlNFVCA9ICdieXRlT2Zmc2V0JztcbnZhciAkQlVGRkVSID0gREVTQ1JJUFRPUlMgPyAnX2InIDogQlVGRkVSO1xudmFyICRMRU5HVEggPSBERVNDUklQVE9SUyA/ICdfbCcgOiBCWVRFX0xFTkdUSDtcbnZhciAkT0ZGU0VUID0gREVTQ1JJUFRPUlMgPyAnX28nIDogQllURV9PRkZTRVQ7XG5cbi8vIElFRUU3NTQgY29udmVyc2lvbnMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pZWVlNzU0XG5mdW5jdGlvbiBwYWNrSUVFRTc1NCh2YWx1ZSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBidWZmZXIgPSBBcnJheShuQnl0ZXMpO1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIHJ0ID0gbUxlbiA9PT0gMjMgPyBwb3coMiwgLTI0KSAtIHBvdygyLCAtNzcpIDogMDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwID8gMSA6IDA7XG4gIHZhciBlLCBtLCBjO1xuICB2YWx1ZSA9IGFicyh2YWx1ZSk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgaWYgKHZhbHVlICE9IHZhbHVlIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBtID0gdmFsdWUgIT0gdmFsdWUgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gZmxvb3IobG9nKHZhbHVlKSAvIExOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBwb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogcG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIHBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIHBvdygyLCBlQmlhcyAtIDEpICogcG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltpKytdID0gbSAmIDI1NSwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG4gIGUgPSBlIDw8IG1MZW4gfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW2krK10gPSBlICYgMjU1LCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcbiAgYnVmZmVyWy0taV0gfD0gcyAqIDEyODtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIHVucGFja0lFRUU3NTQoYnVmZmVyLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBuQml0cyA9IGVMZW4gLSA3O1xuICB2YXIgaSA9IG5CeXRlcyAtIDE7XG4gIHZhciBzID0gYnVmZmVyW2ktLV07XG4gIHZhciBlID0gcyAmIDEyNztcbiAgdmFyIG07XG4gIHMgPj49IDc7XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW2ldLCBpLS0sIG5CaXRzIC09IDgpO1xuICBtID0gZSAmICgxIDw8IC1uQml0cykgLSAxO1xuICBlID4+PSAtbkJpdHM7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW2ldLCBpLS0sIG5CaXRzIC09IDgpO1xuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogcyA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgcG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH0gcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBwb3coMiwgZSAtIG1MZW4pO1xufVxuXG5mdW5jdGlvbiB1bnBhY2tJMzIoYnl0ZXMpIHtcbiAgcmV0dXJuIGJ5dGVzWzNdIDw8IDI0IHwgYnl0ZXNbMl0gPDwgMTYgfCBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG59XG5mdW5jdGlvbiBwYWNrSTgoaXQpIHtcbiAgcmV0dXJuIFtpdCAmIDB4ZmZdO1xufVxuZnVuY3Rpb24gcGFja0kxNihpdCkge1xuICByZXR1cm4gW2l0ICYgMHhmZiwgaXQgPj4gOCAmIDB4ZmZdO1xufVxuZnVuY3Rpb24gcGFja0kzMihpdCkge1xuICByZXR1cm4gW2l0ICYgMHhmZiwgaXQgPj4gOCAmIDB4ZmYsIGl0ID4+IDE2ICYgMHhmZiwgaXQgPj4gMjQgJiAweGZmXTtcbn1cbmZ1bmN0aW9uIHBhY2tGNjQoaXQpIHtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KGl0LCA1MiwgOCk7XG59XG5mdW5jdGlvbiBwYWNrRjMyKGl0KSB7XG4gIHJldHVybiBwYWNrSUVFRTc1NChpdCwgMjMsIDQpO1xufVxuXG5mdW5jdGlvbiBhZGRHZXR0ZXIoQywga2V5LCBpbnRlcm5hbCkge1xuICBkUChDW1BST1RPVFlQRV0sIGtleSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXNbaW50ZXJuYWxdOyB9IH0pO1xufVxuXG5mdW5jdGlvbiBnZXQodmlldywgYnl0ZXMsIGluZGV4LCBpc0xpdHRsZUVuZGlhbikge1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXg7XG4gIHZhciBpbnRJbmRleCA9IHRvSW5kZXgobnVtSW5kZXgpO1xuICBpZiAoaW50SW5kZXggKyBieXRlcyA+IHZpZXdbJExFTkdUSF0pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iO1xuICB2YXIgc3RhcnQgPSBpbnRJbmRleCArIHZpZXdbJE9GRlNFVF07XG4gIHZhciBwYWNrID0gc3RvcmUuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgYnl0ZXMpO1xuICByZXR1cm4gaXNMaXR0bGVFbmRpYW4gPyBwYWNrIDogcGFjay5yZXZlcnNlKCk7XG59XG5mdW5jdGlvbiBzZXQodmlldywgYnl0ZXMsIGluZGV4LCBjb252ZXJzaW9uLCB2YWx1ZSwgaXNMaXR0bGVFbmRpYW4pIHtcbiAgdmFyIG51bUluZGV4ID0gK2luZGV4O1xuICB2YXIgaW50SW5kZXggPSB0b0luZGV4KG51bUluZGV4KTtcbiAgaWYgKGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0lOREVYKTtcbiAgdmFyIHN0b3JlID0gdmlld1skQlVGRkVSXS5fYjtcbiAgdmFyIHN0YXJ0ID0gaW50SW5kZXggKyB2aWV3WyRPRkZTRVRdO1xuICB2YXIgcGFjayA9IGNvbnZlcnNpb24oK3ZhbHVlKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlczsgaSsrKSBzdG9yZVtzdGFydCArIGldID0gcGFja1tpc0xpdHRsZUVuZGlhbiA/IGkgOiBieXRlcyAtIGkgLSAxXTtcbn1cblxuaWYgKCEkdHlwZWQuQUJWKSB7XG4gICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCkge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuICAgIHZhciBieXRlTGVuZ3RoID0gdG9JbmRleChsZW5ndGgpO1xuICAgIHRoaXMuX2IgPSBhcnJheUZpbGwuY2FsbChBcnJheShieXRlTGVuZ3RoKSwgMCk7XG4gICAgdGhpc1skTEVOR1RIXSA9IGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgJERhdGFWaWV3ID0gZnVuY3Rpb24gRGF0YVZpZXcoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkRGF0YVZpZXcsIERBVEFfVklFVyk7XG4gICAgYW5JbnN0YW5jZShidWZmZXIsICRBcnJheUJ1ZmZlciwgREFUQV9WSUVXKTtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYnVmZmVyWyRMRU5HVEhdO1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoYnl0ZU9mZnNldCk7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQhJyk7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPT09IHVuZGVmaW5lZCA/IGJ1ZmZlckxlbmd0aCAtIG9mZnNldCA6IHRvTGVuZ3RoKGJ5dGVMZW5ndGgpO1xuICAgIGlmIChvZmZzZXQgKyBieXRlTGVuZ3RoID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgdGhpc1skQlVGRkVSXSA9IGJ1ZmZlcjtcbiAgICB0aGlzWyRPRkZTRVRdID0gb2Zmc2V0O1xuICAgIHRoaXNbJExFTkdUSF0gPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gIGlmIChERVNDUklQVE9SUykge1xuICAgIGFkZEdldHRlcigkQXJyYXlCdWZmZXIsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCVUZGRVIsICdfYicpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCWVRFX09GRlNFVCwgJ19vJyk7XG4gIH1cblxuICByZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIGdldEludDg6IGZ1bmN0aW9uIGdldEludDgoYnl0ZU9mZnNldCkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXSA8PCAyNCA+PiAyNDtcbiAgICB9LFxuICAgIGdldFVpbnQ4OiBmdW5jdGlvbiBnZXRVaW50OChieXRlT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MTY6IGZ1bmN0aW9uIGdldEludDE2KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pO1xuICAgICAgcmV0dXJuIChieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF0pIDw8IDE2ID4+IDE2O1xuICAgIH0sXG4gICAgZ2V0VWludDE2OiBmdW5jdGlvbiBnZXRVaW50MTYoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MzI6IGZ1bmN0aW9uIGdldEludDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpO1xuICAgIH0sXG4gICAgZ2V0VWludDMyOiBmdW5jdGlvbiBnZXRVaW50MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0kzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSkgPj4+IDA7XG4gICAgfSxcbiAgICBnZXRGbG9hdDMyOiBmdW5jdGlvbiBnZXRGbG9hdDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCAyMywgNCk7XG4gICAgfSxcbiAgICBnZXRGbG9hdDY0OiBmdW5jdGlvbiBnZXRGbG9hdDY0KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCA1MiwgOCk7XG4gICAgfSxcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSTgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldEludDE2OiBmdW5jdGlvbiBzZXRJbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJMTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDE2OiBmdW5jdGlvbiBzZXRVaW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSTE2LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEludDMyOiBmdW5jdGlvbiBzZXRJbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDMyOiBmdW5jdGlvbiBzZXRVaW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0MzI6IGZ1bmN0aW9uIHNldEZsb2F0MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrRjMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0NjQ6IGZ1bmN0aW9uIHNldEZsb2F0NjQoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBwYWNrRjY0LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgaWYgKCFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgJEFycmF5QnVmZmVyKDEpO1xuICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoLTEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICB9KSB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3ICRBcnJheUJ1ZmZlcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoMS41KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBuZXcgJEFycmF5QnVmZmVyKE5hTik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgcmV0dXJuICRBcnJheUJ1ZmZlci5uYW1lICE9IEFSUkFZX0JVRkZFUjtcbiAgfSkpIHtcbiAgICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhpcywgJEFycmF5QnVmZmVyKTtcbiAgICAgIHJldHVybiBuZXcgQmFzZUJ1ZmZlcih0b0luZGV4KGxlbmd0aCkpO1xuICAgIH07XG4gICAgdmFyIEFycmF5QnVmZmVyUHJvdG8gPSAkQXJyYXlCdWZmZXJbUFJPVE9UWVBFXSA9IEJhc2VCdWZmZXJbUFJPVE9UWVBFXTtcbiAgICBmb3IgKHZhciBrZXlzID0gZ09QTihCYXNlQnVmZmVyKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOykge1xuICAgICAgaWYgKCEoKGtleSA9IGtleXNbaisrXSkgaW4gJEFycmF5QnVmZmVyKSkgaGlkZSgkQXJyYXlCdWZmZXIsIGtleSwgQmFzZUJ1ZmZlcltrZXldKTtcbiAgICB9XG4gICAgaWYgKCFMSUJSQVJZKSBBcnJheUJ1ZmZlclByb3RvLmNvbnN0cnVjdG9yID0gJEFycmF5QnVmZmVyO1xuICB9XG4gIC8vIGlPUyBTYWZhcmkgNy54IGJ1Z1xuICB2YXIgdmlldyA9IG5ldyAkRGF0YVZpZXcobmV3ICRBcnJheUJ1ZmZlcigyKSk7XG4gIHZhciAkc2V0SW50OCA9ICREYXRhVmlld1tQUk9UT1RZUEVdLnNldEludDg7XG4gIHZpZXcuc2V0SW50OCgwLCAyMTQ3NDgzNjQ4KTtcbiAgdmlldy5zZXRJbnQ4KDEsIDIxNDc0ODM2NDkpO1xuICBpZiAodmlldy5nZXRJbnQ4KDApIHx8ICF2aWV3LmdldEludDgoMSkpIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgICRzZXRJbnQ4LmNhbGwodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH1cbiAgfSwgdHJ1ZSk7XG59XG5zZXRUb1N0cmluZ1RhZygkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG5zZXRUb1N0cmluZ1RhZygkRGF0YVZpZXcsIERBVEFfVklFVyk7XG5oaWRlKCREYXRhVmlld1tQUk9UT1RZUEVdLCAkdHlwZWQuVklFVywgdHJ1ZSk7XG5leHBvcnRzW0FSUkFZX0JVRkZFUl0gPSAkQXJyYXlCdWZmZXI7XG5leHBvcnRzW0RBVEFfVklFV10gPSAkRGF0YVZpZXc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC1idWZmZXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEZvcmtlZCBmcm9tIGZianMvd2FybmluZzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvZTY2YmEyMGFkNWJlNDMzZWI1NDQyM2YyYjA5N2Q4MjkzMjRkOWRlNi9wYWNrYWdlcy9mYmpzL3NyYy9fX2ZvcmtzX18vd2FybmluZy5qc1xuICpcbiAqIE9ubHkgY2hhbmdlIGlzIHdlIHVzZSBjb25zb2xlLndhcm4gaW5zdGVhZCBvZiBjb25zb2xlLmVycm9yLFxuICogYW5kIGRvIG5vdGhpbmcgd2hlbiAnY29uc29sZScgaXMgbm90IHN1cHBvcnRlZC5cbiAqIFRoaXMgcmVhbGx5IHNpbXBsaWZpZXMgdGhlIGNvZGUuXG4gKiAtLS1cbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbG93UHJpb3JpdHlXYXJuaW5nO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvbG93UHJpb3JpdHlXYXJuaW5nLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0RXJyb3JVdGlscyA9IHJlcXVpcmUoJy4vUmVhY3RFcnJvclV0aWxzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEluamVjdGVkIGRlcGVuZGVuY2llczpcbiAqL1xuXG4vKipcbiAqIC0gYENvbXBvbmVudFRyZWVgOiBbcmVxdWlyZWRdIE1vZHVsZSB0aGF0IGNhbiBjb252ZXJ0IGJldHdlZW4gUmVhY3QgaW5zdGFuY2VzXG4gKiAgIGFuZCBhY3R1YWwgbm9kZSByZWZlcmVuY2VzLlxuICovXG52YXIgQ29tcG9uZW50VHJlZTtcbnZhciBUcmVlVHJhdmVyc2FsO1xudmFyIGluamVjdGlvbiA9IHtcbiAgaW5qZWN0Q29tcG9uZW50VHJlZTogZnVuY3Rpb24gKEluamVjdGVkKSB7XG4gICAgQ29tcG9uZW50VHJlZSA9IEluamVjdGVkO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhJbmplY3RlZCAmJiBJbmplY3RlZC5nZXROb2RlRnJvbUluc3RhbmNlICYmIEluamVjdGVkLmdldEluc3RhbmNlRnJvbU5vZGUsICdFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RDb21wb25lbnRUcmVlKC4uLik6IEluamVjdGVkICcgKyAnbW9kdWxlIGlzIG1pc3NpbmcgZ2V0Tm9kZUZyb21JbnN0YW5jZSBvciBnZXRJbnN0YW5jZUZyb21Ob2RlLicpIDogdm9pZCAwO1xuICAgIH1cbiAgfSxcbiAgaW5qZWN0VHJlZVRyYXZlcnNhbDogZnVuY3Rpb24gKEluamVjdGVkKSB7XG4gICAgVHJlZVRyYXZlcnNhbCA9IEluamVjdGVkO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhJbmplY3RlZCAmJiBJbmplY3RlZC5pc0FuY2VzdG9yICYmIEluamVjdGVkLmdldExvd2VzdENvbW1vbkFuY2VzdG9yLCAnRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24uaW5qZWN0VHJlZVRyYXZlcnNhbCguLi4pOiBJbmplY3RlZCAnICsgJ21vZHVsZSBpcyBtaXNzaW5nIGlzQW5jZXN0b3Igb3IgZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IuJykgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBpc0VuZGlzaCh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlVXAnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcFRvdWNoRW5kJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BUb3VjaENhbmNlbCc7XG59XG5cbmZ1bmN0aW9uIGlzTW92ZWlzaCh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlTW92ZScgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wVG91Y2hNb3ZlJztcbn1cbmZ1bmN0aW9uIGlzU3RhcnRpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZURvd24nIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcFRvdWNoU3RhcnQnO1xufVxuXG52YXIgdmFsaWRhdGVFdmVudERpc3BhdGNoZXM7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG5cbiAgICB2YXIgbGlzdGVuZXJzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKTtcbiAgICB2YXIgbGlzdGVuZXJzTGVuID0gbGlzdGVuZXJzSXNBcnIgPyBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGggOiBkaXNwYXRjaExpc3RlbmVycyA/IDEgOiAwO1xuXG4gICAgdmFyIGluc3RhbmNlc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaEluc3RhbmNlcyk7XG4gICAgdmFyIGluc3RhbmNlc0xlbiA9IGluc3RhbmNlc0lzQXJyID8gZGlzcGF0Y2hJbnN0YW5jZXMubGVuZ3RoIDogZGlzcGF0Y2hJbnN0YW5jZXMgPyAxIDogMDtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGluc3RhbmNlc0lzQXJyID09PSBsaXN0ZW5lcnNJc0FyciAmJiBpbnN0YW5jZXNMZW4gPT09IGxpc3RlbmVyc0xlbiwgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgU3ludGhldGljRXZlbnQgdG8gaGFuZGxlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGluc3QgSW50ZXJuYWwgY29tcG9uZW50IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBsaXN0ZW5lciwgaW5zdCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gRXZlbnRQbHVnaW5VdGlscy5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICBpZiAoc2ltdWxhdGVkKSB7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFja1dpdGhDYXRjaCh0eXBlLCBsaXN0ZW5lciwgZXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sodHlwZSwgbGlzdGVuZXIsIGV2ZW50KTtcbiAgfVxuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcy5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTGlzdGVuZXJzIGFuZCBJbnN0YW5jZXMgYXJlIHR3byBwYXJhbGxlbCBhcnJheXMgdGhhdCBhcmUgYWx3YXlzIGluIHN5bmMuXG4gICAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnNbaV0sIGRpc3BhdGNoSW5zdGFuY2VzW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnMsIGRpc3BhdGNoSW5zdGFuY2VzKTtcbiAgfVxuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLCBidXQgc3RvcHNcbiAqIGF0IHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gcmV0dXJuaW5nIHRydWUsIGFuZCByZXR1cm5zIHRoYXQgaWQuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gaWQgb2YgdGhlIGZpcnN0IGRpc3BhdGNoIGV4ZWN1dGlvbiB3aG8ncyBsaXN0ZW5lciByZXR1cm5zXG4gKiB0cnVlLCBvciBudWxsIGlmIG5vIGxpc3RlbmVyIHJldHVybmVkIHRydWUuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgaWYgKGRpc3BhdGNoTGlzdGVuZXJzW2ldKGV2ZW50LCBkaXNwYXRjaEluc3RhbmNlc1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoSW5zdGFuY2VzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xuICAgIGlmIChkaXNwYXRjaExpc3RlbmVycyhldmVudCwgZGlzcGF0Y2hJbnN0YW5jZXMpKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hJbnN0YW5jZXM7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEBzZWUgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGxcbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZShldmVudCkge1xuICB2YXIgcmV0ID0gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGwoZXZlbnQpO1xuICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIEV4ZWN1dGlvbiBvZiBhIFwiZGlyZWN0XCIgZGlzcGF0Y2ggLSB0aGVyZSBtdXN0IGJlIGF0IG1vc3Qgb25lIGRpc3BhdGNoXG4gKiBhY2N1bXVsYXRlZCBvbiB0aGUgZXZlbnQgb3IgaXQgaXMgY29uc2lkZXJlZCBhbiBlcnJvci4gSXQgZG9lc24ndCByZWFsbHkgbWFrZVxuICogc2Vuc2UgZm9yIGFuIGV2ZW50IHdpdGggbXVsdGlwbGUgZGlzcGF0Y2hlcyAoYnViYmxlZCkgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqIHJldHVybiB2YWx1ZXMgYXQgZWFjaCBkaXNwYXRjaCBleGVjdXRpb24sIGJ1dCBpdCBkb2VzIHRlbmQgdG8gbWFrZSBzZW5zZSB3aGVuXG4gKiBkZWFsaW5nIHdpdGggXCJkaXJlY3RcIiBkaXNwYXRjaGVzLlxuICpcbiAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgZXhlY3V0aW5nIHRoZSBzaW5nbGUgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXJlY3REaXNwYXRjaChldmVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lciA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2UgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG4gICEhQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdleGVjdXRlRGlyZWN0RGlzcGF0Y2goLi4uKTogSW52YWxpZCBgZXZlbnRgLicpIDogX3Byb2RJbnZhcmlhbnQoJzEwMycpIDogdm9pZCAwO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gZGlzcGF0Y2hMaXN0ZW5lciA/IEV2ZW50UGx1Z2luVXRpbHMuZ2V0Tm9kZUZyb21JbnN0YW5jZShkaXNwYXRjaEluc3RhbmNlKSA6IG51bGw7XG4gIHZhciByZXMgPSBkaXNwYXRjaExpc3RlbmVyID8gZGlzcGF0Y2hMaXN0ZW5lcihldmVudCkgOiBudWxsO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZmYgbnVtYmVyIG9mIGRpc3BhdGNoZXMgYWNjdW11bGF0ZWQgaXMgZ3JlYXRlciB0aGFuIDAuXG4gKi9cbmZ1bmN0aW9uIGhhc0Rpc3BhdGNoZXMoZXZlbnQpIHtcbiAgcmV0dXJuICEhZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xufVxuXG4vKipcbiAqIEdlbmVyYWwgdXRpbGl0aWVzIHRoYXQgYXJlIHVzZWZ1bCBpbiBjcmVhdGluZyBjdXN0b20gRXZlbnQgUGx1Z2lucy5cbiAqL1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSB7XG4gIGlzRW5kaXNoOiBpc0VuZGlzaCxcbiAgaXNNb3ZlaXNoOiBpc01vdmVpc2gsXG4gIGlzU3RhcnRpc2g6IGlzU3RhcnRpc2gsXG5cbiAgZXhlY3V0ZURpcmVjdERpc3BhdGNoOiBleGVjdXRlRGlyZWN0RGlzcGF0Y2gsXG4gIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcjogZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyLFxuICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlOiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlLFxuICBoYXNEaXNwYXRjaGVzOiBoYXNEaXNwYXRjaGVzLFxuXG4gIGdldEluc3RhbmNlRnJvbU5vZGU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIENvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKTtcbiAgfSxcbiAgZ2V0Tm9kZUZyb21JbnN0YW5jZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKG5vZGUpO1xuICB9LFxuICBpc0FuY2VzdG9yOiBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBUcmVlVHJhdmVyc2FsLmlzQW5jZXN0b3IoYSwgYik7XG4gIH0sXG4gIGdldExvd2VzdENvbW1vbkFuY2VzdG9yOiBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBUcmVlVHJhdmVyc2FsLmdldExvd2VzdENvbW1vbkFuY2VzdG9yKGEsIGIpO1xuICB9LFxuICBnZXRQYXJlbnRJbnN0YW5jZTogZnVuY3Rpb24gKGluc3QpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC5nZXRQYXJlbnRJbnN0YW5jZShpbnN0KTtcbiAgfSxcbiAgdHJhdmVyc2VUd29QaGFzZTogZnVuY3Rpb24gKHRhcmdldCwgZm4sIGFyZykge1xuICAgIHJldHVybiBUcmVlVHJhdmVyc2FsLnRyYXZlcnNlVHdvUGhhc2UodGFyZ2V0LCBmbiwgYXJnKTtcbiAgfSxcbiAgdHJhdmVyc2VFbnRlckxlYXZlOiBmdW5jdGlvbiAoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbykge1xuICAgIHJldHVybiBUcmVlVHJhdmVyc2FsLnRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKTtcbiAgfSxcblxuICBpbmplY3Rpb246IGluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpblV0aWxzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0V2ZW50UGx1Z2luVXRpbHMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYXVnaHRFcnJvciA9IG51bGw7XG5cbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIHdoaWxlIGd1YXJkaW5nIGFnYWluc3QgZXJyb3JzIHRoYXQgaGFwcGVucyB3aXRoaW4gaXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICogQHBhcmFtIHsqfSBhIEZpcnN0IGFyZ3VtZW50XG4gKiBAcGFyYW0geyp9IGIgU2Vjb25kIGFyZ3VtZW50XG4gKi9cbmZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFjayhuYW1lLCBmdW5jLCBhKSB7XG4gIHRyeSB7XG4gICAgZnVuYyhhKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIGlmIChjYXVnaHRFcnJvciA9PT0gbnVsbCkge1xuICAgICAgY2F1Z2h0RXJyb3IgPSB4O1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RFcnJvclV0aWxzID0ge1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2s6IGludm9rZUd1YXJkZWRDYWxsYmFjayxcblxuICAvKipcbiAgICogSW52b2tlZCBieSBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZSBzbyB0aGF0IGFueSBlcnJvcnMgdGhyb3duIGJ5IHRoZSBldmVudFxuICAgKiBoYW5kbGVyIGFyZSBzdXJlIHRvIGJlIHJldGhyb3duIGJ5IHJldGhyb3dDYXVnaHRFcnJvci5cbiAgICovXG4gIGludm9rZUd1YXJkZWRDYWxsYmFja1dpdGhDYXRjaDogaW52b2tlR3VhcmRlZENhbGxiYWNrLFxuXG4gIC8qKlxuICAgKiBEdXJpbmcgZXhlY3V0aW9uIG9mIGd1YXJkZWQgZnVuY3Rpb25zIHdlIHdpbGwgY2FwdHVyZSB0aGUgZmlyc3QgZXJyb3Igd2hpY2hcbiAgICogd2Ugd2lsbCByZXRocm93IHRvIGJlIGhhbmRsZWQgYnkgdGhlIHRvcCBsZXZlbCBlcnJvciBoYW5kbGVyLlxuICAgKi9cbiAgcmV0aHJvd0NhdWdodEVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhdWdodEVycm9yKSB7XG4gICAgICB2YXIgZXJyb3IgPSBjYXVnaHRFcnJvcjtcbiAgICAgIGNhdWdodEVycm9yID0gbnVsbDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLyoqXG4gICAqIFRvIGhlbHAgZGV2ZWxvcG1lbnQgd2UgY2FuIGdldCBiZXR0ZXIgZGV2dG9vbHMgaW50ZWdyYXRpb24gYnkgc2ltdWxhdGluZyBhXG4gICAqIHJlYWwgYnJvd3NlciBldmVudC5cbiAgICovXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgYSkge1xuICAgICAgdmFyIGJvdW5kRnVuYyA9IGZ1bmMuYmluZChudWxsLCBhKTtcbiAgICAgIHZhciBldnRUeXBlID0gJ3JlYWN0LScgKyBuYW1lO1xuICAgICAgZmFrZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBib3VuZEZ1bmMsIGZhbHNlKTtcbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0RXZlbnQoZXZ0VHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIGZha2VOb2RlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgYm91bmRGdW5jLCBmYWxzZSk7XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXJyb3JVdGlscztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEVycm9yVXRpbHMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdldHMgdGhlIHRhcmdldCBub2RlIGZyb20gYSBuYXRpdmUgYnJvd3NlciBldmVudCBieSBhY2NvdW50aW5nIGZvclxuICogaW5jb25zaXN0ZW5jaWVzIGluIGJyb3dzZXIgRE9NIEFQSXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IFRhcmdldCBub2RlLlxuICovXG5cbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciB0YXJnZXQgPSBuYXRpdmVFdmVudC50YXJnZXQgfHwgbmF0aXZlRXZlbnQuc3JjRWxlbWVudCB8fCB3aW5kb3c7XG5cbiAgLy8gTm9ybWFsaXplIFNWRyA8dXNlPiBlbGVtZW50IGV2ZW50cyAjNDk2M1xuICBpZiAodGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50O1xuICB9XG5cbiAgLy8gU2FmYXJpIG1heSBmaXJlIGV2ZW50cyBvbiB0ZXh0IG5vZGVzIChOb2RlLlRFWFRfTk9ERSBpcyAzKS5cbiAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcbiAgcmV0dXJuIHRhcmdldC5ub2RlVHlwZSA9PT0gMyA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50VGFyZ2V0O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2dldEV2ZW50VGFyZ2V0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIHVzZUhhc0ZlYXR1cmU7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHVzZUhhc0ZlYXR1cmUgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbiAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmXG4gIC8vIGFsd2F5cyByZXR1cm5zIHRydWUgaW4gbmV3ZXIgYnJvd3NlcnMgYXMgcGVyIHRoZSBzdGFuZGFyZC5cbiAgLy8gQHNlZSBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWRvbWltcGxlbWVudGF0aW9uLWhhc2ZlYXR1cmVcbiAgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnJywgJycpICE9PSB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gY2FwdHVyZSBDaGVjayBpZiB0aGUgY2FwdHVyZSBwaGFzZSBpcyBzdXBwb3J0ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCwgY2FwdHVyZSkge1xuICBpZiAoIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSB8fCBjYXB0dXJlICYmICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGRvY3VtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSBldmVudE5hbWUgaW4gZG9jdW1lbnQ7XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmICghaXNTdXBwb3J0ZWQgJiYgdXNlSGFzRmVhdHVyZSAmJiBldmVudE5hbWVTdWZmaXggPT09ICd3aGVlbCcpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byB0ZXN0IHN1cHBvcnQgZm9yIHRoZSBgd2hlZWxgIGV2ZW50IGluIElFOSsuXG4gICAgaXNTdXBwb3J0ZWQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJyk7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFdmVudFN1cHBvcnRlZDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9pc0V2ZW50U3VwcG9ydGVkLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIG1vZGlmaWVyIGtleSB0byB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBpbiB0aGUgZXZlbnQuXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8ja2V5cy1Nb2RpZmllcnNcbiAqL1xuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gIEFsdDogJ2FsdEtleScsXG4gIENvbnRyb2w6ICdjdHJsS2V5JyxcbiAgTWV0YTogJ21ldGFLZXknLFxuICBTaGlmdDogJ3NoaWZ0S2V5J1xufTtcblxuLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBnZXRNb2RpZmllclN0YXRlIHNvIHdlIHNpbXBseSBtYXAgaXQgdG8gdGhlIG9ubHlcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQgaXRzZWxmLCBkb2VzIG5vdCBzdXBwb3J0IExvY2sta2V5cy5cbi8vIEN1cnJlbnRseSwgYWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBDaHJvbWUgc2VlbXMgdG8gc3VwcG9ydCBMb2NrLWtleXMuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcbiAgaWYgKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpIHtcbiAgICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpO1xuICB9XG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcbiAgcmV0dXJuIGtleVByb3AgPyAhIW5hdGl2ZUV2ZW50W2tleVByb3BdIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudE1vZGlmaWVyU3RhdGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZ2V0RXZlbnRNb2RpZmllclN0YXRlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIERhbmdlciA9IHJlcXVpcmUoJy4vRGFuZ2VyJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcblxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSByZXF1aXJlKCcuL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24nKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xuXG5mdW5jdGlvbiBnZXROb2RlQWZ0ZXIocGFyZW50Tm9kZSwgbm9kZSkge1xuICAvLyBTcGVjaWFsIGNhc2UgZm9yIHRleHQgY29tcG9uZW50cywgd2hpY2ggcmV0dXJuIFtvcGVuLCBjbG9zZV0gY29tbWVudHNcbiAgLy8gZnJvbSBnZXRIb3N0Tm9kZS5cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBub2RlID0gbm9kZVsxXTtcbiAgfVxuICByZXR1cm4gbm9kZSA/IG5vZGUubmV4dFNpYmxpbmcgOiBwYXJlbnROb2RlLmZpcnN0Q2hpbGQ7XG59XG5cbi8qKlxuICogSW5zZXJ0cyBgY2hpbGROb2RlYCBhcyBhIGNoaWxkIG9mIGBwYXJlbnROb2RlYCBhdCB0aGUgYGluZGV4YC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHBhcmVudE5vZGUgUGFyZW50IG5vZGUgaW4gd2hpY2ggdG8gaW5zZXJ0LlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjaGlsZE5vZGUgQ2hpbGQgbm9kZSB0byBpbnNlcnQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBjaGlsZC5cbiAqIEBpbnRlcm5hbFxuICovXG52YXIgaW5zZXJ0Q2hpbGRBdCA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICAvLyBXZSByZWx5IGV4Y2x1c2l2ZWx5IG9uIGBpbnNlcnRCZWZvcmUobm9kZSwgbnVsbClgIGluc3RlYWQgb2YgYWxzbyB1c2luZ1xuICAvLyBgYXBwZW5kQ2hpbGQobm9kZSlgLiAoVXNpbmcgYHVuZGVmaW5lZGAgaXMgbm90IGFsbG93ZWQgYnkgYWxsIGJyb3dzZXJzIHNvXG4gIC8vIHdlIGFyZSBjYXJlZnVsIHRvIHVzZSBgbnVsbGAuKVxuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpO1xufSk7XG5cbmZ1bmN0aW9uIGluc2VydExhenlUcmVlQ2hpbGRBdChwYXJlbnROb2RlLCBjaGlsZFRyZWUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgRE9NTGF6eVRyZWUuaW5zZXJ0VHJlZUJlZm9yZShwYXJlbnROb2RlLCBjaGlsZFRyZWUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiBtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkTm9kZSkpIHtcbiAgICBtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBjaGlsZE5vZGVbMF0sIGNoaWxkTm9kZVsxXSwgcmVmZXJlbmNlTm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgaW5zZXJ0Q2hpbGRBdChwYXJlbnROb2RlLCBjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkKHBhcmVudE5vZGUsIGNoaWxkTm9kZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZE5vZGUpKSB7XG4gICAgdmFyIGNsb3NpbmdDb21tZW50ID0gY2hpbGROb2RlWzFdO1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZVswXTtcbiAgICByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgY2xvc2luZ0NvbW1lbnQpO1xuICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvc2luZ0NvbW1lbnQpO1xuICB9XG4gIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGROb2RlKTtcbn1cblxuZnVuY3Rpb24gbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgb3BlbmluZ0NvbW1lbnQsIGNsb3NpbmdDb21tZW50LCByZWZlcmVuY2VOb2RlKSB7XG4gIHZhciBub2RlID0gb3BlbmluZ0NvbW1lbnQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIG5leHROb2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICBpbnNlcnRDaGlsZEF0KHBhcmVudE5vZGUsIG5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICAgIGlmIChub2RlID09PSBjbG9zaW5nQ29tbWVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG5vZGUgPSBuZXh0Tm9kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIHN0YXJ0Tm9kZSwgY2xvc2luZ0NvbW1lbnQpIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZS5uZXh0U2libGluZztcbiAgICBpZiAobm9kZSA9PT0gY2xvc2luZ0NvbW1lbnQpIHtcbiAgICAgIC8vIFRoZSBjbG9zaW5nIGNvbW1lbnQgaXMgcmVtb3ZlZCBieSBSZWFjdE11bHRpQ2hpbGQuXG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZURlbGltaXRlZFRleHQob3BlbmluZ0NvbW1lbnQsIGNsb3NpbmdDb21tZW50LCBzdHJpbmdUZXh0KSB7XG4gIHZhciBwYXJlbnROb2RlID0gb3BlbmluZ0NvbW1lbnQucGFyZW50Tm9kZTtcbiAgdmFyIG5vZGVBZnRlckNvbW1lbnQgPSBvcGVuaW5nQ29tbWVudC5uZXh0U2libGluZztcbiAgaWYgKG5vZGVBZnRlckNvbW1lbnQgPT09IGNsb3NpbmdDb21tZW50KSB7XG4gICAgLy8gVGhlcmUgYXJlIG5vIHRleHQgbm9kZXMgYmV0d2VlbiB0aGUgb3BlbmluZyBhbmQgY2xvc2luZyBjb21tZW50czsgaW5zZXJ0XG4gICAgLy8gYSBuZXcgb25lIGlmIHN0cmluZ1RleHQgaXNuJ3QgZW1wdHkuXG4gICAgaWYgKHN0cmluZ1RleHQpIHtcbiAgICAgIGluc2VydENoaWxkQXQocGFyZW50Tm9kZSwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc3RyaW5nVGV4dCksIG5vZGVBZnRlckNvbW1lbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc3RyaW5nVGV4dCkge1xuICAgICAgLy8gU2V0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIGZpcnN0IG5vZGUgYWZ0ZXIgdGhlIG9wZW5pbmcgY29tbWVudCwgYW5kXG4gICAgICAvLyByZW1vdmUgYWxsIGZvbGxvd2luZyBub2RlcyB1cCB1bnRpbCB0aGUgY2xvc2luZyBjb21tZW50LlxuICAgICAgc2V0VGV4dENvbnRlbnQobm9kZUFmdGVyQ29tbWVudCwgc3RyaW5nVGV4dCk7XG4gICAgICByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIG5vZGVBZnRlckNvbW1lbnQsIGNsb3NpbmdDb21tZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBvcGVuaW5nQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICBpbnN0YW5jZUlEOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShvcGVuaW5nQ29tbWVudCkuX2RlYnVnSUQsXG4gICAgICB0eXBlOiAncmVwbGFjZSB0ZXh0JyxcbiAgICAgIHBheWxvYWQ6IHN0cmluZ1RleHRcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAgPSBEYW5nZXIuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXA7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCA9IGZ1bmN0aW9uIChvbGRDaGlsZCwgbWFya3VwLCBwcmV2SW5zdGFuY2UpIHtcbiAgICBEYW5nZXIuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAob2xkQ2hpbGQsIG1hcmt1cCk7XG4gICAgaWYgKHByZXZJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgIGluc3RhbmNlSUQ6IHByZXZJbnN0YW5jZS5fZGVidWdJRCxcbiAgICAgICAgdHlwZTogJ3JlcGxhY2Ugd2l0aCcsXG4gICAgICAgIHBheWxvYWQ6IG1hcmt1cC50b1N0cmluZygpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5leHRJbnN0YW5jZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG1hcmt1cC5ub2RlKTtcbiAgICAgIGlmIChuZXh0SW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgICAgaW5zdGFuY2VJRDogbmV4dEluc3RhbmNlLl9kZWJ1Z0lELFxuICAgICAgICAgIHR5cGU6ICdtb3VudCcsXG4gICAgICAgICAgcGF5bG9hZDogbWFya3VwLnRvU3RyaW5nKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIHVwZGF0aW5nIHdpdGggRE9NIGNoaWxkcmVuLlxuICovXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0ge1xuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDogZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAsXG5cbiAgcmVwbGFjZURlbGltaXRlZFRleHQ6IHJlcGxhY2VEZWxpbWl0ZWRUZXh0LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgY29tcG9uZW50J3MgY2hpbGRyZW4gYnkgcHJvY2Vzc2luZyBhIHNlcmllcyBvZiB1cGRhdGVzLiBUaGVcbiAgICogdXBkYXRlIGNvbmZpZ3VyYXRpb25zIGFyZSBlYWNoIGV4cGVjdGVkIHRvIGhhdmUgYSBgcGFyZW50Tm9kZWAgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXk8b2JqZWN0Pn0gdXBkYXRlcyBMaXN0IG9mIHVwZGF0ZSBjb25maWd1cmF0aW9ucy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm9jZXNzVXBkYXRlczogZnVuY3Rpb24gKHBhcmVudE5vZGUsIHVwZGF0ZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHBhcmVudE5vZGVEZWJ1Z0lEID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUocGFyZW50Tm9kZSkuX2RlYnVnSUQ7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCB1cGRhdGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICB2YXIgdXBkYXRlID0gdXBkYXRlc1trXTtcbiAgICAgIHN3aXRjaCAodXBkYXRlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnSU5TRVJUX01BUktVUCc6XG4gICAgICAgICAgaW5zZXJ0TGF6eVRyZWVDaGlsZEF0KHBhcmVudE5vZGUsIHVwZGF0ZS5jb250ZW50LCBnZXROb2RlQWZ0ZXIocGFyZW50Tm9kZSwgdXBkYXRlLmFmdGVyTm9kZSkpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgICAgICAgaW5zdGFuY2VJRDogcGFyZW50Tm9kZURlYnVnSUQsXG4gICAgICAgICAgICAgIHR5cGU6ICdpbnNlcnQgY2hpbGQnLFxuICAgICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgdG9JbmRleDogdXBkYXRlLnRvSW5kZXgsXG4gICAgICAgICAgICAgICAgY29udGVudDogdXBkYXRlLmNvbnRlbnQudG9TdHJpbmcoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ01PVkVfRVhJU1RJTkcnOlxuICAgICAgICAgIG1vdmVDaGlsZChwYXJlbnROb2RlLCB1cGRhdGUuZnJvbU5vZGUsIGdldE5vZGVBZnRlcihwYXJlbnROb2RlLCB1cGRhdGUuYWZ0ZXJOb2RlKSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICAgICAgICBpbnN0YW5jZUlEOiBwYXJlbnROb2RlRGVidWdJRCxcbiAgICAgICAgICAgICAgdHlwZTogJ21vdmUgY2hpbGQnLFxuICAgICAgICAgICAgICBwYXlsb2FkOiB7IGZyb21JbmRleDogdXBkYXRlLmZyb21JbmRleCwgdG9JbmRleDogdXBkYXRlLnRvSW5kZXggfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdTRVRfTUFSS1VQJzpcbiAgICAgICAgICBzZXRJbm5lckhUTUwocGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgICAgICAgaW5zdGFuY2VJRDogcGFyZW50Tm9kZURlYnVnSUQsXG4gICAgICAgICAgICAgIHR5cGU6ICdyZXBsYWNlIGNoaWxkcmVuJyxcbiAgICAgICAgICAgICAgcGF5bG9hZDogdXBkYXRlLmNvbnRlbnQudG9TdHJpbmcoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdURVhUX0NPTlRFTlQnOlxuICAgICAgICAgIHNldFRleHRDb250ZW50KHBhcmVudE5vZGUsIHVwZGF0ZS5jb250ZW50KTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgICAgICAgIGluc3RhbmNlSUQ6IHBhcmVudE5vZGVEZWJ1Z0lELFxuICAgICAgICAgICAgICB0eXBlOiAncmVwbGFjZSB0ZXh0JyxcbiAgICAgICAgICAgICAgcGF5bG9hZDogdXBkYXRlLmNvbnRlbnQudG9TdHJpbmcoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdSRU1PVkVfTk9ERSc6XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgdXBkYXRlLmZyb21Ob2RlKTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgICAgICAgIGluc3RhbmNlSUQ6IHBhcmVudE5vZGVEZWJ1Z0lELFxuICAgICAgICAgICAgICB0eXBlOiAncmVtb3ZlIGNoaWxkJyxcbiAgICAgICAgICAgICAgcGF5bG9hZDogeyBmcm9tSW5kZXg6IHVwZGF0ZS5mcm9tSW5kZXggfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01DaGlsZHJlbk9wZXJhdGlvbnM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTU5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJyxcbiAgbWF0aG1sOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCcsXG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01OYW1lc3BhY2VzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0RPTU5hbWVzcGFjZXMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuLyogZ2xvYmFscyBNU0FwcCAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi9cblxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSBmdW5jdGlvbiAoZnVuYykge1xuICBpZiAodHlwZW9mIE1TQXBwICE9PSAndW5kZWZpbmVkJyAmJiBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuYyhhcmcwLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9jcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xudmFyIHByb3BUeXBlc0ZhY3RvcnkgPSByZXF1aXJlKCdwcm9wLXR5cGVzL2ZhY3RvcnknKTtcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Jyk7XG52YXIgUHJvcFR5cGVzID0gcHJvcFR5cGVzRmFjdG9yeShSZWFjdC5pc1ZhbGlkRWxlbWVudCk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgYnV0dG9uOiB0cnVlLFxuICBjaGVja2JveDogdHJ1ZSxcbiAgaW1hZ2U6IHRydWUsXG4gIGhpZGRlbjogdHJ1ZSxcbiAgcmFkaW86IHRydWUsXG4gIHJlc2V0OiB0cnVlLFxuICBzdWJtaXQ6IHRydWVcbn07XG5cbmZ1bmN0aW9uIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpIHtcbiAgIShpbnB1dFByb3BzLmNoZWNrZWRMaW5rID09IG51bGwgfHwgaW5wdXRQcm9wcy52YWx1ZUxpbmsgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSBjaGVja2VkTGluayBhbmQgYSB2YWx1ZUxpbmsuIElmIHlvdSB3YW50IHRvIHVzZSBjaGVja2VkTGluaywgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgdmFsdWVMaW5rIGFuZCB2aWNlIHZlcnNhLicpIDogX3Byb2RJbnZhcmlhbnQoJzg3JykgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpIHtcbiAgX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcyk7XG4gICEoaW5wdXRQcm9wcy52YWx1ZSA9PSBudWxsICYmIGlucHV0UHJvcHMub25DaGFuZ2UgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSB2YWx1ZUxpbmsgYW5kIGEgdmFsdWUgb3Igb25DaGFuZ2UgZXZlbnQuIElmIHlvdSB3YW50IHRvIHVzZSB2YWx1ZSBvciBvbkNoYW5nZSwgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgdmFsdWVMaW5rLicpIDogX3Byb2RJbnZhcmlhbnQoJzg4JykgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKSB7XG4gIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpO1xuICAhKGlucHV0UHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIGlucHV0UHJvcHMub25DaGFuZ2UgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSBjaGVja2VkTGluayBhbmQgYSBjaGVja2VkIHByb3BlcnR5IG9yIG9uQ2hhbmdlIGV2ZW50LiBJZiB5b3Ugd2FudCB0byB1c2UgY2hlY2tlZCBvciBvbkNoYW5nZSwgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgY2hlY2tlZExpbmsnKSA6IF9wcm9kSW52YXJpYW50KCc4OScpIDogdm9pZCAwO1xufVxuXG52YXIgcHJvcFR5cGVzID0ge1xuICB2YWx1ZTogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICB9LFxuICBjaGVja2VkOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgfSxcbiAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jXG59O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBQcm92aWRlIGEgbGlua2VkIGB2YWx1ZWAgYXR0cmlidXRlIGZvciBjb250cm9sbGVkIGZvcm1zLiBZb3Ugc2hvdWxkIG5vdCB1c2VcbiAqIHRoaXMgb3V0c2lkZSBvZiB0aGUgUmVhY3RET00gY29udHJvbGxlZCBmb3JtIGNvbXBvbmVudHMuXG4gKi9cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0ge1xuICBjaGVja1Byb3BUeXBlczogZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BzLCBvd25lcikge1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgICAgaWYgKHByb3BUeXBlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yID0gcHJvcFR5cGVzW3Byb3BOYW1lXShwcm9wcywgcHJvcE5hbWUsIHRhZ05hbWUsICdwcm9wJywgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgZm9ybSBwcm9wVHlwZTogJXMlcycsIGVycm9yLm1lc3NhZ2UsIGFkZGVuZHVtKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHsqfSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dCBlaXRoZXIgZnJvbSB2YWx1ZSBwcm9wIG9yIGxpbmsuXG4gICAqL1xuICBnZXRWYWx1ZTogZnVuY3Rpb24gKGlucHV0UHJvcHMpIHtcbiAgICBpZiAoaW5wdXRQcm9wcy52YWx1ZUxpbmspIHtcbiAgICAgIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy52YWx1ZUxpbmsudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Kn0gY3VycmVudCBjaGVja2VkIHN0YXR1cyBvZiB0aGUgaW5wdXQgZWl0aGVyIGZyb20gY2hlY2tlZCBwcm9wXG4gICAqICAgICAgICAgICAgIG9yIGxpbmsuXG4gICAqL1xuICBnZXRDaGVja2VkOiBmdW5jdGlvbiAoaW5wdXRQcm9wcykge1xuICAgIGlmIChpbnB1dFByb3BzLmNoZWNrZWRMaW5rKSB7XG4gICAgICBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkTGluay52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0UHJvcHMuY2hlY2tlZDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IGNoYW5nZSBldmVudCB0byBoYW5kbGVcbiAgICovXG4gIGV4ZWN1dGVPbkNoYW5nZTogZnVuY3Rpb24gKGlucHV0UHJvcHMsIGV2ZW50KSB7XG4gICAgaWYgKGlucHV0UHJvcHMudmFsdWVMaW5rKSB7XG4gICAgICBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWVMaW5rLnJlcXVlc3RDaGFuZ2UoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0UHJvcHMuY2hlY2tlZExpbmspIHtcbiAgICAgIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWRMaW5rLnJlcXVlc3RDaGFuZ2UoZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRQcm9wcy5vbkNoYW5nZSkge1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMub25DaGFuZ2UuY2FsbCh1bmRlZmluZWQsIGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGlua2VkVmFsdWVVdGlscztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9MaW5rZWRWYWx1ZVV0aWxzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBpbmplY3RlZCA9IGZhbHNlO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHtcbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgaW5qZWN0YWJsZSBob29rIGZvciBzd2FwcGluZyBvdXQgbW91bnQgaW1hZ2VzIGluIHRoZSBtaWRkbGUgb2ZcbiAgICogdGhlIHRyZWUuXG4gICAqL1xuICByZXBsYWNlTm9kZVdpdGhNYXJrdXA6IG51bGwsXG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgaW5qZWN0YWJsZSBob29rIGZvciBwcm9jZXNzaW5nIGEgcXVldWUgb2YgY2hpbGQgdXBkYXRlcy4gV2lsbFxuICAgKiBsYXRlciBtb3ZlIGludG8gTXVsdGlDaGlsZENvbXBvbmVudHMuXG4gICAqL1xuICBwcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiBudWxsLFxuXG4gIGluamVjdGlvbjoge1xuICAgIGluamVjdEVudmlyb25tZW50OiBmdW5jdGlvbiAoZW52aXJvbm1lbnQpIHtcbiAgICAgICEhaW5qZWN0ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQ6IGluamVjdEVudmlyb25tZW50KCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuJykgOiBfcHJvZEludmFyaWFudCgnMTA0JykgOiB2b2lkIDA7XG4gICAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cCA9IGVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cDtcbiAgICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyA9IGVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXM7XG4gICAgICBpbmplY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICogXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgaWYgKHggPT09IHkpIHtcbiAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgIC8vIEFkZGVkIHRoZSBub256ZXJvIHkgY2hlY2sgdG8gbWFrZSBGbG93IGhhcHB5LCBidXQgaXQgaXMgcmVkdW5kYW50XG4gICAgcmV0dXJuIHggIT09IDAgfHwgeSAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5cbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKGlzKG9iakEsIG9iakIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgIWlzKG9iakFba2V5c0FbaV1dLCBvYmpCW2tleXNBW2ldXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaGFsbG93RXF1YWw7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL3NoYWxsb3dFcXVhbC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2l2ZW4gYSBgcHJldkVsZW1lbnRgIGFuZCBgbmV4dEVsZW1lbnRgLCBkZXRlcm1pbmVzIGlmIHRoZSBleGlzdGluZ1xuICogaW5zdGFuY2Ugc2hvdWxkIGJlIHVwZGF0ZWQgYXMgb3Bwb3NlZCB0byBiZWluZyBkZXN0cm95ZWQgb3IgcmVwbGFjZWQgYnkgYSBuZXdcbiAqIGluc3RhbmNlLiBCb3RoIGFyZ3VtZW50cyBhcmUgZWxlbWVudHMuIFRoaXMgZW5zdXJlcyB0aGF0IHRoaXMgbG9naWMgY2FuXG4gKiBvcGVyYXRlIG9uIHN0YXRlbGVzcyB0cmVlcyB3aXRob3V0IGFueSBiYWNraW5nIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gcHJldkVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gbmV4dEVsZW1lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV4aXN0aW5nIGluc3RhbmNlIHNob3VsZCBiZSB1cGRhdGVkLlxuICogQHByb3RlY3RlZFxuICovXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkge1xuICB2YXIgcHJldkVtcHR5ID0gcHJldkVsZW1lbnQgPT09IG51bGwgfHwgcHJldkVsZW1lbnQgPT09IGZhbHNlO1xuICB2YXIgbmV4dEVtcHR5ID0gbmV4dEVsZW1lbnQgPT09IG51bGwgfHwgbmV4dEVsZW1lbnQgPT09IGZhbHNlO1xuICBpZiAocHJldkVtcHR5IHx8IG5leHRFbXB0eSkge1xuICAgIHJldHVybiBwcmV2RW1wdHkgPT09IG5leHRFbXB0eTtcbiAgfVxuXG4gIHZhciBwcmV2VHlwZSA9IHR5cGVvZiBwcmV2RWxlbWVudDtcbiAgdmFyIG5leHRUeXBlID0gdHlwZW9mIG5leHRFbGVtZW50O1xuICBpZiAocHJldlR5cGUgPT09ICdzdHJpbmcnIHx8IHByZXZUeXBlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBuZXh0VHlwZSA9PT0gJ3N0cmluZycgfHwgbmV4dFR5cGUgPT09ICdudW1iZXInO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgcHJldkVsZW1lbnQudHlwZSA9PT0gbmV4dEVsZW1lbnQudHlwZSAmJiBwcmV2RWxlbWVudC5rZXkgPT09IG5leHRFbGVtZW50LmtleTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0gKCcnICsga2V5KS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuXG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuXG4vKipcbiAqIFVuZXNjYXBlIGFuZCB1bndyYXAga2V5IGZvciBodW1hbi1yZWFkYWJsZSBkaXNwbGF5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byB1bmVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHVuZXNjYXBlZCBrZXkuXG4gKi9cbmZ1bmN0aW9uIHVuZXNjYXBlKGtleSkge1xuICB2YXIgdW5lc2NhcGVSZWdleCA9IC8oPTB8PTIpL2c7XG4gIHZhciB1bmVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0wJzogJz0nLFxuICAgICc9Mic6ICc6J1xuICB9O1xuICB2YXIga2V5U3Vic3RyaW5nID0ga2V5WzBdID09PSAnLicgJiYga2V5WzFdID09PSAnJCcgPyBrZXkuc3Vic3RyaW5nKDIpIDoga2V5LnN1YnN0cmluZygxKTtcblxuICByZXR1cm4gKCcnICsga2V5U3Vic3RyaW5nKS5yZXBsYWNlKHVuZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiB1bmVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcbn1cblxudmFyIEtleUVzY2FwZVV0aWxzID0ge1xuICBlc2NhcGU6IGVzY2FwZSxcbiAgdW5lc2NhcGU6IHVuZXNjYXBlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleUVzY2FwZVV0aWxzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0tleUVzY2FwZVV0aWxzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpIHtcbiAgUmVhY3RVcGRhdGVzLmVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudChhcmcpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgYXJnO1xuICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICB2YXIgZGlzcGxheU5hbWUgPSBhcmcuY29uc3RydWN0b3IgJiYgYXJnLmNvbnN0cnVjdG9yLm5hbWUgfHwgdHlwZTtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhcmcpO1xuICBpZiAoa2V5cy5sZW5ndGggPiAwICYmIGtleXMubGVuZ3RoIDwgMjApIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWUgKyAnIChrZXlzOiAnICsga2V5cy5qb2luKCcsICcpICsgJyknO1xuICB9XG4gIHJldHVybiBkaXNwbGF5TmFtZTtcbn1cblxuZnVuY3Rpb24gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHZhciBpbnRlcm5hbEluc3RhbmNlID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQocHVibGljSW5zdGFuY2UpO1xuICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICAgIC8vIE9ubHkgd2FybiB3aGVuIHdlIGhhdmUgYSBjYWxsZXJOYW1lLiBPdGhlcndpc2Ugd2Ugc2hvdWxkIGJlIHNpbGVudC5cbiAgICAgIC8vIFdlJ3JlIHByb2JhYmx5IGNhbGxpbmcgZnJvbSBlbnF1ZXVlQ2FsbGJhY2suIFdlIGRvbid0IHdhbnQgdG8gd2FyblxuICAgICAgLy8gdGhlcmUgYmVjYXVzZSB3ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgbGlmZWN5Y2xlIG1ldGhvZC5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjYWxsZXJOYW1lLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiAnICsgJ1RoaXMgaXMgYSBuby1vcC4gUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGN0b3IgJiYgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcycpIDogdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAnJXMoLi4uKTogQ2Fubm90IHVwZGF0ZSBkdXJpbmcgYW4gZXhpc3Rpbmcgc3RhdGUgdHJhbnNpdGlvbiAoc3VjaCBhcyAnICsgXCJ3aXRoaW4gYHJlbmRlcmAgb3IgYW5vdGhlciBjb21wb25lbnQncyBjb25zdHJ1Y3RvcikuIFJlbmRlciBtZXRob2RzIFwiICsgJ3Nob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyBjb25zdHJ1Y3RvciAnICsgJ3NpZGUtZWZmZWN0cyBhcmUgYW4gYW50aS1wYXR0ZXJuLCBidXQgY2FuIGJlIG1vdmVkIHRvICcgKyAnYGNvbXBvbmVudFdpbGxNb3VudGAuJywgY2FsbGVyTmFtZSkgOiB2b2lkIDA7XG4gIH1cblxuICByZXR1cm4gaW50ZXJuYWxJbnN0YW5jZTtcbn1cblxuLyoqXG4gKiBSZWFjdFVwZGF0ZVF1ZXVlIGFsbG93cyBmb3Igc3RhdGUgdXBkYXRlcyB0byBiZSBzY2hlZHVsZWQgaW50byBhIGxhdGVyXG4gKiByZWNvbmNpbGlhdGlvbiBzdGVwLlxuICovXG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgICBpZiAob3duZXIgIT09IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcob3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgICBvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHB1YmxpY0luc3RhbmNlKTtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgLy8gRHVyaW5nIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgcmVuZGVyIHRoaXMgd2lsbCBzdGlsbCBiZSBudWxsIGJ1dCBhZnRlclxuICAgICAgLy8gdGhhdCB3aWxsIGFsd2F5cyByZW5kZXIgdG8gc29tZXRoaW5nLiBBdCBsZWFzdCBmb3Igbm93LiBTbyB3ZSBjYW4gdXNlXG4gICAgICAvLyB0aGlzIGhhY2suXG4gICAgICByZXR1cm4gISFpbnRlcm5hbEluc3RhbmNlLl9yZW5kZXJlZENvbXBvbmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWxsZXJOYW1lIE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUNhbGxiYWNrOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgUmVhY3RVcGRhdGVRdWV1ZS52YWxpZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBjYWxsZXJOYW1lKTtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG5cbiAgICAvLyBQcmV2aW91c2x5IHdlIHdvdWxkIHRocm93IGFuIGVycm9yIGlmIHdlIGRpZG4ndCBoYXZlIGFuIGludGVybmFsXG4gICAgLy8gaW5zdGFuY2UuIFNpbmNlIHdlIHdhbnQgdG8gbWFrZSBpdCBhIG5vLW9wIGluc3RlYWQsIHdlIG1pcnJvciB0aGUgc2FtZVxuICAgIC8vIGJlaGF2aW9yIHdlIGhhdmUgaW4gb3RoZXIgZW5xdWV1ZSogbWV0aG9kcy5cbiAgICAvLyBXZSBhbHNvIG5lZWQgdG8gaWdub3JlIGNhbGxiYWNrcyBpbiBjb21wb25lbnRXaWxsTW91bnQuIFNlZVxuICAgIC8vIGVucXVldWVVcGRhdGVzLlxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MpIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MgPSBbY2FsbGJhY2tdO1xuICAgIH1cbiAgICAvLyBUT0RPOiBUaGUgY2FsbGJhY2sgaGVyZSBpcyBpZ25vcmVkIHdoZW4gc2V0U3RhdGUgaXMgY2FsbGVkIGZyb21cbiAgICAvLyBjb21wb25lbnRXaWxsTW91bnQuIEVpdGhlciBmaXggaXQgb3IgZGlzYWxsb3cgZG9pbmcgc28gY29tcGxldGVseSBpblxuICAgIC8vIGZhdm9yIG9mIGdldEluaXRpYWxTdGF0ZS4gQWx0ZXJuYXRpdmVseSwgd2UgY2FuIGRpc2FsbG93XG4gICAgLy8gY29tcG9uZW50V2lsbE1vdW50IGR1cmluZyBzZXJ2ZXItc2lkZSByZW5kZXJpbmcuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICBlbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MpIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MgPSBbY2FsbGJhY2tdO1xuICAgIH1cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gdHJ1ZTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gW2NvbXBsZXRlU3RhdGVdO1xuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSB0cnVlO1xuXG4gICAgLy8gRnV0dXJlLXByb29mIDE1LjVcbiAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS52YWxpZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCAncmVwbGFjZVN0YXRlJyk7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcykge1xuICAgICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcyA9IFtjYWxsYmFja107XG4gICAgICB9XG4gICAgfVxuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0U3RhdGUoKTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHBhcnRpYWxTdGF0ZSAhPSBudWxsLCAnc2V0U3RhdGUoLi4uKTogWW91IHBhc3NlZCBhbiB1bmRlZmluZWQgb3IgbnVsbCBzdGF0ZSBvYmplY3Q7ICcgKyAnaW5zdGVhZCwgdXNlIGZvcmNlVXBkYXRlKCkuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHF1ZXVlID0gaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1N0YXRlUXVldWUgfHwgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gW10pO1xuICAgIHF1ZXVlLnB1c2gocGFydGlhbFN0YXRlKTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgZW5xdWV1ZUVsZW1lbnRJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIG5leHRFbGVtZW50LCBuZXh0Q29udGV4dCkge1xuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XG4gICAgLy8gVE9ETzogaW50cm9kdWNlIF9wZW5kaW5nQ29udGV4dCBpbnN0ZWFkIG9mIHNldHRpbmcgaXQgZGlyZWN0bHkuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fY29udGV4dCA9IG5leHRDb250ZXh0O1xuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgdmFsaWRhdGVDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgISghY2FsbGJhY2sgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudChjYWxsYmFjaykpIDogX3Byb2RJbnZhcmlhbnQoJzEyMicsIGNhbGxlck5hbWUsIGZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudChjYWxsYmFjaykpIDogdm9pZCAwO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlUXVldWU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RVcGRhdGVRdWV1ZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gVGhpcyB2YWxpZGF0aW9uIGNvZGUgd2FzIHdyaXR0ZW4gYmFzZWQgb24gdGhlIEhUTUw1IHBhcnNpbmcgc3BlYzpcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgLy9cbiAgLy8gTm90ZTogdGhpcyBkb2VzIG5vdCBjYXRjaCBhbGwgaW52YWxpZCBuZXN0aW5nLCBub3IgZG9lcyBpdCB0cnkgdG8gKGFzIGl0J3NcbiAgLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcbiAgLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4gIC8vIGludGVuZGVkLiBGb3IgZXhhbXBsZSwgPGI+PGRpdj48L2Rpdj48L2I+IGlzIGludmFsaWQgYnV0IHdlIGRvbid0IHdhcm5cbiAgLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxuICAvLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbiAgLy8gZmlyc3QsIGNhdXNpbmcgYSBjb25mdXNpbmcgbWVzcy5cblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNzcGVjaWFsXG4gIHZhciBzcGVjaWFsVGFncyA9IFsnYWRkcmVzcycsICdhcHBsZXQnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2Jhc2UnLCAnYmFzZWZvbnQnLCAnYmdzb3VuZCcsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NvbCcsICdjb2xncm91cCcsICdkZCcsICdkZXRhaWxzJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZW1iZWQnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnZnJhbWUnLCAnZnJhbWVzZXQnLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpc2luZGV4JywgJ2xpJywgJ2xpbmsnLCAnbGlzdGluZycsICdtYWluJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRhJywgJ25hdicsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ29iamVjdCcsICdvbCcsICdwJywgJ3BhcmFtJywgJ3BsYWludGV4dCcsICdwcmUnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NvdXJjZScsICdzdHlsZScsICdzdW1tYXJ5JywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3RyJywgJ3RyYWNrJywgJ3VsJywgJ3dicicsICd4bXAnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICB2YXIgaW5TY29wZVRhZ3MgPSBbJ2FwcGxldCcsICdjYXB0aW9uJywgJ2h0bWwnLCAndGFibGUnLCAndGQnLCAndGgnLCAnbWFycXVlZScsICdvYmplY3QnLCAndGVtcGxhdGUnLFxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbiAgLy8gVE9ETzogRGlzdGluZ3Vpc2ggYnkgbmFtZXNwYWNlIGhlcmUgLS0gZm9yIDx0aXRsZT4sIGluY2x1ZGluZyBpdCBoZXJlXG4gIC8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3NcbiAgJ2ZvcmVpZ25PYmplY3QnLCAnZGVzYycsICd0aXRsZSddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLWJ1dHRvbi1zY29wZVxuICB2YXIgYnV0dG9uU2NvcGVUYWdzID0gaW5TY29wZVRhZ3MuY29uY2F0KFsnYnV0dG9uJ10pO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2dlbmVyYXRlLWltcGxpZWQtZW5kLXRhZ3NcbiAgdmFyIGltcGxpZWRFbmRUYWdzID0gWydkZCcsICdkdCcsICdsaScsICdvcHRpb24nLCAnb3B0Z3JvdXAnLCAncCcsICdycCcsICdydCddO1xuXG4gIHZhciBlbXB0eUFuY2VzdG9ySW5mbyA9IHtcbiAgICBjdXJyZW50OiBudWxsLFxuXG4gICAgZm9ybVRhZzogbnVsbCxcbiAgICBhVGFnSW5TY29wZTogbnVsbCxcbiAgICBidXR0b25UYWdJblNjb3BlOiBudWxsLFxuICAgIG5vYnJUYWdJblNjb3BlOiBudWxsLFxuICAgIHBUYWdJbkJ1dHRvblNjb3BlOiBudWxsLFxuXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbFxuICB9O1xuXG4gIHZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gZnVuY3Rpb24gKG9sZEluZm8sIHRhZywgaW5zdGFuY2UpIHtcbiAgICB2YXIgYW5jZXN0b3JJbmZvID0gX2Fzc2lnbih7fSwgb2xkSW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGluZm8gPSB7IHRhZzogdGFnLCBpbnN0YW5jZTogaW5zdGFuY2UgfTtcblxuICAgIGlmIChpblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGJ1dHRvblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlZSBydWxlcyBmb3IgJ2xpJywgJ2RkJywgJ2R0JyBzdGFydCB0YWdzIGluXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIGlmIChzcGVjaWFsVGFncy5pbmRleE9mKHRhZykgIT09IC0xICYmIHRhZyAhPT0gJ2FkZHJlc3MnICYmIHRhZyAhPT0gJ2RpdicgJiYgdGFnICE9PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JJbmZvLmN1cnJlbnQgPSBpbmZvO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2Zvcm0nKSB7XG4gICAgICBhbmNlc3RvckluZm8uZm9ybVRhZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdhJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2J1dHRvbicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ25vYnInKSB7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdsaScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2RkJyB8fCB0YWcgPT09ICdkdCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2VzdG9ySW5mbztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgaXNUYWdWYWxpZFdpdGhQYXJlbnQgPSBmdW5jdGlvbiAodGFnLCBwYXJlbnRUYWcpIHtcbiAgICAvLyBGaXJzdCwgbGV0J3MgY2hlY2sgaWYgd2UncmUgaW4gYW4gdW51c3VhbCBwYXJzaW5nIG1vZGUuLi5cbiAgICBzd2l0Y2ggKHBhcmVudFRhZykge1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluc2VsZWN0XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICdvcHRncm91cCcgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgY2FzZSAnb3B0Z3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBTdHJpY3RseSBzcGVha2luZywgc2VlaW5nIGFuIDxvcHRpb24+IGRvZXNuJ3QgbWVhbiB3ZSdyZSBpbiBhIDxzZWxlY3Q+XG4gICAgICAvLyBidXRcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50ZFxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY2FwdGlvblxuICAgICAgLy8gTm8gc3BlY2lhbCBiZWhhdmlvciBzaW5jZSB0aGVzZSBydWxlcyBmYWxsIGJhY2sgdG8gXCJpbiBib2R5XCIgbW9kZSBmb3JcbiAgICAgIC8vIGFsbCBleGNlcHQgc3BlY2lhbCB0YWJsZSBub2RlcyB3aGljaCBjYXVzZSBiYWQgcGFyc2luZyBiZWhhdmlvciBhbnl3YXkuXG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRyXG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0aCcgfHwgdGFnID09PSAndGQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRib2R5XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0cicgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY29sZ3JvdXBcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NvbCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGFibGVcbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NhcHRpb24nIHx8IHRhZyA9PT0gJ2NvbGdyb3VwJyB8fCB0YWcgPT09ICd0Ym9keScgfHwgdGFnID09PSAndGZvb3QnIHx8IHRhZyA9PT0gJ3RoZWFkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5oZWFkXG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2Jhc2UnIHx8IHRhZyA9PT0gJ2Jhc2Vmb250JyB8fCB0YWcgPT09ICdiZ3NvdW5kJyB8fCB0YWcgPT09ICdsaW5rJyB8fCB0YWcgPT09ICdtZXRhJyB8fCB0YWcgPT09ICd0aXRsZScgfHwgdGFnID09PSAnbm9zY3JpcHQnIHx8IHRhZyA9PT0gJ25vZnJhbWVzJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCN0aGUtaHRtbC1lbGVtZW50XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2hlYWQnIHx8IHRhZyA9PT0gJ2JvZHknO1xuICAgICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2h0bWwnO1xuICAgIH1cblxuICAgIC8vIFByb2JhYmx5IGluIHRoZSBcImluIGJvZHlcIiBwYXJzaW5nIG1vZGUsIHNvIHdlIG91dGxhdyBvbmx5IHRhZyBjb21ib3NcbiAgICAvLyB3aGVyZSB0aGUgcGFyc2luZyBydWxlcyBjYXVzZSBpbXBsaWNpdCBvcGVucyBvciBjbG9zZXMgdG8gYmUgYWRkZWQuXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgIT09ICdoMScgJiYgcGFyZW50VGFnICE9PSAnaDInICYmIHBhcmVudFRhZyAhPT0gJ2gzJyAmJiBwYXJlbnRUYWcgIT09ICdoNCcgJiYgcGFyZW50VGFnICE9PSAnaDUnICYmIHBhcmVudFRhZyAhPT0gJ2g2JztcblxuICAgICAgY2FzZSAncnAnOlxuICAgICAgY2FzZSAncnQnOlxuICAgICAgICByZXR1cm4gaW1wbGllZEVuZFRhZ3MuaW5kZXhPZihwYXJlbnRUYWcpID09PSAtMTtcblxuICAgICAgY2FzZSAnYm9keSc6XG4gICAgICBjYXNlICdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2NvbCc6XG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgY2FzZSAndGgnOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndHInOlxuICAgICAgICAvLyBUaGVzZSB0YWdzIGFyZSBvbmx5IHZhbGlkIHdpdGggYSBmZXcgcGFyZW50cyB0aGF0IGhhdmUgc3BlY2lhbCBjaGlsZFxuICAgICAgICAvLyBwYXJzaW5nIHJ1bGVzIC0tIGlmIHdlJ3JlIGRvd24gaGVyZSwgdGhlbiBub25lIG9mIHRob3NlIG1hdGNoZWQgYW5kXG4gICAgICAgIC8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxuICAgICAgICAvLyBjYXNlcyBhcmUgaW52YWxpZC5cbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyA9PSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgY2FzZSAnYXJ0aWNsZSc6XG4gICAgICBjYXNlICdhc2lkZSc6XG4gICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBjYXNlICdkaXInOlxuICAgICAgY2FzZSAnZGl2JzpcbiAgICAgIGNhc2UgJ2RsJzpcbiAgICAgIGNhc2UgJ2ZpZWxkc2V0JzpcbiAgICAgIGNhc2UgJ2ZpZ2NhcHRpb24nOlxuICAgICAgY2FzZSAnZmlndXJlJzpcbiAgICAgIGNhc2UgJ2Zvb3Rlcic6XG4gICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgY2FzZSAnaGdyb3VwJzpcbiAgICAgIGNhc2UgJ21haW4nOlxuICAgICAgY2FzZSAnbWVudSc6XG4gICAgICBjYXNlICduYXYnOlxuICAgICAgY2FzZSAnb2wnOlxuICAgICAgY2FzZSAncCc6XG4gICAgICBjYXNlICdzZWN0aW9uJzpcbiAgICAgIGNhc2UgJ3N1bW1hcnknOlxuICAgICAgY2FzZSAndWwnOlxuICAgICAgY2FzZSAncHJlJzpcbiAgICAgIGNhc2UgJ2xpc3RpbmcnOlxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgY2FzZSAnaHInOlxuICAgICAgY2FzZSAneG1wJzpcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZm9ybVRhZyB8fCBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2xpJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdkZCc6XG4gICAgICBjYXNlICdkdCc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIC8vIFNwZWMgc2F5cyBzb21ldGhpbmcgYWJvdXQgc3RvcmluZyBhIGxpc3Qgb2YgbWFya2VycywgYnV0IGl0IHNvdW5kc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIHRoaXMgY2hlY2suXG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ25vYnInOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHaXZlbiBhIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50IGluc3RhbmNlLCByZXR1cm4gYSBsaXN0IG9mIGl0cyByZWN1cnNpdmVcbiAgICogb3duZXJzLCBzdGFydGluZyBhdCB0aGUgcm9vdCBhbmQgZW5kaW5nIHdpdGggdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHZhciBmaW5kT3duZXJTdGFjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICBkbyB7XG4gICAgICBzdGFjay5wdXNoKGluc3RhbmNlKTtcbiAgICB9IHdoaWxlIChpbnN0YW5jZSA9IGluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXIpO1xuICAgIHN0YWNrLnJldmVyc2UoKTtcbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG5cbiAgdmFyIGRpZFdhcm4gPSB7fTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcgPSBmdW5jdGlvbiAoY2hpbGRUYWcsIGNoaWxkVGV4dCwgY2hpbGRJbnN0YW5jZSwgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG5cbiAgICBpZiAoY2hpbGRUZXh0ICE9IG51bGwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGNoaWxkVGFnID09IG51bGwsICd2YWxpZGF0ZURPTU5lc3Rpbmc6IHdoZW4gY2hpbGRUZXh0IGlzIHBhc3NlZCwgY2hpbGRUYWcgc2hvdWxkIGJlIG51bGwnKSA6IHZvaWQgMDtcbiAgICAgIGNoaWxkVGFnID0gJyN0ZXh0JztcbiAgICB9XG5cbiAgICB2YXIgaW52YWxpZFBhcmVudCA9IGlzVGFnVmFsaWRXaXRoUGFyZW50KGNoaWxkVGFnLCBwYXJlbnRUYWcpID8gbnVsbCA6IHBhcmVudEluZm87XG4gICAgdmFyIGludmFsaWRBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgPyBudWxsIDogZmluZEludmFsaWRBbmNlc3RvckZvclRhZyhjaGlsZFRhZywgYW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgcHJvYmxlbWF0aWMgPSBpbnZhbGlkUGFyZW50IHx8IGludmFsaWRBbmNlc3RvcjtcblxuICAgIGlmIChwcm9ibGVtYXRpYykge1xuICAgICAgdmFyIGFuY2VzdG9yVGFnID0gcHJvYmxlbWF0aWMudGFnO1xuICAgICAgdmFyIGFuY2VzdG9ySW5zdGFuY2UgPSBwcm9ibGVtYXRpYy5pbnN0YW5jZTtcblxuICAgICAgdmFyIGNoaWxkT3duZXIgPSBjaGlsZEluc3RhbmNlICYmIGNoaWxkSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVyID0gYW5jZXN0b3JJbnN0YW5jZSAmJiBhbmNlc3Rvckluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG5cbiAgICAgIHZhciBjaGlsZE93bmVycyA9IGZpbmRPd25lclN0YWNrKGNoaWxkT3duZXIpO1xuICAgICAgdmFyIGFuY2VzdG9yT3duZXJzID0gZmluZE93bmVyU3RhY2soYW5jZXN0b3JPd25lcik7XG5cbiAgICAgIHZhciBtaW5TdGFja0xlbiA9IE1hdGgubWluKGNoaWxkT3duZXJzLmxlbmd0aCwgYW5jZXN0b3JPd25lcnMubGVuZ3RoKTtcbiAgICAgIHZhciBpO1xuXG4gICAgICB2YXIgZGVlcGVzdENvbW1vbiA9IC0xO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG1pblN0YWNrTGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGNoaWxkT3duZXJzW2ldID09PSBhbmNlc3Rvck93bmVyc1tpXSkge1xuICAgICAgICAgIGRlZXBlc3RDb21tb24gPSBpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBVTktOT1dOID0gJyh1bmtub3duKSc7XG4gICAgICB2YXIgY2hpbGRPd25lck5hbWVzID0gY2hpbGRPd25lcnMuc2xpY2UoZGVlcGVzdENvbW1vbiArIDEpLm1hcChmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgICByZXR1cm4gaW5zdC5nZXROYW1lKCkgfHwgVU5LTk9XTjtcbiAgICAgIH0pO1xuICAgICAgdmFyIGFuY2VzdG9yT3duZXJOYW1lcyA9IGFuY2VzdG9yT3duZXJzLnNsaWNlKGRlZXBlc3RDb21tb24gKyAxKS5tYXAoZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgcmV0dXJuIGluc3QuZ2V0TmFtZSgpIHx8IFVOS05PV047XG4gICAgICB9KTtcbiAgICAgIHZhciBvd25lckluZm8gPSBbXS5jb25jYXQoXG4gICAgICAvLyBJZiB0aGUgcGFyZW50IGFuZCBjaGlsZCBpbnN0YW5jZXMgaGF2ZSBhIGNvbW1vbiBvd25lciBhbmNlc3Rvciwgc3RhcnRcbiAgICAgIC8vIHdpdGggdGhhdCAtLSBvdGhlcndpc2Ugd2UganVzdCBzdGFydCB3aXRoIHRoZSBwYXJlbnQncyBvd25lcnMuXG4gICAgICBkZWVwZXN0Q29tbW9uICE9PSAtMSA/IGNoaWxkT3duZXJzW2RlZXBlc3RDb21tb25dLmdldE5hbWUoKSB8fCBVTktOT1dOIDogW10sIGFuY2VzdG9yT3duZXJOYW1lcywgYW5jZXN0b3JUYWcsXG4gICAgICAvLyBJZiB3ZSdyZSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgKG5vbi1wYXJlbnQpIGFuY2VzdHJ5LCBhZGQgJy4uLidcbiAgICAgIGludmFsaWRBbmNlc3RvciA/IFsnLi4uJ10gOiBbXSwgY2hpbGRPd25lck5hbWVzLCBjaGlsZFRhZykuam9pbignID4gJyk7XG5cbiAgICAgIHZhciB3YXJuS2V5ID0gISFpbnZhbGlkUGFyZW50ICsgJ3wnICsgY2hpbGRUYWcgKyAnfCcgKyBhbmNlc3RvclRhZyArICd8JyArIG93bmVySW5mbztcbiAgICAgIGlmIChkaWRXYXJuW3dhcm5LZXldKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRpZFdhcm5bd2FybktleV0gPSB0cnVlO1xuXG4gICAgICB2YXIgdGFnRGlzcGxheU5hbWUgPSBjaGlsZFRhZztcbiAgICAgIHZhciB3aGl0ZXNwYWNlSW5mbyA9ICcnO1xuICAgICAgaWYgKGNoaWxkVGFnID09PSAnI3RleHQnKSB7XG4gICAgICAgIGlmICgvXFxTLy50ZXN0KGNoaWxkVGV4dCkpIHtcbiAgICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdUZXh0IG5vZGVzJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdXaGl0ZXNwYWNlIHRleHQgbm9kZXMnO1xuICAgICAgICAgIHdoaXRlc3BhY2VJbmZvID0gXCIgTWFrZSBzdXJlIHlvdSBkb24ndCBoYXZlIGFueSBleHRyYSB3aGl0ZXNwYWNlIGJldHdlZW4gdGFncyBvbiBcIiArICdlYWNoIGxpbmUgb2YgeW91ciBzb3VyY2UgY29kZS4nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICc8JyArIGNoaWxkVGFnICsgJz4nO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW52YWxpZFBhcmVudCkge1xuICAgICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgICBpZiAoYW5jZXN0b3JUYWcgPT09ICd0YWJsZScgJiYgY2hpbGRUYWcgPT09ICd0cicpIHtcbiAgICAgICAgICBpbmZvICs9ICcgQWRkIGEgPHRib2R5PiB0byB5b3VyIGNvZGUgdG8gbWF0Y2ggdGhlIERPTSB0cmVlIGdlbmVyYXRlZCBieSAnICsgJ3RoZSBicm93c2VyLic7XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGNoaWxkIG9mIDwlcz4uJXMgJyArICdTZWUgJXMuJXMnLCB0YWdEaXNwbGF5TmFtZSwgYW5jZXN0b3JUYWcsIHdoaXRlc3BhY2VJbmZvLCBvd25lckluZm8sIGluZm8pIDogdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGRlc2NlbmRhbnQgb2YgJyArICc8JXM+LiBTZWUgJXMuJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCBvd25lckluZm8pIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm87XG5cbiAgLy8gRm9yIHRlc3RpbmdcbiAgdmFsaWRhdGVET01OZXN0aW5nLmlzVGFnVmFsaWRJbkNvbnRleHQgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8uY3VycmVudDtcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcbiAgICByZXR1cm4gaXNUYWdWYWxpZFdpdGhQYXJlbnQodGFnLCBwYXJlbnRUYWcpICYmICFmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKHRhZywgYW5jZXN0b3JJbmZvKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZGF0ZURPTU5lc3Rpbmc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvdmFsaWRhdGVET01OZXN0aW5nLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBgY2hhckNvZGVgIHJlcHJlc2VudHMgdGhlIGFjdHVhbCBcImNoYXJhY3RlciBjb2RlXCIgYW5kIGlzIHNhZmUgdG8gdXNlIHdpdGhcbiAqIGBTdHJpbmcuZnJvbUNoYXJDb2RlYC4gQXMgc3VjaCwgb25seSBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBwcmludGFibGVcbiAqIGNoYXJhY3RlcnMgcHJvZHVjZSBhIHZhbGlkIGBjaGFyQ29kZWAsIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIEVudGVyLlxuICogVGhlIFRhYi1rZXkgaXMgY29uc2lkZXJlZCBub24tcHJpbnRhYmxlIGFuZCBkb2VzIG5vdCBoYXZlIGEgYGNoYXJDb2RlYCxcbiAqIHByZXN1bWFibHkgYmVjYXVzZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgdGFiLWNoYXJhY3RlciBpbiBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE5vcm1hbGl6ZWQgYGNoYXJDb2RlYCBwcm9wZXJ0eS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjaGFyQ29kZTtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTtcblxuICAgIC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cbiAgICBpZiAoY2hhckNvZGUgPT09IDAgJiYga2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIGNoYXJDb2RlID0gMTM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgYGNoYXJDb2RlYCwgYnV0IGBrZXlDb2RlYCBoYXMgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgY2hhckNvZGUgPSBrZXlDb2RlO1xuICB9XG5cbiAgLy8gU29tZSBub24tcHJpbnRhYmxlIGtleXMgYXJlIHJlcG9ydGVkIGluIGBjaGFyQ29kZWAvYGtleUNvZGVgLCBkaXNjYXJkIHRoZW0uXG4gIC8vIE11c3Qgbm90IGRpc2NhcmQgdGhlIChub24tKXByaW50YWJsZSBFbnRlci1rZXkuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudENoYXJDb2RlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2dldEV2ZW50Q2hhckNvZGUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICBTeW1ib2wuZm9yICYmXG4gICAgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuICAgIDB4ZWFjNztcblxuICB2YXIgaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG9iamVjdCAhPT0gbnVsbCAmJlxuICAgICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH07XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMiLCIvKipcbiAqIFByaW50cyBhIHdhcm5pbmcgaW4gdGhlIGNvbnNvbGUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSB3YXJuaW5nIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCBpZiB5b3UgZW5hYmxlXG4gICAgLy8gXCJicmVhayBvbiBhbGwgZXhjZXB0aW9uc1wiIGluIHlvdXIgY29uc29sZSxcbiAgICAvLyBpdCB3b3VsZCBwYXVzZSB0aGUgZXhlY3V0aW9uIGF0IHRoaXMgbGluZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbiAgfSBjYXRjaCAoZSkge31cbiAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy93YXJuaW5nLmpzIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgZ2V0UHJvdG90eXBlIGZyb20gJy4vX2dldFByb3RvdHlwZS5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1BsYWluT2JqZWN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1BsYWluT2JqZWN0LmpzIiwiaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSAncmVkdXgnXG5pbXBvcnQgY291bnRlciBmcm9tICcuL2NvdW50ZXInXG5cbmNvbnN0IHJvb3RSZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHtcbiAgY291bnRlclxufSlcblxuZXhwb3J0IGRlZmF1bHQgcm9vdFJlZHVjZXJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbW1vbi9yZWR1Y2Vycy9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ2YXIgRU5USVRJRVMgPSBbWydBYWN1dGUnLCBbMTkzXV0sIFsnYWFjdXRlJywgWzIyNV1dLCBbJ0FicmV2ZScsIFsyNThdXSwgWydhYnJldmUnLCBbMjU5XV0sIFsnYWMnLCBbODc2Nl1dLCBbJ2FjZCcsIFs4NzY3XV0sIFsnYWNFJywgWzg3NjYsIDgxOV1dLCBbJ0FjaXJjJywgWzE5NF1dLCBbJ2FjaXJjJywgWzIyNl1dLCBbJ2FjdXRlJywgWzE4MF1dLCBbJ0FjeScsIFsxMDQwXV0sIFsnYWN5JywgWzEwNzJdXSwgWydBRWxpZycsIFsxOThdXSwgWydhZWxpZycsIFsyMzBdXSwgWydhZicsIFs4Mjg5XV0sIFsnQWZyJywgWzEyMDA2OF1dLCBbJ2FmcicsIFsxMjAwOTRdXSwgWydBZ3JhdmUnLCBbMTkyXV0sIFsnYWdyYXZlJywgWzIyNF1dLCBbJ2FsZWZzeW0nLCBbODUwMV1dLCBbJ2FsZXBoJywgWzg1MDFdXSwgWydBbHBoYScsIFs5MTNdXSwgWydhbHBoYScsIFs5NDVdXSwgWydBbWFjcicsIFsyNTZdXSwgWydhbWFjcicsIFsyNTddXSwgWydhbWFsZycsIFsxMDgxNV1dLCBbJ2FtcCcsIFszOF1dLCBbJ0FNUCcsIFszOF1dLCBbJ2FuZGFuZCcsIFsxMDgzN11dLCBbJ0FuZCcsIFsxMDgzNV1dLCBbJ2FuZCcsIFs4NzQzXV0sIFsnYW5kZCcsIFsxMDg0NF1dLCBbJ2FuZHNsb3BlJywgWzEwODQwXV0sIFsnYW5kdicsIFsxMDg0Ml1dLCBbJ2FuZycsIFs4NzM2XV0sIFsnYW5nZScsIFsxMDY2MF1dLCBbJ2FuZ2xlJywgWzg3MzZdXSwgWydhbmdtc2RhYScsIFsxMDY2NF1dLCBbJ2FuZ21zZGFiJywgWzEwNjY1XV0sIFsnYW5nbXNkYWMnLCBbMTA2NjZdXSwgWydhbmdtc2RhZCcsIFsxMDY2N11dLCBbJ2FuZ21zZGFlJywgWzEwNjY4XV0sIFsnYW5nbXNkYWYnLCBbMTA2NjldXSwgWydhbmdtc2RhZycsIFsxMDY3MF1dLCBbJ2FuZ21zZGFoJywgWzEwNjcxXV0sIFsnYW5nbXNkJywgWzg3MzddXSwgWydhbmdydCcsIFs4NzM1XV0sIFsnYW5ncnR2YicsIFs4ODk0XV0sIFsnYW5ncnR2YmQnLCBbMTA2NTNdXSwgWydhbmdzcGgnLCBbODczOF1dLCBbJ2FuZ3N0JywgWzE5N11dLCBbJ2FuZ3phcnInLCBbOTA4NF1dLCBbJ0FvZ29uJywgWzI2MF1dLCBbJ2FvZ29uJywgWzI2MV1dLCBbJ0FvcGYnLCBbMTIwMTIwXV0sIFsnYW9wZicsIFsxMjAxNDZdXSwgWydhcGFjaXInLCBbMTA4NjNdXSwgWydhcCcsIFs4Nzc2XV0sIFsnYXBFJywgWzEwODY0XV0sIFsnYXBlJywgWzg3NzhdXSwgWydhcGlkJywgWzg3NzldXSwgWydhcG9zJywgWzM5XV0sIFsnQXBwbHlGdW5jdGlvbicsIFs4Mjg5XV0sIFsnYXBwcm94JywgWzg3NzZdXSwgWydhcHByb3hlcScsIFs4Nzc4XV0sIFsnQXJpbmcnLCBbMTk3XV0sIFsnYXJpbmcnLCBbMjI5XV0sIFsnQXNjcicsIFsxMTk5NjRdXSwgWydhc2NyJywgWzExOTk5MF1dLCBbJ0Fzc2lnbicsIFs4Nzg4XV0sIFsnYXN0JywgWzQyXV0sIFsnYXN5bXAnLCBbODc3Nl1dLCBbJ2FzeW1wZXEnLCBbODc4MV1dLCBbJ0F0aWxkZScsIFsxOTVdXSwgWydhdGlsZGUnLCBbMjI3XV0sIFsnQXVtbCcsIFsxOTZdXSwgWydhdW1sJywgWzIyOF1dLCBbJ2F3Y29uaW50JywgWzg3NTVdXSwgWydhd2ludCcsIFsxMDc2OV1dLCBbJ2JhY2tjb25nJywgWzg3ODBdXSwgWydiYWNrZXBzaWxvbicsIFsxMDE0XV0sIFsnYmFja3ByaW1lJywgWzgyNDVdXSwgWydiYWNrc2ltJywgWzg3NjVdXSwgWydiYWNrc2ltZXEnLCBbODkwOV1dLCBbJ0JhY2tzbGFzaCcsIFs4NzI2XV0sIFsnQmFydicsIFsxMDk4M11dLCBbJ2JhcnZlZScsIFs4ODkzXV0sIFsnYmFyd2VkJywgWzg5NjVdXSwgWydCYXJ3ZWQnLCBbODk2Nl1dLCBbJ2JhcndlZGdlJywgWzg5NjVdXSwgWydiYnJrJywgWzkxNDFdXSwgWydiYnJrdGJyaycsIFs5MTQyXV0sIFsnYmNvbmcnLCBbODc4MF1dLCBbJ0JjeScsIFsxMDQxXV0sIFsnYmN5JywgWzEwNzNdXSwgWydiZHF1bycsIFs4MjIyXV0sIFsnYmVjYXVzJywgWzg3NTddXSwgWydiZWNhdXNlJywgWzg3NTddXSwgWydCZWNhdXNlJywgWzg3NTddXSwgWydiZW1wdHl2JywgWzEwNjcyXV0sIFsnYmVwc2knLCBbMTAxNF1dLCBbJ2Jlcm5vdScsIFs4NDkyXV0sIFsnQmVybm91bGxpcycsIFs4NDkyXV0sIFsnQmV0YScsIFs5MTRdXSwgWydiZXRhJywgWzk0Nl1dLCBbJ2JldGgnLCBbODUwMl1dLCBbJ2JldHdlZW4nLCBbODgxMl1dLCBbJ0JmcicsIFsxMjAwNjldXSwgWydiZnInLCBbMTIwMDk1XV0sIFsnYmlnY2FwJywgWzg4OThdXSwgWydiaWdjaXJjJywgWzk3MTFdXSwgWydiaWdjdXAnLCBbODg5OV1dLCBbJ2JpZ29kb3QnLCBbMTA3NTJdXSwgWydiaWdvcGx1cycsIFsxMDc1M11dLCBbJ2JpZ290aW1lcycsIFsxMDc1NF1dLCBbJ2JpZ3NxY3VwJywgWzEwNzU4XV0sIFsnYmlnc3RhcicsIFs5NzMzXV0sIFsnYmlndHJpYW5nbGVkb3duJywgWzk2NjFdXSwgWydiaWd0cmlhbmdsZXVwJywgWzk2NTFdXSwgWydiaWd1cGx1cycsIFsxMDc1Nl1dLCBbJ2JpZ3ZlZScsIFs4ODk3XV0sIFsnYmlnd2VkZ2UnLCBbODg5Nl1dLCBbJ2JrYXJvdycsIFsxMDUwOV1dLCBbJ2JsYWNrbG96ZW5nZScsIFsxMDczMV1dLCBbJ2JsYWNrc3F1YXJlJywgWzk2NDJdXSwgWydibGFja3RyaWFuZ2xlJywgWzk2NTJdXSwgWydibGFja3RyaWFuZ2xlZG93bicsIFs5NjYyXV0sIFsnYmxhY2t0cmlhbmdsZWxlZnQnLCBbOTY2Nl1dLCBbJ2JsYWNrdHJpYW5nbGVyaWdodCcsIFs5NjU2XV0sIFsnYmxhbmsnLCBbOTI1MV1dLCBbJ2JsazEyJywgWzk2MThdXSwgWydibGsxNCcsIFs5NjE3XV0sIFsnYmxrMzQnLCBbOTYxOV1dLCBbJ2Jsb2NrJywgWzk2MDhdXSwgWydibmUnLCBbNjEsIDg0MjFdXSwgWydibmVxdWl2JywgWzg4MDEsIDg0MjFdXSwgWydiTm90JywgWzEwOTg5XV0sIFsnYm5vdCcsIFs4OTc2XV0sIFsnQm9wZicsIFsxMjAxMjFdXSwgWydib3BmJywgWzEyMDE0N11dLCBbJ2JvdCcsIFs4ODY5XV0sIFsnYm90dG9tJywgWzg4NjldXSwgWydib3d0aWUnLCBbODkwNF1dLCBbJ2JveGJveCcsIFsxMDY5N11dLCBbJ2JveGRsJywgWzk0ODhdXSwgWydib3hkTCcsIFs5NTU3XV0sIFsnYm94RGwnLCBbOTU1OF1dLCBbJ2JveERMJywgWzk1NTldXSwgWydib3hkcicsIFs5NDg0XV0sIFsnYm94ZFInLCBbOTU1NF1dLCBbJ2JveERyJywgWzk1NTVdXSwgWydib3hEUicsIFs5NTU2XV0sIFsnYm94aCcsIFs5NDcyXV0sIFsnYm94SCcsIFs5NTUyXV0sIFsnYm94aGQnLCBbOTUxNl1dLCBbJ2JveEhkJywgWzk1NzJdXSwgWydib3hoRCcsIFs5NTczXV0sIFsnYm94SEQnLCBbOTU3NF1dLCBbJ2JveGh1JywgWzk1MjRdXSwgWydib3hIdScsIFs5NTc1XV0sIFsnYm94aFUnLCBbOTU3Nl1dLCBbJ2JveEhVJywgWzk1NzddXSwgWydib3htaW51cycsIFs4ODYzXV0sIFsnYm94cGx1cycsIFs4ODYyXV0sIFsnYm94dGltZXMnLCBbODg2NF1dLCBbJ2JveHVsJywgWzk0OTZdXSwgWydib3h1TCcsIFs5NTYzXV0sIFsnYm94VWwnLCBbOTU2NF1dLCBbJ2JveFVMJywgWzk1NjVdXSwgWydib3h1cicsIFs5NDkyXV0sIFsnYm94dVInLCBbOTU2MF1dLCBbJ2JveFVyJywgWzk1NjFdXSwgWydib3hVUicsIFs5NTYyXV0sIFsnYm94dicsIFs5NDc0XV0sIFsnYm94VicsIFs5NTUzXV0sIFsnYm94dmgnLCBbOTUzMl1dLCBbJ2JveHZIJywgWzk1NzhdXSwgWydib3hWaCcsIFs5NTc5XV0sIFsnYm94VkgnLCBbOTU4MF1dLCBbJ2JveHZsJywgWzk1MDhdXSwgWydib3h2TCcsIFs5NTY5XV0sIFsnYm94VmwnLCBbOTU3MF1dLCBbJ2JveFZMJywgWzk1NzFdXSwgWydib3h2cicsIFs5NTAwXV0sIFsnYm94dlInLCBbOTU2Nl1dLCBbJ2JveFZyJywgWzk1NjddXSwgWydib3hWUicsIFs5NTY4XV0sIFsnYnByaW1lJywgWzgyNDVdXSwgWydicmV2ZScsIFs3MjhdXSwgWydCcmV2ZScsIFs3MjhdXSwgWydicnZiYXInLCBbMTY2XV0sIFsnYnNjcicsIFsxMTk5OTFdXSwgWydCc2NyJywgWzg0OTJdXSwgWydic2VtaScsIFs4MjcxXV0sIFsnYnNpbScsIFs4NzY1XV0sIFsnYnNpbWUnLCBbODkwOV1dLCBbJ2Jzb2xiJywgWzEwNjkzXV0sIFsnYnNvbCcsIFs5Ml1dLCBbJ2Jzb2xoc3ViJywgWzEwMTg0XV0sIFsnYnVsbCcsIFs4MjI2XV0sIFsnYnVsbGV0JywgWzgyMjZdXSwgWydidW1wJywgWzg3ODJdXSwgWydidW1wRScsIFsxMDkyNl1dLCBbJ2J1bXBlJywgWzg3ODNdXSwgWydCdW1wZXEnLCBbODc4Ml1dLCBbJ2J1bXBlcScsIFs4NzgzXV0sIFsnQ2FjdXRlJywgWzI2Ml1dLCBbJ2NhY3V0ZScsIFsyNjNdXSwgWydjYXBhbmQnLCBbMTA4MjBdXSwgWydjYXBicmN1cCcsIFsxMDgyNV1dLCBbJ2NhcGNhcCcsIFsxMDgyN11dLCBbJ2NhcCcsIFs4NzQ1XV0sIFsnQ2FwJywgWzg5MTRdXSwgWydjYXBjdXAnLCBbMTA4MjNdXSwgWydjYXBkb3QnLCBbMTA4MTZdXSwgWydDYXBpdGFsRGlmZmVyZW50aWFsRCcsIFs4NTE3XV0sIFsnY2FwcycsIFs4NzQ1LCA2NTAyNF1dLCBbJ2NhcmV0JywgWzgyNTddXSwgWydjYXJvbicsIFs3MTFdXSwgWydDYXlsZXlzJywgWzg0OTNdXSwgWydjY2FwcycsIFsxMDgyOV1dLCBbJ0NjYXJvbicsIFsyNjhdXSwgWydjY2Fyb24nLCBbMjY5XV0sIFsnQ2NlZGlsJywgWzE5OV1dLCBbJ2NjZWRpbCcsIFsyMzFdXSwgWydDY2lyYycsIFsyNjRdXSwgWydjY2lyYycsIFsyNjVdXSwgWydDY29uaW50JywgWzg3NTJdXSwgWydjY3VwcycsIFsxMDgyOF1dLCBbJ2NjdXBzc20nLCBbMTA4MzJdXSwgWydDZG90JywgWzI2Nl1dLCBbJ2Nkb3QnLCBbMjY3XV0sIFsnY2VkaWwnLCBbMTg0XV0sIFsnQ2VkaWxsYScsIFsxODRdXSwgWydjZW1wdHl2JywgWzEwNjc0XV0sIFsnY2VudCcsIFsxNjJdXSwgWydjZW50ZXJkb3QnLCBbMTgzXV0sIFsnQ2VudGVyRG90JywgWzE4M11dLCBbJ2NmcicsIFsxMjAwOTZdXSwgWydDZnInLCBbODQ5M11dLCBbJ0NIY3knLCBbMTA2M11dLCBbJ2NoY3knLCBbMTA5NV1dLCBbJ2NoZWNrJywgWzEwMDAzXV0sIFsnY2hlY2ttYXJrJywgWzEwMDAzXV0sIFsnQ2hpJywgWzkzNV1dLCBbJ2NoaScsIFs5NjddXSwgWydjaXJjJywgWzcxMF1dLCBbJ2NpcmNlcScsIFs4NzkxXV0sIFsnY2lyY2xlYXJyb3dsZWZ0JywgWzg2MzRdXSwgWydjaXJjbGVhcnJvd3JpZ2h0JywgWzg2MzVdXSwgWydjaXJjbGVkYXN0JywgWzg4NTldXSwgWydjaXJjbGVkY2lyYycsIFs4ODU4XV0sIFsnY2lyY2xlZGRhc2gnLCBbODg2MV1dLCBbJ0NpcmNsZURvdCcsIFs4ODU3XV0sIFsnY2lyY2xlZFInLCBbMTc0XV0sIFsnY2lyY2xlZFMnLCBbOTQxNl1dLCBbJ0NpcmNsZU1pbnVzJywgWzg4NTRdXSwgWydDaXJjbGVQbHVzJywgWzg4NTNdXSwgWydDaXJjbGVUaW1lcycsIFs4ODU1XV0sIFsnY2lyJywgWzk2NzVdXSwgWydjaXJFJywgWzEwNjkxXV0sIFsnY2lyZScsIFs4NzkxXV0sIFsnY2lyZm5pbnQnLCBbMTA3NjhdXSwgWydjaXJtaWQnLCBbMTA5OTFdXSwgWydjaXJzY2lyJywgWzEwNjkwXV0sIFsnQ2xvY2t3aXNlQ29udG91ckludGVncmFsJywgWzg3NTRdXSwgWydjbHVicycsIFs5ODI3XV0sIFsnY2x1YnN1aXQnLCBbOTgyN11dLCBbJ2NvbG9uJywgWzU4XV0sIFsnQ29sb24nLCBbODc1OV1dLCBbJ0NvbG9uZScsIFsxMDg2OF1dLCBbJ2NvbG9uZScsIFs4Nzg4XV0sIFsnY29sb25lcScsIFs4Nzg4XV0sIFsnY29tbWEnLCBbNDRdXSwgWydjb21tYXQnLCBbNjRdXSwgWydjb21wJywgWzg3MDVdXSwgWydjb21wZm4nLCBbODcyOF1dLCBbJ2NvbXBsZW1lbnQnLCBbODcwNV1dLCBbJ2NvbXBsZXhlcycsIFs4NDUwXV0sIFsnY29uZycsIFs4NzczXV0sIFsnY29uZ2RvdCcsIFsxMDg2MV1dLCBbJ0NvbmdydWVudCcsIFs4ODAxXV0sIFsnY29uaW50JywgWzg3NTBdXSwgWydDb25pbnQnLCBbODc1MV1dLCBbJ0NvbnRvdXJJbnRlZ3JhbCcsIFs4NzUwXV0sIFsnY29wZicsIFsxMjAxNDhdXSwgWydDb3BmJywgWzg0NTBdXSwgWydjb3Byb2QnLCBbODcyMF1dLCBbJ0NvcHJvZHVjdCcsIFs4NzIwXV0sIFsnY29weScsIFsxNjldXSwgWydDT1BZJywgWzE2OV1dLCBbJ2NvcHlzcicsIFs4NDcxXV0sIFsnQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCcsIFs4NzU1XV0sIFsnY3JhcnInLCBbODYyOV1dLCBbJ2Nyb3NzJywgWzEwMDA3XV0sIFsnQ3Jvc3MnLCBbMTA3OTldXSwgWydDc2NyJywgWzExOTk2Nl1dLCBbJ2NzY3InLCBbMTE5OTkyXV0sIFsnY3N1YicsIFsxMDk1OV1dLCBbJ2NzdWJlJywgWzEwOTYxXV0sIFsnY3N1cCcsIFsxMDk2MF1dLCBbJ2NzdXBlJywgWzEwOTYyXV0sIFsnY3Rkb3QnLCBbODk0M11dLCBbJ2N1ZGFycmwnLCBbMTA1NTJdXSwgWydjdWRhcnJyJywgWzEwNTQ5XV0sIFsnY3VlcHInLCBbODkyNl1dLCBbJ2N1ZXNjJywgWzg5MjddXSwgWydjdWxhcnInLCBbODYzMF1dLCBbJ2N1bGFycnAnLCBbMTA1NTddXSwgWydjdXBicmNhcCcsIFsxMDgyNF1dLCBbJ2N1cGNhcCcsIFsxMDgyMl1dLCBbJ0N1cENhcCcsIFs4NzgxXV0sIFsnY3VwJywgWzg3NDZdXSwgWydDdXAnLCBbODkxNV1dLCBbJ2N1cGN1cCcsIFsxMDgyNl1dLCBbJ2N1cGRvdCcsIFs4ODQ1XV0sIFsnY3Vwb3InLCBbMTA4MjFdXSwgWydjdXBzJywgWzg3NDYsIDY1MDI0XV0sIFsnY3VyYXJyJywgWzg2MzFdXSwgWydjdXJhcnJtJywgWzEwNTU2XV0sIFsnY3VybHllcXByZWMnLCBbODkyNl1dLCBbJ2N1cmx5ZXFzdWNjJywgWzg5MjddXSwgWydjdXJseXZlZScsIFs4OTEwXV0sIFsnY3VybHl3ZWRnZScsIFs4OTExXV0sIFsnY3VycmVuJywgWzE2NF1dLCBbJ2N1cnZlYXJyb3dsZWZ0JywgWzg2MzBdXSwgWydjdXJ2ZWFycm93cmlnaHQnLCBbODYzMV1dLCBbJ2N1dmVlJywgWzg5MTBdXSwgWydjdXdlZCcsIFs4OTExXV0sIFsnY3djb25pbnQnLCBbODc1NF1dLCBbJ2N3aW50JywgWzg3NTNdXSwgWydjeWxjdHknLCBbOTAwNV1dLCBbJ2RhZ2dlcicsIFs4MjI0XV0sIFsnRGFnZ2VyJywgWzgyMjVdXSwgWydkYWxldGgnLCBbODUwNF1dLCBbJ2RhcnInLCBbODU5NV1dLCBbJ0RhcnInLCBbODYwOV1dLCBbJ2RBcnInLCBbODY1OV1dLCBbJ2Rhc2gnLCBbODIwOF1dLCBbJ0Rhc2h2JywgWzEwOTgwXV0sIFsnZGFzaHYnLCBbODg2N11dLCBbJ2Ria2Fyb3cnLCBbMTA1MTFdXSwgWydkYmxhYycsIFs3MzNdXSwgWydEY2Fyb24nLCBbMjcwXV0sIFsnZGNhcm9uJywgWzI3MV1dLCBbJ0RjeScsIFsxMDQ0XV0sIFsnZGN5JywgWzEwNzZdXSwgWydkZGFnZ2VyJywgWzgyMjVdXSwgWydkZGFycicsIFs4NjUwXV0sIFsnREQnLCBbODUxN11dLCBbJ2RkJywgWzg1MThdXSwgWydERG90cmFoZCcsIFsxMDUxM11dLCBbJ2Rkb3RzZXEnLCBbMTA4NzFdXSwgWydkZWcnLCBbMTc2XV0sIFsnRGVsJywgWzg3MTFdXSwgWydEZWx0YScsIFs5MTZdXSwgWydkZWx0YScsIFs5NDhdXSwgWydkZW1wdHl2JywgWzEwNjczXV0sIFsnZGZpc2h0JywgWzEwNjIzXV0sIFsnRGZyJywgWzEyMDA3MV1dLCBbJ2RmcicsIFsxMjAwOTddXSwgWydkSGFyJywgWzEwNTk3XV0sIFsnZGhhcmwnLCBbODY0M11dLCBbJ2RoYXJyJywgWzg2NDJdXSwgWydEaWFjcml0aWNhbEFjdXRlJywgWzE4MF1dLCBbJ0RpYWNyaXRpY2FsRG90JywgWzcyOV1dLCBbJ0RpYWNyaXRpY2FsRG91YmxlQWN1dGUnLCBbNzMzXV0sIFsnRGlhY3JpdGljYWxHcmF2ZScsIFs5Nl1dLCBbJ0RpYWNyaXRpY2FsVGlsZGUnLCBbNzMyXV0sIFsnZGlhbScsIFs4OTAwXV0sIFsnZGlhbW9uZCcsIFs4OTAwXV0sIFsnRGlhbW9uZCcsIFs4OTAwXV0sIFsnZGlhbW9uZHN1aXQnLCBbOTgzMF1dLCBbJ2RpYW1zJywgWzk4MzBdXSwgWydkaWUnLCBbMTY4XV0sIFsnRGlmZmVyZW50aWFsRCcsIFs4NTE4XV0sIFsnZGlnYW1tYScsIFs5ODldXSwgWydkaXNpbicsIFs4OTQ2XV0sIFsnZGl2JywgWzI0N11dLCBbJ2RpdmlkZScsIFsyNDddXSwgWydkaXZpZGVvbnRpbWVzJywgWzg5MDNdXSwgWydkaXZvbngnLCBbODkwM11dLCBbJ0RKY3knLCBbMTAyNl1dLCBbJ2RqY3knLCBbMTEwNl1dLCBbJ2RsY29ybicsIFs4OTkwXV0sIFsnZGxjcm9wJywgWzg5NzNdXSwgWydkb2xsYXInLCBbMzZdXSwgWydEb3BmJywgWzEyMDEyM11dLCBbJ2RvcGYnLCBbMTIwMTQ5XV0sIFsnRG90JywgWzE2OF1dLCBbJ2RvdCcsIFs3MjldXSwgWydEb3REb3QnLCBbODQxMl1dLCBbJ2RvdGVxJywgWzg3ODRdXSwgWydkb3RlcWRvdCcsIFs4Nzg1XV0sIFsnRG90RXF1YWwnLCBbODc4NF1dLCBbJ2RvdG1pbnVzJywgWzg3NjBdXSwgWydkb3RwbHVzJywgWzg3MjRdXSwgWydkb3RzcXVhcmUnLCBbODg2NV1dLCBbJ2RvdWJsZWJhcndlZGdlJywgWzg5NjZdXSwgWydEb3VibGVDb250b3VySW50ZWdyYWwnLCBbODc1MV1dLCBbJ0RvdWJsZURvdCcsIFsxNjhdXSwgWydEb3VibGVEb3duQXJyb3cnLCBbODY1OV1dLCBbJ0RvdWJsZUxlZnRBcnJvdycsIFs4NjU2XV0sIFsnRG91YmxlTGVmdFJpZ2h0QXJyb3cnLCBbODY2MF1dLCBbJ0RvdWJsZUxlZnRUZWUnLCBbMTA5ODBdXSwgWydEb3VibGVMb25nTGVmdEFycm93JywgWzEwMjMyXV0sIFsnRG91YmxlTG9uZ0xlZnRSaWdodEFycm93JywgWzEwMjM0XV0sIFsnRG91YmxlTG9uZ1JpZ2h0QXJyb3cnLCBbMTAyMzNdXSwgWydEb3VibGVSaWdodEFycm93JywgWzg2NThdXSwgWydEb3VibGVSaWdodFRlZScsIFs4ODcyXV0sIFsnRG91YmxlVXBBcnJvdycsIFs4NjU3XV0sIFsnRG91YmxlVXBEb3duQXJyb3cnLCBbODY2MV1dLCBbJ0RvdWJsZVZlcnRpY2FsQmFyJywgWzg3NDFdXSwgWydEb3duQXJyb3dCYXInLCBbMTA1MTVdXSwgWydkb3duYXJyb3cnLCBbODU5NV1dLCBbJ0Rvd25BcnJvdycsIFs4NTk1XV0sIFsnRG93bmFycm93JywgWzg2NTldXSwgWydEb3duQXJyb3dVcEFycm93JywgWzg2OTNdXSwgWydEb3duQnJldmUnLCBbNzg1XV0sIFsnZG93bmRvd25hcnJvd3MnLCBbODY1MF1dLCBbJ2Rvd25oYXJwb29ubGVmdCcsIFs4NjQzXV0sIFsnZG93bmhhcnBvb25yaWdodCcsIFs4NjQyXV0sIFsnRG93bkxlZnRSaWdodFZlY3RvcicsIFsxMDU3Nl1dLCBbJ0Rvd25MZWZ0VGVlVmVjdG9yJywgWzEwNTkwXV0sIFsnRG93bkxlZnRWZWN0b3JCYXInLCBbMTA1ODJdXSwgWydEb3duTGVmdFZlY3RvcicsIFs4NjM3XV0sIFsnRG93blJpZ2h0VGVlVmVjdG9yJywgWzEwNTkxXV0sIFsnRG93blJpZ2h0VmVjdG9yQmFyJywgWzEwNTgzXV0sIFsnRG93blJpZ2h0VmVjdG9yJywgWzg2NDFdXSwgWydEb3duVGVlQXJyb3cnLCBbODYxNV1dLCBbJ0Rvd25UZWUnLCBbODg2OF1dLCBbJ2RyYmthcm93JywgWzEwNTEyXV0sIFsnZHJjb3JuJywgWzg5OTFdXSwgWydkcmNyb3AnLCBbODk3Ml1dLCBbJ0RzY3InLCBbMTE5OTY3XV0sIFsnZHNjcicsIFsxMTk5OTNdXSwgWydEU2N5JywgWzEwMjldXSwgWydkc2N5JywgWzExMDldXSwgWydkc29sJywgWzEwNzQyXV0sIFsnRHN0cm9rJywgWzI3Ml1dLCBbJ2RzdHJvaycsIFsyNzNdXSwgWydkdGRvdCcsIFs4OTQ1XV0sIFsnZHRyaScsIFs5NjYzXV0sIFsnZHRyaWYnLCBbOTY2Ml1dLCBbJ2R1YXJyJywgWzg2OTNdXSwgWydkdWhhcicsIFsxMDYwN11dLCBbJ2R3YW5nbGUnLCBbMTA2NjJdXSwgWydEWmN5JywgWzEwMzldXSwgWydkemN5JywgWzExMTldXSwgWydkemlncmFycicsIFsxMDIzOV1dLCBbJ0VhY3V0ZScsIFsyMDFdXSwgWydlYWN1dGUnLCBbMjMzXV0sIFsnZWFzdGVyJywgWzEwODYyXV0sIFsnRWNhcm9uJywgWzI4Ml1dLCBbJ2VjYXJvbicsIFsyODNdXSwgWydFY2lyYycsIFsyMDJdXSwgWydlY2lyYycsIFsyMzRdXSwgWydlY2lyJywgWzg3OTBdXSwgWydlY29sb24nLCBbODc4OV1dLCBbJ0VjeScsIFsxMDY5XV0sIFsnZWN5JywgWzExMDFdXSwgWydlRERvdCcsIFsxMDg3MV1dLCBbJ0Vkb3QnLCBbMjc4XV0sIFsnZWRvdCcsIFsyNzldXSwgWydlRG90JywgWzg3ODVdXSwgWydlZScsIFs4NTE5XV0sIFsnZWZEb3QnLCBbODc4Nl1dLCBbJ0VmcicsIFsxMjAwNzJdXSwgWydlZnInLCBbMTIwMDk4XV0sIFsnZWcnLCBbMTA5MDZdXSwgWydFZ3JhdmUnLCBbMjAwXV0sIFsnZWdyYXZlJywgWzIzMl1dLCBbJ2VncycsIFsxMDkwMl1dLCBbJ2Vnc2RvdCcsIFsxMDkwNF1dLCBbJ2VsJywgWzEwOTA1XV0sIFsnRWxlbWVudCcsIFs4NzEyXV0sIFsnZWxpbnRlcnMnLCBbOTE5MV1dLCBbJ2VsbCcsIFs4NDY3XV0sIFsnZWxzJywgWzEwOTAxXV0sIFsnZWxzZG90JywgWzEwOTAzXV0sIFsnRW1hY3InLCBbMjc0XV0sIFsnZW1hY3InLCBbMjc1XV0sIFsnZW1wdHknLCBbODcwOV1dLCBbJ2VtcHR5c2V0JywgWzg3MDldXSwgWydFbXB0eVNtYWxsU3F1YXJlJywgWzk3MjNdXSwgWydlbXB0eXYnLCBbODcwOV1dLCBbJ0VtcHR5VmVyeVNtYWxsU3F1YXJlJywgWzk2NDNdXSwgWydlbXNwMTMnLCBbODE5Nl1dLCBbJ2Vtc3AxNCcsIFs4MTk3XV0sIFsnZW1zcCcsIFs4MTk1XV0sIFsnRU5HJywgWzMzMF1dLCBbJ2VuZycsIFszMzFdXSwgWydlbnNwJywgWzgxOTRdXSwgWydFb2dvbicsIFsyODBdXSwgWydlb2dvbicsIFsyODFdXSwgWydFb3BmJywgWzEyMDEyNF1dLCBbJ2VvcGYnLCBbMTIwMTUwXV0sIFsnZXBhcicsIFs4OTE3XV0sIFsnZXBhcnNsJywgWzEwNzIzXV0sIFsnZXBsdXMnLCBbMTA4NjVdXSwgWydlcHNpJywgWzk0OV1dLCBbJ0Vwc2lsb24nLCBbOTE3XV0sIFsnZXBzaWxvbicsIFs5NDldXSwgWydlcHNpdicsIFsxMDEzXV0sIFsnZXFjaXJjJywgWzg3OTBdXSwgWydlcWNvbG9uJywgWzg3ODldXSwgWydlcXNpbScsIFs4NzcwXV0sIFsnZXFzbGFudGd0cicsIFsxMDkwMl1dLCBbJ2Vxc2xhbnRsZXNzJywgWzEwOTAxXV0sIFsnRXF1YWwnLCBbMTA4NjldXSwgWydlcXVhbHMnLCBbNjFdXSwgWydFcXVhbFRpbGRlJywgWzg3NzBdXSwgWydlcXVlc3QnLCBbODc5OV1dLCBbJ0VxdWlsaWJyaXVtJywgWzg2NTJdXSwgWydlcXVpdicsIFs4ODAxXV0sIFsnZXF1aXZERCcsIFsxMDg3Ml1dLCBbJ2VxdnBhcnNsJywgWzEwNzI1XV0sIFsnZXJhcnInLCBbMTA2MDldXSwgWydlckRvdCcsIFs4Nzg3XV0sIFsnZXNjcicsIFs4NDk1XV0sIFsnRXNjcicsIFs4NDk2XV0sIFsnZXNkb3QnLCBbODc4NF1dLCBbJ0VzaW0nLCBbMTA4NjddXSwgWydlc2ltJywgWzg3NzBdXSwgWydFdGEnLCBbOTE5XV0sIFsnZXRhJywgWzk1MV1dLCBbJ0VUSCcsIFsyMDhdXSwgWydldGgnLCBbMjQwXV0sIFsnRXVtbCcsIFsyMDNdXSwgWydldW1sJywgWzIzNV1dLCBbJ2V1cm8nLCBbODM2NF1dLCBbJ2V4Y2wnLCBbMzNdXSwgWydleGlzdCcsIFs4NzA3XV0sIFsnRXhpc3RzJywgWzg3MDddXSwgWydleHBlY3RhdGlvbicsIFs4NDk2XV0sIFsnZXhwb25lbnRpYWxlJywgWzg1MTldXSwgWydFeHBvbmVudGlhbEUnLCBbODUxOV1dLCBbJ2ZhbGxpbmdkb3RzZXEnLCBbODc4Nl1dLCBbJ0ZjeScsIFsxMDYwXV0sIFsnZmN5JywgWzEwOTJdXSwgWydmZW1hbGUnLCBbOTc5Ml1dLCBbJ2ZmaWxpZycsIFs2NDI1OV1dLCBbJ2ZmbGlnJywgWzY0MjU2XV0sIFsnZmZsbGlnJywgWzY0MjYwXV0sIFsnRmZyJywgWzEyMDA3M11dLCBbJ2ZmcicsIFsxMjAwOTldXSwgWydmaWxpZycsIFs2NDI1N11dLCBbJ0ZpbGxlZFNtYWxsU3F1YXJlJywgWzk3MjRdXSwgWydGaWxsZWRWZXJ5U21hbGxTcXVhcmUnLCBbOTY0Ml1dLCBbJ2ZqbGlnJywgWzEwMiwgMTA2XV0sIFsnZmxhdCcsIFs5ODM3XV0sIFsnZmxsaWcnLCBbNjQyNThdXSwgWydmbHRucycsIFs5NjQ5XV0sIFsnZm5vZicsIFs0MDJdXSwgWydGb3BmJywgWzEyMDEyNV1dLCBbJ2ZvcGYnLCBbMTIwMTUxXV0sIFsnZm9yYWxsJywgWzg3MDRdXSwgWydGb3JBbGwnLCBbODcwNF1dLCBbJ2ZvcmsnLCBbODkxNl1dLCBbJ2Zvcmt2JywgWzEwOTY5XV0sIFsnRm91cmllcnRyZicsIFs4NDk3XV0sIFsnZnBhcnRpbnQnLCBbMTA3NjVdXSwgWydmcmFjMTInLCBbMTg5XV0sIFsnZnJhYzEzJywgWzg1MzFdXSwgWydmcmFjMTQnLCBbMTg4XV0sIFsnZnJhYzE1JywgWzg1MzNdXSwgWydmcmFjMTYnLCBbODUzN11dLCBbJ2ZyYWMxOCcsIFs4NTM5XV0sIFsnZnJhYzIzJywgWzg1MzJdXSwgWydmcmFjMjUnLCBbODUzNF1dLCBbJ2ZyYWMzNCcsIFsxOTBdXSwgWydmcmFjMzUnLCBbODUzNV1dLCBbJ2ZyYWMzOCcsIFs4NTQwXV0sIFsnZnJhYzQ1JywgWzg1MzZdXSwgWydmcmFjNTYnLCBbODUzOF1dLCBbJ2ZyYWM1OCcsIFs4NTQxXV0sIFsnZnJhYzc4JywgWzg1NDJdXSwgWydmcmFzbCcsIFs4MjYwXV0sIFsnZnJvd24nLCBbODk5NF1dLCBbJ2ZzY3InLCBbMTE5OTk1XV0sIFsnRnNjcicsIFs4NDk3XV0sIFsnZ2FjdXRlJywgWzUwMV1dLCBbJ0dhbW1hJywgWzkxNV1dLCBbJ2dhbW1hJywgWzk0N11dLCBbJ0dhbW1hZCcsIFs5ODhdXSwgWydnYW1tYWQnLCBbOTg5XV0sIFsnZ2FwJywgWzEwODg2XV0sIFsnR2JyZXZlJywgWzI4Nl1dLCBbJ2dicmV2ZScsIFsyODddXSwgWydHY2VkaWwnLCBbMjkwXV0sIFsnR2NpcmMnLCBbMjg0XV0sIFsnZ2NpcmMnLCBbMjg1XV0sIFsnR2N5JywgWzEwNDNdXSwgWydnY3knLCBbMTA3NV1dLCBbJ0dkb3QnLCBbMjg4XV0sIFsnZ2RvdCcsIFsyODldXSwgWydnZScsIFs4ODA1XV0sIFsnZ0UnLCBbODgwN11dLCBbJ2dFbCcsIFsxMDg5Ml1dLCBbJ2dlbCcsIFs4OTIzXV0sIFsnZ2VxJywgWzg4MDVdXSwgWydnZXFxJywgWzg4MDddXSwgWydnZXFzbGFudCcsIFsxMDg3OF1dLCBbJ2dlc2NjJywgWzEwOTIxXV0sIFsnZ2VzJywgWzEwODc4XV0sIFsnZ2VzZG90JywgWzEwODgwXV0sIFsnZ2VzZG90bycsIFsxMDg4Ml1dLCBbJ2dlc2RvdG9sJywgWzEwODg0XV0sIFsnZ2VzbCcsIFs4OTIzLCA2NTAyNF1dLCBbJ2dlc2xlcycsIFsxMDkwMF1dLCBbJ0dmcicsIFsxMjAwNzRdXSwgWydnZnInLCBbMTIwMTAwXV0sIFsnZ2cnLCBbODgxMV1dLCBbJ0dnJywgWzg5MjFdXSwgWydnZ2cnLCBbODkyMV1dLCBbJ2dpbWVsJywgWzg1MDNdXSwgWydHSmN5JywgWzEwMjddXSwgWydnamN5JywgWzExMDddXSwgWydnbGEnLCBbMTA5MTddXSwgWydnbCcsIFs4ODIzXV0sIFsnZ2xFJywgWzEwODk4XV0sIFsnZ2xqJywgWzEwOTE2XV0sIFsnZ25hcCcsIFsxMDg5MF1dLCBbJ2duYXBwcm94JywgWzEwODkwXV0sIFsnZ25lJywgWzEwODg4XV0sIFsnZ25FJywgWzg4MDldXSwgWydnbmVxJywgWzEwODg4XV0sIFsnZ25lcXEnLCBbODgwOV1dLCBbJ2duc2ltJywgWzg5MzVdXSwgWydHb3BmJywgWzEyMDEyNl1dLCBbJ2dvcGYnLCBbMTIwMTUyXV0sIFsnZ3JhdmUnLCBbOTZdXSwgWydHcmVhdGVyRXF1YWwnLCBbODgwNV1dLCBbJ0dyZWF0ZXJFcXVhbExlc3MnLCBbODkyM11dLCBbJ0dyZWF0ZXJGdWxsRXF1YWwnLCBbODgwN11dLCBbJ0dyZWF0ZXJHcmVhdGVyJywgWzEwOTE0XV0sIFsnR3JlYXRlckxlc3MnLCBbODgyM11dLCBbJ0dyZWF0ZXJTbGFudEVxdWFsJywgWzEwODc4XV0sIFsnR3JlYXRlclRpbGRlJywgWzg4MTldXSwgWydHc2NyJywgWzExOTk3MF1dLCBbJ2dzY3InLCBbODQ1OF1dLCBbJ2dzaW0nLCBbODgxOV1dLCBbJ2dzaW1lJywgWzEwODk0XV0sIFsnZ3NpbWwnLCBbMTA4OTZdXSwgWydndGNjJywgWzEwOTE5XV0sIFsnZ3RjaXInLCBbMTA4NzRdXSwgWydndCcsIFs2Ml1dLCBbJ0dUJywgWzYyXV0sIFsnR3QnLCBbODgxMV1dLCBbJ2d0ZG90JywgWzg5MTldXSwgWydndGxQYXInLCBbMTA2NDVdXSwgWydndHF1ZXN0JywgWzEwODc2XV0sIFsnZ3RyYXBwcm94JywgWzEwODg2XV0sIFsnZ3RyYXJyJywgWzEwNjE2XV0sIFsnZ3RyZG90JywgWzg5MTldXSwgWydndHJlcWxlc3MnLCBbODkyM11dLCBbJ2d0cmVxcWxlc3MnLCBbMTA4OTJdXSwgWydndHJsZXNzJywgWzg4MjNdXSwgWydndHJzaW0nLCBbODgxOV1dLCBbJ2d2ZXJ0bmVxcScsIFs4ODA5LCA2NTAyNF1dLCBbJ2d2bkUnLCBbODgwOSwgNjUwMjRdXSwgWydIYWNlaycsIFs3MTFdXSwgWydoYWlyc3AnLCBbODIwMl1dLCBbJ2hhbGYnLCBbMTg5XV0sIFsnaGFtaWx0JywgWzg0NTldXSwgWydIQVJEY3knLCBbMTA2Nl1dLCBbJ2hhcmRjeScsIFsxMDk4XV0sIFsnaGFycmNpcicsIFsxMDU2OF1dLCBbJ2hhcnInLCBbODU5Nl1dLCBbJ2hBcnInLCBbODY2MF1dLCBbJ2hhcnJ3JywgWzg2MjFdXSwgWydIYXQnLCBbOTRdXSwgWydoYmFyJywgWzg0NjNdXSwgWydIY2lyYycsIFsyOTJdXSwgWydoY2lyYycsIFsyOTNdXSwgWydoZWFydHMnLCBbOTgyOV1dLCBbJ2hlYXJ0c3VpdCcsIFs5ODI5XV0sIFsnaGVsbGlwJywgWzgyMzBdXSwgWydoZXJjb24nLCBbODg4OV1dLCBbJ2hmcicsIFsxMjAxMDFdXSwgWydIZnInLCBbODQ2MF1dLCBbJ0hpbGJlcnRTcGFjZScsIFs4NDU5XV0sIFsnaGtzZWFyb3cnLCBbMTA1MzNdXSwgWydoa3N3YXJvdycsIFsxMDUzNF1dLCBbJ2hvYXJyJywgWzg3MDNdXSwgWydob210aHQnLCBbODc2M11dLCBbJ2hvb2tsZWZ0YXJyb3cnLCBbODYxN11dLCBbJ2hvb2tyaWdodGFycm93JywgWzg2MThdXSwgWydob3BmJywgWzEyMDE1M11dLCBbJ0hvcGYnLCBbODQ2MV1dLCBbJ2hvcmJhcicsIFs4MjEzXV0sIFsnSG9yaXpvbnRhbExpbmUnLCBbOTQ3Ml1dLCBbJ2hzY3InLCBbMTE5OTk3XV0sIFsnSHNjcicsIFs4NDU5XV0sIFsnaHNsYXNoJywgWzg0NjNdXSwgWydIc3Ryb2snLCBbMjk0XV0sIFsnaHN0cm9rJywgWzI5NV1dLCBbJ0h1bXBEb3duSHVtcCcsIFs4NzgyXV0sIFsnSHVtcEVxdWFsJywgWzg3ODNdXSwgWydoeWJ1bGwnLCBbODI1OV1dLCBbJ2h5cGhlbicsIFs4MjA4XV0sIFsnSWFjdXRlJywgWzIwNV1dLCBbJ2lhY3V0ZScsIFsyMzddXSwgWydpYycsIFs4MjkxXV0sIFsnSWNpcmMnLCBbMjA2XV0sIFsnaWNpcmMnLCBbMjM4XV0sIFsnSWN5JywgWzEwNDhdXSwgWydpY3knLCBbMTA4MF1dLCBbJ0lkb3QnLCBbMzA0XV0sIFsnSUVjeScsIFsxMDQ1XV0sIFsnaWVjeScsIFsxMDc3XV0sIFsnaWV4Y2wnLCBbMTYxXV0sIFsnaWZmJywgWzg2NjBdXSwgWydpZnInLCBbMTIwMTAyXV0sIFsnSWZyJywgWzg0NjVdXSwgWydJZ3JhdmUnLCBbMjA0XV0sIFsnaWdyYXZlJywgWzIzNl1dLCBbJ2lpJywgWzg1MjBdXSwgWydpaWlpbnQnLCBbMTA3NjRdXSwgWydpaWludCcsIFs4NzQ5XV0sIFsnaWluZmluJywgWzEwNzE2XV0sIFsnaWlvdGEnLCBbODQ4OV1dLCBbJ0lKbGlnJywgWzMwNl1dLCBbJ2lqbGlnJywgWzMwN11dLCBbJ0ltYWNyJywgWzI5OF1dLCBbJ2ltYWNyJywgWzI5OV1dLCBbJ2ltYWdlJywgWzg0NjVdXSwgWydJbWFnaW5hcnlJJywgWzg1MjBdXSwgWydpbWFnbGluZScsIFs4NDY0XV0sIFsnaW1hZ3BhcnQnLCBbODQ2NV1dLCBbJ2ltYXRoJywgWzMwNV1dLCBbJ0ltJywgWzg0NjVdXSwgWydpbW9mJywgWzg4ODddXSwgWydpbXBlZCcsIFs0MzddXSwgWydJbXBsaWVzJywgWzg2NThdXSwgWydpbmNhcmUnLCBbODQ1M11dLCBbJ2luJywgWzg3MTJdXSwgWydpbmZpbicsIFs4NzM0XV0sIFsnaW5maW50aWUnLCBbMTA3MTddXSwgWydpbm9kb3QnLCBbMzA1XV0sIFsnaW50Y2FsJywgWzg4OTBdXSwgWydpbnQnLCBbODc0N11dLCBbJ0ludCcsIFs4NzQ4XV0sIFsnaW50ZWdlcnMnLCBbODQ4NF1dLCBbJ0ludGVncmFsJywgWzg3NDddXSwgWydpbnRlcmNhbCcsIFs4ODkwXV0sIFsnSW50ZXJzZWN0aW9uJywgWzg4OThdXSwgWydpbnRsYXJoaycsIFsxMDc3NV1dLCBbJ2ludHByb2QnLCBbMTA4MTJdXSwgWydJbnZpc2libGVDb21tYScsIFs4MjkxXV0sIFsnSW52aXNpYmxlVGltZXMnLCBbODI5MF1dLCBbJ0lPY3knLCBbMTAyNV1dLCBbJ2lvY3knLCBbMTEwNV1dLCBbJ0lvZ29uJywgWzMwMl1dLCBbJ2lvZ29uJywgWzMwM11dLCBbJ0lvcGYnLCBbMTIwMTI4XV0sIFsnaW9wZicsIFsxMjAxNTRdXSwgWydJb3RhJywgWzkyMV1dLCBbJ2lvdGEnLCBbOTUzXV0sIFsnaXByb2QnLCBbMTA4MTJdXSwgWydpcXVlc3QnLCBbMTkxXV0sIFsnaXNjcicsIFsxMTk5OThdXSwgWydJc2NyJywgWzg0NjRdXSwgWydpc2luJywgWzg3MTJdXSwgWydpc2luZG90JywgWzg5NDldXSwgWydpc2luRScsIFs4OTUzXV0sIFsnaXNpbnMnLCBbODk0OF1dLCBbJ2lzaW5zdicsIFs4OTQ3XV0sIFsnaXNpbnYnLCBbODcxMl1dLCBbJ2l0JywgWzgyOTBdXSwgWydJdGlsZGUnLCBbMjk2XV0sIFsnaXRpbGRlJywgWzI5N11dLCBbJ0l1a2N5JywgWzEwMzBdXSwgWydpdWtjeScsIFsxMTEwXV0sIFsnSXVtbCcsIFsyMDddXSwgWydpdW1sJywgWzIzOV1dLCBbJ0pjaXJjJywgWzMwOF1dLCBbJ2pjaXJjJywgWzMwOV1dLCBbJ0pjeScsIFsxMDQ5XV0sIFsnamN5JywgWzEwODFdXSwgWydKZnInLCBbMTIwMDc3XV0sIFsnamZyJywgWzEyMDEwM11dLCBbJ2ptYXRoJywgWzU2N11dLCBbJ0pvcGYnLCBbMTIwMTI5XV0sIFsnam9wZicsIFsxMjAxNTVdXSwgWydKc2NyJywgWzExOTk3M11dLCBbJ2pzY3InLCBbMTE5OTk5XV0sIFsnSnNlcmN5JywgWzEwMzJdXSwgWydqc2VyY3knLCBbMTExMl1dLCBbJ0p1a2N5JywgWzEwMjhdXSwgWydqdWtjeScsIFsxMTA4XV0sIFsnS2FwcGEnLCBbOTIyXV0sIFsna2FwcGEnLCBbOTU0XV0sIFsna2FwcGF2JywgWzEwMDhdXSwgWydLY2VkaWwnLCBbMzEwXV0sIFsna2NlZGlsJywgWzMxMV1dLCBbJ0tjeScsIFsxMDUwXV0sIFsna2N5JywgWzEwODJdXSwgWydLZnInLCBbMTIwMDc4XV0sIFsna2ZyJywgWzEyMDEwNF1dLCBbJ2tncmVlbicsIFszMTJdXSwgWydLSGN5JywgWzEwNjFdXSwgWydraGN5JywgWzEwOTNdXSwgWydLSmN5JywgWzEwMzZdXSwgWydramN5JywgWzExMTZdXSwgWydLb3BmJywgWzEyMDEzMF1dLCBbJ2tvcGYnLCBbMTIwMTU2XV0sIFsnS3NjcicsIFsxMTk5NzRdXSwgWydrc2NyJywgWzEyMDAwMF1dLCBbJ2xBYXJyJywgWzg2NjZdXSwgWydMYWN1dGUnLCBbMzEzXV0sIFsnbGFjdXRlJywgWzMxNF1dLCBbJ2xhZW1wdHl2JywgWzEwNjc2XV0sIFsnbGFncmFuJywgWzg0NjZdXSwgWydMYW1iZGEnLCBbOTIzXV0sIFsnbGFtYmRhJywgWzk1NV1dLCBbJ2xhbmcnLCBbMTAyMTZdXSwgWydMYW5nJywgWzEwMjE4XV0sIFsnbGFuZ2QnLCBbMTA2NDFdXSwgWydsYW5nbGUnLCBbMTAyMTZdXSwgWydsYXAnLCBbMTA4ODVdXSwgWydMYXBsYWNldHJmJywgWzg0NjZdXSwgWydsYXF1bycsIFsxNzFdXSwgWydsYXJyYicsIFs4Njc2XV0sIFsnbGFycmJmcycsIFsxMDUyN11dLCBbJ2xhcnInLCBbODU5Ml1dLCBbJ0xhcnInLCBbODYwNl1dLCBbJ2xBcnInLCBbODY1Nl1dLCBbJ2xhcnJmcycsIFsxMDUyNV1dLCBbJ2xhcnJoaycsIFs4NjE3XV0sIFsnbGFycmxwJywgWzg2MTldXSwgWydsYXJycGwnLCBbMTA1NTNdXSwgWydsYXJyc2ltJywgWzEwNjExXV0sIFsnbGFycnRsJywgWzg2MTBdXSwgWydsYXRhaWwnLCBbMTA1MjFdXSwgWydsQXRhaWwnLCBbMTA1MjNdXSwgWydsYXQnLCBbMTA5MjNdXSwgWydsYXRlJywgWzEwOTI1XV0sIFsnbGF0ZXMnLCBbMTA5MjUsIDY1MDI0XV0sIFsnbGJhcnInLCBbMTA1MDhdXSwgWydsQmFycicsIFsxMDUxMF1dLCBbJ2xiYnJrJywgWzEwMDk4XV0sIFsnbGJyYWNlJywgWzEyM11dLCBbJ2xicmFjaycsIFs5MV1dLCBbJ2xicmtlJywgWzEwNjM1XV0sIFsnbGJya3NsZCcsIFsxMDYzOV1dLCBbJ2xicmtzbHUnLCBbMTA2MzddXSwgWydMY2Fyb24nLCBbMzE3XV0sIFsnbGNhcm9uJywgWzMxOF1dLCBbJ0xjZWRpbCcsIFszMTVdXSwgWydsY2VkaWwnLCBbMzE2XV0sIFsnbGNlaWwnLCBbODk2OF1dLCBbJ2xjdWInLCBbMTIzXV0sIFsnTGN5JywgWzEwNTFdXSwgWydsY3knLCBbMTA4M11dLCBbJ2xkY2EnLCBbMTA1NTBdXSwgWydsZHF1bycsIFs4MjIwXV0sIFsnbGRxdW9yJywgWzgyMjJdXSwgWydsZHJkaGFyJywgWzEwNTk5XV0sIFsnbGRydXNoYXInLCBbMTA1NzFdXSwgWydsZHNoJywgWzg2MjZdXSwgWydsZScsIFs4ODA0XV0sIFsnbEUnLCBbODgwNl1dLCBbJ0xlZnRBbmdsZUJyYWNrZXQnLCBbMTAyMTZdXSwgWydMZWZ0QXJyb3dCYXInLCBbODY3Nl1dLCBbJ2xlZnRhcnJvdycsIFs4NTkyXV0sIFsnTGVmdEFycm93JywgWzg1OTJdXSwgWydMZWZ0YXJyb3cnLCBbODY1Nl1dLCBbJ0xlZnRBcnJvd1JpZ2h0QXJyb3cnLCBbODY0Nl1dLCBbJ2xlZnRhcnJvd3RhaWwnLCBbODYxMF1dLCBbJ0xlZnRDZWlsaW5nJywgWzg5NjhdXSwgWydMZWZ0RG91YmxlQnJhY2tldCcsIFsxMDIxNF1dLCBbJ0xlZnREb3duVGVlVmVjdG9yJywgWzEwNTkzXV0sIFsnTGVmdERvd25WZWN0b3JCYXInLCBbMTA1ODVdXSwgWydMZWZ0RG93blZlY3RvcicsIFs4NjQzXV0sIFsnTGVmdEZsb29yJywgWzg5NzBdXSwgWydsZWZ0aGFycG9vbmRvd24nLCBbODYzN11dLCBbJ2xlZnRoYXJwb29udXAnLCBbODYzNl1dLCBbJ2xlZnRsZWZ0YXJyb3dzJywgWzg2NDddXSwgWydsZWZ0cmlnaHRhcnJvdycsIFs4NTk2XV0sIFsnTGVmdFJpZ2h0QXJyb3cnLCBbODU5Nl1dLCBbJ0xlZnRyaWdodGFycm93JywgWzg2NjBdXSwgWydsZWZ0cmlnaHRhcnJvd3MnLCBbODY0Nl1dLCBbJ2xlZnRyaWdodGhhcnBvb25zJywgWzg2NTFdXSwgWydsZWZ0cmlnaHRzcXVpZ2Fycm93JywgWzg2MjFdXSwgWydMZWZ0UmlnaHRWZWN0b3InLCBbMTA1NzRdXSwgWydMZWZ0VGVlQXJyb3cnLCBbODYxMl1dLCBbJ0xlZnRUZWUnLCBbODg2N11dLCBbJ0xlZnRUZWVWZWN0b3InLCBbMTA1ODZdXSwgWydsZWZ0dGhyZWV0aW1lcycsIFs4OTA3XV0sIFsnTGVmdFRyaWFuZ2xlQmFyJywgWzEwNzAzXV0sIFsnTGVmdFRyaWFuZ2xlJywgWzg4ODJdXSwgWydMZWZ0VHJpYW5nbGVFcXVhbCcsIFs4ODg0XV0sIFsnTGVmdFVwRG93blZlY3RvcicsIFsxMDU3N11dLCBbJ0xlZnRVcFRlZVZlY3RvcicsIFsxMDU5Ml1dLCBbJ0xlZnRVcFZlY3RvckJhcicsIFsxMDU4NF1dLCBbJ0xlZnRVcFZlY3RvcicsIFs4NjM5XV0sIFsnTGVmdFZlY3RvckJhcicsIFsxMDU3OF1dLCBbJ0xlZnRWZWN0b3InLCBbODYzNl1dLCBbJ2xFZycsIFsxMDg5MV1dLCBbJ2xlZycsIFs4OTIyXV0sIFsnbGVxJywgWzg4MDRdXSwgWydsZXFxJywgWzg4MDZdXSwgWydsZXFzbGFudCcsIFsxMDg3N11dLCBbJ2xlc2NjJywgWzEwOTIwXV0sIFsnbGVzJywgWzEwODc3XV0sIFsnbGVzZG90JywgWzEwODc5XV0sIFsnbGVzZG90bycsIFsxMDg4MV1dLCBbJ2xlc2RvdG9yJywgWzEwODgzXV0sIFsnbGVzZycsIFs4OTIyLCA2NTAyNF1dLCBbJ2xlc2dlcycsIFsxMDg5OV1dLCBbJ2xlc3NhcHByb3gnLCBbMTA4ODVdXSwgWydsZXNzZG90JywgWzg5MThdXSwgWydsZXNzZXFndHInLCBbODkyMl1dLCBbJ2xlc3NlcXFndHInLCBbMTA4OTFdXSwgWydMZXNzRXF1YWxHcmVhdGVyJywgWzg5MjJdXSwgWydMZXNzRnVsbEVxdWFsJywgWzg4MDZdXSwgWydMZXNzR3JlYXRlcicsIFs4ODIyXV0sIFsnbGVzc2d0cicsIFs4ODIyXV0sIFsnTGVzc0xlc3MnLCBbMTA5MTNdXSwgWydsZXNzc2ltJywgWzg4MThdXSwgWydMZXNzU2xhbnRFcXVhbCcsIFsxMDg3N11dLCBbJ0xlc3NUaWxkZScsIFs4ODE4XV0sIFsnbGZpc2h0JywgWzEwNjIwXV0sIFsnbGZsb29yJywgWzg5NzBdXSwgWydMZnInLCBbMTIwMDc5XV0sIFsnbGZyJywgWzEyMDEwNV1dLCBbJ2xnJywgWzg4MjJdXSwgWydsZ0UnLCBbMTA4OTddXSwgWydsSGFyJywgWzEwNTk0XV0sIFsnbGhhcmQnLCBbODYzN11dLCBbJ2xoYXJ1JywgWzg2MzZdXSwgWydsaGFydWwnLCBbMTA2MDJdXSwgWydsaGJsaycsIFs5NjA0XV0sIFsnTEpjeScsIFsxMDMzXV0sIFsnbGpjeScsIFsxMTEzXV0sIFsnbGxhcnInLCBbODY0N11dLCBbJ2xsJywgWzg4MTBdXSwgWydMbCcsIFs4OTIwXV0sIFsnbGxjb3JuZXInLCBbODk5MF1dLCBbJ0xsZWZ0YXJyb3cnLCBbODY2Nl1dLCBbJ2xsaGFyZCcsIFsxMDYwM11dLCBbJ2xsdHJpJywgWzk3MjJdXSwgWydMbWlkb3QnLCBbMzE5XV0sIFsnbG1pZG90JywgWzMyMF1dLCBbJ2xtb3VzdGFjaGUnLCBbOTEzNl1dLCBbJ2xtb3VzdCcsIFs5MTM2XV0sIFsnbG5hcCcsIFsxMDg4OV1dLCBbJ2xuYXBwcm94JywgWzEwODg5XV0sIFsnbG5lJywgWzEwODg3XV0sIFsnbG5FJywgWzg4MDhdXSwgWydsbmVxJywgWzEwODg3XV0sIFsnbG5lcXEnLCBbODgwOF1dLCBbJ2xuc2ltJywgWzg5MzRdXSwgWydsb2FuZycsIFsxMDIyMF1dLCBbJ2xvYXJyJywgWzg3MDFdXSwgWydsb2JyaycsIFsxMDIxNF1dLCBbJ2xvbmdsZWZ0YXJyb3cnLCBbMTAyMjldXSwgWydMb25nTGVmdEFycm93JywgWzEwMjI5XV0sIFsnTG9uZ2xlZnRhcnJvdycsIFsxMDIzMl1dLCBbJ2xvbmdsZWZ0cmlnaHRhcnJvdycsIFsxMDIzMV1dLCBbJ0xvbmdMZWZ0UmlnaHRBcnJvdycsIFsxMDIzMV1dLCBbJ0xvbmdsZWZ0cmlnaHRhcnJvdycsIFsxMDIzNF1dLCBbJ2xvbmdtYXBzdG8nLCBbMTAyMzZdXSwgWydsb25ncmlnaHRhcnJvdycsIFsxMDIzMF1dLCBbJ0xvbmdSaWdodEFycm93JywgWzEwMjMwXV0sIFsnTG9uZ3JpZ2h0YXJyb3cnLCBbMTAyMzNdXSwgWydsb29wYXJyb3dsZWZ0JywgWzg2MTldXSwgWydsb29wYXJyb3dyaWdodCcsIFs4NjIwXV0sIFsnbG9wYXInLCBbMTA2MjldXSwgWydMb3BmJywgWzEyMDEzMV1dLCBbJ2xvcGYnLCBbMTIwMTU3XV0sIFsnbG9wbHVzJywgWzEwNzk3XV0sIFsnbG90aW1lcycsIFsxMDgwNF1dLCBbJ2xvd2FzdCcsIFs4NzI3XV0sIFsnbG93YmFyJywgWzk1XV0sIFsnTG93ZXJMZWZ0QXJyb3cnLCBbODYwMV1dLCBbJ0xvd2VyUmlnaHRBcnJvdycsIFs4NjAwXV0sIFsnbG96JywgWzk2NzRdXSwgWydsb3plbmdlJywgWzk2NzRdXSwgWydsb3pmJywgWzEwNzMxXV0sIFsnbHBhcicsIFs0MF1dLCBbJ2xwYXJsdCcsIFsxMDY0M11dLCBbJ2xyYXJyJywgWzg2NDZdXSwgWydscmNvcm5lcicsIFs4OTkxXV0sIFsnbHJoYXInLCBbODY1MV1dLCBbJ2xyaGFyZCcsIFsxMDYwNV1dLCBbJ2xybScsIFs4MjA2XV0sIFsnbHJ0cmknLCBbODg5NV1dLCBbJ2xzYXF1bycsIFs4MjQ5XV0sIFsnbHNjcicsIFsxMjAwMDFdXSwgWydMc2NyJywgWzg0NjZdXSwgWydsc2gnLCBbODYyNF1dLCBbJ0xzaCcsIFs4NjI0XV0sIFsnbHNpbScsIFs4ODE4XV0sIFsnbHNpbWUnLCBbMTA4OTNdXSwgWydsc2ltZycsIFsxMDg5NV1dLCBbJ2xzcWInLCBbOTFdXSwgWydsc3F1bycsIFs4MjE2XV0sIFsnbHNxdW9yJywgWzgyMThdXSwgWydMc3Ryb2snLCBbMzIxXV0sIFsnbHN0cm9rJywgWzMyMl1dLCBbJ2x0Y2MnLCBbMTA5MThdXSwgWydsdGNpcicsIFsxMDg3M11dLCBbJ2x0JywgWzYwXV0sIFsnTFQnLCBbNjBdXSwgWydMdCcsIFs4ODEwXV0sIFsnbHRkb3QnLCBbODkxOF1dLCBbJ2x0aHJlZScsIFs4OTA3XV0sIFsnbHRpbWVzJywgWzg5MDVdXSwgWydsdGxhcnInLCBbMTA2MTRdXSwgWydsdHF1ZXN0JywgWzEwODc1XV0sIFsnbHRyaScsIFs5NjY3XV0sIFsnbHRyaWUnLCBbODg4NF1dLCBbJ2x0cmlmJywgWzk2NjZdXSwgWydsdHJQYXInLCBbMTA2NDZdXSwgWydsdXJkc2hhcicsIFsxMDU3MF1dLCBbJ2x1cnVoYXInLCBbMTA1OThdXSwgWydsdmVydG5lcXEnLCBbODgwOCwgNjUwMjRdXSwgWydsdm5FJywgWzg4MDgsIDY1MDI0XV0sIFsnbWFjcicsIFsxNzVdXSwgWydtYWxlJywgWzk3OTRdXSwgWydtYWx0JywgWzEwMDE2XV0sIFsnbWFsdGVzZScsIFsxMDAxNl1dLCBbJ01hcCcsIFsxMDUwMV1dLCBbJ21hcCcsIFs4NjE0XV0sIFsnbWFwc3RvJywgWzg2MTRdXSwgWydtYXBzdG9kb3duJywgWzg2MTVdXSwgWydtYXBzdG9sZWZ0JywgWzg2MTJdXSwgWydtYXBzdG91cCcsIFs4NjEzXV0sIFsnbWFya2VyJywgWzk2NDZdXSwgWydtY29tbWEnLCBbMTA3OTNdXSwgWydNY3knLCBbMTA1Ml1dLCBbJ21jeScsIFsxMDg0XV0sIFsnbWRhc2gnLCBbODIxMl1dLCBbJ21ERG90JywgWzg3NjJdXSwgWydtZWFzdXJlZGFuZ2xlJywgWzg3MzddXSwgWydNZWRpdW1TcGFjZScsIFs4Mjg3XV0sIFsnTWVsbGludHJmJywgWzg0OTldXSwgWydNZnInLCBbMTIwMDgwXV0sIFsnbWZyJywgWzEyMDEwNl1dLCBbJ21obycsIFs4NDg3XV0sIFsnbWljcm8nLCBbMTgxXV0sIFsnbWlkYXN0JywgWzQyXV0sIFsnbWlkY2lyJywgWzEwOTkyXV0sIFsnbWlkJywgWzg3MzldXSwgWydtaWRkb3QnLCBbMTgzXV0sIFsnbWludXNiJywgWzg4NjNdXSwgWydtaW51cycsIFs4NzIyXV0sIFsnbWludXNkJywgWzg3NjBdXSwgWydtaW51c2R1JywgWzEwNzk0XV0sIFsnTWludXNQbHVzJywgWzg3MjNdXSwgWydtbGNwJywgWzEwOTcxXV0sIFsnbWxkcicsIFs4MjMwXV0sIFsnbW5wbHVzJywgWzg3MjNdXSwgWydtb2RlbHMnLCBbODg3MV1dLCBbJ01vcGYnLCBbMTIwMTMyXV0sIFsnbW9wZicsIFsxMjAxNThdXSwgWydtcCcsIFs4NzIzXV0sIFsnbXNjcicsIFsxMjAwMDJdXSwgWydNc2NyJywgWzg0OTldXSwgWydtc3Rwb3MnLCBbODc2Nl1dLCBbJ011JywgWzkyNF1dLCBbJ211JywgWzk1Nl1dLCBbJ211bHRpbWFwJywgWzg4ODhdXSwgWydtdW1hcCcsIFs4ODg4XV0sIFsnbmFibGEnLCBbODcxMV1dLCBbJ05hY3V0ZScsIFszMjNdXSwgWyduYWN1dGUnLCBbMzI0XV0sIFsnbmFuZycsIFs4NzM2LCA4NDAyXV0sIFsnbmFwJywgWzg3NzddXSwgWyduYXBFJywgWzEwODY0LCA4MjRdXSwgWyduYXBpZCcsIFs4Nzc5LCA4MjRdXSwgWyduYXBvcycsIFszMjldXSwgWyduYXBwcm94JywgWzg3NzddXSwgWyduYXR1cmFsJywgWzk4MzhdXSwgWyduYXR1cmFscycsIFs4NDY5XV0sIFsnbmF0dXInLCBbOTgzOF1dLCBbJ25ic3AnLCBbMTYwXV0sIFsnbmJ1bXAnLCBbODc4MiwgODI0XV0sIFsnbmJ1bXBlJywgWzg3ODMsIDgyNF1dLCBbJ25jYXAnLCBbMTA4MTldXSwgWydOY2Fyb24nLCBbMzI3XV0sIFsnbmNhcm9uJywgWzMyOF1dLCBbJ05jZWRpbCcsIFszMjVdXSwgWyduY2VkaWwnLCBbMzI2XV0sIFsnbmNvbmcnLCBbODc3NV1dLCBbJ25jb25nZG90JywgWzEwODYxLCA4MjRdXSwgWyduY3VwJywgWzEwODE4XV0sIFsnTmN5JywgWzEwNTNdXSwgWyduY3knLCBbMTA4NV1dLCBbJ25kYXNoJywgWzgyMTFdXSwgWyduZWFyaGsnLCBbMTA1MzJdXSwgWyduZWFycicsIFs4NTk5XV0sIFsnbmVBcnInLCBbODY2M11dLCBbJ25lYXJyb3cnLCBbODU5OV1dLCBbJ25lJywgWzg4MDBdXSwgWyduZWRvdCcsIFs4Nzg0LCA4MjRdXSwgWydOZWdhdGl2ZU1lZGl1bVNwYWNlJywgWzgyMDNdXSwgWydOZWdhdGl2ZVRoaWNrU3BhY2UnLCBbODIwM11dLCBbJ05lZ2F0aXZlVGhpblNwYWNlJywgWzgyMDNdXSwgWydOZWdhdGl2ZVZlcnlUaGluU3BhY2UnLCBbODIwM11dLCBbJ25lcXVpdicsIFs4ODAyXV0sIFsnbmVzZWFyJywgWzEwNTM2XV0sIFsnbmVzaW0nLCBbODc3MCwgODI0XV0sIFsnTmVzdGVkR3JlYXRlckdyZWF0ZXInLCBbODgxMV1dLCBbJ05lc3RlZExlc3NMZXNzJywgWzg4MTBdXSwgWyduZXhpc3QnLCBbODcwOF1dLCBbJ25leGlzdHMnLCBbODcwOF1dLCBbJ05mcicsIFsxMjAwODFdXSwgWyduZnInLCBbMTIwMTA3XV0sIFsnbmdFJywgWzg4MDcsIDgyNF1dLCBbJ25nZScsIFs4ODE3XV0sIFsnbmdlcScsIFs4ODE3XV0sIFsnbmdlcXEnLCBbODgwNywgODI0XV0sIFsnbmdlcXNsYW50JywgWzEwODc4LCA4MjRdXSwgWyduZ2VzJywgWzEwODc4LCA4MjRdXSwgWyduR2cnLCBbODkyMSwgODI0XV0sIFsnbmdzaW0nLCBbODgyMV1dLCBbJ25HdCcsIFs4ODExLCA4NDAyXV0sIFsnbmd0JywgWzg4MTVdXSwgWyduZ3RyJywgWzg4MTVdXSwgWyduR3R2JywgWzg4MTEsIDgyNF1dLCBbJ25oYXJyJywgWzg2MjJdXSwgWyduaEFycicsIFs4NjU0XV0sIFsnbmhwYXInLCBbMTA5OTRdXSwgWyduaScsIFs4NzE1XV0sIFsnbmlzJywgWzg5NTZdXSwgWyduaXNkJywgWzg5NTRdXSwgWyduaXYnLCBbODcxNV1dLCBbJ05KY3knLCBbMTAzNF1dLCBbJ25qY3knLCBbMTExNF1dLCBbJ25sYXJyJywgWzg2MDJdXSwgWydubEFycicsIFs4NjUzXV0sIFsnbmxkcicsIFs4MjI5XV0sIFsnbmxFJywgWzg4MDYsIDgyNF1dLCBbJ25sZScsIFs4ODE2XV0sIFsnbmxlZnRhcnJvdycsIFs4NjAyXV0sIFsnbkxlZnRhcnJvdycsIFs4NjUzXV0sIFsnbmxlZnRyaWdodGFycm93JywgWzg2MjJdXSwgWyduTGVmdHJpZ2h0YXJyb3cnLCBbODY1NF1dLCBbJ25sZXEnLCBbODgxNl1dLCBbJ25sZXFxJywgWzg4MDYsIDgyNF1dLCBbJ25sZXFzbGFudCcsIFsxMDg3NywgODI0XV0sIFsnbmxlcycsIFsxMDg3NywgODI0XV0sIFsnbmxlc3MnLCBbODgxNF1dLCBbJ25MbCcsIFs4OTIwLCA4MjRdXSwgWydubHNpbScsIFs4ODIwXV0sIFsnbkx0JywgWzg4MTAsIDg0MDJdXSwgWydubHQnLCBbODgxNF1dLCBbJ25sdHJpJywgWzg5MzhdXSwgWydubHRyaWUnLCBbODk0MF1dLCBbJ25MdHYnLCBbODgxMCwgODI0XV0sIFsnbm1pZCcsIFs4NzQwXV0sIFsnTm9CcmVhaycsIFs4Mjg4XV0sIFsnTm9uQnJlYWtpbmdTcGFjZScsIFsxNjBdXSwgWydub3BmJywgWzEyMDE1OV1dLCBbJ05vcGYnLCBbODQ2OV1dLCBbJ05vdCcsIFsxMDk4OF1dLCBbJ25vdCcsIFsxNzJdXSwgWydOb3RDb25ncnVlbnQnLCBbODgwMl1dLCBbJ05vdEN1cENhcCcsIFs4ODEzXV0sIFsnTm90RG91YmxlVmVydGljYWxCYXInLCBbODc0Ml1dLCBbJ05vdEVsZW1lbnQnLCBbODcxM11dLCBbJ05vdEVxdWFsJywgWzg4MDBdXSwgWydOb3RFcXVhbFRpbGRlJywgWzg3NzAsIDgyNF1dLCBbJ05vdEV4aXN0cycsIFs4NzA4XV0sIFsnTm90R3JlYXRlcicsIFs4ODE1XV0sIFsnTm90R3JlYXRlckVxdWFsJywgWzg4MTddXSwgWydOb3RHcmVhdGVyRnVsbEVxdWFsJywgWzg4MDcsIDgyNF1dLCBbJ05vdEdyZWF0ZXJHcmVhdGVyJywgWzg4MTEsIDgyNF1dLCBbJ05vdEdyZWF0ZXJMZXNzJywgWzg4MjVdXSwgWydOb3RHcmVhdGVyU2xhbnRFcXVhbCcsIFsxMDg3OCwgODI0XV0sIFsnTm90R3JlYXRlclRpbGRlJywgWzg4MjFdXSwgWydOb3RIdW1wRG93bkh1bXAnLCBbODc4MiwgODI0XV0sIFsnTm90SHVtcEVxdWFsJywgWzg3ODMsIDgyNF1dLCBbJ25vdGluJywgWzg3MTNdXSwgWydub3RpbmRvdCcsIFs4OTQ5LCA4MjRdXSwgWydub3RpbkUnLCBbODk1MywgODI0XV0sIFsnbm90aW52YScsIFs4NzEzXV0sIFsnbm90aW52YicsIFs4OTUxXV0sIFsnbm90aW52YycsIFs4OTUwXV0sIFsnTm90TGVmdFRyaWFuZ2xlQmFyJywgWzEwNzAzLCA4MjRdXSwgWydOb3RMZWZ0VHJpYW5nbGUnLCBbODkzOF1dLCBbJ05vdExlZnRUcmlhbmdsZUVxdWFsJywgWzg5NDBdXSwgWydOb3RMZXNzJywgWzg4MTRdXSwgWydOb3RMZXNzRXF1YWwnLCBbODgxNl1dLCBbJ05vdExlc3NHcmVhdGVyJywgWzg4MjRdXSwgWydOb3RMZXNzTGVzcycsIFs4ODEwLCA4MjRdXSwgWydOb3RMZXNzU2xhbnRFcXVhbCcsIFsxMDg3NywgODI0XV0sIFsnTm90TGVzc1RpbGRlJywgWzg4MjBdXSwgWydOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcicsIFsxMDkxNCwgODI0XV0sIFsnTm90TmVzdGVkTGVzc0xlc3MnLCBbMTA5MTMsIDgyNF1dLCBbJ25vdG5pJywgWzg3MTZdXSwgWydub3RuaXZhJywgWzg3MTZdXSwgWydub3RuaXZiJywgWzg5NThdXSwgWydub3RuaXZjJywgWzg5NTddXSwgWydOb3RQcmVjZWRlcycsIFs4ODMyXV0sIFsnTm90UHJlY2VkZXNFcXVhbCcsIFsxMDkyNywgODI0XV0sIFsnTm90UHJlY2VkZXNTbGFudEVxdWFsJywgWzg5MjhdXSwgWydOb3RSZXZlcnNlRWxlbWVudCcsIFs4NzE2XV0sIFsnTm90UmlnaHRUcmlhbmdsZUJhcicsIFsxMDcwNCwgODI0XV0sIFsnTm90UmlnaHRUcmlhbmdsZScsIFs4OTM5XV0sIFsnTm90UmlnaHRUcmlhbmdsZUVxdWFsJywgWzg5NDFdXSwgWydOb3RTcXVhcmVTdWJzZXQnLCBbODg0NywgODI0XV0sIFsnTm90U3F1YXJlU3Vic2V0RXF1YWwnLCBbODkzMF1dLCBbJ05vdFNxdWFyZVN1cGVyc2V0JywgWzg4NDgsIDgyNF1dLCBbJ05vdFNxdWFyZVN1cGVyc2V0RXF1YWwnLCBbODkzMV1dLCBbJ05vdFN1YnNldCcsIFs4ODM0LCA4NDAyXV0sIFsnTm90U3Vic2V0RXF1YWwnLCBbODg0MF1dLCBbJ05vdFN1Y2NlZWRzJywgWzg4MzNdXSwgWydOb3RTdWNjZWVkc0VxdWFsJywgWzEwOTI4LCA4MjRdXSwgWydOb3RTdWNjZWVkc1NsYW50RXF1YWwnLCBbODkyOV1dLCBbJ05vdFN1Y2NlZWRzVGlsZGUnLCBbODgzMSwgODI0XV0sIFsnTm90U3VwZXJzZXQnLCBbODgzNSwgODQwMl1dLCBbJ05vdFN1cGVyc2V0RXF1YWwnLCBbODg0MV1dLCBbJ05vdFRpbGRlJywgWzg3NjldXSwgWydOb3RUaWxkZUVxdWFsJywgWzg3NzJdXSwgWydOb3RUaWxkZUZ1bGxFcXVhbCcsIFs4Nzc1XV0sIFsnTm90VGlsZGVUaWxkZScsIFs4Nzc3XV0sIFsnTm90VmVydGljYWxCYXInLCBbODc0MF1dLCBbJ25wYXJhbGxlbCcsIFs4NzQyXV0sIFsnbnBhcicsIFs4NzQyXV0sIFsnbnBhcnNsJywgWzExMDA1LCA4NDIxXV0sIFsnbnBhcnQnLCBbODcwNiwgODI0XV0sIFsnbnBvbGludCcsIFsxMDc3Ml1dLCBbJ25wcicsIFs4ODMyXV0sIFsnbnByY3VlJywgWzg5MjhdXSwgWyducHJlYycsIFs4ODMyXV0sIFsnbnByZWNlcScsIFsxMDkyNywgODI0XV0sIFsnbnByZScsIFsxMDkyNywgODI0XV0sIFsnbnJhcnJjJywgWzEwNTQ3LCA4MjRdXSwgWyducmFycicsIFs4NjAzXV0sIFsnbnJBcnInLCBbODY1NV1dLCBbJ25yYXJydycsIFs4NjA1LCA4MjRdXSwgWyducmlnaHRhcnJvdycsIFs4NjAzXV0sIFsnblJpZ2h0YXJyb3cnLCBbODY1NV1dLCBbJ25ydHJpJywgWzg5MzldXSwgWyducnRyaWUnLCBbODk0MV1dLCBbJ25zYycsIFs4ODMzXV0sIFsnbnNjY3VlJywgWzg5MjldXSwgWyduc2NlJywgWzEwOTI4LCA4MjRdXSwgWydOc2NyJywgWzExOTk3N11dLCBbJ25zY3InLCBbMTIwMDAzXV0sIFsnbnNob3J0bWlkJywgWzg3NDBdXSwgWyduc2hvcnRwYXJhbGxlbCcsIFs4NzQyXV0sIFsnbnNpbScsIFs4NzY5XV0sIFsnbnNpbWUnLCBbODc3Ml1dLCBbJ25zaW1lcScsIFs4NzcyXV0sIFsnbnNtaWQnLCBbODc0MF1dLCBbJ25zcGFyJywgWzg3NDJdXSwgWyduc3FzdWJlJywgWzg5MzBdXSwgWyduc3FzdXBlJywgWzg5MzFdXSwgWyduc3ViJywgWzg4MzZdXSwgWyduc3ViRScsIFsxMDk0OSwgODI0XV0sIFsnbnN1YmUnLCBbODg0MF1dLCBbJ25zdWJzZXQnLCBbODgzNCwgODQwMl1dLCBbJ25zdWJzZXRlcScsIFs4ODQwXV0sIFsnbnN1YnNldGVxcScsIFsxMDk0OSwgODI0XV0sIFsnbnN1Y2MnLCBbODgzM11dLCBbJ25zdWNjZXEnLCBbMTA5MjgsIDgyNF1dLCBbJ25zdXAnLCBbODgzN11dLCBbJ25zdXBFJywgWzEwOTUwLCA4MjRdXSwgWyduc3VwZScsIFs4ODQxXV0sIFsnbnN1cHNldCcsIFs4ODM1LCA4NDAyXV0sIFsnbnN1cHNldGVxJywgWzg4NDFdXSwgWyduc3Vwc2V0ZXFxJywgWzEwOTUwLCA4MjRdXSwgWydudGdsJywgWzg4MjVdXSwgWydOdGlsZGUnLCBbMjA5XV0sIFsnbnRpbGRlJywgWzI0MV1dLCBbJ250bGcnLCBbODgyNF1dLCBbJ250cmlhbmdsZWxlZnQnLCBbODkzOF1dLCBbJ250cmlhbmdsZWxlZnRlcScsIFs4OTQwXV0sIFsnbnRyaWFuZ2xlcmlnaHQnLCBbODkzOV1dLCBbJ250cmlhbmdsZXJpZ2h0ZXEnLCBbODk0MV1dLCBbJ051JywgWzkyNV1dLCBbJ251JywgWzk1N11dLCBbJ251bScsIFszNV1dLCBbJ251bWVybycsIFs4NDcwXV0sIFsnbnVtc3AnLCBbODE5OV1dLCBbJ252YXAnLCBbODc4MSwgODQwMl1dLCBbJ252ZGFzaCcsIFs4ODc2XV0sIFsnbnZEYXNoJywgWzg4NzddXSwgWyduVmRhc2gnLCBbODg3OF1dLCBbJ25WRGFzaCcsIFs4ODc5XV0sIFsnbnZnZScsIFs4ODA1LCA4NDAyXV0sIFsnbnZndCcsIFs2MiwgODQwMl1dLCBbJ252SGFycicsIFsxMDUwMF1dLCBbJ252aW5maW4nLCBbMTA3MThdXSwgWydudmxBcnInLCBbMTA0OThdXSwgWydudmxlJywgWzg4MDQsIDg0MDJdXSwgWydudmx0JywgWzYwLCA4NDAyXV0sIFsnbnZsdHJpZScsIFs4ODg0LCA4NDAyXV0sIFsnbnZyQXJyJywgWzEwNDk5XV0sIFsnbnZydHJpZScsIFs4ODg1LCA4NDAyXV0sIFsnbnZzaW0nLCBbODc2NCwgODQwMl1dLCBbJ253YXJoaycsIFsxMDUzMV1dLCBbJ253YXJyJywgWzg1OThdXSwgWydud0FycicsIFs4NjYyXV0sIFsnbndhcnJvdycsIFs4NTk4XV0sIFsnbnduZWFyJywgWzEwNTM1XV0sIFsnT2FjdXRlJywgWzIxMV1dLCBbJ29hY3V0ZScsIFsyNDNdXSwgWydvYXN0JywgWzg4NTldXSwgWydPY2lyYycsIFsyMTJdXSwgWydvY2lyYycsIFsyNDRdXSwgWydvY2lyJywgWzg4NThdXSwgWydPY3knLCBbMTA1NF1dLCBbJ29jeScsIFsxMDg2XV0sIFsnb2Rhc2gnLCBbODg2MV1dLCBbJ09kYmxhYycsIFszMzZdXSwgWydvZGJsYWMnLCBbMzM3XV0sIFsnb2RpdicsIFsxMDgwOF1dLCBbJ29kb3QnLCBbODg1N11dLCBbJ29kc29sZCcsIFsxMDY4NF1dLCBbJ09FbGlnJywgWzMzOF1dLCBbJ29lbGlnJywgWzMzOV1dLCBbJ29mY2lyJywgWzEwNjg3XV0sIFsnT2ZyJywgWzEyMDA4Ml1dLCBbJ29mcicsIFsxMjAxMDhdXSwgWydvZ29uJywgWzczMV1dLCBbJ09ncmF2ZScsIFsyMTBdXSwgWydvZ3JhdmUnLCBbMjQyXV0sIFsnb2d0JywgWzEwNjg5XV0sIFsnb2hiYXInLCBbMTA2NzddXSwgWydvaG0nLCBbOTM3XV0sIFsnb2ludCcsIFs4NzUwXV0sIFsnb2xhcnInLCBbODYzNF1dLCBbJ29sY2lyJywgWzEwNjg2XV0sIFsnb2xjcm9zcycsIFsxMDY4M11dLCBbJ29saW5lJywgWzgyNTRdXSwgWydvbHQnLCBbMTA2ODhdXSwgWydPbWFjcicsIFszMzJdXSwgWydvbWFjcicsIFszMzNdXSwgWydPbWVnYScsIFs5MzddXSwgWydvbWVnYScsIFs5NjldXSwgWydPbWljcm9uJywgWzkyN11dLCBbJ29taWNyb24nLCBbOTU5XV0sIFsnb21pZCcsIFsxMDY3OF1dLCBbJ29taW51cycsIFs4ODU0XV0sIFsnT29wZicsIFsxMjAxMzRdXSwgWydvb3BmJywgWzEyMDE2MF1dLCBbJ29wYXInLCBbMTA2NzldXSwgWydPcGVuQ3VybHlEb3VibGVRdW90ZScsIFs4MjIwXV0sIFsnT3BlbkN1cmx5UXVvdGUnLCBbODIxNl1dLCBbJ29wZXJwJywgWzEwNjgxXV0sIFsnb3BsdXMnLCBbODg1M11dLCBbJ29yYXJyJywgWzg2MzVdXSwgWydPcicsIFsxMDgzNl1dLCBbJ29yJywgWzg3NDRdXSwgWydvcmQnLCBbMTA4NDVdXSwgWydvcmRlcicsIFs4NTAwXV0sIFsnb3JkZXJvZicsIFs4NTAwXV0sIFsnb3JkZicsIFsxNzBdXSwgWydvcmRtJywgWzE4Nl1dLCBbJ29yaWdvZicsIFs4ODg2XV0sIFsnb3JvcicsIFsxMDgzOF1dLCBbJ29yc2xvcGUnLCBbMTA4MzldXSwgWydvcnYnLCBbMTA4NDNdXSwgWydvUycsIFs5NDE2XV0sIFsnT3NjcicsIFsxMTk5NzhdXSwgWydvc2NyJywgWzg1MDBdXSwgWydPc2xhc2gnLCBbMjE2XV0sIFsnb3NsYXNoJywgWzI0OF1dLCBbJ29zb2wnLCBbODg1Nl1dLCBbJ090aWxkZScsIFsyMTNdXSwgWydvdGlsZGUnLCBbMjQ1XV0sIFsnb3RpbWVzYXMnLCBbMTA4MDZdXSwgWydPdGltZXMnLCBbMTA4MDddXSwgWydvdGltZXMnLCBbODg1NV1dLCBbJ091bWwnLCBbMjE0XV0sIFsnb3VtbCcsIFsyNDZdXSwgWydvdmJhcicsIFs5MDIxXV0sIFsnT3ZlckJhcicsIFs4MjU0XV0sIFsnT3ZlckJyYWNlJywgWzkxODJdXSwgWydPdmVyQnJhY2tldCcsIFs5MTQwXV0sIFsnT3ZlclBhcmVudGhlc2lzJywgWzkxODBdXSwgWydwYXJhJywgWzE4Ml1dLCBbJ3BhcmFsbGVsJywgWzg3NDFdXSwgWydwYXInLCBbODc0MV1dLCBbJ3BhcnNpbScsIFsxMDk5NV1dLCBbJ3BhcnNsJywgWzExMDA1XV0sIFsncGFydCcsIFs4NzA2XV0sIFsnUGFydGlhbEQnLCBbODcwNl1dLCBbJ1BjeScsIFsxMDU1XV0sIFsncGN5JywgWzEwODddXSwgWydwZXJjbnQnLCBbMzddXSwgWydwZXJpb2QnLCBbNDZdXSwgWydwZXJtaWwnLCBbODI0MF1dLCBbJ3BlcnAnLCBbODg2OV1dLCBbJ3BlcnRlbmsnLCBbODI0MV1dLCBbJ1BmcicsIFsxMjAwODNdXSwgWydwZnInLCBbMTIwMTA5XV0sIFsnUGhpJywgWzkzNF1dLCBbJ3BoaScsIFs5NjZdXSwgWydwaGl2JywgWzk4MV1dLCBbJ3BobW1hdCcsIFs4NDk5XV0sIFsncGhvbmUnLCBbOTc0Ml1dLCBbJ1BpJywgWzkyOF1dLCBbJ3BpJywgWzk2MF1dLCBbJ3BpdGNoZm9yaycsIFs4OTE2XV0sIFsncGl2JywgWzk4Ml1dLCBbJ3BsYW5jaycsIFs4NDYzXV0sIFsncGxhbmNraCcsIFs4NDYyXV0sIFsncGxhbmt2JywgWzg0NjNdXSwgWydwbHVzYWNpcicsIFsxMDc4N11dLCBbJ3BsdXNiJywgWzg4NjJdXSwgWydwbHVzY2lyJywgWzEwNzg2XV0sIFsncGx1cycsIFs0M11dLCBbJ3BsdXNkbycsIFs4NzI0XV0sIFsncGx1c2R1JywgWzEwNzg5XV0sIFsncGx1c2UnLCBbMTA4NjZdXSwgWydQbHVzTWludXMnLCBbMTc3XV0sIFsncGx1c21uJywgWzE3N11dLCBbJ3BsdXNzaW0nLCBbMTA3OTBdXSwgWydwbHVzdHdvJywgWzEwNzkxXV0sIFsncG0nLCBbMTc3XV0sIFsnUG9pbmNhcmVwbGFuZScsIFs4NDYwXV0sIFsncG9pbnRpbnQnLCBbMTA3NzNdXSwgWydwb3BmJywgWzEyMDE2MV1dLCBbJ1BvcGYnLCBbODQ3M11dLCBbJ3BvdW5kJywgWzE2M11dLCBbJ3ByYXAnLCBbMTA5MzVdXSwgWydQcicsIFsxMDkzOV1dLCBbJ3ByJywgWzg4MjZdXSwgWydwcmN1ZScsIFs4ODI4XV0sIFsncHJlY2FwcHJveCcsIFsxMDkzNV1dLCBbJ3ByZWMnLCBbODgyNl1dLCBbJ3ByZWNjdXJseWVxJywgWzg4MjhdXSwgWydQcmVjZWRlcycsIFs4ODI2XV0sIFsnUHJlY2VkZXNFcXVhbCcsIFsxMDkyN11dLCBbJ1ByZWNlZGVzU2xhbnRFcXVhbCcsIFs4ODI4XV0sIFsnUHJlY2VkZXNUaWxkZScsIFs4ODMwXV0sIFsncHJlY2VxJywgWzEwOTI3XV0sIFsncHJlY25hcHByb3gnLCBbMTA5MzddXSwgWydwcmVjbmVxcScsIFsxMDkzM11dLCBbJ3ByZWNuc2ltJywgWzg5MzZdXSwgWydwcmUnLCBbMTA5MjddXSwgWydwckUnLCBbMTA5MzFdXSwgWydwcmVjc2ltJywgWzg4MzBdXSwgWydwcmltZScsIFs4MjQyXV0sIFsnUHJpbWUnLCBbODI0M11dLCBbJ3ByaW1lcycsIFs4NDczXV0sIFsncHJuYXAnLCBbMTA5MzddXSwgWydwcm5FJywgWzEwOTMzXV0sIFsncHJuc2ltJywgWzg5MzZdXSwgWydwcm9kJywgWzg3MTldXSwgWydQcm9kdWN0JywgWzg3MTldXSwgWydwcm9mYWxhcicsIFs5MDA2XV0sIFsncHJvZmxpbmUnLCBbODk3OF1dLCBbJ3Byb2ZzdXJmJywgWzg5NzldXSwgWydwcm9wJywgWzg3MzNdXSwgWydQcm9wb3J0aW9uYWwnLCBbODczM11dLCBbJ1Byb3BvcnRpb24nLCBbODc1OV1dLCBbJ3Byb3B0bycsIFs4NzMzXV0sIFsncHJzaW0nLCBbODgzMF1dLCBbJ3BydXJlbCcsIFs4ODgwXV0sIFsnUHNjcicsIFsxMTk5NzldXSwgWydwc2NyJywgWzEyMDAwNV1dLCBbJ1BzaScsIFs5MzZdXSwgWydwc2knLCBbOTY4XV0sIFsncHVuY3NwJywgWzgyMDBdXSwgWydRZnInLCBbMTIwMDg0XV0sIFsncWZyJywgWzEyMDExMF1dLCBbJ3FpbnQnLCBbMTA3NjRdXSwgWydxb3BmJywgWzEyMDE2Ml1dLCBbJ1FvcGYnLCBbODQ3NF1dLCBbJ3FwcmltZScsIFs4Mjc5XV0sIFsnUXNjcicsIFsxMTk5ODBdXSwgWydxc2NyJywgWzEyMDAwNl1dLCBbJ3F1YXRlcm5pb25zJywgWzg0NjFdXSwgWydxdWF0aW50JywgWzEwNzc0XV0sIFsncXVlc3QnLCBbNjNdXSwgWydxdWVzdGVxJywgWzg3OTldXSwgWydxdW90JywgWzM0XV0sIFsnUVVPVCcsIFszNF1dLCBbJ3JBYXJyJywgWzg2NjddXSwgWydyYWNlJywgWzg3NjUsIDgxN11dLCBbJ1JhY3V0ZScsIFszNDBdXSwgWydyYWN1dGUnLCBbMzQxXV0sIFsncmFkaWMnLCBbODczMF1dLCBbJ3JhZW1wdHl2JywgWzEwNjc1XV0sIFsncmFuZycsIFsxMDIxN11dLCBbJ1JhbmcnLCBbMTAyMTldXSwgWydyYW5nZCcsIFsxMDY0Ml1dLCBbJ3JhbmdlJywgWzEwNjYxXV0sIFsncmFuZ2xlJywgWzEwMjE3XV0sIFsncmFxdW8nLCBbMTg3XV0sIFsncmFycmFwJywgWzEwNjEzXV0sIFsncmFycmInLCBbODY3N11dLCBbJ3JhcnJiZnMnLCBbMTA1MjhdXSwgWydyYXJyYycsIFsxMDU0N11dLCBbJ3JhcnInLCBbODU5NF1dLCBbJ1JhcnInLCBbODYwOF1dLCBbJ3JBcnInLCBbODY1OF1dLCBbJ3JhcnJmcycsIFsxMDUyNl1dLCBbJ3JhcnJoaycsIFs4NjE4XV0sIFsncmFycmxwJywgWzg2MjBdXSwgWydyYXJycGwnLCBbMTA1NjVdXSwgWydyYXJyc2ltJywgWzEwNjEyXV0sIFsnUmFycnRsJywgWzEwNTE4XV0sIFsncmFycnRsJywgWzg2MTFdXSwgWydyYXJydycsIFs4NjA1XV0sIFsncmF0YWlsJywgWzEwNTIyXV0sIFsnckF0YWlsJywgWzEwNTI0XV0sIFsncmF0aW8nLCBbODc1OF1dLCBbJ3JhdGlvbmFscycsIFs4NDc0XV0sIFsncmJhcnInLCBbMTA1MDldXSwgWydyQmFycicsIFsxMDUxMV1dLCBbJ1JCYXJyJywgWzEwNTEyXV0sIFsncmJicmsnLCBbMTAwOTldXSwgWydyYnJhY2UnLCBbMTI1XV0sIFsncmJyYWNrJywgWzkzXV0sIFsncmJya2UnLCBbMTA2MzZdXSwgWydyYnJrc2xkJywgWzEwNjM4XV0sIFsncmJya3NsdScsIFsxMDY0MF1dLCBbJ1JjYXJvbicsIFszNDRdXSwgWydyY2Fyb24nLCBbMzQ1XV0sIFsnUmNlZGlsJywgWzM0Ml1dLCBbJ3JjZWRpbCcsIFszNDNdXSwgWydyY2VpbCcsIFs4OTY5XV0sIFsncmN1YicsIFsxMjVdXSwgWydSY3knLCBbMTA1Nl1dLCBbJ3JjeScsIFsxMDg4XV0sIFsncmRjYScsIFsxMDU1MV1dLCBbJ3JkbGRoYXInLCBbMTA2MDFdXSwgWydyZHF1bycsIFs4MjIxXV0sIFsncmRxdW9yJywgWzgyMjFdXSwgWydDbG9zZUN1cmx5RG91YmxlUXVvdGUnLCBbODIyMV1dLCBbJ3Jkc2gnLCBbODYyN11dLCBbJ3JlYWwnLCBbODQ3Nl1dLCBbJ3JlYWxpbmUnLCBbODQ3NV1dLCBbJ3JlYWxwYXJ0JywgWzg0NzZdXSwgWydyZWFscycsIFs4NDc3XV0sIFsnUmUnLCBbODQ3Nl1dLCBbJ3JlY3QnLCBbOTY0NV1dLCBbJ3JlZycsIFsxNzRdXSwgWydSRUcnLCBbMTc0XV0sIFsnUmV2ZXJzZUVsZW1lbnQnLCBbODcxNV1dLCBbJ1JldmVyc2VFcXVpbGlicml1bScsIFs4NjUxXV0sIFsnUmV2ZXJzZVVwRXF1aWxpYnJpdW0nLCBbMTA2MDddXSwgWydyZmlzaHQnLCBbMTA2MjFdXSwgWydyZmxvb3InLCBbODk3MV1dLCBbJ3JmcicsIFsxMjAxMTFdXSwgWydSZnInLCBbODQ3Nl1dLCBbJ3JIYXInLCBbMTA1OTZdXSwgWydyaGFyZCcsIFs4NjQxXV0sIFsncmhhcnUnLCBbODY0MF1dLCBbJ3JoYXJ1bCcsIFsxMDYwNF1dLCBbJ1JobycsIFs5MjldXSwgWydyaG8nLCBbOTYxXV0sIFsncmhvdicsIFsxMDA5XV0sIFsnUmlnaHRBbmdsZUJyYWNrZXQnLCBbMTAyMTddXSwgWydSaWdodEFycm93QmFyJywgWzg2NzddXSwgWydyaWdodGFycm93JywgWzg1OTRdXSwgWydSaWdodEFycm93JywgWzg1OTRdXSwgWydSaWdodGFycm93JywgWzg2NThdXSwgWydSaWdodEFycm93TGVmdEFycm93JywgWzg2NDRdXSwgWydyaWdodGFycm93dGFpbCcsIFs4NjExXV0sIFsnUmlnaHRDZWlsaW5nJywgWzg5NjldXSwgWydSaWdodERvdWJsZUJyYWNrZXQnLCBbMTAyMTVdXSwgWydSaWdodERvd25UZWVWZWN0b3InLCBbMTA1ODldXSwgWydSaWdodERvd25WZWN0b3JCYXInLCBbMTA1ODFdXSwgWydSaWdodERvd25WZWN0b3InLCBbODY0Ml1dLCBbJ1JpZ2h0Rmxvb3InLCBbODk3MV1dLCBbJ3JpZ2h0aGFycG9vbmRvd24nLCBbODY0MV1dLCBbJ3JpZ2h0aGFycG9vbnVwJywgWzg2NDBdXSwgWydyaWdodGxlZnRhcnJvd3MnLCBbODY0NF1dLCBbJ3JpZ2h0bGVmdGhhcnBvb25zJywgWzg2NTJdXSwgWydyaWdodHJpZ2h0YXJyb3dzJywgWzg2NDldXSwgWydyaWdodHNxdWlnYXJyb3cnLCBbODYwNV1dLCBbJ1JpZ2h0VGVlQXJyb3cnLCBbODYxNF1dLCBbJ1JpZ2h0VGVlJywgWzg4NjZdXSwgWydSaWdodFRlZVZlY3RvcicsIFsxMDU4N11dLCBbJ3JpZ2h0dGhyZWV0aW1lcycsIFs4OTA4XV0sIFsnUmlnaHRUcmlhbmdsZUJhcicsIFsxMDcwNF1dLCBbJ1JpZ2h0VHJpYW5nbGUnLCBbODg4M11dLCBbJ1JpZ2h0VHJpYW5nbGVFcXVhbCcsIFs4ODg1XV0sIFsnUmlnaHRVcERvd25WZWN0b3InLCBbMTA1NzVdXSwgWydSaWdodFVwVGVlVmVjdG9yJywgWzEwNTg4XV0sIFsnUmlnaHRVcFZlY3RvckJhcicsIFsxMDU4MF1dLCBbJ1JpZ2h0VXBWZWN0b3InLCBbODYzOF1dLCBbJ1JpZ2h0VmVjdG9yQmFyJywgWzEwNTc5XV0sIFsnUmlnaHRWZWN0b3InLCBbODY0MF1dLCBbJ3JpbmcnLCBbNzMwXV0sIFsncmlzaW5nZG90c2VxJywgWzg3ODddXSwgWydybGFycicsIFs4NjQ0XV0sIFsncmxoYXInLCBbODY1Ml1dLCBbJ3JsbScsIFs4MjA3XV0sIFsncm1vdXN0YWNoZScsIFs5MTM3XV0sIFsncm1vdXN0JywgWzkxMzddXSwgWydybm1pZCcsIFsxMDk5MF1dLCBbJ3JvYW5nJywgWzEwMjIxXV0sIFsncm9hcnInLCBbODcwMl1dLCBbJ3JvYnJrJywgWzEwMjE1XV0sIFsncm9wYXInLCBbMTA2MzBdXSwgWydyb3BmJywgWzEyMDE2M11dLCBbJ1JvcGYnLCBbODQ3N11dLCBbJ3JvcGx1cycsIFsxMDc5OF1dLCBbJ3JvdGltZXMnLCBbMTA4MDVdXSwgWydSb3VuZEltcGxpZXMnLCBbMTA2MDhdXSwgWydycGFyJywgWzQxXV0sIFsncnBhcmd0JywgWzEwNjQ0XV0sIFsncnBwb2xpbnQnLCBbMTA3NzBdXSwgWydycmFycicsIFs4NjQ5XV0sIFsnUnJpZ2h0YXJyb3cnLCBbODY2N11dLCBbJ3JzYXF1bycsIFs4MjUwXV0sIFsncnNjcicsIFsxMjAwMDddXSwgWydSc2NyJywgWzg0NzVdXSwgWydyc2gnLCBbODYyNV1dLCBbJ1JzaCcsIFs4NjI1XV0sIFsncnNxYicsIFs5M11dLCBbJ3JzcXVvJywgWzgyMTddXSwgWydyc3F1b3InLCBbODIxN11dLCBbJ0Nsb3NlQ3VybHlRdW90ZScsIFs4MjE3XV0sIFsncnRocmVlJywgWzg5MDhdXSwgWydydGltZXMnLCBbODkwNl1dLCBbJ3J0cmknLCBbOTY1N11dLCBbJ3J0cmllJywgWzg4ODVdXSwgWydydHJpZicsIFs5NjU2XV0sIFsncnRyaWx0cmknLCBbMTA3MDJdXSwgWydSdWxlRGVsYXllZCcsIFsxMDc0MF1dLCBbJ3J1bHVoYXInLCBbMTA2MDBdXSwgWydyeCcsIFs4NDc4XV0sIFsnU2FjdXRlJywgWzM0Nl1dLCBbJ3NhY3V0ZScsIFszNDddXSwgWydzYnF1bycsIFs4MjE4XV0sIFsnc2NhcCcsIFsxMDkzNl1dLCBbJ1NjYXJvbicsIFszNTJdXSwgWydzY2Fyb24nLCBbMzUzXV0sIFsnU2MnLCBbMTA5NDBdXSwgWydzYycsIFs4ODI3XV0sIFsnc2NjdWUnLCBbODgyOV1dLCBbJ3NjZScsIFsxMDkyOF1dLCBbJ3NjRScsIFsxMDkzMl1dLCBbJ1NjZWRpbCcsIFszNTBdXSwgWydzY2VkaWwnLCBbMzUxXV0sIFsnU2NpcmMnLCBbMzQ4XV0sIFsnc2NpcmMnLCBbMzQ5XV0sIFsnc2NuYXAnLCBbMTA5MzhdXSwgWydzY25FJywgWzEwOTM0XV0sIFsnc2Nuc2ltJywgWzg5MzddXSwgWydzY3BvbGludCcsIFsxMDc3MV1dLCBbJ3Njc2ltJywgWzg4MzFdXSwgWydTY3knLCBbMTA1N11dLCBbJ3NjeScsIFsxMDg5XV0sIFsnc2RvdGInLCBbODg2NV1dLCBbJ3Nkb3QnLCBbODkwMV1dLCBbJ3Nkb3RlJywgWzEwODU0XV0sIFsnc2VhcmhrJywgWzEwNTMzXV0sIFsnc2VhcnInLCBbODYwMF1dLCBbJ3NlQXJyJywgWzg2NjRdXSwgWydzZWFycm93JywgWzg2MDBdXSwgWydzZWN0JywgWzE2N11dLCBbJ3NlbWknLCBbNTldXSwgWydzZXN3YXInLCBbMTA1MzddXSwgWydzZXRtaW51cycsIFs4NzI2XV0sIFsnc2V0bW4nLCBbODcyNl1dLCBbJ3NleHQnLCBbMTAwMzhdXSwgWydTZnInLCBbMTIwMDg2XV0sIFsnc2ZyJywgWzEyMDExMl1dLCBbJ3Nmcm93bicsIFs4OTk0XV0sIFsnc2hhcnAnLCBbOTgzOV1dLCBbJ1NIQ0hjeScsIFsxMDY1XV0sIFsnc2hjaGN5JywgWzEwOTddXSwgWydTSGN5JywgWzEwNjRdXSwgWydzaGN5JywgWzEwOTZdXSwgWydTaG9ydERvd25BcnJvdycsIFs4NTk1XV0sIFsnU2hvcnRMZWZ0QXJyb3cnLCBbODU5Ml1dLCBbJ3Nob3J0bWlkJywgWzg3MzldXSwgWydzaG9ydHBhcmFsbGVsJywgWzg3NDFdXSwgWydTaG9ydFJpZ2h0QXJyb3cnLCBbODU5NF1dLCBbJ1Nob3J0VXBBcnJvdycsIFs4NTkzXV0sIFsnc2h5JywgWzE3M11dLCBbJ1NpZ21hJywgWzkzMV1dLCBbJ3NpZ21hJywgWzk2M11dLCBbJ3NpZ21hZicsIFs5NjJdXSwgWydzaWdtYXYnLCBbOTYyXV0sIFsnc2ltJywgWzg3NjRdXSwgWydzaW1kb3QnLCBbMTA4NThdXSwgWydzaW1lJywgWzg3NzFdXSwgWydzaW1lcScsIFs4NzcxXV0sIFsnc2ltZycsIFsxMDkxMF1dLCBbJ3NpbWdFJywgWzEwOTEyXV0sIFsnc2ltbCcsIFsxMDkwOV1dLCBbJ3NpbWxFJywgWzEwOTExXV0sIFsnc2ltbmUnLCBbODc3NF1dLCBbJ3NpbXBsdXMnLCBbMTA3ODhdXSwgWydzaW1yYXJyJywgWzEwNjEwXV0sIFsnc2xhcnInLCBbODU5Ml1dLCBbJ1NtYWxsQ2lyY2xlJywgWzg3MjhdXSwgWydzbWFsbHNldG1pbnVzJywgWzg3MjZdXSwgWydzbWFzaHAnLCBbMTA4MDNdXSwgWydzbWVwYXJzbCcsIFsxMDcyNF1dLCBbJ3NtaWQnLCBbODczOV1dLCBbJ3NtaWxlJywgWzg5OTVdXSwgWydzbXQnLCBbMTA5MjJdXSwgWydzbXRlJywgWzEwOTI0XV0sIFsnc210ZXMnLCBbMTA5MjQsIDY1MDI0XV0sIFsnU09GVGN5JywgWzEwNjhdXSwgWydzb2Z0Y3knLCBbMTEwMF1dLCBbJ3NvbGJhcicsIFs5MDIzXV0sIFsnc29sYicsIFsxMDY5Ml1dLCBbJ3NvbCcsIFs0N11dLCBbJ1NvcGYnLCBbMTIwMTM4XV0sIFsnc29wZicsIFsxMjAxNjRdXSwgWydzcGFkZXMnLCBbOTgyNF1dLCBbJ3NwYWRlc3VpdCcsIFs5ODI0XV0sIFsnc3BhcicsIFs4NzQxXV0sIFsnc3FjYXAnLCBbODg1MV1dLCBbJ3NxY2FwcycsIFs4ODUxLCA2NTAyNF1dLCBbJ3NxY3VwJywgWzg4NTJdXSwgWydzcWN1cHMnLCBbODg1MiwgNjUwMjRdXSwgWydTcXJ0JywgWzg3MzBdXSwgWydzcXN1YicsIFs4ODQ3XV0sIFsnc3FzdWJlJywgWzg4NDldXSwgWydzcXN1YnNldCcsIFs4ODQ3XV0sIFsnc3FzdWJzZXRlcScsIFs4ODQ5XV0sIFsnc3FzdXAnLCBbODg0OF1dLCBbJ3Nxc3VwZScsIFs4ODUwXV0sIFsnc3FzdXBzZXQnLCBbODg0OF1dLCBbJ3Nxc3Vwc2V0ZXEnLCBbODg1MF1dLCBbJ3NxdWFyZScsIFs5NjMzXV0sIFsnU3F1YXJlJywgWzk2MzNdXSwgWydTcXVhcmVJbnRlcnNlY3Rpb24nLCBbODg1MV1dLCBbJ1NxdWFyZVN1YnNldCcsIFs4ODQ3XV0sIFsnU3F1YXJlU3Vic2V0RXF1YWwnLCBbODg0OV1dLCBbJ1NxdWFyZVN1cGVyc2V0JywgWzg4NDhdXSwgWydTcXVhcmVTdXBlcnNldEVxdWFsJywgWzg4NTBdXSwgWydTcXVhcmVVbmlvbicsIFs4ODUyXV0sIFsnc3F1YXJmJywgWzk2NDJdXSwgWydzcXUnLCBbOTYzM11dLCBbJ3NxdWYnLCBbOTY0Ml1dLCBbJ3NyYXJyJywgWzg1OTRdXSwgWydTc2NyJywgWzExOTk4Ml1dLCBbJ3NzY3InLCBbMTIwMDA4XV0sIFsnc3NldG1uJywgWzg3MjZdXSwgWydzc21pbGUnLCBbODk5NV1dLCBbJ3NzdGFyZicsIFs4OTAyXV0sIFsnU3RhcicsIFs4OTAyXV0sIFsnc3RhcicsIFs5NzM0XV0sIFsnc3RhcmYnLCBbOTczM11dLCBbJ3N0cmFpZ2h0ZXBzaWxvbicsIFsxMDEzXV0sIFsnc3RyYWlnaHRwaGknLCBbOTgxXV0sIFsnc3RybnMnLCBbMTc1XV0sIFsnc3ViJywgWzg4MzRdXSwgWydTdWInLCBbODkxMl1dLCBbJ3N1YmRvdCcsIFsxMDk0MV1dLCBbJ3N1YkUnLCBbMTA5NDldXSwgWydzdWJlJywgWzg4MzhdXSwgWydzdWJlZG90JywgWzEwOTQ3XV0sIFsnc3VibXVsdCcsIFsxMDk0NV1dLCBbJ3N1Ym5FJywgWzEwOTU1XV0sIFsnc3VibmUnLCBbODg0Ml1dLCBbJ3N1YnBsdXMnLCBbMTA5NDNdXSwgWydzdWJyYXJyJywgWzEwNjE3XV0sIFsnc3Vic2V0JywgWzg4MzRdXSwgWydTdWJzZXQnLCBbODkxMl1dLCBbJ3N1YnNldGVxJywgWzg4MzhdXSwgWydzdWJzZXRlcXEnLCBbMTA5NDldXSwgWydTdWJzZXRFcXVhbCcsIFs4ODM4XV0sIFsnc3Vic2V0bmVxJywgWzg4NDJdXSwgWydzdWJzZXRuZXFxJywgWzEwOTU1XV0sIFsnc3Vic2ltJywgWzEwOTUxXV0sIFsnc3Vic3ViJywgWzEwOTY1XV0sIFsnc3Vic3VwJywgWzEwOTYzXV0sIFsnc3VjY2FwcHJveCcsIFsxMDkzNl1dLCBbJ3N1Y2MnLCBbODgyN11dLCBbJ3N1Y2NjdXJseWVxJywgWzg4MjldXSwgWydTdWNjZWVkcycsIFs4ODI3XV0sIFsnU3VjY2VlZHNFcXVhbCcsIFsxMDkyOF1dLCBbJ1N1Y2NlZWRzU2xhbnRFcXVhbCcsIFs4ODI5XV0sIFsnU3VjY2VlZHNUaWxkZScsIFs4ODMxXV0sIFsnc3VjY2VxJywgWzEwOTI4XV0sIFsnc3VjY25hcHByb3gnLCBbMTA5MzhdXSwgWydzdWNjbmVxcScsIFsxMDkzNF1dLCBbJ3N1Y2Nuc2ltJywgWzg5MzddXSwgWydzdWNjc2ltJywgWzg4MzFdXSwgWydTdWNoVGhhdCcsIFs4NzE1XV0sIFsnc3VtJywgWzg3MjFdXSwgWydTdW0nLCBbODcyMV1dLCBbJ3N1bmcnLCBbOTgzNF1dLCBbJ3N1cDEnLCBbMTg1XV0sIFsnc3VwMicsIFsxNzhdXSwgWydzdXAzJywgWzE3OV1dLCBbJ3N1cCcsIFs4ODM1XV0sIFsnU3VwJywgWzg5MTNdXSwgWydzdXBkb3QnLCBbMTA5NDJdXSwgWydzdXBkc3ViJywgWzEwOTY4XV0sIFsnc3VwRScsIFsxMDk1MF1dLCBbJ3N1cGUnLCBbODgzOV1dLCBbJ3N1cGVkb3QnLCBbMTA5NDhdXSwgWydTdXBlcnNldCcsIFs4ODM1XV0sIFsnU3VwZXJzZXRFcXVhbCcsIFs4ODM5XV0sIFsnc3VwaHNvbCcsIFsxMDE4NV1dLCBbJ3N1cGhzdWInLCBbMTA5NjddXSwgWydzdXBsYXJyJywgWzEwNjE5XV0sIFsnc3VwbXVsdCcsIFsxMDk0Nl1dLCBbJ3N1cG5FJywgWzEwOTU2XV0sIFsnc3VwbmUnLCBbODg0M11dLCBbJ3N1cHBsdXMnLCBbMTA5NDRdXSwgWydzdXBzZXQnLCBbODgzNV1dLCBbJ1N1cHNldCcsIFs4OTEzXV0sIFsnc3Vwc2V0ZXEnLCBbODgzOV1dLCBbJ3N1cHNldGVxcScsIFsxMDk1MF1dLCBbJ3N1cHNldG5lcScsIFs4ODQzXV0sIFsnc3Vwc2V0bmVxcScsIFsxMDk1Nl1dLCBbJ3N1cHNpbScsIFsxMDk1Ml1dLCBbJ3N1cHN1YicsIFsxMDk2NF1dLCBbJ3N1cHN1cCcsIFsxMDk2Nl1dLCBbJ3N3YXJoaycsIFsxMDUzNF1dLCBbJ3N3YXJyJywgWzg2MDFdXSwgWydzd0FycicsIFs4NjY1XV0sIFsnc3dhcnJvdycsIFs4NjAxXV0sIFsnc3dud2FyJywgWzEwNTM4XV0sIFsnc3psaWcnLCBbMjIzXV0sIFsnVGFiJywgWzldXSwgWyd0YXJnZXQnLCBbODk4Ml1dLCBbJ1RhdScsIFs5MzJdXSwgWyd0YXUnLCBbOTY0XV0sIFsndGJyaycsIFs5MTQwXV0sIFsnVGNhcm9uJywgWzM1Nl1dLCBbJ3RjYXJvbicsIFszNTddXSwgWydUY2VkaWwnLCBbMzU0XV0sIFsndGNlZGlsJywgWzM1NV1dLCBbJ1RjeScsIFsxMDU4XV0sIFsndGN5JywgWzEwOTBdXSwgWyd0ZG90JywgWzg0MTFdXSwgWyd0ZWxyZWMnLCBbODk4MV1dLCBbJ1RmcicsIFsxMjAwODddXSwgWyd0ZnInLCBbMTIwMTEzXV0sIFsndGhlcmU0JywgWzg3NTZdXSwgWyd0aGVyZWZvcmUnLCBbODc1Nl1dLCBbJ1RoZXJlZm9yZScsIFs4NzU2XV0sIFsnVGhldGEnLCBbOTIwXV0sIFsndGhldGEnLCBbOTUyXV0sIFsndGhldGFzeW0nLCBbOTc3XV0sIFsndGhldGF2JywgWzk3N11dLCBbJ3RoaWNrYXBwcm94JywgWzg3NzZdXSwgWyd0aGlja3NpbScsIFs4NzY0XV0sIFsnVGhpY2tTcGFjZScsIFs4Mjg3LCA4MjAyXV0sIFsnVGhpblNwYWNlJywgWzgyMDFdXSwgWyd0aGluc3AnLCBbODIwMV1dLCBbJ3Roa2FwJywgWzg3NzZdXSwgWyd0aGtzaW0nLCBbODc2NF1dLCBbJ1RIT1JOJywgWzIyMl1dLCBbJ3Rob3JuJywgWzI1NF1dLCBbJ3RpbGRlJywgWzczMl1dLCBbJ1RpbGRlJywgWzg3NjRdXSwgWydUaWxkZUVxdWFsJywgWzg3NzFdXSwgWydUaWxkZUZ1bGxFcXVhbCcsIFs4NzczXV0sIFsnVGlsZGVUaWxkZScsIFs4Nzc2XV0sIFsndGltZXNiYXInLCBbMTA4MDFdXSwgWyd0aW1lc2InLCBbODg2NF1dLCBbJ3RpbWVzJywgWzIxNV1dLCBbJ3RpbWVzZCcsIFsxMDgwMF1dLCBbJ3RpbnQnLCBbODc0OV1dLCBbJ3RvZWEnLCBbMTA1MzZdXSwgWyd0b3Bib3QnLCBbOTAxNF1dLCBbJ3RvcGNpcicsIFsxMDk5M11dLCBbJ3RvcCcsIFs4ODY4XV0sIFsnVG9wZicsIFsxMjAxMzldXSwgWyd0b3BmJywgWzEyMDE2NV1dLCBbJ3RvcGZvcmsnLCBbMTA5NzBdXSwgWyd0b3NhJywgWzEwNTM3XV0sIFsndHByaW1lJywgWzgyNDRdXSwgWyd0cmFkZScsIFs4NDgyXV0sIFsnVFJBREUnLCBbODQ4Ml1dLCBbJ3RyaWFuZ2xlJywgWzk2NTNdXSwgWyd0cmlhbmdsZWRvd24nLCBbOTY2M11dLCBbJ3RyaWFuZ2xlbGVmdCcsIFs5NjY3XV0sIFsndHJpYW5nbGVsZWZ0ZXEnLCBbODg4NF1dLCBbJ3RyaWFuZ2xlcScsIFs4Nzk2XV0sIFsndHJpYW5nbGVyaWdodCcsIFs5NjU3XV0sIFsndHJpYW5nbGVyaWdodGVxJywgWzg4ODVdXSwgWyd0cmlkb3QnLCBbOTcwOF1dLCBbJ3RyaWUnLCBbODc5Nl1dLCBbJ3RyaW1pbnVzJywgWzEwODEwXV0sIFsnVHJpcGxlRG90JywgWzg0MTFdXSwgWyd0cmlwbHVzJywgWzEwODA5XV0sIFsndHJpc2InLCBbMTA3MDFdXSwgWyd0cml0aW1lJywgWzEwODExXV0sIFsndHJwZXppdW0nLCBbOTE4Nl1dLCBbJ1RzY3InLCBbMTE5OTgzXV0sIFsndHNjcicsIFsxMjAwMDldXSwgWydUU2N5JywgWzEwNjJdXSwgWyd0c2N5JywgWzEwOTRdXSwgWydUU0hjeScsIFsxMDM1XV0sIFsndHNoY3knLCBbMTExNV1dLCBbJ1RzdHJvaycsIFszNThdXSwgWyd0c3Ryb2snLCBbMzU5XV0sIFsndHdpeHQnLCBbODgxMl1dLCBbJ3R3b2hlYWRsZWZ0YXJyb3cnLCBbODYwNl1dLCBbJ3R3b2hlYWRyaWdodGFycm93JywgWzg2MDhdXSwgWydVYWN1dGUnLCBbMjE4XV0sIFsndWFjdXRlJywgWzI1MF1dLCBbJ3VhcnInLCBbODU5M11dLCBbJ1VhcnInLCBbODYwN11dLCBbJ3VBcnInLCBbODY1N11dLCBbJ1VhcnJvY2lyJywgWzEwNTY5XV0sIFsnVWJyY3knLCBbMTAzOF1dLCBbJ3VicmN5JywgWzExMThdXSwgWydVYnJldmUnLCBbMzY0XV0sIFsndWJyZXZlJywgWzM2NV1dLCBbJ1VjaXJjJywgWzIxOV1dLCBbJ3VjaXJjJywgWzI1MV1dLCBbJ1VjeScsIFsxMDU5XV0sIFsndWN5JywgWzEwOTFdXSwgWyd1ZGFycicsIFs4NjQ1XV0sIFsnVWRibGFjJywgWzM2OF1dLCBbJ3VkYmxhYycsIFszNjldXSwgWyd1ZGhhcicsIFsxMDYwNl1dLCBbJ3VmaXNodCcsIFsxMDYyMl1dLCBbJ1VmcicsIFsxMjAwODhdXSwgWyd1ZnInLCBbMTIwMTE0XV0sIFsnVWdyYXZlJywgWzIxN11dLCBbJ3VncmF2ZScsIFsyNDldXSwgWyd1SGFyJywgWzEwNTk1XV0sIFsndWhhcmwnLCBbODYzOV1dLCBbJ3VoYXJyJywgWzg2MzhdXSwgWyd1aGJsaycsIFs5NjAwXV0sIFsndWxjb3JuJywgWzg5ODhdXSwgWyd1bGNvcm5lcicsIFs4OTg4XV0sIFsndWxjcm9wJywgWzg5NzVdXSwgWyd1bHRyaScsIFs5NzIwXV0sIFsnVW1hY3InLCBbMzYyXV0sIFsndW1hY3InLCBbMzYzXV0sIFsndW1sJywgWzE2OF1dLCBbJ1VuZGVyQmFyJywgWzk1XV0sIFsnVW5kZXJCcmFjZScsIFs5MTgzXV0sIFsnVW5kZXJCcmFja2V0JywgWzkxNDFdXSwgWydVbmRlclBhcmVudGhlc2lzJywgWzkxODFdXSwgWydVbmlvbicsIFs4ODk5XV0sIFsnVW5pb25QbHVzJywgWzg4NDZdXSwgWydVb2dvbicsIFszNzBdXSwgWyd1b2dvbicsIFszNzFdXSwgWydVb3BmJywgWzEyMDE0MF1dLCBbJ3VvcGYnLCBbMTIwMTY2XV0sIFsnVXBBcnJvd0JhcicsIFsxMDUxNF1dLCBbJ3VwYXJyb3cnLCBbODU5M11dLCBbJ1VwQXJyb3cnLCBbODU5M11dLCBbJ1VwYXJyb3cnLCBbODY1N11dLCBbJ1VwQXJyb3dEb3duQXJyb3cnLCBbODY0NV1dLCBbJ3VwZG93bmFycm93JywgWzg1OTddXSwgWydVcERvd25BcnJvdycsIFs4NTk3XV0sIFsnVXBkb3duYXJyb3cnLCBbODY2MV1dLCBbJ1VwRXF1aWxpYnJpdW0nLCBbMTA2MDZdXSwgWyd1cGhhcnBvb25sZWZ0JywgWzg2MzldXSwgWyd1cGhhcnBvb25yaWdodCcsIFs4NjM4XV0sIFsndXBsdXMnLCBbODg0Nl1dLCBbJ1VwcGVyTGVmdEFycm93JywgWzg1OThdXSwgWydVcHBlclJpZ2h0QXJyb3cnLCBbODU5OV1dLCBbJ3Vwc2knLCBbOTY1XV0sIFsnVXBzaScsIFs5NzhdXSwgWyd1cHNpaCcsIFs5NzhdXSwgWydVcHNpbG9uJywgWzkzM11dLCBbJ3Vwc2lsb24nLCBbOTY1XV0sIFsnVXBUZWVBcnJvdycsIFs4NjEzXV0sIFsnVXBUZWUnLCBbODg2OV1dLCBbJ3VwdXBhcnJvd3MnLCBbODY0OF1dLCBbJ3VyY29ybicsIFs4OTg5XV0sIFsndXJjb3JuZXInLCBbODk4OV1dLCBbJ3VyY3JvcCcsIFs4OTc0XV0sIFsnVXJpbmcnLCBbMzY2XV0sIFsndXJpbmcnLCBbMzY3XV0sIFsndXJ0cmknLCBbOTcyMV1dLCBbJ1VzY3InLCBbMTE5OTg0XV0sIFsndXNjcicsIFsxMjAwMTBdXSwgWyd1dGRvdCcsIFs4OTQ0XV0sIFsnVXRpbGRlJywgWzM2MF1dLCBbJ3V0aWxkZScsIFszNjFdXSwgWyd1dHJpJywgWzk2NTNdXSwgWyd1dHJpZicsIFs5NjUyXV0sIFsndXVhcnInLCBbODY0OF1dLCBbJ1V1bWwnLCBbMjIwXV0sIFsndXVtbCcsIFsyNTJdXSwgWyd1d2FuZ2xlJywgWzEwNjYzXV0sIFsndmFuZ3J0JywgWzEwNjUyXV0sIFsndmFyZXBzaWxvbicsIFsxMDEzXV0sIFsndmFya2FwcGEnLCBbMTAwOF1dLCBbJ3Zhcm5vdGhpbmcnLCBbODcwOV1dLCBbJ3ZhcnBoaScsIFs5ODFdXSwgWyd2YXJwaScsIFs5ODJdXSwgWyd2YXJwcm9wdG8nLCBbODczM11dLCBbJ3ZhcnInLCBbODU5N11dLCBbJ3ZBcnInLCBbODY2MV1dLCBbJ3ZhcnJobycsIFsxMDA5XV0sIFsndmFyc2lnbWEnLCBbOTYyXV0sIFsndmFyc3Vic2V0bmVxJywgWzg4NDIsIDY1MDI0XV0sIFsndmFyc3Vic2V0bmVxcScsIFsxMDk1NSwgNjUwMjRdXSwgWyd2YXJzdXBzZXRuZXEnLCBbODg0MywgNjUwMjRdXSwgWyd2YXJzdXBzZXRuZXFxJywgWzEwOTU2LCA2NTAyNF1dLCBbJ3ZhcnRoZXRhJywgWzk3N11dLCBbJ3ZhcnRyaWFuZ2xlbGVmdCcsIFs4ODgyXV0sIFsndmFydHJpYW5nbGVyaWdodCcsIFs4ODgzXV0sIFsndkJhcicsIFsxMDk4NF1dLCBbJ1ZiYXInLCBbMTA5ODddXSwgWyd2QmFydicsIFsxMDk4NV1dLCBbJ1ZjeScsIFsxMDQyXV0sIFsndmN5JywgWzEwNzRdXSwgWyd2ZGFzaCcsIFs4ODY2XV0sIFsndkRhc2gnLCBbODg3Ml1dLCBbJ1ZkYXNoJywgWzg4NzNdXSwgWydWRGFzaCcsIFs4ODc1XV0sIFsnVmRhc2hsJywgWzEwOTgyXV0sIFsndmVlYmFyJywgWzg4OTFdXSwgWyd2ZWUnLCBbODc0NF1dLCBbJ1ZlZScsIFs4ODk3XV0sIFsndmVlZXEnLCBbODc5NF1dLCBbJ3ZlbGxpcCcsIFs4OTQyXV0sIFsndmVyYmFyJywgWzEyNF1dLCBbJ1ZlcmJhcicsIFs4MjE0XV0sIFsndmVydCcsIFsxMjRdXSwgWydWZXJ0JywgWzgyMTRdXSwgWydWZXJ0aWNhbEJhcicsIFs4NzM5XV0sIFsnVmVydGljYWxMaW5lJywgWzEyNF1dLCBbJ1ZlcnRpY2FsU2VwYXJhdG9yJywgWzEwMDcyXV0sIFsnVmVydGljYWxUaWxkZScsIFs4NzY4XV0sIFsnVmVyeVRoaW5TcGFjZScsIFs4MjAyXV0sIFsnVmZyJywgWzEyMDA4OV1dLCBbJ3ZmcicsIFsxMjAxMTVdXSwgWyd2bHRyaScsIFs4ODgyXV0sIFsndm5zdWInLCBbODgzNCwgODQwMl1dLCBbJ3Zuc3VwJywgWzg4MzUsIDg0MDJdXSwgWydWb3BmJywgWzEyMDE0MV1dLCBbJ3ZvcGYnLCBbMTIwMTY3XV0sIFsndnByb3AnLCBbODczM11dLCBbJ3ZydHJpJywgWzg4ODNdXSwgWydWc2NyJywgWzExOTk4NV1dLCBbJ3ZzY3InLCBbMTIwMDExXV0sIFsndnN1Ym5FJywgWzEwOTU1LCA2NTAyNF1dLCBbJ3ZzdWJuZScsIFs4ODQyLCA2NTAyNF1dLCBbJ3ZzdXBuRScsIFsxMDk1NiwgNjUwMjRdXSwgWyd2c3VwbmUnLCBbODg0MywgNjUwMjRdXSwgWydWdmRhc2gnLCBbODg3NF1dLCBbJ3Z6aWd6YWcnLCBbMTA2NTBdXSwgWydXY2lyYycsIFszNzJdXSwgWyd3Y2lyYycsIFszNzNdXSwgWyd3ZWRiYXInLCBbMTA4NDddXSwgWyd3ZWRnZScsIFs4NzQzXV0sIFsnV2VkZ2UnLCBbODg5Nl1dLCBbJ3dlZGdlcScsIFs4NzkzXV0sIFsnd2VpZXJwJywgWzg0NzJdXSwgWydXZnInLCBbMTIwMDkwXV0sIFsnd2ZyJywgWzEyMDExNl1dLCBbJ1dvcGYnLCBbMTIwMTQyXV0sIFsnd29wZicsIFsxMjAxNjhdXSwgWyd3cCcsIFs4NDcyXV0sIFsnd3InLCBbODc2OF1dLCBbJ3dyZWF0aCcsIFs4NzY4XV0sIFsnV3NjcicsIFsxMTk5ODZdXSwgWyd3c2NyJywgWzEyMDAxMl1dLCBbJ3hjYXAnLCBbODg5OF1dLCBbJ3hjaXJjJywgWzk3MTFdXSwgWyd4Y3VwJywgWzg4OTldXSwgWyd4ZHRyaScsIFs5NjYxXV0sIFsnWGZyJywgWzEyMDA5MV1dLCBbJ3hmcicsIFsxMjAxMTddXSwgWyd4aGFycicsIFsxMDIzMV1dLCBbJ3hoQXJyJywgWzEwMjM0XV0sIFsnWGknLCBbOTI2XV0sIFsneGknLCBbOTU4XV0sIFsneGxhcnInLCBbMTAyMjldXSwgWyd4bEFycicsIFsxMDIzMl1dLCBbJ3htYXAnLCBbMTAyMzZdXSwgWyd4bmlzJywgWzg5NTVdXSwgWyd4b2RvdCcsIFsxMDc1Ml1dLCBbJ1hvcGYnLCBbMTIwMTQzXV0sIFsneG9wZicsIFsxMjAxNjldXSwgWyd4b3BsdXMnLCBbMTA3NTNdXSwgWyd4b3RpbWUnLCBbMTA3NTRdXSwgWyd4cmFycicsIFsxMDIzMF1dLCBbJ3hyQXJyJywgWzEwMjMzXV0sIFsnWHNjcicsIFsxMTk5ODddXSwgWyd4c2NyJywgWzEyMDAxM11dLCBbJ3hzcWN1cCcsIFsxMDc1OF1dLCBbJ3h1cGx1cycsIFsxMDc1Nl1dLCBbJ3h1dHJpJywgWzk2NTFdXSwgWyd4dmVlJywgWzg4OTddXSwgWyd4d2VkZ2UnLCBbODg5Nl1dLCBbJ1lhY3V0ZScsIFsyMjFdXSwgWyd5YWN1dGUnLCBbMjUzXV0sIFsnWUFjeScsIFsxMDcxXV0sIFsneWFjeScsIFsxMTAzXV0sIFsnWWNpcmMnLCBbMzc0XV0sIFsneWNpcmMnLCBbMzc1XV0sIFsnWWN5JywgWzEwNjddXSwgWyd5Y3knLCBbMTA5OV1dLCBbJ3llbicsIFsxNjVdXSwgWydZZnInLCBbMTIwMDkyXV0sIFsneWZyJywgWzEyMDExOF1dLCBbJ1lJY3knLCBbMTAzMV1dLCBbJ3lpY3knLCBbMTExMV1dLCBbJ1lvcGYnLCBbMTIwMTQ0XV0sIFsneW9wZicsIFsxMjAxNzBdXSwgWydZc2NyJywgWzExOTk4OF1dLCBbJ3lzY3InLCBbMTIwMDE0XV0sIFsnWVVjeScsIFsxMDcwXV0sIFsneXVjeScsIFsxMTAyXV0sIFsneXVtbCcsIFsyNTVdXSwgWydZdW1sJywgWzM3Nl1dLCBbJ1phY3V0ZScsIFszNzddXSwgWyd6YWN1dGUnLCBbMzc4XV0sIFsnWmNhcm9uJywgWzM4MV1dLCBbJ3pjYXJvbicsIFszODJdXSwgWydaY3knLCBbMTA0N11dLCBbJ3pjeScsIFsxMDc5XV0sIFsnWmRvdCcsIFszNzldXSwgWyd6ZG90JywgWzM4MF1dLCBbJ3plZXRyZicsIFs4NDg4XV0sIFsnWmVyb1dpZHRoU3BhY2UnLCBbODIwM11dLCBbJ1pldGEnLCBbOTE4XV0sIFsnemV0YScsIFs5NTBdXSwgWyd6ZnInLCBbMTIwMTE5XV0sIFsnWmZyJywgWzg0ODhdXSwgWydaSGN5JywgWzEwNDZdXSwgWyd6aGN5JywgWzEwNzhdXSwgWyd6aWdyYXJyJywgWzg2NjldXSwgWyd6b3BmJywgWzEyMDE3MV1dLCBbJ1pvcGYnLCBbODQ4NF1dLCBbJ1pzY3InLCBbMTE5OTg5XV0sIFsnenNjcicsIFsxMjAwMTVdXSwgWyd6d2onLCBbODIwNV1dLCBbJ3p3bmonLCBbODIwNF1dXTtcblxudmFyIGFscGhhSW5kZXggPSB7fTtcbnZhciBjaGFySW5kZXggPSB7fTtcblxuY3JlYXRlSW5kZXhlcyhhbHBoYUluZGV4LCBjaGFySW5kZXgpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBIdG1sNUVudGl0aWVzKCkge31cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNUVudGl0aWVzLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJigjP1tcXHdcXGRdKyk7Py9nLCBmdW5jdGlvbihzLCBlbnRpdHkpIHtcbiAgICAgICAgdmFyIGNocjtcbiAgICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IGVudGl0eS5jaGFyQXQoMSkgPT09ICd4JyA/XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigyKS50b0xvd2VyQ2FzZSgpLCAxNikgOlxuICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMSkpO1xuXG4gICAgICAgICAgICBpZiAoIShpc05hTihjb2RlKSB8fCBjb2RlIDwgLTMyNzY4IHx8IGNvZGUgPiA2NTUzNSkpIHtcbiAgICAgICAgICAgICAgICBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hyID0gYWxwaGFJbmRleFtlbnRpdHldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaHIgfHwgcztcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIEh0bWw1RW50aXRpZXMuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNUVudGl0aWVzKCkuZGVjb2RlKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNUVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoYXJJbmZvID0gY2hhckluZGV4W3N0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICAgICAgaWYgKGNoYXJJbmZvKSB7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBjaGFySW5mb1tzdHIuY2hhckNvZGVBdChpICsgMSldO1xuICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbHBoYSA9IGNoYXJJbmZvWycnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBIdG1sNUVudGl0aWVzLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmVuY29kZShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBjaGFySW5mbyA9IGNoYXJJbmRleFtjXTtcbiAgICAgICAgaWYgKGNoYXJJbmZvKSB7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBjaGFySW5mb1tzdHIuY2hhckNvZGVBdChpICsgMSldO1xuICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbHBoYSA9IGNoYXJJbmZvWycnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjIDwgMzIgfHwgYyA+IDEyNikge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gSHRtbDVFbnRpdGllcy5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5lbmNvZGVOb25VVEYoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw1RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDw9IDI1NSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0cltpKytdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICBpKytcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIEh0bWw1RW50aXRpZXMuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5lbmNvZGVOb25BU0NJSShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGFscGhhSW5kZXggUGFzc2VkIGJ5IHJlZmVyZW5jZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGFySW5kZXggUGFzc2VkIGJ5IHJlZmVyZW5jZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5kZXhlcyhhbHBoYUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICB2YXIgaSA9IEVOVElUSUVTLmxlbmd0aDtcbiAgICB2YXIgX3Jlc3VsdHMgPSBbXTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZhciBlID0gRU5USVRJRVNbaV07XG4gICAgICAgIHZhciBhbHBoYSA9IGVbMF07XG4gICAgICAgIHZhciBjaGFycyA9IGVbMV07XG4gICAgICAgIHZhciBjaHIgPSBjaGFyc1swXTtcbiAgICAgICAgdmFyIGFkZENoYXIgPSAoY2hyIDwgMzIgfHwgY2hyID4gMTI2KSB8fCBjaHIgPT09IDYyIHx8IGNociA9PT0gNjAgfHwgY2hyID09PSAzOCB8fCBjaHIgPT09IDM0IHx8IGNociA9PT0gMzk7XG4gICAgICAgIHZhciBjaGFySW5mbztcbiAgICAgICAgaWYgKGFkZENoYXIpIHtcbiAgICAgICAgICAgIGNoYXJJbmZvID0gY2hhckluZGV4W2Nocl0gPSBjaGFySW5kZXhbY2hyXSB8fCB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhcnNbMV0pIHtcbiAgICAgICAgICAgIHZhciBjaHIyID0gY2hhcnNbMV07XG4gICAgICAgICAgICBhbHBoYUluZGV4W2FscGhhXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMik7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGFkZENoYXIgJiYgKGNoYXJJbmZvW2NocjJdID0gYWxwaGEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFscGhhSW5kZXhbYWxwaGFdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChhZGRDaGFyICYmIChjaGFySW5mb1snJ10gPSBhbHBoYSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWw1RW50aXRpZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvaHRtbDUtZW50aXRpZXMuanMiLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy1leHQuanMiLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBTID0gU3ltYm9sKCk7XG4gIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICB2YXIgaXNFbnVtID0gcElFLmY7XG4gIHdoaWxlIChhTGVuID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSBpZiAoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSkgVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGludm9rZSA9IHJlcXVpcmUoJy4vX2ludm9rZScpO1xudmFyIGFycmF5U2xpY2UgPSBbXS5zbGljZTtcbnZhciBmYWN0b3JpZXMgPSB7fTtcblxudmFyIGNvbnN0cnVjdCA9IGZ1bmN0aW9uIChGLCBsZW4sIGFyZ3MpIHtcbiAgaWYgKCEobGVuIGluIGZhY3RvcmllcykpIHtcbiAgICBmb3IgKHZhciBuID0gW10sIGkgPSAwOyBpIDwgbGVuOyBpKyspIG5baV0gPSAnYVsnICsgaSArICddJztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICBmYWN0b3JpZXNbbGVuXSA9IEZ1bmN0aW9uKCdGLGEnLCAncmV0dXJuIG5ldyBGKCcgKyBuLmpvaW4oJywnKSArICcpJyk7XG4gIH0gcmV0dXJuIGZhY3Rvcmllc1tsZW5dKEYsIGFyZ3MpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5iaW5kIHx8IGZ1bmN0aW9uIGJpbmQodGhhdCAvKiAsIC4uLmFyZ3MgKi8pIHtcbiAgdmFyIGZuID0gYUZ1bmN0aW9uKHRoaXMpO1xuICB2YXIgcGFydEFyZ3MgPSBhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgdmFyIGJvdW5kID0gZnVuY3Rpb24gKC8qIGFyZ3MuLi4gKi8pIHtcbiAgICB2YXIgYXJncyA9IHBhcnRBcmdzLmNvbmNhdChhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBib3VuZCA/IGNvbnN0cnVjdChmbiwgYXJncy5sZW5ndGgsIGFyZ3MpIDogaW52b2tlKGZuLCBhcmdzLCB0aGF0KTtcbiAgfTtcbiAgaWYgKGlzT2JqZWN0KGZuLnByb3RvdHlwZSkpIGJvdW5kLnByb3RvdHlwZSA9IGZuLnByb3RvdHlwZTtcbiAgcmV0dXJuIGJvdW5kO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2JpbmQuanMiLCIvLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCBhcmdzLCB0aGF0KSB7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbnZva2UuanMiLCJ2YXIgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucGFyc2VJbnQ7XG52YXIgJHRyaW0gPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW07XG52YXIgd3MgPSByZXF1aXJlKCcuL19zdHJpbmctd3MnKTtcbnZhciBoZXggPSAvXlstK10/MFt4WF0vO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICRwYXJzZUludCh3cyArICcwOCcpICE9PSA4IHx8ICRwYXJzZUludCh3cyArICcweDE2JykgIT09IDIyID8gZnVuY3Rpb24gcGFyc2VJbnQoc3RyLCByYWRpeCkge1xuICB2YXIgc3RyaW5nID0gJHRyaW0oU3RyaW5nKHN0ciksIDMpO1xuICByZXR1cm4gJHBhcnNlSW50KHN0cmluZywgKHJhZGl4ID4+PiAwKSB8fCAoaGV4LnRlc3Qoc3RyaW5nKSA/IDE2IDogMTApKTtcbn0gOiAkcGFyc2VJbnQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wYXJzZS1pbnQuanMiLCJ2YXIgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5wYXJzZUZsb2F0O1xudmFyICR0cmltID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltO1xuXG5tb2R1bGUuZXhwb3J0cyA9IDEgLyAkcGFyc2VGbG9hdChyZXF1aXJlKCcuL19zdHJpbmctd3MnKSArICctMCcpICE9PSAtSW5maW5pdHkgPyBmdW5jdGlvbiBwYXJzZUZsb2F0KHN0cikge1xuICB2YXIgc3RyaW5nID0gJHRyaW0oU3RyaW5nKHN0ciksIDMpO1xuICB2YXIgcmVzdWx0ID0gJHBhcnNlRmxvYXQoc3RyaW5nKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gMCAmJiBzdHJpbmcuY2hhckF0KDApID09ICctJyA/IC0wIDogcmVzdWx0O1xufSA6ICRwYXJzZUZsb2F0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtZmxvYXQuanMiLCJ2YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgbXNnKSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ251bWJlcicgJiYgY29mKGl0KSAhPSAnTnVtYmVyJykgdGhyb3cgVHlwZUVycm9yKG1zZyk7XG4gIHJldHVybiAraXQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1udW1iZXItdmFsdWUuanMiLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNJbnRlZ2VyKGl0KSB7XG4gIHJldHVybiAhaXNPYmplY3QoaXQpICYmIGlzRmluaXRlKGl0KSAmJiBmbG9vcihpdCkgPT09IGl0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWludGVnZXIuanMiLCIvLyAyMC4yLjIuMjAgTWF0aC5sb2cxcCh4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLmxvZzFwIHx8IGZ1bmN0aW9uIGxvZzFwKHgpIHtcbiAgcmV0dXJuICh4ID0gK3gpID4gLTFlLTggJiYgeCA8IDFlLTggPyB4IC0geCAqIHggLyAyIDogTWF0aC5sb2coMSArIHgpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtbG9nMXAuanMiLCIvLyAyMC4yLjIuMTYgTWF0aC5mcm91bmQoeClcbnZhciBzaWduID0gcmVxdWlyZSgnLi9fbWF0aC1zaWduJyk7XG52YXIgcG93ID0gTWF0aC5wb3c7XG52YXIgRVBTSUxPTiA9IHBvdygyLCAtNTIpO1xudmFyIEVQU0lMT04zMiA9IHBvdygyLCAtMjMpO1xudmFyIE1BWDMyID0gcG93KDIsIDEyNykgKiAoMiAtIEVQU0lMT04zMik7XG52YXIgTUlOMzIgPSBwb3coMiwgLTEyNik7XG5cbnZhciByb3VuZFRpZXNUb0V2ZW4gPSBmdW5jdGlvbiAobikge1xuICByZXR1cm4gbiArIDEgLyBFUFNJTE9OIC0gMSAvIEVQU0lMT047XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguZnJvdW5kIHx8IGZ1bmN0aW9uIGZyb3VuZCh4KSB7XG4gIHZhciAkYWJzID0gTWF0aC5hYnMoeCk7XG4gIHZhciAkc2lnbiA9IHNpZ24oeCk7XG4gIHZhciBhLCByZXN1bHQ7XG4gIGlmICgkYWJzIDwgTUlOMzIpIHJldHVybiAkc2lnbiAqIHJvdW5kVGllc1RvRXZlbigkYWJzIC8gTUlOMzIgLyBFUFNJTE9OMzIpICogTUlOMzIgKiBFUFNJTE9OMzI7XG4gIGEgPSAoMSArIEVQU0lMT04zMiAvIEVQU0lMT04pICogJGFicztcbiAgcmVzdWx0ID0gYSAtIChhIC0gJGFicyk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgaWYgKHJlc3VsdCA+IE1BWDMyIHx8IHJlc3VsdCAhPSByZXN1bHQpIHJldHVybiAkc2lnbiAqIEluZmluaXR5O1xuICByZXR1cm4gJHNpZ24gKiByZXN1bHQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1mcm91bmQuanMiLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIGFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsInZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIGNhbGxiYWNrZm4sIGFMZW4sIG1lbW8sIGlzUmlnaHQpIHtcbiAgYUZ1bmN0aW9uKGNhbGxiYWNrZm4pO1xuICB2YXIgTyA9IHRvT2JqZWN0KHRoYXQpO1xuICB2YXIgc2VsZiA9IElPYmplY3QoTyk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciBpbmRleCA9IGlzUmlnaHQgPyBsZW5ndGggLSAxIDogMDtcbiAgdmFyIGkgPSBpc1JpZ2h0ID8gLTEgOiAxO1xuICBpZiAoYUxlbiA8IDIpIGZvciAoOzspIHtcbiAgICBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleCArPSBpO1xuICAgIGlmIChpc1JpZ2h0ID8gaW5kZXggPCAwIDogbGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICB9XG4gIH1cbiAgZm9yICg7aXNSaWdodCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSkgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICB9XG4gIHJldHVybiBtZW1vO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXJlZHVjZS5qcyIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtdLmNvcHlXaXRoaW4gfHwgZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQgLyogPSAwICovLCBzdGFydCAvKiA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbiA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIHRvID0gdG9BYnNvbHV0ZUluZGV4KHRhcmdldCwgbGVuKTtcbiAgdmFyIGZyb20gPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbik7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGNvdW50ID0gTWF0aC5taW4oKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuKSkgLSBmcm9tLCBsZW4gLSB0byk7XG4gIHZhciBpbmMgPSAxO1xuICBpZiAoZnJvbSA8IHRvICYmIHRvIDwgZnJvbSArIGNvdW50KSB7XG4gICAgaW5jID0gLTE7XG4gICAgZnJvbSArPSBjb3VudCAtIDE7XG4gICAgdG8gKz0gY291bnQgLSAxO1xuICB9XG4gIHdoaWxlIChjb3VudC0tID4gMCkge1xuICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtcbiAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICB0byArPSBpbmM7XG4gICAgZnJvbSArPSBpbmM7XG4gIH0gcmV0dXJuIE87XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktY29weS13aXRoaW4uanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzKClcbmlmIChyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmIC8uL2cuZmxhZ3MgIT0gJ2cnKSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKFJlZ0V4cC5wcm90b3R5cGUsICdmbGFncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IHJlcXVpcmUoJy4vX2ZsYWdzJylcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiB7IGU6IGZhbHNlLCB2OiBleGVjKCkgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7IGU6IHRydWUsIHY6IGUgfTtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BlcmZvcm0uanMiLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDLCB4KSB7XG4gIGFuT2JqZWN0KEMpO1xuICBpZiAoaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgcmVzb2x2ZSh4KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvbWlzZS1yZXNvbHZlLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgTUFQID0gJ01hcCc7XG5cbi8vIDIzLjEgTWFwIE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKE1BUCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gTWFwKCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMS4zLjYgTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSBzdHJvbmcuZ2V0RW50cnkodmFsaWRhdGUodGhpcywgTUFQKSwga2V5KTtcbiAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudjtcbiAgfSxcbiAgLy8gMjMuMS4zLjkgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHZhbGlkYXRlKHRoaXMsIE1BUCksIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nLCB0cnVlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hcC5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciAkaXRlckRlZmluZSA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBmYXN0S2V5ID0gcmVxdWlyZSgnLi9fbWV0YScpLmZhc3RLZXk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgU0laRSA9IERFU0NSSVBUT1JTID8gJ19zJyA6ICdzaXplJztcblxudmFyIGdldEVudHJ5ID0gZnVuY3Rpb24gKHRoYXQsIGtleSkge1xuICAvLyBmYXN0IGNhc2VcbiAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpO1xuICB2YXIgZW50cnk7XG4gIGlmIChpbmRleCAhPT0gJ0YnKSByZXR1cm4gdGhhdC5faVtpbmRleF07XG4gIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICBmb3IgKGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubikge1xuICAgIGlmIChlbnRyeS5rID09IGtleSkgcmV0dXJuIGVudHJ5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX3QgPSBOQU1FOyAgICAgICAgIC8vIGNvbGxlY3Rpb24gdHlwZVxuICAgICAgdGhhdC5faSA9IGNyZWF0ZShudWxsKTsgLy8gaW5kZXhcbiAgICAgIHRoYXQuX2YgPSB1bmRlZmluZWQ7ICAgIC8vIGZpcnN0IGVudHJ5XG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAgICAvLyBsYXN0IGVudHJ5XG4gICAgICB0aGF0W1NJWkVdID0gMDsgICAgICAgICAvLyBzaXplXG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIGZvciAodmFyIHRoYXQgPSB2YWxpZGF0ZSh0aGlzLCBOQU1FKSwgZGF0YSA9IHRoYXQuX2ksIGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubikge1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmIChlbnRyeS5wKSBlbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuX2YgPSB0aGF0Ll9sID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGF0W1NJWkVdID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB0aGF0ID0gdmFsaWRhdGUodGhpcywgTkFNRSk7XG4gICAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHZhciBuZXh0ID0gZW50cnkubjtcbiAgICAgICAgICB2YXIgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXQuX2lbZW50cnkuaV07XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYgKHByZXYpIHByZXYubiA9IG5leHQ7XG4gICAgICAgICAgaWYgKG5leHQpIG5leHQucCA9IHByZXY7XG4gICAgICAgICAgaWYgKHRoYXQuX2YgPT0gZW50cnkpIHRoYXQuX2YgPSBuZXh0O1xuICAgICAgICAgIGlmICh0aGF0Ll9sID09IGVudHJ5KSB0aGF0Ll9sID0gcHJldjtcbiAgICAgICAgICB0aGF0W1NJWkVdLS07XG4gICAgICAgIH0gcmV0dXJuICEhZW50cnk7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMi4zLjYgU2V0LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICAvLyAyMy4xLjMuNSBNYXAucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICAgICAgdmFsaWRhdGUodGhpcywgTkFNRSk7XG4gICAgICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKTtcbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICB3aGlsZSAoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGlzLl9mKSB7XG4gICAgICAgICAgZihlbnRyeS52LCBlbnRyeS5rLCB0aGlzKTtcbiAgICAgICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucikgZW50cnkgPSBlbnRyeS5wO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodmFsaWRhdGUodGhpcywgTkFNRSksIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKERFU0NSSVBUT1JTKSBkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHRoaXMsIE5BTUUpW1NJWkVdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICB2YXIgcHJldiwgaW5kZXg7XG4gICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBlbnRyeS52ID0gdmFsdWU7XG4gICAgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGF0Ll9sID0gZW50cnkgPSB7XG4gICAgICAgIGk6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLCAvLyA8LSBpbmRleFxuICAgICAgICBrOiBrZXksICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0ga2V5XG4gICAgICAgIHY6IHZhbHVlLCAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxuICAgICAgICBwOiBwcmV2ID0gdGhhdC5fbCwgICAgICAgICAgICAgLy8gPC0gcHJldmlvdXMgZW50cnlcbiAgICAgICAgbjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgIC8vIDwtIG5leHQgZW50cnlcbiAgICAgICAgcjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHJlbW92ZWRcbiAgICAgIH07XG4gICAgICBpZiAoIXRoYXQuX2YpIHRoYXQuX2YgPSBlbnRyeTtcbiAgICAgIGlmIChwcmV2KSBwcmV2Lm4gPSBlbnRyeTtcbiAgICAgIHRoYXRbU0laRV0rKztcbiAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgaWYgKGluZGV4ICE9PSAnRicpIHRoYXQuX2lbaW5kZXhdID0gZW50cnk7XG4gICAgfSByZXR1cm4gdGhhdDtcbiAgfSxcbiAgZ2V0RW50cnk6IGdldEVudHJ5LFxuICBzZXRTdHJvbmc6IGZ1bmN0aW9uIChDLCBOQU1FLCBJU19NQVApIHtcbiAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cbiAgICAvLyAyMy4xLjMuNCwgMjMuMS4zLjgsIDIzLjEuMy4xMSwgMjMuMS4zLjEyLCAyMy4yLjMuNSwgMjMuMi4zLjgsIDIzLjIuMy4xMCwgMjMuMi4zLjExXG4gICAgJGl0ZXJEZWZpbmUoQywgTkFNRSwgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gICAgICB0aGlzLl90ID0gdmFsaWRhdGUoaXRlcmF0ZWQsIE5BTUUpOyAvLyB0YXJnZXRcbiAgICAgIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAgICAgIC8vIGtpbmRcbiAgICAgIHRoaXMuX2wgPSB1bmRlZmluZWQ7ICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzXG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdmFyIGtpbmQgPSB0aGF0Ll9rO1xuICAgICAgdmFyIGVudHJ5ID0gdGhhdC5fbDtcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnIpIGVudHJ5ID0gZW50cnkucDtcbiAgICAgIC8vIGdldCBuZXh0IGVudHJ5XG4gICAgICBpZiAoIXRoYXQuX3QgfHwgISh0aGF0Ll9sID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGF0Ll90Ll9mKSkge1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICB0aGF0Ll90ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc3RlcCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgZW50cnkuayk7XG4gICAgICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgZW50cnkudik7XG4gICAgICByZXR1cm4gc3RlcCgwLCBbZW50cnkuaywgZW50cnkudl0pO1xuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnLCAhSVNfTUFQLCB0cnVlKTtcblxuICAgIC8vIGFkZCBbQEBzcGVjaWVzXSwgMjMuMS4yLjIsIDIzLjIuMi4yXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgU0VUID0gJ1NldCc7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFNFVCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodmFsaWRhdGUodGhpcywgU0VUKSwgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc2V0LmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMCk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpO1xudmFyIHdlYWsgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBXRUFLX01BUCA9ICdXZWFrTWFwJztcbnZhciBnZXRXZWFrID0gbWV0YS5nZXRXZWFrO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IHdlYWsudWZzdG9yZTtcbnZhciB0bXAgPSB7fTtcbnZhciBJbnRlcm5hbE1hcDtcblxudmFyIHdyYXBwZXIgPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrTWFwKCkge1xuICAgIHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICB9O1xufTtcblxudmFyIG1ldGhvZHMgPSB7XG4gIC8vIDIzLjMuMy4zIFdlYWtNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBXRUFLX01BUCkpLmdldChrZXkpO1xuICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhW3RoaXMuX2ldIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSxcbiAgLy8gMjMuMy4zLjUgV2Vha01hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gd2Vhay5kZWYodmFsaWRhdGUodGhpcywgV0VBS19NQVApLCBrZXksIHZhbHVlKTtcbiAgfVxufTtcblxuLy8gMjMuMyBXZWFrTWFwIE9iamVjdHNcbnZhciAkV2Vha01hcCA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFdFQUtfTUFQLCB3cmFwcGVyLCBtZXRob2RzLCB3ZWFrLCB0cnVlLCB0cnVlKTtcblxuLy8gSUUxMSBXZWFrTWFwIGZyb3plbiBrZXlzIGZpeFxuaWYgKGZhaWxzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyAkV2Vha01hcCgpLnNldCgoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHRtcCksIDcpLmdldCh0bXApICE9IDc7IH0pKSB7XG4gIEludGVybmFsTWFwID0gd2Vhay5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBXRUFLX01BUCk7XG4gIGFzc2lnbihJbnRlcm5hbE1hcC5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICBtZXRhLk5FRUQgPSB0cnVlO1xuICBlYWNoKFsnZGVsZXRlJywgJ2hhcycsICdnZXQnLCAnc2V0J10sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcHJvdG8gPSAkV2Vha01hcC5wcm90b3R5cGU7XG4gICAgdmFyIG1ldGhvZCA9IHByb3RvW2tleV07XG4gICAgcmVkZWZpbmUocHJvdG8sIGtleSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIC8vIHN0b3JlIGZyb3plbiBvYmplY3RzIG9uIGludGVybmFsIHdlYWttYXAgc2hpbVxuICAgICAgaWYgKGlzT2JqZWN0KGEpICYmICFpc0V4dGVuc2libGUoYSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mKSB0aGlzLl9mID0gbmV3IEludGVybmFsTWFwKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9mW2tleV0oYSwgYik7XG4gICAgICAgIHJldHVybiBrZXkgPT0gJ3NldCcgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgLy8gc3RvcmUgYWxsIHRoZSByZXN0IG9uIG5hdGl2ZSB3ZWFrbWFwXG4gICAgICB9IHJldHVybiBtZXRob2QuY2FsbCh0aGlzLCBhLCBiKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLW1hcC5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGdldFdlYWsgPSByZXF1aXJlKCcuL19tZXRhJykuZ2V0V2VhaztcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBjcmVhdGVBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKTtcbnZhciAkaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgYXJyYXlGaW5kID0gY3JlYXRlQXJyYXlNZXRob2QoNSk7XG52YXIgYXJyYXlGaW5kSW5kZXggPSBjcmVhdGVBcnJheU1ldGhvZCg2KTtcbnZhciBpZCA9IDA7XG5cbi8vIGZhbGxiYWNrIGZvciB1bmNhdWdodCBmcm96ZW4ga2V5c1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAodGhhdCkge1xuICByZXR1cm4gdGhhdC5fbCB8fCAodGhhdC5fbCA9IG5ldyBVbmNhdWdodEZyb3plblN0b3JlKCkpO1xufTtcbnZhciBVbmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmEgPSBbXTtcbn07XG52YXIgZmluZFVuY2F1Z2h0RnJvemVuID0gZnVuY3Rpb24gKHN0b3JlLCBrZXkpIHtcbiAgcmV0dXJuIGFycmF5RmluZChzdG9yZS5hLCBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgfSk7XG59O1xuVW5jYXVnaHRGcm96ZW5TdG9yZS5wcm90b3R5cGUgPSB7XG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgcmV0dXJuIGVudHJ5WzFdO1xuICB9LFxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gISFmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgZW50cnlbMV0gPSB2YWx1ZTtcbiAgICBlbHNlIHRoaXMuYS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0sXG4gICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGluZGV4ID0gYXJyYXlGaW5kSW5kZXgodGhpcy5hLCBmdW5jdGlvbiAoaXQpIHtcbiAgICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICAgIH0pO1xuICAgIGlmICh+aW5kZXgpIHRoaXMuYS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiAhIX5pbmRleDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll90ID0gTkFNRTsgICAgICAvLyBjb2xsZWN0aW9uIHR5cGVcbiAgICAgIHRoYXQuX2kgPSBpZCsrOyAgICAgIC8vIGNvbGxlY3Rpb24gaWRcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7IC8vIGxlYWsgc3RvcmUgZm9yIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RzXG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjMuMy4yIFdlYWtNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy40LjMuMyBXZWFrU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmICRoYXMoZGF0YSwgdGhpcy5faSkgJiYgZGVsZXRlIGRhdGFbdGhpcy5faV07XG4gICAgICB9LFxuICAgICAgLy8gMjMuMy4zLjQgV2Vha01hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjQuMy40IFdlYWtTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSkuaGFzKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmICRoYXMoZGF0YSwgdGhpcy5faSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZGF0YSA9IGdldFdlYWsoYW5PYmplY3Qoa2V5KSwgdHJ1ZSk7XG4gICAgaWYgKGRhdGEgPT09IHRydWUpIHVuY2F1Z2h0RnJvemVuU3RvcmUodGhhdCkuc2V0KGtleSwgdmFsdWUpO1xuICAgIGVsc2UgZGF0YVt0aGF0Ll9pXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGF0O1xuICB9LFxuICB1ZnN0b3JlOiB1bmNhdWdodEZyb3plblN0b3JlXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi13ZWFrLmpzIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9pbmRleFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICB2YXIgbnVtYmVyID0gdG9JbnRlZ2VyKGl0KTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKG51bWJlcik7XG4gIGlmIChudW1iZXIgIT09IGxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcignV3JvbmcgbGVuZ3RoIScpO1xuICByZXR1cm4gbGVuZ3RoO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzIiwiLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgUmVmbGVjdCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IFJlZmxlY3QgJiYgUmVmbGVjdC5vd25LZXlzIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnT1BOLmYoYW5PYmplY3QoaXQpKTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHJldHVybiBnZXRTeW1ib2xzID8ga2V5cy5jb25jYXQoZ2V0U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vd24ta2V5cy5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtZmxhdE1hcC8jc2VjLUZsYXR0ZW5JbnRvQXJyYXlcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgSVNfQ09OQ0FUX1NQUkVBREFCTEUgPSByZXF1aXJlKCcuL193a3MnKSgnaXNDb25jYXRTcHJlYWRhYmxlJyk7XG5cbmZ1bmN0aW9uIGZsYXR0ZW5JbnRvQXJyYXkodGFyZ2V0LCBvcmlnaW5hbCwgc291cmNlLCBzb3VyY2VMZW4sIHN0YXJ0LCBkZXB0aCwgbWFwcGVyLCB0aGlzQXJnKSB7XG4gIHZhciB0YXJnZXRJbmRleCA9IHN0YXJ0O1xuICB2YXIgc291cmNlSW5kZXggPSAwO1xuICB2YXIgbWFwRm4gPSBtYXBwZXIgPyBjdHgobWFwcGVyLCB0aGlzQXJnLCAzKSA6IGZhbHNlO1xuICB2YXIgZWxlbWVudCwgc3ByZWFkYWJsZTtcblxuICB3aGlsZSAoc291cmNlSW5kZXggPCBzb3VyY2VMZW4pIHtcbiAgICBpZiAoc291cmNlSW5kZXggaW4gc291cmNlKSB7XG4gICAgICBlbGVtZW50ID0gbWFwRm4gPyBtYXBGbihzb3VyY2Vbc291cmNlSW5kZXhdLCBzb3VyY2VJbmRleCwgb3JpZ2luYWwpIDogc291cmNlW3NvdXJjZUluZGV4XTtcblxuICAgICAgc3ByZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKGlzT2JqZWN0KGVsZW1lbnQpKSB7XG4gICAgICAgIHNwcmVhZGFibGUgPSBlbGVtZW50W0lTX0NPTkNBVF9TUFJFQURBQkxFXTtcbiAgICAgICAgc3ByZWFkYWJsZSA9IHNwcmVhZGFibGUgIT09IHVuZGVmaW5lZCA/ICEhc3ByZWFkYWJsZSA6IGlzQXJyYXkoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcHJlYWRhYmxlICYmIGRlcHRoID4gMCkge1xuICAgICAgICB0YXJnZXRJbmRleCA9IGZsYXR0ZW5JbnRvQXJyYXkodGFyZ2V0LCBvcmlnaW5hbCwgZWxlbWVudCwgdG9MZW5ndGgoZWxlbWVudC5sZW5ndGgpLCB0YXJnZXRJbmRleCwgZGVwdGggLSAxKSAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGFyZ2V0SW5kZXggPj0gMHgxZmZmZmZmZmZmZmZmZikgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgIHRhcmdldFt0YXJnZXRJbmRleF0gPSBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICB0YXJnZXRJbmRleCsrO1xuICAgIH1cbiAgICBzb3VyY2VJbmRleCsrO1xuICB9XG4gIHJldHVybiB0YXJnZXRJbmRleDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuSW50b0FycmF5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmxhdHRlbi1pbnRvLWFycmF5LmpzIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHJlcGVhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCBtYXhMZW5ndGgsIGZpbGxTdHJpbmcsIGxlZnQpIHtcbiAgdmFyIFMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gIHZhciBzdHJpbmdMZW5ndGggPSBTLmxlbmd0aDtcbiAgdmFyIGZpbGxTdHIgPSBmaWxsU3RyaW5nID09PSB1bmRlZmluZWQgPyAnICcgOiBTdHJpbmcoZmlsbFN0cmluZyk7XG4gIHZhciBpbnRNYXhMZW5ndGggPSB0b0xlbmd0aChtYXhMZW5ndGgpO1xuICBpZiAoaW50TWF4TGVuZ3RoIDw9IHN0cmluZ0xlbmd0aCB8fCBmaWxsU3RyID09ICcnKSByZXR1cm4gUztcbiAgdmFyIGZpbGxMZW4gPSBpbnRNYXhMZW5ndGggLSBzdHJpbmdMZW5ndGg7XG4gIHZhciBzdHJpbmdGaWxsZXIgPSByZXBlYXQuY2FsbChmaWxsU3RyLCBNYXRoLmNlaWwoZmlsbExlbiAvIGZpbGxTdHIubGVuZ3RoKSk7XG4gIGlmIChzdHJpbmdGaWxsZXIubGVuZ3RoID4gZmlsbExlbikgc3RyaW5nRmlsbGVyID0gc3RyaW5nRmlsbGVyLnNsaWNlKDAsIGZpbGxMZW4pO1xuICByZXR1cm4gbGVmdCA/IHN0cmluZ0ZpbGxlciArIFMgOiBTICsgc3RyaW5nRmlsbGVyO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1wYWQuanMiLCJ2YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGlzRW51bSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXNFbnRyaWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdChpdCk7XG4gICAgdmFyIGtleXMgPSBnZXRLZXlzKE8pO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGkpIGlmIChpc0VudW0uY2FsbChPLCBrZXkgPSBrZXlzW2krK10pKSB7XG4gICAgICByZXN1bHQucHVzaChpc0VudHJpZXMgPyBba2V5LCBPW2tleV1dIDogT1trZXldKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXRvLWFycmF5LmpzIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgZnJvbSA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICBpZiAoY2xhc3NvZih0aGlzKSAhPSBOQU1FKSB0aHJvdyBUeXBlRXJyb3IoTkFNRSArIFwiI3RvSlNPTiBpc24ndCBnZW5lcmljXCIpO1xuICAgIHJldHVybiBmcm9tKHRoaXMpO1xuICB9O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qcyIsInZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyLCBJVEVSQVRPUikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvck9mKGl0ZXIsIGZhbHNlLCByZXN1bHQucHVzaCwgcmVzdWx0LCBJVEVSQVRPUik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qcyIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbm1vZHVsZS5leHBvcnRzID0gTWF0aC5zY2FsZSB8fCBmdW5jdGlvbiBzY2FsZSh4LCBpbkxvdywgaW5IaWdoLCBvdXRMb3csIG91dEhpZ2gpIHtcbiAgaWYgKFxuICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDBcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIHx8IHggIT0geFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgfHwgaW5Mb3cgIT0gaW5Mb3dcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIHx8IGluSGlnaCAhPSBpbkhpZ2hcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIHx8IG91dExvdyAhPSBvdXRMb3dcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIHx8IG91dEhpZ2ggIT0gb3V0SGlnaFxuICApIHJldHVybiBOYU47XG4gIGlmICh4ID09PSBJbmZpbml0eSB8fCB4ID09PSAtSW5maW5pdHkpIHJldHVybiB4O1xuICByZXR1cm4gKHggLSBpbkxvdykgKiAob3V0SGlnaCAtIG91dExvdykgLyAoaW5IaWdoIC0gaW5Mb3cpICsgb3V0TG93O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtc2NhbGUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3ROb29wVXBkYXRlUXVldWUnKTtcblxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSByZXF1aXJlKCcuL2xvd1ByaW9yaXR5V2FybmluZycpO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBSZWFjdENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gICEodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJykgOiBfcHJvZEludmFyaWFudCgnODUnKSA6IHZvaWQgMDtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhY3RDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGxvd1ByaW9yaXR5V2FybmluZyhmYWxzZSwgJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0UHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAvLyBEdXBsaWNhdGVkIGZyb20gUmVhY3RDb21wb25lbnQuXG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBSZWFjdENvbXBvbmVudC5wcm90b3R5cGU7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVhY3RQdXJlQ29tcG9uZW50O1xuLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5fYXNzaWduKFJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSk7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENvbXBvbmVudDogUmVhY3RDb21wb25lbnQsXG4gIFB1cmVDb21wb25lbnQ6IFJlYWN0UHVyZUNvbXBvbmVudFxufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0QmFzZUNsYXNzZXMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gJyArICdUaGlzIGlzIGEgbm8tb3AuIFBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBjb25zdHJ1Y3RvciAmJiAoY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnKSA6IHZvaWQgMDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUNhbGxiYWNrOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrKSB7fSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3ROb29wVXBkYXRlUXVldWUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudCB0eXBlLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ10gJiYgU3ltYm9sWydmb3InXSgncmVhY3QuZWxlbWVudCcpIHx8IDB4ZWFjNztcblxubW9kdWxlLmV4cG9ydHMgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRTeW1ib2wuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBTeW1ib2wgKi9cblxudmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICpcbiAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICpcbiAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAqICAgICAgIC4uLlxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpdGVyYXRvckZuO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0SXRlcmF0b3JGbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldEl0ZXJhdG9yRm4uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuLyoqXG4gKiBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgcHJvdmlkZXMgYSB3cmFwcGVyIGFyb3VuZCBhIGVsZW1lbnQgZmFjdG9yeVxuICogd2hpY2ggdmFsaWRhdGVzIHRoZSBwcm9wcyBwYXNzZWQgdG8gdGhlIGVsZW1lbnQuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbiAqIHVzZWQgb25seSBpbiBERVYgYW5kIGNvdWxkIGJlIHJlcGxhY2VkIGJ5IGEgc3RhdGljIHR5cGUgY2hlY2tlciBmb3IgbGFuZ3VhZ2VzXG4gKiB0aGF0IHN1cHBvcnQgaXQuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbnZhciBjaGVja1JlYWN0VHlwZVNwZWMgPSByZXF1aXJlKCcuL2NoZWNrUmVhY3RUeXBlU3BlYycpO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgbG93UHJpb3JpdHlXYXJuaW5nID0gcmVxdWlyZSgnLi9sb3dQcmlvcml0eVdhcm5pbmcnKTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQgJiYgZWxlbWVudFByb3BzLl9fc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc291cmNlID0gZWxlbWVudFByb3BzLl9fc291cmNlO1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJyBDaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gJyBDaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDwnICsgcGFyZW50TmFtZSArICc+Lic7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmZvO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gIHZhciBtZW1vaXplciA9IG93bmVySGFzS2V5VXNlV2FybmluZy51bmlxdWVLZXkgfHwgKG93bmVySGFzS2V5VXNlV2FybmluZy51bmlxdWVLZXkgPSB7fSk7XG5cbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuICBpZiAobWVtb2l6ZXJbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbWVtb2l6ZXJbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gIC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGNoaWxkT3duZXIgPSAnIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tICcgKyBlbGVtZW50Ll9vd25lci5nZXROYW1lKCkgKyAnLic7XG4gIH1cblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJXMnLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEN1cnJlbnRTdGFja0FkZGVuZHVtKGVsZW1lbnQpKSA6IHZvaWQgMDtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcbiAgICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcbiAgICAvLyBFbnRyeSBpdGVyYXRvcnMgcHJvdmlkZSBpbXBsaWNpdCBrZXlzLlxuICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHZhciBjb21wb25lbnRDbGFzcyA9IGVsZW1lbnQudHlwZTtcbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmFtZSA9IGNvbXBvbmVudENsYXNzLmRpc3BsYXlOYW1lIHx8IGNvbXBvbmVudENsYXNzLm5hbWU7XG4gIGlmIChjb21wb25lbnRDbGFzcy5wcm9wVHlwZXMpIHtcbiAgICBjaGVja1JlYWN0VHlwZVNwZWMoY29tcG9uZW50Q2xhc3MucHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQsIG51bGwpO1xuICB9XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICB9XG59XG5cbnZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSB7XG4gIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nO1xuICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4uXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHByb3BzKTtcbiAgICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZm8gKz0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDdXJyZW50U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgICAgIHZhciBjdXJyZW50U291cmNlID0gcHJvcHMgIT09IG51bGwgJiYgcHJvcHMgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5fX3NvdXJjZSAhPT0gdW5kZWZpbmVkID8gcHJvcHMuX19zb3VyY2UgOiBudWxsO1xuICAgICAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rLnB1c2hOb25TdGFuZGFyZFdhcm5pbmdTdGFjayh0cnVlLCBjdXJyZW50U291cmNlKTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSwgaW5mbykgOiB2b2lkIDA7XG4gICAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sucG9wTm9uU3RhbmRhcmRXYXJuaW5nU3RhY2soKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9LFxuXG4gIGNyZWF0ZUZhY3Rvcnk6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsIHR5cGUpO1xuICAgIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICAgIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxvd1ByaW9yaXR5V2FybmluZyhmYWxzZSwgJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbiAgfSxcblxuICBjbG9uZUVsZW1lbnQ6IGZ1bmN0aW9uIChlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICAgIH1cbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3I7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRWYWxpZGF0b3IuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFJlYWN0IDE1LjUgcmVmZXJlbmNlcyB0aGlzIG1vZHVsZSwgYW5kIGFzc3VtZXMgUHJvcFR5cGVzIGFyZSBzdGlsbCBjYWxsYWJsZSBpbiBwcm9kdWN0aW9uLlxuLy8gVGhlcmVmb3JlIHdlIHJlLWV4cG9ydCBkZXZlbG9wbWVudC1vbmx5IHZlcnNpb24gd2l0aCBhbGwgdGhlIFByb3BUeXBlcyBjaGVja3MgaGVyZS5cbi8vIEhvd2V2ZXIgaWYgb25lIGlzIG1pZ3JhdGluZyB0byB0aGUgYHByb3AtdHlwZXNgIG5wbSBsaWJyYXJ5LCB0aGV5IHdpbGwgZ28gdGhyb3VnaCB0aGVcbi8vIGBpbmRleC5qc2AgZW50cnkgcG9pbnQsIGFuZCBpdCB3aWxsIGJyYW5jaCBkZXBlbmRpbmcgb24gdGhlIGVudmlyb25tZW50LlxudmFyIGZhY3RvcnkgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50KSB7XG4gIC8vIEl0IGlzIHN0aWxsIGFsbG93ZWQgaW4gMTUuNS5cbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSBmYWxzZTtcbiAgcmV0dXJuIGZhY3RvcnkoaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnkuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXJcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9ICcnO1xuICB9XG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcbiAgICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCVzYCBwcm9wIG9uIGAlc2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nLFxuICAgICAgICAgICAgICBwcm9wRnVsbE5hbWUsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIHByb3BWYWx1ZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAocHJvcFZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGlkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICVzIGF0IGluZGV4ICVzLicsXG4gICAgICAgICAgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpLFxuICAgICAgICAgIGlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NQ29tcG9uZW50RmxhZ3MgPSB7XG4gIGhhc0NhY2hlZENoaWxkTm9kZXM6IDEgPDwgMFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUNvbXBvbmVudEZsYWdzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NQ29tcG9uZW50RmxhZ3MuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBpdGVtcyB0aGF0IG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkIGludG8gdGhlIGZpcnN0IG9uZS4gVGhpc1xuICogaXMgdXNlZCB0byBjb25zZXJ2ZSBtZW1vcnkgYnkgYXZvaWRpbmcgYXJyYXkgYWxsb2NhdGlvbnMsIGFuZCB0aHVzIHNhY3JpZmljZXNcbiAqIEFQSSBjbGVhbm5lc3MuIFNpbmNlIGBjdXJyZW50YCBjYW4gYmUgbnVsbCBiZWZvcmUgYmVpbmcgcGFzc2VkIGluIGFuZCBub3RcbiAqIG51bGwgYWZ0ZXIgdGhpcyBmdW5jdGlvbiwgbWFrZSBzdXJlIHRvIGFzc2lnbiBpdCBiYWNrIHRvIGBjdXJyZW50YDpcbiAqXG4gKiBgYSA9IGFjY3VtdWxhdGVJbnRvKGEsIGIpO2BcbiAqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgc3BhcmluZ2x5IHVzZWQuIFRyeSBgYWNjdW11bGF0ZWAgZm9yIHNvbWV0aGluZyBjbGVhbmVyLlxuICpcbiAqIEByZXR1cm4geyp8YXJyYXk8Kj59IEFuIGFjY3VtdWxhdGlvbiBvZiBpdGVtcy5cbiAqL1xuXG5mdW5jdGlvbiBhY2N1bXVsYXRlSW50byhjdXJyZW50LCBuZXh0KSB7XG4gICEobmV4dCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdhY2N1bXVsYXRlSW50byguLi4pOiBBY2N1bXVsYXRlZCBpdGVtcyBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC4nKSA6IF9wcm9kSW52YXJpYW50KCczMCcpIDogdm9pZCAwO1xuXG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8vIEJvdGggYXJlIG5vdCBlbXB0eS4gV2FybmluZzogTmV2ZXIgY2FsbCB4LmNvbmNhdCh5KSB3aGVuIHlvdSBhcmUgbm90XG4gIC8vIGNlcnRhaW4gdGhhdCB4IGlzIGFuIEFycmF5ICh4IGNvdWxkIGJlIGEgc3RyaW5nIHdpdGggY29uY2F0IG1ldGhvZCkuXG4gIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAgIGN1cnJlbnQucHVzaC5hcHBseShjdXJyZW50LCBuZXh0KTtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBjdXJyZW50LnB1c2gobmV4dCk7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgIC8vIEEgYml0IHRvbyBkYW5nZXJvdXMgdG8gbXV0YXRlIGBuZXh0YC5cbiAgICByZXR1cm4gW2N1cnJlbnRdLmNvbmNhdChuZXh0KTtcbiAgfVxuXG4gIHJldHVybiBbY3VycmVudCwgbmV4dF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWNjdW11bGF0ZUludG87XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvYWNjdW11bGF0ZUludG8uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHBhcmFtIHthcnJheX0gYXJyIGFuIFwiYWNjdW11bGF0aW9uXCIgb2YgaXRlbXMgd2hpY2ggaXMgZWl0aGVyIGFuIEFycmF5IG9yXG4gKiBhIHNpbmdsZSBpdGVtLiBVc2VmdWwgd2hlbiBwYWlyZWQgd2l0aCB0aGUgYGFjY3VtdWxhdGVgIG1vZHVsZS4gVGhpcyBpcyBhXG4gKiBzaW1wbGUgdXRpbGl0eSB0aGF0IGFsbG93cyB1cyB0byByZWFzb24gYWJvdXQgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zLCBidXRcbiAqIGhhbmRsaW5nIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgZXhhY3RseSBvbmUgaXRlbSAoYW5kIHdlIGRvIG5vdCBuZWVkIHRvXG4gKiBhbGxvY2F0ZSBhbiBhcnJheSkuXG4gKi9cblxuZnVuY3Rpb24gZm9yRWFjaEFjY3VtdWxhdGVkKGFyciwgY2IsIHNjb3BlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBhcnIuZm9yRWFjaChjYiwgc2NvcGUpO1xuICB9IGVsc2UgaWYgKGFycikge1xuICAgIGNiLmNhbGwoc2NvcGUsIGFycik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoQWNjdW11bGF0ZWQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZm9yRWFjaEFjY3VtdWxhdGVkLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGNvbnRlbnRLZXkgPSBudWxsO1xuXG4vKipcbiAqIEdldHMgdGhlIGtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQgb24gYSBET00gbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBLZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50QWNjZXNzb3IoKSB7XG4gIGlmICghY29udGVudEtleSAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgICAvLyBQcmVmZXIgdGV4dENvbnRlbnQgdG8gaW5uZXJUZXh0IGJlY2F1c2UgbWFueSBicm93c2VycyBzdXBwb3J0IGJvdGggYnV0XG4gICAgLy8gU1ZHIDx0ZXh0PiBlbGVtZW50cyBkb24ndCBzdXBwb3J0IGlubmVyVGV4dCBldmVuIHdoZW4gPGRpdj4gZG9lcy5cbiAgICBjb250ZW50S2V5ID0gJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPyAndGV4dENvbnRlbnQnIDogJ2lubmVyVGV4dCc7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnRLZXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9nZXRUZXh0Q29udGVudEFjY2Vzc29yLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHBzZXVkby1ldmVudCBtb2R1bGUgdG8gaGVscCBrZWVwIHRyYWNrIG9mIGNvbXBvbmVudHMgd2FpdGluZyB0b1xuICogYmUgbm90aWZpZWQgd2hlbiB0aGVpciBET00gcmVwcmVzZW50YXRpb25zIGFyZSBhdmFpbGFibGUgZm9yIHVzZS5cbiAqXG4gKiBUaGlzIGltcGxlbWVudHMgYFBvb2xlZENsYXNzYCwgc28geW91IHNob3VsZCBuZXZlciBuZWVkIHRvIGluc3RhbnRpYXRlIHRoaXMuXG4gKiBJbnN0ZWFkLCB1c2UgYENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKClgLlxuICpcbiAqIEBjbGFzcyBSZWFjdE1vdW50UmVhZHlcbiAqIEBpbXBsZW1lbnRzIFBvb2xlZENsYXNzXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG52YXIgQ2FsbGJhY2tRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2FsbGJhY2tRdWV1ZShhcmcpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FsbGJhY2tRdWV1ZSk7XG5cbiAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbiAgICB0aGlzLl9hcmcgPSBhcmc7XG4gIH1cblxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gYG5vdGlmeUFsbGAgaXMgaW52b2tlZC5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgSW52b2tlZCB3aGVuIGBub3RpZnlBbGxgIGlzIGludm9rZWQuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gY29udGV4dCBDb250ZXh0IHRvIGNhbGwgYGNhbGxiYWNrYCB3aXRoLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cblxuICBDYWxsYmFja1F1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24gZW5xdWV1ZShjYWxsYmFjaywgY29udGV4dCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCBbXTtcbiAgICB0aGlzLl9jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgdGhpcy5fY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cyB8fCBbXTtcbiAgICB0aGlzLl9jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnZva2VzIGFsbCBlbnF1ZXVlZCBjYWxsYmFja3MgYW5kIGNsZWFycyB0aGUgcXVldWUuIFRoaXMgaXMgaW52b2tlZCBhZnRlclxuICAgKiB0aGUgRE9NIHJlcHJlc2VudGF0aW9uIG9mIGEgY29tcG9uZW50IGhhcyBiZWVuIGNyZWF0ZWQgb3IgdXBkYXRlZC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgQ2FsbGJhY2tRdWV1ZS5wcm90b3R5cGUubm90aWZ5QWxsID0gZnVuY3Rpb24gbm90aWZ5QWxsKCkge1xuICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3M7XG4gICAgdmFyIGNvbnRleHRzID0gdGhpcy5fY29udGV4dHM7XG4gICAgdmFyIGFyZyA9IHRoaXMuX2FyZztcbiAgICBpZiAoY2FsbGJhY2tzICYmIGNvbnRleHRzKSB7XG4gICAgICAhKGNhbGxiYWNrcy5sZW5ndGggPT09IGNvbnRleHRzLmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTWlzbWF0Y2hlZCBsaXN0IG9mIGNvbnRleHRzIGluIGNhbGxiYWNrIHF1ZXVlJykgOiBfcHJvZEludmFyaWFudCgnMjQnKSA6IHZvaWQgMDtcbiAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gICAgICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsYmFja3NbaV0uY2FsbChjb250ZXh0c1tpXSwgYXJnKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgY29udGV4dHMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH07XG5cbiAgQ2FsbGJhY2tRdWV1ZS5wcm90b3R5cGUuY2hlY2twb2ludCA9IGZ1bmN0aW9uIGNoZWNrcG9pbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrcyA/IHRoaXMuX2NhbGxiYWNrcy5sZW5ndGggOiAwO1xuICB9O1xuXG4gIENhbGxiYWNrUXVldWUucHJvdG90eXBlLnJvbGxiYWNrID0gZnVuY3Rpb24gcm9sbGJhY2sobGVuKSB7XG4gICAgaWYgKHRoaXMuX2NhbGxiYWNrcyAmJiB0aGlzLl9jb250ZXh0cykge1xuICAgICAgdGhpcy5fY2FsbGJhY2tzLmxlbmd0aCA9IGxlbjtcbiAgICAgIHRoaXMuX2NvbnRleHRzLmxlbmd0aCA9IGxlbjtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgaW50ZXJuYWwgcXVldWUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIENhbGxiYWNrUXVldWUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIHRoaXMuXG4gICAqL1xuXG5cbiAgQ2FsbGJhY2tRdWV1ZS5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uIGRlc3RydWN0b3IoKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9O1xuXG4gIHJldHVybiBDYWxsYmFja1F1ZXVlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhDYWxsYmFja1F1ZXVlKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9DYWxsYmFja1F1ZXVlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RGZWF0dXJlRmxhZ3MgPSB7XG4gIC8vIFdoZW4gdHJ1ZSwgY2FsbCBjb25zb2xlLnRpbWUoKSBiZWZvcmUgYW5kIC50aW1lRW5kKCkgYWZ0ZXIgZWFjaCB0b3AtbGV2ZWxcbiAgLy8gcmVuZGVyIChib3RoIGluaXRpYWwgcmVuZGVycyBhbmQgdXBkYXRlcykuIFVzZWZ1bCB3aGVuIGxvb2tpbmcgYXQgcHJvZC1tb2RlXG4gIC8vIHRpbWVsaW5lIHByb2ZpbGVzIGluIENocm9tZSwgZm9yIGV4YW1wbGUuXG4gIGxvZ1RvcExldmVsUmVuZGVyczogZmFsc2Vcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RGZWF0dXJlRmxhZ3M7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RGZWF0dXJlRmxhZ3MuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcblxuZnVuY3Rpb24gaXNDaGVja2FibGUoZWxlbSkge1xuICB2YXIgdHlwZSA9IGVsZW0udHlwZTtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKHR5cGUgPT09ICdjaGVja2JveCcgfHwgdHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRyYWNrZXIoaW5zdCkge1xuICByZXR1cm4gaW5zdC5fd3JhcHBlclN0YXRlLnZhbHVlVHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gYXR0YWNoVHJhY2tlcihpbnN0LCB0cmFja2VyKSB7XG4gIGluc3QuX3dyYXBwZXJTdGF0ZS52YWx1ZVRyYWNrZXIgPSB0cmFja2VyO1xufVxuXG5mdW5jdGlvbiBkZXRhY2hUcmFja2VyKGluc3QpIHtcbiAgZGVsZXRlIGluc3QuX3dyYXBwZXJTdGF0ZS52YWx1ZVRyYWNrZXI7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlRnJvbU5vZGUobm9kZSkge1xuICB2YXIgdmFsdWU7XG4gIGlmIChub2RlKSB7XG4gICAgdmFsdWUgPSBpc0NoZWNrYWJsZShub2RlKSA/ICcnICsgbm9kZS5jaGVja2VkIDogbm9kZS52YWx1ZTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbnZhciBpbnB1dFZhbHVlVHJhY2tpbmcgPSB7XG4gIC8vIGV4cG9zZWQgZm9yIHRlc3RpbmdcbiAgX2dldFRyYWNrZXJGcm9tTm9kZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gZ2V0VHJhY2tlcihSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKSk7XG4gIH0sXG5cblxuICB0cmFjazogZnVuY3Rpb24gKGluc3QpIHtcbiAgICBpZiAoZ2V0VHJhY2tlcihpbnN0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gICAgdmFyIHZhbHVlRmllbGQgPSBpc0NoZWNrYWJsZShub2RlKSA/ICdjaGVja2VkJyA6ICd2YWx1ZSc7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5vZGUuY29uc3RydWN0b3IucHJvdG90eXBlLCB2YWx1ZUZpZWxkKTtcblxuICAgIHZhciBjdXJyZW50VmFsdWUgPSAnJyArIG5vZGVbdmFsdWVGaWVsZF07XG5cbiAgICAvLyBpZiBzb21lb25lIGhhcyBhbHJlYWR5IGRlZmluZWQgYSB2YWx1ZSBvciBTYWZhcmksIHRoZW4gYmFpbFxuICAgIC8vIGFuZCBkb24ndCB0cmFjayB2YWx1ZSB3aWxsIGNhdXNlIG92ZXIgcmVwb3J0aW5nIG9mIGNoYW5nZXMsXG4gICAgLy8gYnV0IGl0J3MgYmV0dGVyIHRoZW4gYSBoYXJkIGZhaWx1cmVcbiAgICAvLyAobmVlZGVkIGZvciBjZXJ0YWluIHRlc3RzIHRoYXQgc3B5T24gaW5wdXQgdmFsdWVzIGFuZCBTYWZhcmkpXG4gICAgaWYgKG5vZGUuaGFzT3duUHJvcGVydHkodmFsdWVGaWVsZCkgfHwgdHlwZW9mIGRlc2NyaXB0b3IuZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBkZXNjcmlwdG9yLnNldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub2RlLCB2YWx1ZUZpZWxkLCB7XG4gICAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmNhbGwodGhpcyk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY3VycmVudFZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgICAgZGVzY3JpcHRvci5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhdHRhY2hUcmFja2VyKGluc3QsIHtcbiAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgICB9LFxuICAgICAgc2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgfSxcbiAgICAgIHN0b3BUcmFja2luZzogZnVuY3Rpb24gKCkge1xuICAgICAgICBkZXRhY2hUcmFja2VyKGluc3QpO1xuICAgICAgICBkZWxldGUgbm9kZVt2YWx1ZUZpZWxkXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICB1cGRhdGVWYWx1ZUlmQ2hhbmdlZDogZnVuY3Rpb24gKGluc3QpIHtcbiAgICBpZiAoIWluc3QpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHRyYWNrZXIgPSBnZXRUcmFja2VyKGluc3QpO1xuXG4gICAgaWYgKCF0cmFja2VyKSB7XG4gICAgICBpbnB1dFZhbHVlVHJhY2tpbmcudHJhY2soaW5zdCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgbGFzdFZhbHVlID0gdHJhY2tlci5nZXRWYWx1ZSgpO1xuICAgIHZhciBuZXh0VmFsdWUgPSBnZXRWYWx1ZUZyb21Ob2RlKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpKTtcblxuICAgIGlmIChuZXh0VmFsdWUgIT09IGxhc3RWYWx1ZSkge1xuICAgICAgdHJhY2tlci5zZXRWYWx1ZShuZXh0VmFsdWUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBzdG9wVHJhY2tpbmc6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHRyYWNrZXIgPSBnZXRUcmFja2VyKGluc3QpO1xuICAgIGlmICh0cmFja2VyKSB7XG4gICAgICB0cmFja2VyLnN0b3BUcmFja2luZygpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnB1dFZhbHVlVHJhY2tpbmc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvaW5wdXRWYWx1ZVRyYWNraW5nLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG5cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICBjb2xvcjogdHJ1ZSxcbiAgZGF0ZTogdHJ1ZSxcbiAgZGF0ZXRpbWU6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWUsXG4gIGVtYWlsOiB0cnVlLFxuICBtb250aDogdHJ1ZSxcbiAgbnVtYmVyOiB0cnVlLFxuICBwYXNzd29yZDogdHJ1ZSxcbiAgcmFuZ2U6IHRydWUsXG4gIHNlYXJjaDogdHJ1ZSxcbiAgdGVsOiB0cnVlLFxuICB0ZXh0OiB0cnVlLFxuICB0aW1lOiB0cnVlLFxuICB1cmw6IHRydWUsXG4gIHdlZWs6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dElucHV0RWxlbWVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnKSB7XG4gICAgcmV0dXJuICEhc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0SW5wdXRFbGVtZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2lzVGV4dElucHV0RWxlbWVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBWaWV3cG9ydE1ldHJpY3MgPSB7XG4gIGN1cnJlbnRTY3JvbGxMZWZ0OiAwLFxuXG4gIGN1cnJlbnRTY3JvbGxUb3A6IDAsXG5cbiAgcmVmcmVzaFNjcm9sbFZhbHVlczogZnVuY3Rpb24gKHNjcm9sbFBvc2l0aW9uKSB7XG4gICAgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxMZWZ0ID0gc2Nyb2xsUG9zaXRpb24ueDtcbiAgICBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbFRvcCA9IHNjcm9sbFBvc2l0aW9uLnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmlld3BvcnRNZXRyaWNzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1ZpZXdwb3J0TWV0cmljcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xuXG4vKipcbiAqIFNldCB0aGUgdGV4dENvbnRlbnQgcHJvcGVydHkgb2YgYSBub2RlLCBlbnN1cmluZyB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkXG4gKiBldmVuIGluIElFOC4gaW5uZXJUZXh0IGlzIGEgcG9vciBzdWJzdGl0dXRlIGZvciB0ZXh0Q29udGVudCBhbmQsIGFtb25nIG1hbnlcbiAqIGlzc3VlcywgaW5zZXJ0cyA8YnI+IGluc3RlYWQgb2YgdGhlIGxpdGVyYWwgbmV3bGluZSBjaGFycy4gaW5uZXJIVE1MIGJlaGF2ZXNcbiAqIGFzIGl0IHNob3VsZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgaWYgKHRleHQpIHtcbiAgICB2YXIgZmlyc3RDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcblxuICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQgPT09IG5vZGUubGFzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59O1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIGlmICghKCd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSkge1xuICAgIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgIG5vZGUubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0SW5uZXJIVE1MKG5vZGUsIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih0ZXh0KSk7XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRleHRDb250ZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL3NldFRleHRDb250ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlIGlucHV0L3RleHRhcmVhIHRvIGZvY3VzXG4gKi9cblxuZnVuY3Rpb24gZm9jdXNOb2RlKG5vZGUpIHtcbiAgLy8gSUU4IGNhbiB0aHJvdyBcIkNhbid0IG1vdmUgZm9jdXMgdG8gdGhlIGNvbnRyb2wgYmVjYXVzZSBpdCBpcyBpbnZpc2libGUsXG4gIC8vIG5vdCBlbmFibGVkLCBvciBvZiBhIHR5cGUgdGhhdCBkb2VzIG5vdCBhY2NlcHQgdGhlIGZvY3VzLlwiIGZvciBhbGwga2luZHMgb2ZcbiAgLy8gcmVhc29ucyB0aGF0IGFyZSB0b28gZXhwZW5zaXZlIGFuZCBmcmFnaWxlIHRvIHRlc3QuXG4gIHRyeSB7XG4gICAgbm9kZS5mb2N1cygpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvY3VzTm9kZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZm9jdXNOb2RlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cblxudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZFJvdzogdHJ1ZSxcbiAgZ3JpZFJvd0VuZDogdHJ1ZSxcbiAgZ3JpZFJvd1NwYW46IHRydWUsXG4gIGdyaWRSb3dTdGFydDogdHJ1ZSxcbiAgZ3JpZENvbHVtbjogdHJ1ZSxcbiAgZ3JpZENvbHVtbkVuZDogdHJ1ZSxcbiAgZ3JpZENvbHVtblNwYW46IHRydWUsXG4gIGdyaWRDb2x1bW5TdGFydDogdHJ1ZSxcbiAgZm9udFdlaWdodDogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcmRlcjogdHJ1ZSxcbiAgb3JwaGFuczogdHJ1ZSxcbiAgdGFiU2l6ZTogdHJ1ZSxcbiAgd2lkb3dzOiB0cnVlLFxuICB6SW5kZXg6IHRydWUsXG4gIHpvb206IHRydWUsXG5cbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaGFycmF5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnbXMnLCAnTW96JywgJ08nXTtcblxuLy8gVXNpbmcgT2JqZWN0LmtleXMgaGVyZSwgb3IgZWxzZSB0aGUgdmFuaWxsYSBmb3ItaW4gbG9vcCBtYWtlcyBJRTggZ28gaW50byBhblxuLy8gaW5maW5pdGUgbG9vcCwgYmVjYXVzZSBpdCBpdGVyYXRlcyBvdmVyIHRoZSBuZXdseSBhZGRlZCBwcm9wcyB0b28uXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBNb3N0IHN0eWxlIHByb3BlcnRpZXMgY2FuIGJlIHVuc2V0IGJ5IGRvaW5nIC5zdHlsZVtwcm9wXSA9ICcnIGJ1dCBJRThcbiAqIGRvZXNuJ3QgbGlrZSBkb2luZyB0aGF0IHdpdGggc2hvcnRoYW5kIHByb3BlcnRpZXMgc28gZm9yIHRoZSBwcm9wZXJ0aWVzIHRoYXRcbiAqIElFOCBicmVha3Mgb24sIHdoaWNoIGFyZSBsaXN0ZWQgaGVyZSwgd2UgaW5zdGVhZCB1bnNldCBlYWNoIG9mIHRoZVxuICogaW5kaXZpZHVhbCBwcm9wZXJ0aWVzLiBTZWUgaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzODUuXG4gKiBUaGUgNC12YWx1ZSAnY2xvY2snIHByb3BlcnRpZXMgbGlrZSBtYXJnaW4sIHBhZGRpbmcsIGJvcmRlci13aWR0aCBzZWVtIHRvXG4gKiBiZWhhdmUgd2l0aG91dCBhbnkgcHJvYmxlbXMuIEN1cmlvdXNseSwgbGlzdC1zdHlsZSB3b3JrcyB0b28gd2l0aG91dCBhbnlcbiAqIHNwZWNpYWwgcHJvZGRpbmcuXG4gKi9cbnZhciBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnMgPSB7XG4gIGJhY2tncm91bmQ6IHtcbiAgICBiYWNrZ3JvdW5kQXR0YWNobWVudDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHRydWUsXG4gICAgYmFja2dyb3VuZEltYWdlOiB0cnVlLFxuICAgIGJhY2tncm91bmRQb3NpdGlvblg6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWTogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUmVwZWF0OiB0cnVlXG4gIH0sXG4gIGJhY2tncm91bmRQb3NpdGlvbjoge1xuICAgIGJhY2tncm91bmRQb3NpdGlvblg6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWTogdHJ1ZVxuICB9LFxuICBib3JkZXI6IHtcbiAgICBib3JkZXJXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJCb3R0b206IHtcbiAgICBib3JkZXJCb3R0b21XaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJCb3R0b21TdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJCb3R0b21Db2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJMZWZ0OiB7XG4gICAgYm9yZGVyTGVmdFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlckxlZnRTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJMZWZ0Q29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyUmlnaHQ6IHtcbiAgICBib3JkZXJSaWdodFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlclJpZ2h0U3R5bGU6IHRydWUsXG4gICAgYm9yZGVyUmlnaHRDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJUb3A6IHtcbiAgICBib3JkZXJUb3BXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJUb3BTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJUb3BDb2xvcjogdHJ1ZVxuICB9LFxuICBmb250OiB7XG4gICAgZm9udFN0eWxlOiB0cnVlLFxuICAgIGZvbnRWYXJpYW50OiB0cnVlLFxuICAgIGZvbnRXZWlnaHQ6IHRydWUsXG4gICAgZm9udFNpemU6IHRydWUsXG4gICAgbGluZUhlaWdodDogdHJ1ZSxcbiAgICBmb250RmFtaWx5OiB0cnVlXG4gIH0sXG4gIG91dGxpbmU6IHtcbiAgICBvdXRsaW5lV2lkdGg6IHRydWUsXG4gICAgb3V0bGluZVN0eWxlOiB0cnVlLFxuICAgIG91dGxpbmVDb2xvcjogdHJ1ZVxuICB9XG59O1xuXG52YXIgQ1NTUHJvcGVydHkgPSB7XG4gIGlzVW5pdGxlc3NOdW1iZXI6IGlzVW5pdGxlc3NOdW1iZXIsXG4gIHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uczogc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU1Byb3BlcnR5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0NTU1Byb3BlcnR5LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXInKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVggPSBuZXcgUmVnRXhwKCdeWycgKyBET01Qcm9wZXJ0eS5BVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgJ11bJyArIERPTVByb3BlcnR5LkFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSkgOiB2b2lkIDA7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCBwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICYmICF2YWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICYmIGlzTmFOKHZhbHVlKSB8fCBwcm9wZXJ0eUluZm8uaGFzUG9zaXRpdmVOdW1lcmljVmFsdWUgJiYgdmFsdWUgPCAxIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSBmYWxzZTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggRE9NIHByb3BlcnRpZXMuXG4gKi9cbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIElEIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVW5lc2NhcGVkIElELlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIoaWQpO1xuICB9LFxuXG4gIHNldEF0dHJpYnV0ZUZvcklEOiBmdW5jdGlvbiAobm9kZSwgaWQpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRSwgaWQpO1xuICB9LFxuXG4gIGNyZWF0ZU1hcmt1cEZvclJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRE9NUHJvcGVydHkuUk9PVF9BVFRSSUJVVEVfTkFNRSArICc9XCJcIic7XG4gIH0sXG5cbiAgc2V0QXR0cmlidXRlRm9yUm9vdDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShET01Qcm9wZXJ0eS5ST09UX0FUVFJJQlVURV9OQU1FLCAnJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciBhIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IE1hcmt1cCBzdHJpbmcsIG9yIG51bGwgaWYgdGhlIHByb3BlcnR5IHdhcyBpbnZhbGlkLlxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9XCJcIic7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciBhIGN1c3RvbSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcsIG9yIGVtcHR5IHN0cmluZyBpZiB0aGUgcHJvcGVydHkgd2FzIGludmFsaWQuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBuYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICBzZXRWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IERPTVByb3BlcnR5LnByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAgIC8vIENvbnRyYXJ5IHRvIGBzZXRBdHRyaWJ1dGVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgcHJvcGVybHlcbiAgICAgICAgLy8gYHRvU3RyaW5nYGVkIGJ5IElFOC85LlxuICAgICAgICBub2RlW3Byb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgICAgICAgLy8gYHNldEF0dHJpYnV0ZWAgd2l0aCBvYmplY3RzIGJlY29tZXMgb25seSBgW29iamVjdF1gIGluIElFOC85LFxuICAgICAgICAvLyAoJycgKyB2YWx1ZSkgbWFrZXMgaXQgb3V0cHV0IHRoZSBjb3JyZWN0IHRvU3RyaW5nKCktdmFsdWUuXG4gICAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgYXR0cmlidXRlTmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXlsb2FkID0ge307XG4gICAgICBwYXlsb2FkW25hbWVdID0gdmFsdWU7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgaW5zdGFuY2VJRDogUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkuX2RlYnVnSUQsXG4gICAgICAgIHR5cGU6ICd1cGRhdGUgYXR0cmlidXRlJyxcbiAgICAgICAgcGF5bG9hZDogcGF5bG9hZFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIHNldFZhbHVlRm9yQXR0cmlidXRlOiBmdW5jdGlvbiAobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCAnJyArIHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHBheWxvYWQgPSB7fTtcbiAgICAgIHBheWxvYWRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICBpbnN0YW5jZUlEOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKS5fZGVidWdJRCxcbiAgICAgICAgdHlwZTogJ3VwZGF0ZSBhdHRyaWJ1dGUnLFxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYW4gYXR0cmlidXRlcyBmcm9tIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqL1xuICBkZWxldGVWYWx1ZUZvckF0dHJpYnV0ZTogZnVuY3Rpb24gKG5vZGUsIG5hbWUpIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgIGluc3RhbmNlSUQ6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELFxuICAgICAgICB0eXBlOiAncmVtb3ZlIGF0dHJpYnV0ZScsXG4gICAgICAgIHBheWxvYWQ6IG5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIGRlbGV0ZVZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbiAgICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgICB2YXIgbXV0YXRpb25NZXRob2QgPSBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2Q7XG4gICAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdW5kZWZpbmVkKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuICAgICAgICBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSkge1xuICAgICAgICAgIG5vZGVbcHJvcE5hbWVdID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgaW5zdGFuY2VJRDogUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkuX2RlYnVnSUQsXG4gICAgICAgIHR5cGU6ICdyZW1vdmUgYXR0cmlidXRlJyxcbiAgICAgICAgcGF5bG9hZDogbmFtZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVByb3BlcnR5T3BlcmF0aW9ucztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKCcuL0xpbmtlZFZhbHVlVXRpbHMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FyblZhbHVlTGluayA9IGZhbHNlO1xudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zSWZQZW5kaW5nVXBkYXRlQW5kTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQgJiYgdGhpcy5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUpIHtcbiAgICB0aGlzLl93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgdXBkYXRlT3B0aW9ucyh0aGlzLCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxudmFyIHZhbHVlUHJvcE5hbWVzID0gWyd2YWx1ZScsICdkZWZhdWx0VmFsdWUnXTtcblxuLyoqXG4gKiBWYWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcFR5cGVzKGluc3QsIHByb3BzKSB7XG4gIHZhciBvd25lciA9IGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgTGlua2VkVmFsdWVVdGlscy5jaGVja1Byb3BUeXBlcygnc2VsZWN0JywgcHJvcHMsIG93bmVyKTtcblxuICBpZiAocHJvcHMudmFsdWVMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZUxpbmspIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2B2YWx1ZUxpbmtgIHByb3Agb24gYHNlbGVjdGAgaXMgZGVwcmVjYXRlZDsgc2V0IGB2YWx1ZWAgYW5kIGBvbkNoYW5nZWAgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICBkaWRXYXJuVmFsdWVMaW5rID0gdHJ1ZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVQcm9wTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcE5hbWUgPSB2YWx1ZVByb3BOYW1lc1tpXTtcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKTtcbiAgICBpZiAocHJvcHMubXVsdGlwbGUgJiYgIWlzQXJyYXkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikpIDogdm9pZCAwO1xuICAgIH0gZWxzZSBpZiAoIXByb3BzLm11bHRpcGxlICYmIGlzQXJyYXkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyICcgKyAndmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBpbnN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGxlXG4gKiBAcGFyYW0geyp9IHByb3BWYWx1ZSBBIHN0cmluZ2FibGUgKHdpdGggYG11bHRpcGxlYCwgYSBsaXN0IG9mIHN0cmluZ2FibGVzKS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMoaW5zdCwgbXVsdGlwbGUsIHByb3BWYWx1ZSkge1xuICB2YXIgc2VsZWN0ZWRWYWx1ZSwgaTtcbiAgdmFyIG9wdGlvbnMgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KS5vcHRpb25zO1xuXG4gIGlmIChtdWx0aXBsZSkge1xuICAgIHNlbGVjdGVkVmFsdWUgPSB7fTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzZWxlY3RlZFZhbHVlWycnICsgcHJvcFZhbHVlW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBzZWxlY3RlZFZhbHVlLmhhc093blByb3BlcnR5KG9wdGlvbnNbaV0udmFsdWUpO1xuICAgICAgaWYgKG9wdGlvbnNbaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbaV0uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IHNldCBgc2VsZWN0LnZhbHVlYCBhcyBleGFjdCBiZWhhdmlvciBpc24ndCBjb25zaXN0ZW50IGFjcm9zcyBhbGxcbiAgICAvLyBicm93c2VycyBmb3IgYWxsIGNhc2VzLlxuICAgIHNlbGVjdGVkVmFsdWUgPSAnJyArIHByb3BWYWx1ZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG9wdGlvbnNbaV0udmFsdWUgPT09IHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgb3B0aW9uc1tpXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICBvcHRpb25zWzBdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHNlbGVjdD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgb3B0aW9uYWxseSBzZXR0aW5nIHRoZVxuICogcHJvcHMgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuIElmIGBtdWx0aXBsZWAgaXMgZmFsc2UsIHRoZSBwcm9wIG11c3QgYmUgYVxuICogc3RyaW5nYWJsZS4gSWYgYG11bHRpcGxlYCBpcyB0cnVlLCB0aGUgcHJvcCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ2FibGVzLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGNoYW5nZSB0aGVcbiAqIHNlbGVjdGVkIG9wdGlvbiB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAqXG4gKiBJZiBpdCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBvcHRpb25zIHdpbGwgbm90XG4gKiB1cGRhdGUgaW4gcmVzcG9uc2UgdG8gdXNlciBhY3Rpb25zLiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIG9wdGlvbnMgdG8gdXBkYXRlLlxuICpcbiAqIElmIGBkZWZhdWx0VmFsdWVgIGlzIHByb3ZpZGVkLCBhbnkgb3B0aW9ucyB3aXRoIHRoZSBzdXBwbGllZCB2YWx1ZXMgd2lsbCBiZVxuICogc2VsZWN0ZWQuXG4gKi9cbnZhciBSZWFjdERPTVNlbGVjdCA9IHtcbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICByZXR1cm4gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgIG9uQ2hhbmdlOiBpbnN0Ll93cmFwcGVyU3RhdGUub25DaGFuZ2UsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH0sXG5cbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY2hlY2tTZWxlY3RQcm9wVHlwZXMoaW5zdCwgcHJvcHMpO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIHBlbmRpbmdVcGRhdGU6IGZhbHNlLFxuICAgICAgaW5pdGlhbFZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICBsaXN0ZW5lcnM6IG51bGwsXG4gICAgICBvbkNoYW5nZTogX2hhbmRsZUNoYW5nZS5iaW5kKGluc3QpLFxuICAgICAgd2FzTXVsdGlwbGU6IEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpXG4gICAgfTtcblxuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnU2VsZWN0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBzZWxlY3QgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnKSA6IHZvaWQgMDtcbiAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIGdldFNlbGVjdFZhbHVlQ29udGV4dDogZnVuY3Rpb24gKGluc3QpIHtcbiAgICAvLyBSZWFjdERPTU9wdGlvbiBsb29rcyBhdCB0aGlzIGluaXRpYWwgdmFsdWUgc28gdGhlIGluaXRpYWwgZ2VuZXJhdGVkXG4gICAgLy8gbWFya3VwIGhhcyBjb3JyZWN0IGBzZWxlY3RlZGAgYXR0cmlidXRlc1xuICAgIHJldHVybiBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlO1xuICB9LFxuXG4gIHBvc3RVcGRhdGVXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgLy8gQWZ0ZXIgdGhlIGluaXRpYWwgbW91bnQsIHdlIGNvbnRyb2wgc2VsZWN0ZWQtbmVzcyBtYW51YWxseSBzbyBkb24ndCBwYXNzXG4gICAgLy8gdGhpcyB2YWx1ZSBkb3duXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSA9IHVuZGVmaW5lZDtcblxuICAgIHZhciB3YXNNdWx0aXBsZSA9IGluc3QuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGUgPSBCb29sZWFuKHByb3BzLm11bHRpcGxlKTtcblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgdXBkYXRlT3B0aW9ucyhpbnN0LCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAod2FzTXVsdGlwbGUgIT09IEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpKSB7XG4gICAgICAvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXG4gICAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlT3B0aW9ucyhpbnN0LCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgcHJvcHMuZGVmYXVsdFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJldmVydCB0aGUgc2VsZWN0IGJhY2sgdG8gaXRzIGRlZmF1bHQgdW5zZWxlY3RlZCBzdGF0ZS5cbiAgICAgICAgdXBkYXRlT3B0aW9ucyhpbnN0LCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgcHJvcHMubXVsdGlwbGUgPyBbXSA6ICcnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9oYW5kbGVDaGFuZ2UoZXZlbnQpIHtcbiAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gIHZhciByZXR1cm5WYWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZXhlY3V0ZU9uQ2hhbmdlKHByb3BzLCBldmVudCk7XG5cbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcbiAgICB0aGlzLl93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgUmVhY3RVcGRhdGVzLmFzYXAodXBkYXRlT3B0aW9uc0lmUGVuZGluZ1VwZGF0ZUFuZE1vdW50ZWQsIHRoaXMpO1xuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01TZWxlY3Q7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01TZWxlY3QuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKTtcbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVtcHR5Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RIb3N0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdEhvc3RDb21wb25lbnQnKTtcblxudmFyIGdldE5leHREZWJ1Z0lEID0gcmVxdWlyZSgncmVhY3QvbGliL2dldE5leHREZWJ1Z0lEJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLy8gVG8gYXZvaWQgYSBjeWNsaWMgZGVwZW5kZW5jeSwgd2UgY3JlYXRlIHRoZSBmaW5hbCBjbGFzcyBpbiB0aGlzIG1vZHVsZVxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlciA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHRoaXMuY29uc3RydWN0KGVsZW1lbnQpO1xufTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XG4gIGlmIChvd25lcikge1xuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHR5cGUgcmVmZXJlbmNlIGlzIGEga25vd24gaW50ZXJuYWwgdHlwZS4gSS5lLiBub3QgYSB1c2VyXG4gKiBwcm92aWRlZCBjb21wb3NpdGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0eXBlXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhpcyBpcyBhIHZhbGlkIGludGVybmFsIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzSW50ZXJuYWxDb21wb25lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlLm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5yZWNlaXZlQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgUmVhY3ROb2RlLCBjcmVhdGUgYW4gaW5zdGFuY2UgdGhhdCB3aWxsIGFjdHVhbGx5IGJlIG1vdW50ZWQuXG4gKlxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkSGF2ZURlYnVnSURcbiAqIEByZXR1cm4ge29iamVjdH0gQSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGVsZW1lbnQncyBjb25zdHJ1Y3Rvci5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZnVuY3Rpb24gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChub2RlLCBzaG91bGRIYXZlRGVidWdJRCkge1xuICB2YXIgaW5zdGFuY2U7XG5cbiAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gZmFsc2UpIHtcbiAgICBpbnN0YW5jZSA9IFJlYWN0RW1wdHlDb21wb25lbnQuY3JlYXRlKGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBlbGVtZW50ID0gbm9kZTtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLlwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShlbGVtZW50Ll9vd25lcik7XG4gICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSwgaW5mbykgOiBfcHJvZEludmFyaWFudCgnMTMwJywgdHlwZSA9PSBudWxsID8gdHlwZSA6IHR5cGVvZiB0eXBlLCBpbmZvKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIGNhc2Ugc3RyaW5nIHZhbHVlc1xuICAgIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgaW5zdGFuY2UgPSBSZWFjdEhvc3RDb21wb25lbnQuY3JlYXRlSW50ZXJuYWxDb21wb25lbnQoZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmIChpc0ludGVybmFsQ29tcG9uZW50VHlwZShlbGVtZW50LnR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIHRlbXBvcmFyaWx5IGF2YWlsYWJsZSBmb3IgY3VzdG9tIGNvbXBvbmVudHMgdGhhdCBhcmUgbm90IHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb25zLiBJLmUuIEFSVC4gT25jZSB0aG9zZSBhcmUgdXBkYXRlZCB0byB1c2UgdGhlIHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb24sIHdlIGNhbiBkcm9wIHRoaXMgY29kZSBwYXRoLlxuICAgICAgaW5zdGFuY2UgPSBuZXcgZWxlbWVudC50eXBlKGVsZW1lbnQpO1xuXG4gICAgICAvLyBXZSByZW5hbWVkIHRoaXMuIEFsbG93IHRoZSBvbGQgbmFtZSBmb3IgY29tcGF0LiA6KFxuICAgICAgaWYgKCFpbnN0YW5jZS5nZXRIb3N0Tm9kZSkge1xuICAgICAgICBpbnN0YW5jZS5nZXRIb3N0Tm9kZSA9IGluc3RhbmNlLmdldE5hdGl2ZU5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlID0gbmV3IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlcihlbGVtZW50KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBub2RlID09PSAnbnVtYmVyJykge1xuICAgIGluc3RhbmNlID0gUmVhY3RIb3N0Q29tcG9uZW50LmNyZWF0ZUluc3RhbmNlRm9yVGV4dChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRW5jb3VudGVyZWQgaW52YWxpZCBSZWFjdCBub2RlIG9mIHR5cGUgJXMnLCB0eXBlb2Ygbm9kZSkgOiBfcHJvZEludmFyaWFudCgnMTMxJywgdHlwZW9mIG5vZGUpIDogdm9pZCAwO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdGFuY2UubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLnJlY2VpdmVDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmdldEhvc3ROb2RlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS51bm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nLCAnT25seSBSZWFjdCBDb21wb25lbnRzIGNhbiBiZSBtb3VudGVkLicpIDogdm9pZCAwO1xuICB9XG5cbiAgLy8gVGhlc2UgdHdvIGZpZWxkcyBhcmUgdXNlZCBieSB0aGUgRE9NIGFuZCBBUlQgZGlmZmluZyBhbGdvcml0aG1zXG4gIC8vIHJlc3BlY3RpdmVseS4gSW5zdGVhZCBvZiB1c2luZyBleHBhbmRvcyBvbiBjb21wb25lbnRzLCB3ZSBzaG91bGQgYmVcbiAgLy8gc3RvcmluZyB0aGUgc3RhdGUgbmVlZGVkIGJ5IHRoZSBkaWZmaW5nIGFsZ29yaXRobXMgZWxzZXdoZXJlLlxuICBpbnN0YW5jZS5fbW91bnRJbmRleCA9IDA7XG4gIGluc3RhbmNlLl9tb3VudEltYWdlID0gbnVsbDtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGluc3RhbmNlLl9kZWJ1Z0lEID0gc2hvdWxkSGF2ZURlYnVnSUQgPyBnZXROZXh0RGVidWdJRCgpIDogMDtcbiAgfVxuXG4gIC8vIEludGVybmFsIGluc3RhbmNlcyBzaG91bGQgZnVsbHkgY29uc3RydWN0ZWQgYXQgdGhpcyBwb2ludCwgc28gdGhleSBzaG91bGRcbiAgLy8gbm90IGdldCBhbnkgbmV3IGZpZWxkcyBhZGRlZCB0byB0aGVtIGF0IHRoaXMgcG9pbnQuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKGluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbl9hc3NpZ24oUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyLnByb3RvdHlwZSwgUmVhY3RDb21wb3NpdGVDb21wb25lbnQsIHtcbiAgX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQ6IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnRcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Tm9kZVR5cGVzID0ge1xuICBIT1NUOiAwLFxuICBDT01QT1NJVEU6IDEsXG4gIEVNUFRZOiAyLFxuXG4gIGdldFR5cGU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBSZWFjdE5vZGVUeXBlcy5FTVBUWTtcbiAgICB9IGVsc2UgaWYgKFJlYWN0LmlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICBpZiAodHlwZW9mIG5vZGUudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gUmVhY3ROb2RlVHlwZXMuQ09NUE9TSVRFO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0Tm9kZVR5cGVzLkhPU1Q7XG4gICAgICB9XG4gICAgfVxuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmV4cGVjdGVkIG5vZGU6ICVzJywgbm9kZSkgOiBfcHJvZEludmFyaWFudCgnMjYnLCBub2RlKSA6IHZvaWQgMDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE5vZGVUeXBlcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdE5vZGVUeXBlcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUNvbXBvbmVudEZhY3Rvcnk7XG5cbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50SW5qZWN0aW9uID0ge1xuICBpbmplY3RFbXB0eUNvbXBvbmVudEZhY3Rvcnk6IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgZW1wdHlDb21wb25lbnRGYWN0b3J5ID0gZmFjdG9yeTtcbiAgfVxufTtcblxudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gKGluc3RhbnRpYXRlKSB7XG4gICAgcmV0dXJuIGVtcHR5Q29tcG9uZW50RmFjdG9yeShpbnN0YW50aWF0ZSk7XG4gIH1cbn07XG5cblJlYWN0RW1wdHlDb21wb25lbnQuaW5qZWN0aW9uID0gUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVtcHR5Q29tcG9uZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RW1wdHlDb21wb25lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBnZW5lcmljQ29tcG9uZW50Q2xhc3MgPSBudWxsO1xudmFyIHRleHRDb21wb25lbnRDbGFzcyA9IG51bGw7XG5cbnZhciBSZWFjdEhvc3RDb21wb25lbnRJbmplY3Rpb24gPSB7XG4gIC8vIFRoaXMgYWNjZXB0cyBhIGNsYXNzIHRoYXQgcmVjZWl2ZXMgdGhlIHRhZyBzdHJpbmcuIFRoaXMgaXMgYSBjYXRjaCBhbGxcbiAgLy8gdGhhdCBjYW4gcmVuZGVyIGFueSBraW5kIG9mIHRhZy5cbiAgaW5qZWN0R2VuZXJpY0NvbXBvbmVudENsYXNzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3MpIHtcbiAgICBnZW5lcmljQ29tcG9uZW50Q2xhc3MgPSBjb21wb25lbnRDbGFzcztcbiAgfSxcbiAgLy8gVGhpcyBhY2NlcHRzIGEgdGV4dCBjb21wb25lbnQgY2xhc3MgdGhhdCB0YWtlcyB0aGUgdGV4dCBzdHJpbmcgdG8gYmVcbiAgLy8gcmVuZGVyZWQgYXMgcHJvcHMuXG4gIGluamVjdFRleHRDb21wb25lbnRDbGFzczogZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzKSB7XG4gICAgdGV4dENvbXBvbmVudENsYXNzID0gY29tcG9uZW50Q2xhc3M7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IGEgaG9zdCBpbnRlcm5hbCBjb21wb25lbnQgY2xhc3MgZm9yIGEgc3BlY2lmaWMgdGFnLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGNyZWF0ZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgaW50ZXJuYWwgY2xhc3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUludGVybmFsQ29tcG9uZW50KGVsZW1lbnQpIHtcbiAgIWdlbmVyaWNDb21wb25lbnRDbGFzcyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGVyZSBpcyBubyByZWdpc3RlcmVkIGNvbXBvbmVudCBmb3IgdGhlIHRhZyAlcycsIGVsZW1lbnQudHlwZSkgOiBfcHJvZEludmFyaWFudCgnMTExJywgZWxlbWVudC50eXBlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIG5ldyBnZW5lcmljQ29tcG9uZW50Q2xhc3MoZWxlbWVudCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdFRleHR9IHRleHRcbiAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZUZvclRleHQodGV4dCkge1xuICByZXR1cm4gbmV3IHRleHRDb21wb25lbnRDbGFzcyh0ZXh0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVGV4dENvbXBvbmVudChjb21wb25lbnQpIHtcbiAgcmV0dXJuIGNvbXBvbmVudCBpbnN0YW5jZW9mIHRleHRDb21wb25lbnRDbGFzcztcbn1cblxudmFyIFJlYWN0SG9zdENvbXBvbmVudCA9IHtcbiAgY3JlYXRlSW50ZXJuYWxDb21wb25lbnQ6IGNyZWF0ZUludGVybmFsQ29tcG9uZW50LFxuICBjcmVhdGVJbnN0YW5jZUZvclRleHQ6IGNyZWF0ZUluc3RhbmNlRm9yVGV4dCxcbiAgaXNUZXh0Q29tcG9uZW50OiBpc1RleHRDb21wb25lbnQsXG4gIGluamVjdGlvbjogUmVhY3RIb3N0Q29tcG9uZW50SW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SG9zdENvbXBvbmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEhvc3RDb21wb25lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFN5bWJvbCcpO1xuXG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIEtleUVzY2FwZVV0aWxzID0gcmVxdWlyZSgnLi9LZXlFc2NhcGVVdGlscycpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIFRoaXMgaXMgaW5saW5lZCBmcm9tIFJlYWN0RWxlbWVudCBzaW5jZSB0aGlzIGZpbGUgaXMgc2hhcmVkIGJldHdlZW5cbiAqIGlzb21vcnBoaWMgYW5kIHJlbmRlcmVycy4gV2UgY291bGQgZXh0cmFjdCB0aGlzIHRvIGFcbiAqXG4gKi9cblxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgY29tcG9uZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGNvbXBvbmVudCBBIGNvbXBvbmVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRLZXkoY29tcG9uZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKGNvbXBvbmVudCAmJiB0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBjb21wb25lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gS2V5RXNjYXBlVXRpbHMuZXNjYXBlKGNvbXBvbmVudC5rZXkpO1xuICB9XG4gIC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbi8qKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVTb0ZhciBOYW1lIG9mIHRoZSBrZXkgcGF0aCBzbyBmYXIuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBVc2VkIHRvIHBhc3MgaW5mb3JtYXRpb24gdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXG4gKiBwcm9jZXNzLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCBuYW1lU29GYXIsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCB8fCB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fFxuICAvLyBUaGUgZm9sbG93aW5nIGlzIGlubGluZWQgZnJvbSBSZWFjdEVsZW1lbnQuIFRoaXMgbWVhbnMgd2UgY2FuIG9wdGltaXplXG4gIC8vIHNvbWUgY2hlY2tzLiBSZWFjdCBGaWJlciBhbHNvIGlubGluZXMgdGhpcyBsb2dpYyBmb3Igc2ltaWxhciBwdXJwb3Nlcy5cbiAgdHlwZSA9PT0gJ29iamVjdCcgJiYgY2hpbGRyZW4uJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sXG4gICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzLlxuICAgIG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IGNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGlpID0gMDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSA9ICcnO1xuICAgICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgbWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICAgICAgICAgIGlmIChtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSkge1xuICAgICAgICAgICAgICBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtID0gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lICsgJ2AuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHlldCBmdWxseSBzdXBwb3J0ZWQuIEl0IGlzIGFuICcgKyAnZXhwZXJpbWVudGFsIGZlYXR1cmUgdGhhdCBtaWdodCBiZSByZW1vdmVkLiBDb252ZXJ0IGl0IHRvIGEgJyArICdzZXF1ZW5jZSAvIGl0ZXJhYmxlIG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0pIDogdm9pZCAwO1xuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIGNoaWxkID0gZW50cnlbMV07XG4gICAgICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgS2V5RXNjYXBlVXRpbHMuZXNjYXBlKGVudHJ5WzBdKSArIFNVQlNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZCwgMCk7XG4gICAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZCBvciB3cmFwIHRoZSBvYmplY3QgdXNpbmcgY3JlYXRlRnJhZ21lbnQob2JqZWN0KSBmcm9tIHRoZSAnICsgJ1JlYWN0IGFkZC1vbnMuJztcbiAgICAgICAgaWYgKGNoaWxkcmVuLl9pc1JlYWN0RWxlbWVudCkge1xuICAgICAgICAgIGFkZGVuZHVtID0gXCIgSXQgbG9va3MgbGlrZSB5b3UncmUgdXNpbmcgYW4gZWxlbWVudCBjcmVhdGVkIGJ5IGEgZGlmZmVyZW50IFwiICsgJ3ZlcnNpb24gb2YgUmVhY3QuIE1ha2Ugc3VyZSB0byB1c2Ugb25seSBvbmUgY29weSBvZiBSZWFjdC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgYWRkZW5kdW0gKz0gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogX3Byb2RJbnZhcmlhbnQoJzMxJywgY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nLCBhZGRlbmR1bSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLCBidXRcbiAqIG1pZ2h0IGFsc28gYmUgc3BlY2lmaWVkIHRocm91Z2ggYXR0cmlidXRlczpcbiAqXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4sIC4uLilgXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMubGVmdFBhbmVsQ2hpbGRyZW4sIC4uLilgXG4gKlxuICogVGhlIGB0cmF2ZXJzZUNvbnRleHRgIGlzIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHRoYXQgaXMgcGFzc2VkIHRocm91Z2ggdGhlXG4gKiBlbnRpcmUgdHJhdmVyc2FsLiBJdCBjYW4gYmUgdXNlZCB0byBzdG9yZSBhY2N1bXVsYXRpb25zIG9yIGFueXRoaW5nIGVsc2UgdGhhdFxuICogdGhlIGNhbGxiYWNrIG1pZ2h0IGZpbmQgcmVsZXZhbnQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBvYmplY3QuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgVG8gaW52b2tlIHVwb24gdHJhdmVyc2luZyBlYWNoIGNoaWxkLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgZm9yIHRyYXZlcnNhbC5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sICcnLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0cmF2ZXJzZUFsbENoaWxkcmVuO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL3RyYXZlcnNlQWxsQ2hpbGRyZW4uanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogVXBzdHJlYW0gdmVyc2lvbiBvZiBldmVudCBsaXN0ZW5lci4gRG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgc3BlY2lmaWNcbiAqIG5hdHVyZSBvZiBwbGF0Zm9ybS5cbiAqL1xudmFyIEV2ZW50TGlzdGVuZXIgPSB7XG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGJ1YmJsZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3Rlbih0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5hdHRhY2hFdmVudCkge1xuICAgICAgdGFyZ2V0LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgY2FwdHVyZTogZnVuY3Rpb24gY2FwdHVyZSh0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F0dGVtcHRlZCB0byBsaXN0ZW4gdG8gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZSBvbiBhICcgKyAnYnJvd3NlciB0aGF0IGRvZXMgbm90IHN1cHBvcnQgdGhlIGNhcHR1cmUgcGhhc2UuIFlvdXIgYXBwbGljYXRpb24gJyArICd3aWxsIG5vdCByZWNlaXZlIHNvbWUgZXZlbnRzLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBlbXB0eUZ1bmN0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICByZWdpc3RlckRlZmF1bHQ6IGZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdCgpIHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50TGlzdGVuZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0aW9uJyk7XG5cbnZhciBjb250YWluc05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9jb250YWluc05vZGUnKTtcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xuXG5mdW5jdGlvbiBpc0luRG9jdW1lbnQobm9kZSkge1xuICByZXR1cm4gY29udGFpbnNOb2RlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSk7XG59XG5cbi8qKlxuICogQFJlYWN0SW5wdXRTZWxlY3Rpb246IFJlYWN0IGlucHV0IHNlbGVjdGlvbiBtb2R1bGUuIEJhc2VkIG9uIFNlbGVjdGlvbi5qcyxcbiAqIGJ1dCBtb2RpZmllZCB0byBiZSBzdWl0YWJsZSBmb3IgcmVhY3QgYW5kIGhhcyBhIGNvdXBsZSBvZiBidWcgZml4ZXMgKGRvZXNuJ3RcbiAqIGFzc3VtZSBidXR0b25zIGhhdmUgcmFuZ2Ugc2VsZWN0aW9ucyBhbGxvd2VkKS5cbiAqIElucHV0IHNlbGVjdGlvbiBtb2R1bGUgZm9yIFJlYWN0LlxuICovXG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHtcbiAgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIG5vZGVOYW1lICYmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICd0ZXh0JyB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCBlbGVtLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKTtcbiAgfSxcblxuICBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBmb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgZm9jdXNlZEVsZW06IGZvY3VzZWRFbGVtLFxuICAgICAgc2VsZWN0aW9uUmFuZ2U6IFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGZvY3VzZWRFbGVtKSA/IFJlYWN0SW5wdXRTZWxlY3Rpb24uZ2V0U2VsZWN0aW9uKGZvY3VzZWRFbGVtKSA6IG51bGxcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAgICogcmVzdG9yZSBpdC4gVGhpcyBpcyB1c2VmdWwgd2hlbiBwZXJmb3JtaW5nIG9wZXJhdGlvbnMgdGhhdCBjb3VsZCByZW1vdmUgZG9tXG4gICAqIG5vZGVzIGFuZCBwbGFjZSB0aGVtIGJhY2sgaW4sIHJlc3VsdGluZyBpbiBmb2N1cyBiZWluZyBsb3N0LlxuICAgKi9cbiAgcmVzdG9yZVNlbGVjdGlvbjogZnVuY3Rpb24gKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pIHtcbiAgICB2YXIgY3VyRm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgdmFyIHByaW9yRm9jdXNlZEVsZW0gPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLmZvY3VzZWRFbGVtO1xuICAgIHZhciBwcmlvclNlbGVjdGlvblJhbmdlID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5zZWxlY3Rpb25SYW5nZTtcbiAgICBpZiAoY3VyRm9jdXNlZEVsZW0gIT09IHByaW9yRm9jdXNlZEVsZW0gJiYgaXNJbkRvY3VtZW50KHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgICBpZiAoUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgICAgUmVhY3RJbnB1dFNlbGVjdGlvbi5zZXRTZWxlY3Rpb24ocHJpb3JGb2N1c2VkRWxlbSwgcHJpb3JTZWxlY3Rpb25SYW5nZSk7XG4gICAgICB9XG4gICAgICBmb2N1c05vZGUocHJpb3JGb2N1c2VkRWxlbSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAZ2V0U2VsZWN0aW9uOiBHZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgZm9jdXNlZCB0ZXh0YXJlYSwgaW5wdXQgb3JcbiAgICogY29udGVudEVkaXRhYmxlIG5vZGUuXG4gICAqIC1AaW5wdXQ6IExvb2sgdXAgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0XG4gICAqIC1AcmV0dXJuIHtzdGFydDogc2VsZWN0aW9uU3RhcnQsIGVuZDogc2VsZWN0aW9uRW5kfVxuICAgKi9cbiAgZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICB2YXIgc2VsZWN0aW9uO1xuXG4gICAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAgIC8vIE1vZGVybiBicm93c2VyIHdpdGggaW5wdXQgb3IgdGV4dGFyZWEuXG4gICAgICBzZWxlY3Rpb24gPSB7XG4gICAgICAgIHN0YXJ0OiBpbnB1dC5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgZW5kOiBpbnB1dC5zZWxlY3Rpb25FbmRcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24gJiYgaW5wdXQubm9kZU5hbWUgJiYgaW5wdXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xuICAgICAgLy8gSUU4IGlucHV0LlxuICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAvLyBUaGVyZSBjYW4gb25seSBiZSBvbmUgc2VsZWN0aW9uIHBlciBkb2N1bWVudCBpbiBJRSwgc28gaXQgbXVzdFxuICAgICAgLy8gYmUgaW4gb3VyIGVsZW1lbnQuXG4gICAgICBpZiAocmFuZ2UucGFyZW50RWxlbWVudCgpID09PSBpbnB1dCkge1xuICAgICAgICBzZWxlY3Rpb24gPSB7XG4gICAgICAgICAgc3RhcnQ6IC1yYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIC1pbnB1dC52YWx1ZS5sZW5ndGgpLFxuICAgICAgICAgIGVuZDogLXJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIC1pbnB1dC52YWx1ZS5sZW5ndGgpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbnRlbnQgZWRpdGFibGUgb3Igb2xkIElFIHRleHRhcmVhLlxuICAgICAgc2VsZWN0aW9uID0gUmVhY3RET01TZWxlY3Rpb24uZ2V0T2Zmc2V0cyhpbnB1dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGVjdGlvbiB8fCB7IHN0YXJ0OiAwLCBlbmQ6IDAgfTtcbiAgfSxcblxuICAvKipcbiAgICogQHNldFNlbGVjdGlvbjogU2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIHRleHRhcmVhIG9yIGlucHV0IGFuZCBmb2N1c2VzXG4gICAqIHRoZSBpbnB1dC5cbiAgICogLUBpbnB1dCAgICAgU2V0IHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dCBvciB0ZXh0YXJlYVxuICAgKiAtQG9mZnNldHMgICBPYmplY3Qgb2Ygc2FtZSBmb3JtIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSBnZXQqXG4gICAqL1xuICBzZXRTZWxlY3Rpb246IGZ1bmN0aW9uIChpbnB1dCwgb2Zmc2V0cykge1xuICAgIHZhciBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgdmFyIGVuZCA9IG9mZnNldHMuZW5kO1xuICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZW5kID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAgIGlucHV0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSBNYXRoLm1pbihlbmQsIGlucHV0LnZhbHVlLmxlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24gJiYgaW5wdXQubm9kZU5hbWUgJiYgaW5wdXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xuICAgICAgdmFyIHJhbmdlID0gaW5wdXQuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICAgICAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kIC0gc3RhcnQpO1xuICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RE9NU2VsZWN0aW9uLnNldE9mZnNldHMoaW5wdXQsIG9mZnNldHMpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdElucHV0U2VsZWN0aW9uO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0SW5wdXRTZWxlY3Rpb24uanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbi8qKlxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXG4gKlxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IG9yIGRvY3VtZW50IGJvZHkgaXMgbm90XG4gKiB5ZXQgZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0gez9ET01Eb2N1bWVudH0gZG9jIERlZmF1bHRzIHRvIGN1cnJlbnQgZG9jdW1lbnQuXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChkb2MpIC8qP0RPTUVsZW1lbnQqL3tcbiAgZG9jID0gZG9jIHx8ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB1bmRlZmluZWQpO1xuICBpZiAodHlwZW9mIGRvYyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkb2MuYWN0aXZlRWxlbWVudCB8fCBkb2MuYm9keTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBkb2MuYm9keTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFjdGl2ZUVsZW1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3QnKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdERPTUNvbnRhaW5lckluZm8gPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29udGFpbmVySW5mbycpO1xudmFyIFJlYWN0RE9NRmVhdHVyZUZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUZlYXR1cmVGbGFncycpO1xudmFyIFJlYWN0RmVhdHVyZUZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdEZlYXR1cmVGbGFncycpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbnZhciBSZWFjdE1hcmt1cENoZWNrc3VtID0gcmVxdWlyZSgnLi9SZWFjdE1hcmt1cENoZWNrc3VtJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZVF1ZXVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgQVRUUl9OQU1FID0gRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUU7XG52YXIgUk9PVF9BVFRSX05BTUUgPSBET01Qcm9wZXJ0eS5ST09UX0FUVFJJQlVURV9OQU1FO1xuXG52YXIgRUxFTUVOVF9OT0RFX1RZUEUgPSAxO1xudmFyIERPQ19OT0RFX1RZUEUgPSA5O1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSA9IDExO1xuXG52YXIgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRCA9IHt9O1xuXG4vKipcbiAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyXG4gKiB0aGF0J3Mgbm90IGNvbW1vbiBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gc3RyaW5ncy5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgY2hhcmFjdGVyIHdoZXJlIHRoZSBzdHJpbmdzIGRpdmVyZ2VcbiAqL1xuZnVuY3Rpb24gZmlyc3REaWZmZXJlbmNlSW5kZXgoc3RyaW5nMSwgc3RyaW5nMikge1xuICB2YXIgbWluTGVuID0gTWF0aC5taW4oc3RyaW5nMS5sZW5ndGgsIHN0cmluZzIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5MZW47IGkrKykge1xuICAgIGlmIChzdHJpbmcxLmNoYXJBdChpKSAhPT0gc3RyaW5nMi5jaGFyQXQoaSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyaW5nMS5sZW5ndGggPT09IHN0cmluZzIubGVuZ3RoID8gLTEgOiBtaW5MZW47XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTURvY3VtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdGhhdCBtYXkgY29udGFpblxuICogYSBSZWFjdCBjb21wb25lbnRcbiAqIEByZXR1cm4gez8qfSBET00gZWxlbWVudCB0aGF0IG1heSBoYXZlIHRoZSByZWFjdFJvb3QgSUQsIG9yIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxHZXRJRChub2RlKSB7XG4gIC8vIElmIG5vZGUgaXMgc29tZXRoaW5nIGxpa2UgYSB3aW5kb3csIGRvY3VtZW50LCBvciB0ZXh0IG5vZGUsIG5vbmUgb2ZcbiAgLy8gd2hpY2ggc3VwcG9ydCBhdHRyaWJ1dGVzIG9yIGEgLmdldEF0dHJpYnV0ZSBtZXRob2QsIGdyYWNlZnVsbHkgcmV0dXJuXG4gIC8vIHRoZSBlbXB0eSBzdHJpbmcsIGFzIGlmIHRoZSBhdHRyaWJ1dGUgd2VyZSBtaXNzaW5nLlxuICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoQVRUUl9OQU1FKSB8fCAnJztcbn1cblxuLyoqXG4gKiBNb3VudHMgdGhpcyBjb21wb25lbnQgYW5kIGluc2VydHMgaXQgaW50byB0aGUgRE9NLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudEluc3RhbmNlIFRoZSBpbnN0YW5jZSB0byBtb3VudC5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIG1vdW50IGludG8uXG4gKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIElmIHRydWUsIGRvIG5vdCBpbnNlcnQgbWFya3VwXG4gKi9cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50SW50b05vZGUod3JhcHBlckluc3RhbmNlLCBjb250YWluZXIsIHRyYW5zYWN0aW9uLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xuICB2YXIgbWFya2VyTmFtZTtcbiAgaWYgKFJlYWN0RmVhdHVyZUZsYWdzLmxvZ1RvcExldmVsUmVuZGVycykge1xuICAgIHZhciB3cmFwcGVkRWxlbWVudCA9IHdyYXBwZXJJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQucHJvcHMuY2hpbGQ7XG4gICAgdmFyIHR5cGUgPSB3cmFwcGVkRWxlbWVudC50eXBlO1xuICAgIG1hcmtlck5hbWUgPSAnUmVhY3QgbW91bnQ6ICcgKyAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gdHlwZSA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lKTtcbiAgICBjb25zb2xlLnRpbWUobWFya2VyTmFtZSk7XG4gIH1cblxuICB2YXIgbWFya3VwID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KHdyYXBwZXJJbnN0YW5jZSwgdHJhbnNhY3Rpb24sIG51bGwsIFJlYWN0RE9NQ29udGFpbmVySW5mbyh3cmFwcGVySW5zdGFuY2UsIGNvbnRhaW5lciksIGNvbnRleHQsIDAgLyogcGFyZW50RGVidWdJRCAqL1xuICApO1xuXG4gIGlmIChtYXJrZXJOYW1lKSB7XG4gICAgY29uc29sZS50aW1lRW5kKG1hcmtlck5hbWUpO1xuICB9XG5cbiAgd3JhcHBlckluc3RhbmNlLl9yZW5kZXJlZENvbXBvbmVudC5fdG9wTGV2ZWxXcmFwcGVyID0gd3JhcHBlckluc3RhbmNlO1xuICBSZWFjdE1vdW50Ll9tb3VudEltYWdlSW50b05vZGUobWFya3VwLCBjb250YWluZXIsIHdyYXBwZXJJbnN0YW5jZSwgc2hvdWxkUmV1c2VNYXJrdXAsIHRyYW5zYWN0aW9uKTtcbn1cblxuLyoqXG4gKiBCYXRjaGVkIG1vdW50LlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudEluc3RhbmNlIFRoZSBpbnN0YW5jZSB0byBtb3VudC5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIG1vdW50IGludG8uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIElmIHRydWUsIGRvIG5vdCBpbnNlcnQgbWFya3VwXG4gKi9cbmZ1bmN0aW9uIGJhdGNoZWRNb3VudENvbXBvbmVudEludG9Ob2RlKGNvbXBvbmVudEluc3RhbmNlLCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XG4gIHZhciB0cmFuc2FjdGlvbiA9IFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmdldFBvb2xlZChcbiAgLyogdXNlQ3JlYXRlRWxlbWVudCAqL1xuICAhc2hvdWxkUmV1c2VNYXJrdXAgJiYgUmVhY3RET01GZWF0dXJlRmxhZ3MudXNlQ3JlYXRlRWxlbWVudCk7XG4gIHRyYW5zYWN0aW9uLnBlcmZvcm0obW91bnRDb21wb25lbnRJbnRvTm9kZSwgbnVsbCwgY29tcG9uZW50SW5zdGFuY2UsIGNvbnRhaW5lciwgdHJhbnNhY3Rpb24sIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KTtcbiAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG59XG5cbi8qKlxuICogVW5tb3VudHMgYSBjb21wb25lbnQgYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgRE9NLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGluc3RhbmNlIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHVubW91bnQgZnJvbS5cbiAqIEBmaW5hbFxuICogQGludGVybmFsXG4gKiBAc2VlIHtSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGV9XG4gKi9cbmZ1bmN0aW9uIHVubW91bnRDb21wb25lbnRGcm9tTm9kZShpbnN0YW5jZSwgY29udGFpbmVyLCBzYWZlbHkpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkZsdXNoKCk7XG4gIH1cbiAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQoaW5zdGFuY2UsIHNhZmVseSk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kRmx1c2goKTtcbiAgfVxuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUpIHtcbiAgICBjb250YWluZXIgPSBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gaHR0cDovL2pzcGVyZi5jb20vZW1wdHlpbmctYS1ub2RlXG4gIHdoaWxlIChjb250YWluZXIubGFzdENoaWxkKSB7XG4gICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5sYXN0Q2hpbGQpO1xuICB9XG59XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaGFzIGEgZGlyZWN0IFJlYWN0LXJlbmRlcmVkIGNoaWxkIHRoYXQgaXNcbiAqIG5vdCBhIFJlYWN0IHJvb3QgZWxlbWVudC4gVXNlZnVsIGZvciB3YXJuaW5nIGluIGByZW5kZXJgLFxuICogYHVubW91bnRDb21wb25lbnRBdE5vZGVgLCBldGMuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIGVsZW1lbnQgY29udGFpbnMgYSBkaXJlY3QgY2hpbGQgdGhhdCB3YXNcbiAqIHJlbmRlcmVkIGJ5IFJlYWN0IGJ1dCBpcyBub3QgYSByb290IGVsZW1lbnQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaGFzTm9uUm9vdFJlYWN0Q2hpbGQoY29udGFpbmVyKSB7XG4gIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgaWYgKHJvb3RFbCkge1xuICAgIHZhciBpbnN0ID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUocm9vdEVsKTtcbiAgICByZXR1cm4gISEoaW5zdCAmJiBpbnN0Ll9ob3N0UGFyZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGlzIGEgUmVhY3QgRE9NIGVsZW1lbnQgYW5kXG4gKiBpdCBoYXMgYmVlbiByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3QuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIGhhcyBiZWVuIHJlbmRlcmVkIGJ5IGFub3RoZXIgY29weSBvZiBSZWFjdFxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIG5vZGVJc1JlbmRlcmVkQnlPdGhlckluc3RhbmNlKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHJldHVybiAhIShyb290RWwgJiYgaXNSZWFjdE5vZGUocm9vdEVsKSAmJiAhUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUocm9vdEVsKSk7XG59XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaXMgYSB2YWxpZCBub2RlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIGlzIGEgdmFsaWQgRE9NIG5vZGUuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZENvbnRhaW5lcihub2RlKSB7XG4gIHJldHVybiAhIShub2RlICYmIChub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSkpO1xufVxuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGlzIGEgdmFsaWQgUmVhY3Qgbm9kZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBpcyBhIHZhbGlkIFJlYWN0IERPTSBub2RlLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzUmVhY3ROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIGlzVmFsaWRDb250YWluZXIobm9kZSkgJiYgKG5vZGUuaGFzQXR0cmlidXRlKFJPT1RfQVRUUl9OQU1FKSB8fCBub2RlLmhhc0F0dHJpYnV0ZShBVFRSX05BTUUpKTtcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFJvb3RJbnN0YW5jZUluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHZhciBwcmV2SG9zdEluc3RhbmNlID0gcm9vdEVsICYmIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHJvb3RFbCk7XG4gIHJldHVybiBwcmV2SG9zdEluc3RhbmNlICYmICFwcmV2SG9zdEluc3RhbmNlLl9ob3N0UGFyZW50ID8gcHJldkhvc3RJbnN0YW5jZSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFRvcExldmVsV3JhcHBlckluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdCA9IGdldEhvc3RSb290SW5zdGFuY2VJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gcm9vdCA/IHJvb3QuX2hvc3RDb250YWluZXJJbmZvLl90b3BMZXZlbFdyYXBwZXIgOiBudWxsO1xufVxuXG4vKipcbiAqIFRlbXBvcmFyeSAoPykgaGFjayBzbyB0aGF0IHdlIGNhbiBzdG9yZSBhbGwgdG9wLWxldmVsIHBlbmRpbmcgdXBkYXRlcyBvblxuICogY29tcG9zaXRlcyBpbnN0ZWFkIG9mIGhhdmluZyB0byB3b3JyeSBhYm91dCBkaWZmZXJlbnQgdHlwZXMgb2YgY29tcG9uZW50c1xuICogaGVyZS5cbiAqL1xudmFyIHRvcExldmVsUm9vdENvdW50ZXIgPSAxO1xudmFyIFRvcExldmVsV3JhcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yb290SUQgPSB0b3BMZXZlbFJvb3RDb3VudGVyKys7XG59O1xuVG9wTGV2ZWxXcmFwcGVyLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBUb3BMZXZlbFdyYXBwZXIuZGlzcGxheU5hbWUgPSAnVG9wTGV2ZWxXcmFwcGVyJztcbn1cblRvcExldmVsV3JhcHBlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZDtcbn07XG5Ub3BMZXZlbFdyYXBwZXIuaXNSZWFjdFRvcExldmVsV3JhcHBlciA9IHRydWU7XG5cbi8qKlxuICogTW91bnRpbmcgaXMgdGhlIHByb2Nlc3Mgb2YgaW5pdGlhbGl6aW5nIGEgUmVhY3QgY29tcG9uZW50IGJ5IGNyZWF0aW5nIGl0c1xuICogcmVwcmVzZW50YXRpdmUgRE9NIGVsZW1lbnRzIGFuZCBpbnNlcnRpbmcgdGhlbSBpbnRvIGEgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gKiBBbnkgcHJpb3IgY29udGVudCBpbnNpZGUgYGNvbnRhaW5lcmAgaXMgZGVzdHJveWVkIGluIHRoZSBwcm9jZXNzLlxuICpcbiAqICAgUmVhY3RNb3VudC5yZW5kZXIoXG4gKiAgICAgY29tcG9uZW50LFxuICogICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXInKVxuICogICApO1xuICpcbiAqICAgPGRpdiBpZD1cImNvbnRhaW5lclwiPiAgICAgICAgICAgICAgICAgICA8LS0gU3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gKiAgICAgPGRpdiBkYXRhLXJlYWN0aWQ9XCIuM1wiPiAgICAgICAgICAgICAgPC0tIFJlbmRlcmVkIHJlYWN0Um9vdCBvZiBSZWFjdFxuICogICAgICAgLy8gLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LlxuICogICAgIDwvZGl2PlxuICogICA8L2Rpdj5cbiAqXG4gKiBJbnNpZGUgb2YgYGNvbnRhaW5lcmAsIHRoZSBmaXJzdCBlbGVtZW50IHJlbmRlcmVkIGlzIHRoZSBcInJlYWN0Um9vdFwiLlxuICovXG52YXIgUmVhY3RNb3VudCA9IHtcbiAgVG9wTGV2ZWxXcmFwcGVyOiBUb3BMZXZlbFdyYXBwZXIsXG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgZGV2dG9vbHMuIFRoZSBrZXlzIGFyZSBub3QgaW1wb3J0YW50LlxuICAgKi9cbiAgX2luc3RhbmNlc0J5UmVhY3RSb290SUQ6IGluc3RhbmNlc0J5UmVhY3RSb290SUQsXG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBob29rIHByb3ZpZGVkIHRvIHN1cHBvcnQgcmVuZGVyaW5nIFJlYWN0IGNvbXBvbmVudHMgd2hpbGVcbiAgICogZW5zdXJpbmcgdGhhdCB0aGUgYXBwYXJlbnQgc2Nyb2xsIHBvc2l0aW9uIG9mIGl0cyBgY29udGFpbmVyYCBkb2VzIG5vdFxuICAgKiBjaGFuZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIFRoZSBgY29udGFpbmVyYCBiZWluZyByZW5kZXJlZCBpbnRvLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZW5kZXJDYWxsYmFjayBUaGlzIG11c3QgYmUgY2FsbGVkIG9uY2UgdG8gZG8gdGhlIHJlbmRlci5cbiAgICovXG4gIHNjcm9sbE1vbml0b3I6IGZ1bmN0aW9uIChjb250YWluZXIsIHJlbmRlckNhbGxiYWNrKSB7XG4gICAgcmVuZGVyQ2FsbGJhY2soKTtcbiAgfSxcblxuICAvKipcbiAgICogVGFrZSBhIGNvbXBvbmVudCB0aGF0J3MgYWxyZWFkeSBtb3VudGVkIGludG8gdGhlIERPTSBhbmQgcmVwbGFjZSBpdHMgcHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gcHJldkNvbXBvbmVudCBjb21wb25lbnQgaW5zdGFuY2UgYWxyZWFkeSBpbiB0aGUgRE9NXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBjb21wb25lbnQgaW5zdGFuY2UgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciB0byByZW5kZXIgaW50b1xuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICovXG4gIF91cGRhdGVSb290Q29tcG9uZW50OiBmdW5jdGlvbiAocHJldkNvbXBvbmVudCwgbmV4dEVsZW1lbnQsIG5leHRDb250ZXh0LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgUmVhY3RNb3VudC5zY3JvbGxNb25pdG9yKGNvbnRhaW5lciwgZnVuY3Rpb24gKCkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlRWxlbWVudEludGVybmFsKHByZXZDb21wb25lbnQsIG5leHRFbGVtZW50LCBuZXh0Q29udGV4dCk7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbChwcmV2Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJldkNvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVyIGEgbmV3IGNvbXBvbmVudCBpbnRvIHRoZSBET00uIEhvb2tlZCBieSBob29rcyFcbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IGVsZW1lbnQgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciB0byByZW5kZXIgaW50b1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIGlmIHdlIHNob3VsZCBza2lwIHRoZSBtYXJrdXAgaW5zZXJ0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBuZXh0Q29tcG9uZW50XG4gICAqL1xuICBfcmVuZGVyTmV3Um9vdENvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XG4gICAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXG4gICAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gICAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLlxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCwgJ19yZW5kZXJOZXdSb290Q29tcG9uZW50KCk6IFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gJyArICdvZiBwcm9wcyBhbmQgc3RhdGU7IHRyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gJyArICdyZW5kZXIgaXMgbm90IGFsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnX3JlZ2lzdGVyQ29tcG9uZW50KC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzcnKSA6IHZvaWQgMDtcblxuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5lbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3JpbmcoKTtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRFbGVtZW50LCBmYWxzZSk7XG5cbiAgICAvLyBUaGUgaW5pdGlhbCByZW5kZXIgaXMgc3luY2hyb25vdXMgYnV0IGFueSB1cGRhdGVzIHRoYXQgaGFwcGVuIGR1cmluZ1xuICAgIC8vIHJlbmRlcmluZywgaW4gY29tcG9uZW50V2lsbE1vdW50IG9yIGNvbXBvbmVudERpZE1vdW50LCB3aWxsIGJlIGJhdGNoZWRcbiAgICAvLyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgYmF0Y2hpbmcgc3RyYXRlZ3kuXG5cbiAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMoYmF0Y2hlZE1vdW50Q29tcG9uZW50SW50b05vZGUsIGNvbXBvbmVudEluc3RhbmNlLCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KTtcblxuICAgIHZhciB3cmFwcGVySUQgPSBjb21wb25lbnRJbnN0YW5jZS5faW5zdGFuY2Uucm9vdElEO1xuICAgIGluc3RhbmNlc0J5UmVhY3RSb290SURbd3JhcHBlcklEXSA9IGNvbXBvbmVudEluc3RhbmNlO1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudEluc3RhbmNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgUmVhY3QgY29tcG9uZW50IGludG8gdGhlIERPTSBpbiB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gICAqXG4gICAqIElmIHRoZSBSZWFjdCBjb21wb25lbnQgd2FzIHByZXZpb3VzbHkgcmVuZGVyZWQgaW50byBgY29udGFpbmVyYCwgdGhpcyB3aWxsXG4gICAqIHBlcmZvcm0gYW4gdXBkYXRlIG9uIGl0IGFuZCBvbmx5IG11dGF0ZSB0aGUgRE9NIGFzIG5lY2Vzc2FyeSB0byByZWZsZWN0IHRoZVxuICAgKiBsYXRlc3QgUmVhY3QgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBwYXJlbnRDb21wb25lbnQgVGhlIGNvbmNlcHR1YWwgcGFyZW50IG9mIHRoaXMgcmVuZGVyIHRyZWUuXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBDb21wb25lbnQgZWxlbWVudCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cbiAgICovXG4gIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgICEocGFyZW50Q29tcG9uZW50ICE9IG51bGwgJiYgUmVhY3RJbnN0YW5jZU1hcC5oYXMocGFyZW50Q29tcG9uZW50KSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncGFyZW50Q29tcG9uZW50IG11c3QgYmUgYSB2YWxpZCBSZWFjdCBDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCczOCcpIDogdm9pZCAwO1xuICAgIHJldHVybiBSZWFjdE1vdW50Ll9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKTtcbiAgfSxcblxuICBfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgUmVhY3RVcGRhdGVRdWV1ZS52YWxpZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCAnUmVhY3RET00ucmVuZGVyJyk7XG4gICAgIVJlYWN0LmlzVmFsaWRFbGVtZW50KG5leHRFbGVtZW50KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTS5yZW5kZXIoKTogSW52YWxpZCBjb21wb25lbnQgZWxlbWVudC4lcycsIHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ3N0cmluZycgPyBcIiBJbnN0ZWFkIG9mIHBhc3NpbmcgYSBzdHJpbmcgbGlrZSAnZGl2JywgcGFzcyBcIiArIFwiUmVhY3QuY3JlYXRlRWxlbWVudCgnZGl2Jykgb3IgPGRpdiAvPi5cIiA6IHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgY2xhc3MgbGlrZSBGb28sIHBhc3MgJyArICdSZWFjdC5jcmVhdGVFbGVtZW50KEZvbykgb3IgPEZvbyAvPi4nIDogLy8gQ2hlY2sgaWYgaXQgcXVhY2tzIGxpa2UgYW4gZWxlbWVudFxuICAgIG5leHRFbGVtZW50ICE9IG51bGwgJiYgbmV4dEVsZW1lbnQucHJvcHMgIT09IHVuZGVmaW5lZCA/ICcgVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHVuaW50ZW50aW9uYWxseSBsb2FkaW5nIHR3byBpbmRlcGVuZGVudCAnICsgJ2NvcGllcyBvZiBSZWFjdC4nIDogJycpIDogX3Byb2RJbnZhcmlhbnQoJzM5JywgdHlwZW9mIG5leHRFbGVtZW50ID09PSAnc3RyaW5nJyA/IFwiIEluc3RlYWQgb2YgcGFzc2luZyBhIHN0cmluZyBsaWtlICdkaXYnLCBwYXNzIFwiICsgXCJSZWFjdC5jcmVhdGVFbGVtZW50KCdkaXYnKSBvciA8ZGl2IC8+LlwiIDogdHlwZW9mIG5leHRFbGVtZW50ID09PSAnZnVuY3Rpb24nID8gJyBJbnN0ZWFkIG9mIHBhc3NpbmcgYSBjbGFzcyBsaWtlIEZvbywgcGFzcyAnICsgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9vKSBvciA8Rm9vIC8+LicgOiBuZXh0RWxlbWVudCAhPSBudWxsICYmIG5leHRFbGVtZW50LnByb3BzICE9PSB1bmRlZmluZWQgPyAnIFRoaXMgbWF5IGJlIGNhdXNlZCBieSB1bmludGVudGlvbmFsbHkgbG9hZGluZyB0d28gaW5kZXBlbmRlbnQgJyArICdjb3BpZXMgb2YgUmVhY3QuJyA6ICcnKSA6IHZvaWQgMDtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjb250YWluZXIgfHwgIWNvbnRhaW5lci50YWdOYW1lIHx8IGNvbnRhaW5lci50YWdOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdCT0RZJywgJ3JlbmRlcigpOiBSZW5kZXJpbmcgY29tcG9uZW50cyBkaXJlY3RseSBpbnRvIGRvY3VtZW50LmJvZHkgaXMgJyArICdkaXNjb3VyYWdlZCwgc2luY2UgaXRzIGNoaWxkcmVuIGFyZSBvZnRlbiBtYW5pcHVsYXRlZCBieSB0aGlyZC1wYXJ0eSAnICsgJ3NjcmlwdHMgYW5kIGJyb3dzZXIgZXh0ZW5zaW9ucy4gVGhpcyBtYXkgbGVhZCB0byBzdWJ0bGUgJyArICdyZWNvbmNpbGlhdGlvbiBpc3N1ZXMuIFRyeSByZW5kZXJpbmcgaW50byBhIGNvbnRhaW5lciBlbGVtZW50IGNyZWF0ZWQgJyArICdmb3IgeW91ciBhcHAuJykgOiB2b2lkIDA7XG5cbiAgICB2YXIgbmV4dFdyYXBwZWRFbGVtZW50ID0gUmVhY3QuY3JlYXRlRWxlbWVudChUb3BMZXZlbFdyYXBwZXIsIHtcbiAgICAgIGNoaWxkOiBuZXh0RWxlbWVudFxuICAgIH0pO1xuXG4gICAgdmFyIG5leHRDb250ZXh0O1xuICAgIGlmIChwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgIHZhciBwYXJlbnRJbnN0ID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQocGFyZW50Q29tcG9uZW50KTtcbiAgICAgIG5leHRDb250ZXh0ID0gcGFyZW50SW5zdC5fcHJvY2Vzc0NoaWxkQ29udGV4dChwYXJlbnRJbnN0Ll9jb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dENvbnRleHQgPSBlbXB0eU9iamVjdDtcbiAgICB9XG5cbiAgICB2YXIgcHJldkNvbXBvbmVudCA9IGdldFRvcExldmVsV3JhcHBlckluQ29udGFpbmVyKGNvbnRhaW5lcik7XG5cbiAgICBpZiAocHJldkNvbXBvbmVudCkge1xuICAgICAgdmFyIHByZXZXcmFwcGVkRWxlbWVudCA9IHByZXZDb21wb25lbnQuX2N1cnJlbnRFbGVtZW50O1xuICAgICAgdmFyIHByZXZFbGVtZW50ID0gcHJldldyYXBwZWRFbGVtZW50LnByb3BzLmNoaWxkO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkpIHtcbiAgICAgICAgdmFyIHB1YmxpY0luc3QgPSBwcmV2Q29tcG9uZW50Ll9yZW5kZXJlZENvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgICAgICB2YXIgdXBkYXRlZENhbGxiYWNrID0gY2FsbGJhY2sgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwocHVibGljSW5zdCk7XG4gICAgICAgIH07XG4gICAgICAgIFJlYWN0TW91bnQuX3VwZGF0ZVJvb3RDb21wb25lbnQocHJldkNvbXBvbmVudCwgbmV4dFdyYXBwZWRFbGVtZW50LCBuZXh0Q29udGV4dCwgY29udGFpbmVyLCB1cGRhdGVkQ2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gcHVibGljSW5zdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZShjb250YWluZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZWFjdFJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdmFyIGNvbnRhaW5lckhhc1JlYWN0TWFya3VwID0gcmVhY3RSb290RWxlbWVudCAmJiAhIWludGVybmFsR2V0SUQocmVhY3RSb290RWxlbWVudCk7XG4gICAgdmFyIGNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkID0gaGFzTm9uUm9vdFJlYWN0Q2hpbGQoY29udGFpbmVyKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQsICdyZW5kZXIoLi4uKTogUmVwbGFjaW5nIFJlYWN0LXJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBuZXcgcm9vdCAnICsgJ2NvbXBvbmVudC4gSWYgeW91IGludGVuZGVkIHRvIHVwZGF0ZSB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCAnICsgJ3lvdSBzaG91bGQgaW5zdGVhZCBoYXZlIHRoZSBleGlzdGluZyBjaGlsZHJlbiB1cGRhdGUgdGhlaXIgc3RhdGUgJyArICdhbmQgcmVuZGVyIHRoZSBuZXcgY29tcG9uZW50cyBpbnN0ZWFkIG9mIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyLicpIDogdm9pZCAwO1xuXG4gICAgICBpZiAoIWNvbnRhaW5lckhhc1JlYWN0TWFya3VwIHx8IHJlYWN0Um9vdEVsZW1lbnQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgdmFyIHJvb3RFbGVtZW50U2libGluZyA9IHJlYWN0Um9vdEVsZW1lbnQ7XG4gICAgICAgIHdoaWxlIChyb290RWxlbWVudFNpYmxpbmcpIHtcbiAgICAgICAgICBpZiAoaW50ZXJuYWxHZXRJRChyb290RWxlbWVudFNpYmxpbmcpKSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ3JlbmRlcigpOiBUYXJnZXQgbm9kZSBoYXMgbWFya3VwIHJlbmRlcmVkIGJ5IFJlYWN0LCBidXQgdGhlcmUgJyArICdhcmUgdW5yZWxhdGVkIG5vZGVzIGFzIHdlbGwuIFRoaXMgaXMgbW9zdCBjb21tb25seSBjYXVzZWQgYnkgJyArICd3aGl0ZS1zcGFjZSBpbnNlcnRlZCBhcm91bmQgc2VydmVyLXJlbmRlcmVkIG1hcmt1cC4nKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByb290RWxlbWVudFNpYmxpbmcgPSByb290RWxlbWVudFNpYmxpbmcubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkUmV1c2VNYXJrdXAgPSBjb250YWluZXJIYXNSZWFjdE1hcmt1cCAmJiAhcHJldkNvbXBvbmVudCAmJiAhY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQ7XG4gICAgdmFyIGNvbXBvbmVudCA9IFJlYWN0TW91bnQuX3JlbmRlck5ld1Jvb3RDb21wb25lbnQobmV4dFdyYXBwZWRFbGVtZW50LCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBuZXh0Q29udGV4dCkuX3JlbmRlcmVkQ29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKGNvbXBvbmVudCk7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBSZWFjdCBjb21wb25lbnQgaW50byB0aGUgRE9NIGluIHRoZSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAgICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0ZG9tLnJlbmRlclxuICAgKlxuICAgKiBJZiB0aGUgUmVhY3QgY29tcG9uZW50IHdhcyBwcmV2aW91c2x5IHJlbmRlcmVkIGludG8gYGNvbnRhaW5lcmAsIHRoaXMgd2lsbFxuICAgKiBwZXJmb3JtIGFuIHVwZGF0ZSBvbiBpdCBhbmQgb25seSBtdXRhdGUgdGhlIERPTSBhcyBuZWNlc3NhcnkgdG8gcmVmbGVjdCB0aGVcbiAgICogbGF0ZXN0IFJlYWN0IGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IENvbXBvbmVudCBlbGVtZW50IHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gQ29tcG9uZW50IGluc3RhbmNlIHJlbmRlcmVkIGluIGBjb250YWluZXJgLlxuICAgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gUmVhY3RNb3VudC5fcmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVbm1vdW50cyBhbmQgZGVzdHJveXMgdGhlIFJlYWN0IGNvbXBvbmVudCByZW5kZXJlZCBpbiB0aGUgYGNvbnRhaW5lcmAuXG4gICAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdGRvbS51bm1vdW50Y29tcG9uZW50YXRub2RlXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IGNvbnRhaW5pbmcgYSBSZWFjdCBjb21wb25lbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYSBjb21wb25lbnQgd2FzIGZvdW5kIGluIGFuZCB1bm1vdW50ZWQgZnJvbVxuICAgKiAgICAgICAgICAgICAgICAgICBgY29udGFpbmVyYFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAgIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xuICAgIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS4gKFN0cmljdGx5IHNwZWFraW5nLCB1bm1vdW50aW5nIHdvbid0IGNhdXNlIGFcbiAgICAvLyByZW5kZXIgYnV0IHdlIHN0aWxsIGRvbid0IGV4cGVjdCB0byBiZSBpbiBhIHJlbmRlciBjYWxsIGhlcmUuKVxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoKTogUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiAnICsgJ29mIHByb3BzIGFuZCBzdGF0ZTsgdHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgJyArICdpcyBub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnNDAnKSA6IHZvaWQgMDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghbm9kZUlzUmVuZGVyZWRCeU90aGVySW5zdGFuY2UoY29udGFpbmVyKSwgXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IGFub3RoZXIgY29weSBvZiBSZWFjdC4nKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB2YXIgcHJldkNvbXBvbmVudCA9IGdldFRvcExldmVsV3JhcHBlckluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgaWYgKCFwcmV2Q29tcG9uZW50KSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGUgbm9kZSBiZWluZyB1bm1vdW50ZWQgd2FzIHJlbmRlcmVkIGJ5IFJlYWN0LCBidXQgaXNuJ3QgYVxuICAgICAgLy8gcm9vdCBub2RlLlxuICAgICAgdmFyIGNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkID0gaGFzTm9uUm9vdFJlYWN0Q2hpbGQoY29udGFpbmVyKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnRhaW5lciBpdHNlbGYgaXMgYSBSZWFjdCByb290IG5vZGUuXG4gICAgICB2YXIgaXNDb250YWluZXJSZWFjdFJvb3QgPSBjb250YWluZXIubm9kZVR5cGUgPT09IDEgJiYgY29udGFpbmVyLmhhc0F0dHJpYnV0ZShST09UX0FUVFJfTkFNRSk7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCwgXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IFJlYWN0IGFuZCBpcyBub3QgYSB0b3AtbGV2ZWwgY29udGFpbmVyLiAlcycsIGlzQ29udGFpbmVyUmVhY3RSb290ID8gJ1lvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgcGFzc2VkIGluIGEgUmVhY3Qgcm9vdCBub2RlIGluc3RlYWQgJyArICdvZiBpdHMgY29udGFpbmVyLicgOiAnSW5zdGVhZCwgaGF2ZSB0aGUgcGFyZW50IGNvbXBvbmVudCB1cGRhdGUgaXRzIHN0YXRlIGFuZCAnICsgJ3JlcmVuZGVyIGluIG9yZGVyIHRvIHJlbW92ZSB0aGlzIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkZWxldGUgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFtwcmV2Q29tcG9uZW50Ll9pbnN0YW5jZS5yb290SURdO1xuICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyh1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUsIHByZXZDb21wb25lbnQsIGNvbnRhaW5lciwgZmFsc2UpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIF9tb3VudEltYWdlSW50b05vZGU6IGZ1bmN0aW9uIChtYXJrdXAsIGNvbnRhaW5lciwgaW5zdGFuY2UsIHNob3VsZFJldXNlTWFya3VwLCB0cmFuc2FjdGlvbikge1xuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnbW91bnRDb21wb25lbnRJbnRvTm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCB2YWxpZC4nKSA6IF9wcm9kSW52YXJpYW50KCc0MScpIDogdm9pZCAwO1xuXG4gICAgaWYgKHNob3VsZFJldXNlTWFya3VwKSB7XG4gICAgICB2YXIgcm9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgIGlmIChSZWFjdE1hcmt1cENoZWNrc3VtLmNhblJldXNlTWFya3VwKG1hcmt1cCwgcm9vdEVsZW1lbnQpKSB7XG4gICAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUoaW5zdGFuY2UsIHJvb3RFbGVtZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNoZWNrc3VtID0gcm9vdEVsZW1lbnQuZ2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcbiAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcblxuICAgICAgICB2YXIgcm9vdE1hcmt1cCA9IHJvb3RFbGVtZW50Lm91dGVySFRNTDtcbiAgICAgICAgcm9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FLCBjaGVja3N1bSk7XG5cbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRNYXJrdXAgPSBtYXJrdXA7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgLy8gYmVjYXVzZSByb290TWFya3VwIGlzIHJldHJpZXZlZCBmcm9tIHRoZSBET00sIHZhcmlvdXMgbm9ybWFsaXphdGlvbnNcbiAgICAgICAgICAvLyB3aWxsIGhhdmUgb2NjdXJyZWQgd2hpY2ggd2lsbCBub3QgYmUgcHJlc2VudCBpbiBgbWFya3VwYC4gSGVyZSxcbiAgICAgICAgICAvLyBpbnNlcnQgbWFya3VwIGludG8gYSA8ZGl2PiBvciA8aWZyYW1lPiBkZXBlbmRpbmcgb24gdGhlIGNvbnRhaW5lclxuICAgICAgICAgIC8vIHR5cGUgdG8gcGVyZm9ybSB0aGUgc2FtZSBub3JtYWxpemF0aW9ucyBiZWZvcmUgY29tcGFyaW5nLlxuICAgICAgICAgIHZhciBub3JtYWxpemVyO1xuICAgICAgICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFKSB7XG4gICAgICAgICAgICBub3JtYWxpemVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBub3JtYWxpemVyLmlubmVySFRNTCA9IG1hcmt1cDtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRNYXJrdXAgPSBub3JtYWxpemVyLmlubmVySFRNTDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9ybWFsaXplciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChub3JtYWxpemVyKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIuY29udGVudERvY3VtZW50LndyaXRlKG1hcmt1cCk7XG4gICAgICAgICAgICBub3JtYWxpemVkTWFya3VwID0gbm9ybWFsaXplci5jb250ZW50RG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm91dGVySFRNTDtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobm9ybWFsaXplcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpZmZJbmRleCA9IGZpcnN0RGlmZmVyZW5jZUluZGV4KG5vcm1hbGl6ZWRNYXJrdXAsIHJvb3RNYXJrdXApO1xuICAgICAgICB2YXIgZGlmZmVyZW5jZSA9ICcgKGNsaWVudCkgJyArIG5vcm1hbGl6ZWRNYXJrdXAuc3Vic3RyaW5nKGRpZmZJbmRleCAtIDIwLCBkaWZmSW5kZXggKyAyMCkgKyAnXFxuIChzZXJ2ZXIpICcgKyByb290TWFya3VwLnN1YnN0cmluZyhkaWZmSW5kZXggLSAyMCwgZGlmZkluZGV4ICsgMjApO1xuXG4gICAgICAgICEoY29udGFpbmVyLm5vZGVUeXBlICE9PSBET0NfTk9ERV9UWVBFKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdZb3VcXCdyZSB0cnlpbmcgdG8gcmVuZGVyIGEgY29tcG9uZW50IHRvIHRoZSBkb2N1bWVudCB1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nIGJ1dCB0aGUgY2hlY2tzdW0gd2FzIGludmFsaWQuIFRoaXMgdXN1YWxseSBtZWFucyB5b3UgcmVuZGVyZWQgYSBkaWZmZXJlbnQgY29tcG9uZW50IHR5cGUgb3IgcHJvcHMgb24gdGhlIGNsaWVudCBmcm9tIHRoZSBvbmUgb24gdGhlIHNlcnZlciwgb3IgeW91ciByZW5kZXIoKSBtZXRob2RzIGFyZSBpbXB1cmUuIFJlYWN0IGNhbm5vdCBoYW5kbGUgdGhpcyBjYXNlIGR1ZSB0byBjcm9zcy1icm93c2VyIHF1aXJrcyBieSByZW5kZXJpbmcgYXQgdGhlIGRvY3VtZW50IHJvb3QuIFlvdSBzaG91bGQgbG9vayBmb3IgZW52aXJvbm1lbnQgZGVwZW5kZW50IGNvZGUgaW4geW91ciBjb21wb25lbnRzIGFuZCBlbnN1cmUgdGhlIHByb3BzIGFyZSB0aGUgc2FtZSBjbGllbnQgYW5kIHNlcnZlciBzaWRlOlxcbiVzJywgZGlmZmVyZW5jZSkgOiBfcHJvZEludmFyaWFudCgnNDInLCBkaWZmZXJlbmNlKSA6IHZvaWQgMDtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgYXR0ZW1wdGVkIHRvIHJldXNlIG1hcmt1cCBpbiBhIGNvbnRhaW5lciBidXQgdGhlICcgKyAnY2hlY2tzdW0gd2FzIGludmFsaWQuIFRoaXMgZ2VuZXJhbGx5IG1lYW5zIHRoYXQgeW91IGFyZSAnICsgJ3VzaW5nIHNlcnZlciByZW5kZXJpbmcgYW5kIHRoZSBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSAnICsgJ3NlcnZlciB3YXMgbm90IHdoYXQgdGhlIGNsaWVudCB3YXMgZXhwZWN0aW5nLiBSZWFjdCBpbmplY3RlZCAnICsgJ25ldyBtYXJrdXAgdG8gY29tcGVuc2F0ZSB3aGljaCB3b3JrcyBidXQgeW91IGhhdmUgbG9zdCBtYW55ICcgKyAnb2YgdGhlIGJlbmVmaXRzIG9mIHNlcnZlciByZW5kZXJpbmcuIEluc3RlYWQsIGZpZ3VyZSBvdXQgJyArICd3aHkgdGhlIG1hcmt1cCBiZWluZyBnZW5lcmF0ZWQgaXMgZGlmZmVyZW50IG9uIHRoZSBjbGllbnQgJyArICdvciBzZXJ2ZXI6XFxuJXMnLCBkaWZmZXJlbmNlKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgICEoY29udGFpbmVyLm5vZGVUeXBlICE9PSBET0NfTk9ERV9UWVBFKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdZb3VcXCdyZSB0cnlpbmcgdG8gcmVuZGVyIGEgY29tcG9uZW50IHRvIHRoZSBkb2N1bWVudCBidXQgeW91IGRpZG5cXCd0IHVzZSBzZXJ2ZXIgcmVuZGVyaW5nLiBXZSBjYW5cXCd0IGRvIHRoaXMgd2l0aG91dCB1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nIGR1ZSB0byBjcm9zcy1icm93c2VyIHF1aXJrcy4gU2VlIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nKCkgZm9yIHNlcnZlciByZW5kZXJpbmcuJykgOiBfcHJvZEludmFyaWFudCgnNDMnKSA6IHZvaWQgMDtcblxuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB3aGlsZSAoY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmxhc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICBET01MYXp5VHJlZS5pbnNlcnRUcmVlQmVmb3JlKGNvbnRhaW5lciwgbWFya3VwLCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0SW5uZXJIVE1MKGNvbnRhaW5lciwgbWFya3VwKTtcbiAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUoaW5zdGFuY2UsIGNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGhvc3ROb2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUoY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgaWYgKGhvc3ROb2RlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICAgIGluc3RhbmNlSUQ6IGhvc3ROb2RlLl9kZWJ1Z0lELFxuICAgICAgICAgIHR5cGU6ICdtb3VudCcsXG4gICAgICAgICAgcGF5bG9hZDogbWFya3VwLnRvU3RyaW5nKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TW91bnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RNb3VudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE5vZGVUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3ROb2RlVHlwZXMnKTtcblxuZnVuY3Rpb24gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUoaW5zdCkge1xuICB2YXIgdHlwZTtcblxuICB3aGlsZSAoKHR5cGUgPSBpbnN0Ll9yZW5kZXJlZE5vZGVUeXBlKSA9PT0gUmVhY3ROb2RlVHlwZXMuQ09NUE9TSVRFKSB7XG4gICAgaW5zdCA9IGluc3QuX3JlbmRlcmVkQ29tcG9uZW50O1xuICB9XG5cbiAgaWYgKHR5cGUgPT09IFJlYWN0Tm9kZVR5cGVzLkhPU1QpIHtcbiAgICByZXR1cm4gaW5zdC5fcmVuZGVyZWRDb21wb25lbnQ7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gUmVhY3ROb2RlVHlwZXMuRU1QVFkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlLmpzIiwiaW1wb3J0IFByb3ZpZGVyLCB7IGNyZWF0ZVByb3ZpZGVyIH0gZnJvbSAnLi9jb21wb25lbnRzL1Byb3ZpZGVyJztcbmltcG9ydCBjb25uZWN0QWR2YW5jZWQgZnJvbSAnLi9jb21wb25lbnRzL2Nvbm5lY3RBZHZhbmNlZCc7XG5pbXBvcnQgY29ubmVjdCBmcm9tICcuL2Nvbm5lY3QvY29ubmVjdCc7XG5cbmV4cG9ydCB7IFByb3ZpZGVyLCBjcmVhdGVQcm92aWRlciwgY29ubmVjdEFkdmFuY2VkLCBjb25uZWN0IH07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2luZGV4LmpzIiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuZXhwb3J0IHZhciBzdWJzY3JpcHRpb25TaGFwZSA9IFByb3BUeXBlcy5zaGFwZSh7XG4gIHRyeVN1YnNjcmliZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgdHJ5VW5zdWJzY3JpYmU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIG5vdGlmeU5lc3RlZFN1YnM6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIGlzU3Vic2NyaWJlZDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxufSk7XG5cbmV4cG9ydCB2YXIgc3RvcmVTaGFwZSA9IFByb3BUeXBlcy5zaGFwZSh7XG4gIHN1YnNjcmliZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgZGlzcGF0Y2g6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIGdldFN0YXRlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvUHJvcFR5cGVzLmpzIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmltcG9ydCBob2lzdFN0YXRpY3MgZnJvbSAnaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgU3Vic2NyaXB0aW9uIGZyb20gJy4uL3V0aWxzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBzdG9yZVNoYXBlLCBzdWJzY3JpcHRpb25TaGFwZSB9IGZyb20gJy4uL3V0aWxzL1Byb3BUeXBlcyc7XG5cbnZhciBob3RSZWxvYWRpbmdWZXJzaW9uID0gMDtcbnZhciBkdW1teVN0YXRlID0ge307XG5mdW5jdGlvbiBub29wKCkge31cbmZ1bmN0aW9uIG1ha2VTZWxlY3RvclN0YXRlZnVsKHNvdXJjZVNlbGVjdG9yLCBzdG9yZSkge1xuICAvLyB3cmFwIHRoZSBzZWxlY3RvciBpbiBhbiBvYmplY3QgdGhhdCB0cmFja3MgaXRzIHJlc3VsdHMgYmV0d2VlbiBydW5zLlxuICB2YXIgc2VsZWN0b3IgPSB7XG4gICAgcnVuOiBmdW5jdGlvbiBydW5Db21wb25lbnRTZWxlY3Rvcihwcm9wcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG5leHRQcm9wcyA9IHNvdXJjZVNlbGVjdG9yKHN0b3JlLmdldFN0YXRlKCksIHByb3BzKTtcbiAgICAgICAgaWYgKG5leHRQcm9wcyAhPT0gc2VsZWN0b3IucHJvcHMgfHwgc2VsZWN0b3IuZXJyb3IpIHtcbiAgICAgICAgICBzZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIHNlbGVjdG9yLnByb3BzID0gbmV4dFByb3BzO1xuICAgICAgICAgIHNlbGVjdG9yLmVycm9yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgc2VsZWN0b3IuZXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGVjdG9yO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb25uZWN0QWR2YW5jZWQoXG4vKlxuICBzZWxlY3RvckZhY3RvcnkgaXMgYSBmdW5jIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIHJldHVybmluZyB0aGUgc2VsZWN0b3IgZnVuY3Rpb24gdXNlZCB0b1xuICBjb21wdXRlIG5ldyBwcm9wcyBmcm9tIHN0YXRlLCBwcm9wcywgYW5kIGRpc3BhdGNoLiBGb3IgZXhhbXBsZTpcbiAgICAgZXhwb3J0IGRlZmF1bHQgY29ubmVjdEFkdmFuY2VkKChkaXNwYXRjaCwgb3B0aW9ucykgPT4gKHN0YXRlLCBwcm9wcykgPT4gKHtcbiAgICAgIHRoaW5nOiBzdGF0ZS50aGluZ3NbcHJvcHMudGhpbmdJZF0sXG4gICAgICBzYXZlVGhpbmc6IGZpZWxkcyA9PiBkaXNwYXRjaChhY3Rpb25DcmVhdG9ycy5zYXZlVGhpbmcocHJvcHMudGhpbmdJZCwgZmllbGRzKSksXG4gICAgfSkpKFlvdXJDb21wb25lbnQpXG4gICBBY2Nlc3MgdG8gZGlzcGF0Y2ggaXMgcHJvdmlkZWQgdG8gdGhlIGZhY3Rvcnkgc28gc2VsZWN0b3JGYWN0b3JpZXMgY2FuIGJpbmQgYWN0aW9uQ3JlYXRvcnNcbiAgb3V0c2lkZSBvZiB0aGVpciBzZWxlY3RvciBhcyBhbiBvcHRpbWl6YXRpb24uIE9wdGlvbnMgcGFzc2VkIHRvIGNvbm5lY3RBZHZhbmNlZCBhcmUgcGFzc2VkIHRvXG4gIHRoZSBzZWxlY3RvckZhY3RvcnksIGFsb25nIHdpdGggZGlzcGxheU5hbWUgYW5kIFdyYXBwZWRDb21wb25lbnQsIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gICBOb3RlIHRoYXQgc2VsZWN0b3JGYWN0b3J5IGlzIHJlc3BvbnNpYmxlIGZvciBhbGwgY2FjaGluZy9tZW1vaXphdGlvbiBvZiBpbmJvdW5kIGFuZCBvdXRib3VuZFxuICBwcm9wcy4gRG8gbm90IHVzZSBjb25uZWN0QWR2YW5jZWQgZGlyZWN0bHkgd2l0aG91dCBtZW1vaXppbmcgcmVzdWx0cyBiZXR3ZWVuIGNhbGxzIHRvIHlvdXJcbiAgc2VsZWN0b3IsIG90aGVyd2lzZSB0aGUgQ29ubmVjdCBjb21wb25lbnQgd2lsbCByZS1yZW5kZXIgb24gZXZlcnkgc3RhdGUgb3IgcHJvcHMgY2hhbmdlLlxuKi9cbnNlbGVjdG9yRmFjdG9yeSkge1xuICB2YXIgX2NvbnRleHRUeXBlcywgX2NoaWxkQ29udGV4dFR5cGVzO1xuXG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgIF9yZWYkZ2V0RGlzcGxheU5hbWUgPSBfcmVmLmdldERpc3BsYXlOYW1lLFxuICAgICAgZ2V0RGlzcGxheU5hbWUgPSBfcmVmJGdldERpc3BsYXlOYW1lID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAnQ29ubmVjdEFkdmFuY2VkKCcgKyBuYW1lICsgJyknO1xuICB9IDogX3JlZiRnZXREaXNwbGF5TmFtZSxcbiAgICAgIF9yZWYkbWV0aG9kTmFtZSA9IF9yZWYubWV0aG9kTmFtZSxcbiAgICAgIG1ldGhvZE5hbWUgPSBfcmVmJG1ldGhvZE5hbWUgPT09IHVuZGVmaW5lZCA/ICdjb25uZWN0QWR2YW5jZWQnIDogX3JlZiRtZXRob2ROYW1lLFxuICAgICAgX3JlZiRyZW5kZXJDb3VudFByb3AgPSBfcmVmLnJlbmRlckNvdW50UHJvcCxcbiAgICAgIHJlbmRlckNvdW50UHJvcCA9IF9yZWYkcmVuZGVyQ291bnRQcm9wID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBfcmVmJHJlbmRlckNvdW50UHJvcCxcbiAgICAgIF9yZWYkc2hvdWxkSGFuZGxlU3RhdCA9IF9yZWYuc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLFxuICAgICAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzID0gX3JlZiRzaG91bGRIYW5kbGVTdGF0ID09PSB1bmRlZmluZWQgPyB0cnVlIDogX3JlZiRzaG91bGRIYW5kbGVTdGF0LFxuICAgICAgX3JlZiRzdG9yZUtleSA9IF9yZWYuc3RvcmVLZXksXG4gICAgICBzdG9yZUtleSA9IF9yZWYkc3RvcmVLZXkgPT09IHVuZGVmaW5lZCA/ICdzdG9yZScgOiBfcmVmJHN0b3JlS2V5LFxuICAgICAgX3JlZiR3aXRoUmVmID0gX3JlZi53aXRoUmVmLFxuICAgICAgd2l0aFJlZiA9IF9yZWYkd2l0aFJlZiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJHdpdGhSZWYsXG4gICAgICBjb25uZWN0T3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2dldERpc3BsYXlOYW1lJywgJ21ldGhvZE5hbWUnLCAncmVuZGVyQ291bnRQcm9wJywgJ3Nob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcycsICdzdG9yZUtleScsICd3aXRoUmVmJ10pO1xuXG4gIHZhciBzdWJzY3JpcHRpb25LZXkgPSBzdG9yZUtleSArICdTdWJzY3JpcHRpb24nO1xuICB2YXIgdmVyc2lvbiA9IGhvdFJlbG9hZGluZ1ZlcnNpb24rKztcblxuICB2YXIgY29udGV4dFR5cGVzID0gKF9jb250ZXh0VHlwZXMgPSB7fSwgX2NvbnRleHRUeXBlc1tzdG9yZUtleV0gPSBzdG9yZVNoYXBlLCBfY29udGV4dFR5cGVzW3N1YnNjcmlwdGlvbktleV0gPSBzdWJzY3JpcHRpb25TaGFwZSwgX2NvbnRleHRUeXBlcyk7XG4gIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IChfY2hpbGRDb250ZXh0VHlwZXMgPSB7fSwgX2NoaWxkQ29udGV4dFR5cGVzW3N1YnNjcmlwdGlvbktleV0gPSBzdWJzY3JpcHRpb25TaGFwZSwgX2NoaWxkQ29udGV4dFR5cGVzKTtcblxuICByZXR1cm4gZnVuY3Rpb24gd3JhcFdpdGhDb25uZWN0KFdyYXBwZWRDb21wb25lbnQpIHtcbiAgICBpbnZhcmlhbnQodHlwZW9mIFdyYXBwZWRDb21wb25lbnQgPT0gJ2Z1bmN0aW9uJywgJ1lvdSBtdXN0IHBhc3MgYSBjb21wb25lbnQgdG8gdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5ICcgKyAoJ2Nvbm5lY3QuIEluc3RlYWQgcmVjZWl2ZWQgJyArIEpTT04uc3RyaW5naWZ5KFdyYXBwZWRDb21wb25lbnQpKSk7XG5cbiAgICB2YXIgd3JhcHBlZENvbXBvbmVudE5hbWUgPSBXcmFwcGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IFdyYXBwZWRDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JztcblxuICAgIHZhciBkaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lKHdyYXBwZWRDb21wb25lbnROYW1lKTtcblxuICAgIHZhciBzZWxlY3RvckZhY3RvcnlPcHRpb25zID0gX2V4dGVuZHMoe30sIGNvbm5lY3RPcHRpb25zLCB7XG4gICAgICBnZXREaXNwbGF5TmFtZTogZ2V0RGlzcGxheU5hbWUsXG4gICAgICBtZXRob2ROYW1lOiBtZXRob2ROYW1lLFxuICAgICAgcmVuZGVyQ291bnRQcm9wOiByZW5kZXJDb3VudFByb3AsXG4gICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXM6IHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyxcbiAgICAgIHN0b3JlS2V5OiBzdG9yZUtleSxcbiAgICAgIHdpdGhSZWY6IHdpdGhSZWYsXG4gICAgICBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUsXG4gICAgICB3cmFwcGVkQ29tcG9uZW50TmFtZTogd3JhcHBlZENvbXBvbmVudE5hbWUsXG4gICAgICBXcmFwcGVkQ29tcG9uZW50OiBXcmFwcGVkQ29tcG9uZW50XG4gICAgfSk7XG5cbiAgICB2YXIgQ29ubmVjdCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gICAgICBfaW5oZXJpdHMoQ29ubmVjdCwgX0NvbXBvbmVudCk7XG5cbiAgICAgIGZ1bmN0aW9uIENvbm5lY3QocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbm5lY3QpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCkpO1xuXG4gICAgICAgIF90aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHt9O1xuICAgICAgICBfdGhpcy5yZW5kZXJDb3VudCA9IDA7XG4gICAgICAgIF90aGlzLnN0b3JlID0gcHJvcHNbc3RvcmVLZXldIHx8IGNvbnRleHRbc3RvcmVLZXldO1xuICAgICAgICBfdGhpcy5wcm9wc01vZGUgPSBCb29sZWFuKHByb3BzW3N0b3JlS2V5XSk7XG4gICAgICAgIF90aGlzLnNldFdyYXBwZWRJbnN0YW5jZSA9IF90aGlzLnNldFdyYXBwZWRJbnN0YW5jZS5iaW5kKF90aGlzKTtcblxuICAgICAgICBpbnZhcmlhbnQoX3RoaXMuc3RvcmUsICdDb3VsZCBub3QgZmluZCBcIicgKyBzdG9yZUtleSArICdcIiBpbiBlaXRoZXIgdGhlIGNvbnRleHQgb3IgcHJvcHMgb2YgJyArICgnXCInICsgZGlzcGxheU5hbWUgKyAnXCIuIEVpdGhlciB3cmFwIHRoZSByb290IGNvbXBvbmVudCBpbiBhIDxQcm92aWRlcj4sICcpICsgKCdvciBleHBsaWNpdGx5IHBhc3MgXCInICsgc3RvcmVLZXkgKyAnXCIgYXMgYSBwcm9wIHRvIFwiJyArIGRpc3BsYXlOYW1lICsgJ1wiLicpKTtcblxuICAgICAgICBfdGhpcy5pbml0U2VsZWN0b3IoKTtcbiAgICAgICAgX3RoaXMuaW5pdFN1YnNjcmlwdGlvbigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgICAgdmFyIF9yZWYyO1xuXG4gICAgICAgIC8vIElmIHRoaXMgY29tcG9uZW50IHJlY2VpdmVkIHN0b3JlIGZyb20gcHJvcHMsIGl0cyBzdWJzY3JpcHRpb24gc2hvdWxkIGJlIHRyYW5zcGFyZW50XG4gICAgICAgIC8vIHRvIGFueSBkZXNjZW5kYW50cyByZWNlaXZpbmcgc3RvcmUrc3Vic2NyaXB0aW9uIGZyb20gY29udGV4dDsgaXQgcGFzc2VzIGFsb25nXG4gICAgICAgIC8vIHN1YnNjcmlwdGlvbiBwYXNzZWQgdG8gaXQuIE90aGVyd2lzZSwgaXQgc2hhZG93cyB0aGUgcGFyZW50IHN1YnNjcmlwdGlvbiwgd2hpY2ggYWxsb3dzXG4gICAgICAgIC8vIENvbm5lY3QgdG8gY29udHJvbCBvcmRlcmluZyBvZiBub3RpZmljYXRpb25zIHRvIGZsb3cgdG9wLWRvd24uXG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLnByb3BzTW9kZSA/IG51bGwgOiB0aGlzLnN1YnNjcmlwdGlvbjtcbiAgICAgICAgcmV0dXJuIF9yZWYyID0ge30sIF9yZWYyW3N1YnNjcmlwdGlvbktleV0gPSBzdWJzY3JpcHRpb24gfHwgdGhpcy5jb250ZXh0W3N1YnNjcmlwdGlvbktleV0sIF9yZWYyO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgaWYgKCFzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHJldHVybjtcblxuICAgICAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgZmlyZXMgZHVyaW5nIHNlcnZlciBzaWRlIHJlbmRlcmluZywgYnV0IGNvbXBvbmVudERpZE1vdW50IGFuZFxuICAgICAgICAvLyBjb21wb25lbnRXaWxsVW5tb3VudCBkbyBub3QuIEJlY2F1c2Ugb2YgdGhpcywgdHJ5U3Vic2NyaWJlIGhhcHBlbnMgZHVyaW5nIC4uLmRpZE1vdW50LlxuICAgICAgICAvLyBPdGhlcndpc2UsIHVuc3Vic2NyaXB0aW9uIHdvdWxkIG5ldmVyIHRha2UgcGxhY2UgZHVyaW5nIFNTUiwgY2F1c2luZyBhIG1lbW9yeSBsZWFrLlxuICAgICAgICAvLyBUbyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgYSBjaGlsZCBjb21wb25lbnQgbWF5IGhhdmUgdHJpZ2dlcmVkIGEgc3RhdGUgY2hhbmdlIGJ5XG4gICAgICAgIC8vIGRpc3BhdGNoaW5nIGFuIGFjdGlvbiBpbiBpdHMgY29tcG9uZW50V2lsbE1vdW50LCB3ZSBoYXZlIHRvIHJlLXJ1biB0aGUgc2VsZWN0IGFuZCBtYXliZVxuICAgICAgICAvLyByZS1yZW5kZXIuXG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnRyeVN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnJ1bih0aGlzLnByb3BzKTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlKSB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rvci5ydW4obmV4dFByb3BzKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB0aGlzLnN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMubm90aWZ5TmVzdGVkU3VicyA9IG5vb3A7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBudWxsO1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnJ1biA9IG5vb3A7XG4gICAgICAgIHRoaXMuc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5nZXRXcmFwcGVkSW5zdGFuY2UgPSBmdW5jdGlvbiBnZXRXcmFwcGVkSW5zdGFuY2UoKSB7XG4gICAgICAgIGludmFyaWFudCh3aXRoUmVmLCAnVG8gYWNjZXNzIHRoZSB3cmFwcGVkIGluc3RhbmNlLCB5b3UgbmVlZCB0byBzcGVjaWZ5ICcgKyAoJ3sgd2l0aFJlZjogdHJ1ZSB9IGluIHRoZSBvcHRpb25zIGFyZ3VtZW50IG9mIHRoZSAnICsgbWV0aG9kTmFtZSArICcoKSBjYWxsLicpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZEluc3RhbmNlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuc2V0V3JhcHBlZEluc3RhbmNlID0gZnVuY3Rpb24gc2V0V3JhcHBlZEluc3RhbmNlKHJlZikge1xuICAgICAgICB0aGlzLndyYXBwZWRJbnN0YW5jZSA9IHJlZjtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmluaXRTZWxlY3RvciA9IGZ1bmN0aW9uIGluaXRTZWxlY3RvcigpIHtcbiAgICAgICAgdmFyIHNvdXJjZVNlbGVjdG9yID0gc2VsZWN0b3JGYWN0b3J5KHRoaXMuc3RvcmUuZGlzcGF0Y2gsIHNlbGVjdG9yRmFjdG9yeU9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gbWFrZVNlbGVjdG9yU3RhdGVmdWwoc291cmNlU2VsZWN0b3IsIHRoaXMuc3RvcmUpO1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnJ1bih0aGlzLnByb3BzKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmluaXRTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiBpbml0U3Vic2NyaXB0aW9uKCkge1xuICAgICAgICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykgcmV0dXJuO1xuXG4gICAgICAgIC8vIHBhcmVudFN1YidzIHNvdXJjZSBzaG91bGQgbWF0Y2ggd2hlcmUgc3RvcmUgY2FtZSBmcm9tOiBwcm9wcyB2cy4gY29udGV4dC4gQSBjb21wb25lbnRcbiAgICAgICAgLy8gY29ubmVjdGVkIHRvIHRoZSBzdG9yZSB2aWEgcHJvcHMgc2hvdWxkbid0IHVzZSBzdWJzY3JpcHRpb24gZnJvbSBjb250ZXh0LCBvciB2aWNlIHZlcnNhLlxuICAgICAgICB2YXIgcGFyZW50U3ViID0gKHRoaXMucHJvcHNNb2RlID8gdGhpcy5wcm9wcyA6IHRoaXMuY29udGV4dClbc3Vic2NyaXB0aW9uS2V5XTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKHRoaXMuc3RvcmUsIHBhcmVudFN1YiwgdGhpcy5vblN0YXRlQ2hhbmdlLmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIGBub3RpZnlOZXN0ZWRTdWJzYCBpcyBkdXBsaWNhdGVkIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgY29tcG9uZW50IGlzICB1bm1vdW50ZWQgaW5cbiAgICAgICAgLy8gdGhlIG1pZGRsZSBvZiB0aGUgbm90aWZpY2F0aW9uIGxvb3AsIHdoZXJlIGB0aGlzLnN1YnNjcmlwdGlvbmAgd2lsbCB0aGVuIGJlIG51bGwuIEFuXG4gICAgICAgIC8vIGV4dHJhIG51bGwgY2hlY2sgZXZlcnkgY2hhbmdlIGNhbiBiZSBhdm9pZGVkIGJ5IGNvcHlpbmcgdGhlIG1ldGhvZCBvbnRvIGB0aGlzYCBhbmQgdGhlblxuICAgICAgICAvLyByZXBsYWNpbmcgaXQgd2l0aCBhIG5vLW9wIG9uIHVubW91bnQuIFRoaXMgY2FuIHByb2JhYmx5IGJlIGF2b2lkZWQgaWYgU3Vic2NyaXB0aW9uJ3NcbiAgICAgICAgLy8gbGlzdGVuZXJzIGxvZ2ljIGlzIGNoYW5nZWQgdG8gbm90IGNhbGwgbGlzdGVuZXJzIHRoYXQgaGF2ZSBiZWVuIHVuc3Vic2NyaWJlZCBpbiB0aGVcbiAgICAgICAgLy8gbWlkZGxlIG9mIHRoZSBub3RpZmljYXRpb24gbG9vcC5cbiAgICAgICAgdGhpcy5ub3RpZnlOZXN0ZWRTdWJzID0gdGhpcy5zdWJzY3JpcHRpb24ubm90aWZ5TmVzdGVkU3Vicy5iaW5kKHRoaXMuc3Vic2NyaXB0aW9uKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLm9uU3RhdGVDaGFuZ2UgPSBmdW5jdGlvbiBvblN0YXRlQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnJ1bih0aGlzLnByb3BzKTtcblxuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlKSB7XG4gICAgICAgICAgdGhpcy5ub3RpZnlOZXN0ZWRTdWJzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jb21wb25lbnREaWRVcGRhdGUgPSB0aGlzLm5vdGlmeU5lc3RlZFN1YnNPbkNvbXBvbmVudERpZFVwZGF0ZTtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKGR1bW15U3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5ub3RpZnlOZXN0ZWRTdWJzT25Db21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBub3RpZnlOZXN0ZWRTdWJzT25Db21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIC8vIGBjb21wb25lbnREaWRVcGRhdGVgIGlzIGNvbmRpdGlvbmFsbHkgaW1wbGVtZW50ZWQgd2hlbiBgb25TdGF0ZUNoYW5nZWAgZGV0ZXJtaW5lcyBpdFxuICAgICAgICAvLyBuZWVkcyB0byBub3RpZnkgbmVzdGVkIHN1YnMuIE9uY2UgY2FsbGVkLCBpdCB1bmltcGxlbWVudHMgaXRzZWxmIHVudGlsIGZ1cnRoZXIgc3RhdGVcbiAgICAgICAgLy8gY2hhbmdlcyBvY2N1ci4gRG9pbmcgaXQgdGhpcyB3YXkgdnMgaGF2aW5nIGEgcGVybWFuZW50IGBjb21wb25lbnREaWRVcGRhdGVgIHRoYXQgZG9lc1xuICAgICAgICAvLyBhIGJvb2xlYW4gY2hlY2sgZXZlcnkgdGltZSBhdm9pZHMgYW4gZXh0cmEgbWV0aG9kIGNhbGwgbW9zdCBvZiB0aGUgdGltZSwgcmVzdWx0aW5nXG4gICAgICAgIC8vIGluIHNvbWUgcGVyZiBib29zdC5cbiAgICAgICAgdGhpcy5jb21wb25lbnREaWRVcGRhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubm90aWZ5TmVzdGVkU3VicygpO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuaXNTdWJzY3JpYmVkID0gZnVuY3Rpb24gaXNTdWJzY3JpYmVkKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLnN1YnNjcmlwdGlvbikgJiYgdGhpcy5zdWJzY3JpcHRpb24uaXNTdWJzY3JpYmVkKCk7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5hZGRFeHRyYVByb3BzID0gZnVuY3Rpb24gYWRkRXh0cmFQcm9wcyhwcm9wcykge1xuICAgICAgICBpZiAoIXdpdGhSZWYgJiYgIXJlbmRlckNvdW50UHJvcCAmJiAhKHRoaXMucHJvcHNNb2RlICYmIHRoaXMuc3Vic2NyaXB0aW9uKSkgcmV0dXJuIHByb3BzO1xuICAgICAgICAvLyBtYWtlIGEgc2hhbGxvdyBjb3B5IHNvIHRoYXQgZmllbGRzIGFkZGVkIGRvbid0IGxlYWsgdG8gdGhlIG9yaWdpbmFsIHNlbGVjdG9yLlxuICAgICAgICAvLyB0aGlzIGlzIGVzcGVjaWFsbHkgaW1wb3J0YW50IGZvciAncmVmJyBzaW5jZSB0aGF0J3MgYSByZWZlcmVuY2UgYmFjayB0byB0aGUgY29tcG9uZW50XG4gICAgICAgIC8vIGluc3RhbmNlLiBhIHNpbmdsZXRvbiBtZW1vaXplZCBzZWxlY3RvciB3b3VsZCB0aGVuIGJlIGhvbGRpbmcgYSByZWZlcmVuY2UgdG8gdGhlXG4gICAgICAgIC8vIGluc3RhbmNlLCBwcmV2ZW50aW5nIHRoZSBpbnN0YW5jZSBmcm9tIGJlaW5nIGdhcmJhZ2UgY29sbGVjdGVkLCBhbmQgdGhhdCB3b3VsZCBiZSBiYWRcbiAgICAgICAgdmFyIHdpdGhFeHRyYXMgPSBfZXh0ZW5kcyh7fSwgcHJvcHMpO1xuICAgICAgICBpZiAod2l0aFJlZikgd2l0aEV4dHJhcy5yZWYgPSB0aGlzLnNldFdyYXBwZWRJbnN0YW5jZTtcbiAgICAgICAgaWYgKHJlbmRlckNvdW50UHJvcCkgd2l0aEV4dHJhc1tyZW5kZXJDb3VudFByb3BdID0gdGhpcy5yZW5kZXJDb3VudCsrO1xuICAgICAgICBpZiAodGhpcy5wcm9wc01vZGUgJiYgdGhpcy5zdWJzY3JpcHRpb24pIHdpdGhFeHRyYXNbc3Vic2NyaXB0aW9uS2V5XSA9IHRoaXMuc3Vic2NyaXB0aW9uO1xuICAgICAgICByZXR1cm4gd2l0aEV4dHJhcztcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gdGhpcy5zZWxlY3RvcjtcbiAgICAgICAgc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNlbGVjdG9yLmVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgc2VsZWN0b3IuZXJyb3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoV3JhcHBlZENvbXBvbmVudCwgdGhpcy5hZGRFeHRyYVByb3BzKHNlbGVjdG9yLnByb3BzKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBDb25uZWN0O1xuICAgIH0oQ29tcG9uZW50KTtcblxuICAgIENvbm5lY3QuV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnQ7XG4gICAgQ29ubmVjdC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgIENvbm5lY3QuY2hpbGRDb250ZXh0VHlwZXMgPSBjaGlsZENvbnRleHRUeXBlcztcbiAgICBDb25uZWN0LmNvbnRleHRUeXBlcyA9IGNvbnRleHRUeXBlcztcbiAgICBDb25uZWN0LnByb3BUeXBlcyA9IGNvbnRleHRUeXBlcztcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVwZGF0ZSgpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgLy8gV2UgYXJlIGhvdCByZWxvYWRpbmchXG4gICAgICAgIGlmICh0aGlzLnZlcnNpb24gIT09IHZlcnNpb24pIHtcbiAgICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICAgIHRoaXMuaW5pdFNlbGVjdG9yKCk7XG5cbiAgICAgICAgICAvLyBJZiBhbnkgY29ubmVjdGVkIGRlc2NlbmRhbnRzIGRvbid0IGhvdCByZWxvYWQgKGFuZCByZXN1YnNjcmliZSBpbiB0aGUgcHJvY2VzcyksIHRoZWlyXG4gICAgICAgICAgLy8gbGlzdGVuZXJzIHdpbGwgYmUgbG9zdCB3aGVuIHdlIHVuc3Vic2NyaWJlLiBVbmZvcnR1bmF0ZWx5LCBieSBjb3B5aW5nIG92ZXIgYWxsXG4gICAgICAgICAgLy8gbGlzdGVuZXJzLCB0aGlzIGRvZXMgbWVhbiB0aGF0IHRoZSBvbGQgdmVyc2lvbnMgb2YgY29ubmVjdGVkIGRlc2NlbmRhbnRzIHdpbGwgc3RpbGwgYmVcbiAgICAgICAgICAvLyBub3RpZmllZCBvZiBzdGF0ZSBjaGFuZ2VzOyBob3dldmVyLCB0aGVpciBvblN0YXRlQ2hhbmdlIGZ1bmN0aW9uIGlzIGEgbm8tb3Agc28gdGhpc1xuICAgICAgICAgIC8vIGlzbid0IGEgaHVnZSBkZWFsLlxuICAgICAgICAgIHZhciBvbGRMaXN0ZW5lcnMgPSBbXTtcblxuICAgICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgb2xkTGlzdGVuZXJzID0gdGhpcy5zdWJzY3JpcHRpb24ubGlzdGVuZXJzLmdldCgpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udHJ5VW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5pbml0U3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgaWYgKHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udHJ5U3Vic2NyaWJlKCk7XG4gICAgICAgICAgICBvbGRMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5zdWJzY3JpcHRpb24ubGlzdGVuZXJzLnN1YnNjcmliZShsaXN0ZW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGhvaXN0U3RhdGljcyhDb25uZWN0LCBXcmFwcGVkQ29tcG9uZW50KTtcbiAgfTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29tcG9uZW50cy9jb25uZWN0QWR2YW5jZWQuanMiLCJpbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICdsb2Rhc2gtZXMvaXNQbGFpbk9iamVjdCc7XG5pbXBvcnQgJCRvYnNlcnZhYmxlIGZyb20gJ3N5bWJvbC1vYnNlcnZhYmxlJztcblxuLyoqXG4gKiBUaGVzZSBhcmUgcHJpdmF0ZSBhY3Rpb24gdHlwZXMgcmVzZXJ2ZWQgYnkgUmVkdXguXG4gKiBGb3IgYW55IHVua25vd24gYWN0aW9ucywgeW91IG11c3QgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlLlxuICogSWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuXG4gKiBEbyBub3QgcmVmZXJlbmNlIHRoZXNlIGFjdGlvbiB0eXBlcyBkaXJlY3RseSBpbiB5b3VyIGNvZGUuXG4gKi9cbmV4cG9ydCB2YXIgQWN0aW9uVHlwZXMgPSB7XG4gIElOSVQ6ICdAQHJlZHV4L0lOSVQnXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBSZWR1eCBzdG9yZSB0aGF0IGhvbGRzIHRoZSBzdGF0ZSB0cmVlLlxuICAgKiBUaGUgb25seSB3YXkgdG8gY2hhbmdlIHRoZSBkYXRhIGluIHRoZSBzdG9yZSBpcyB0byBjYWxsIGBkaXNwYXRjaCgpYCBvbiBpdC5cbiAgICpcbiAgICogVGhlcmUgc2hvdWxkIG9ubHkgYmUgYSBzaW5nbGUgc3RvcmUgaW4geW91ciBhcHAuIFRvIHNwZWNpZnkgaG93IGRpZmZlcmVudFxuICAgKiBwYXJ0cyBvZiB0aGUgc3RhdGUgdHJlZSByZXNwb25kIHRvIGFjdGlvbnMsIHlvdSBtYXkgY29tYmluZSBzZXZlcmFsIHJlZHVjZXJzXG4gICAqIGludG8gYSBzaW5nbGUgcmVkdWNlciBmdW5jdGlvbiBieSB1c2luZyBgY29tYmluZVJlZHVjZXJzYC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVkdWNlciBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbmV4dCBzdGF0ZSB0cmVlLCBnaXZlblxuICAgKiB0aGUgY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgYWN0aW9uIHRvIGhhbmRsZS5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IFtwcmVsb2FkZWRTdGF0ZV0gVGhlIGluaXRpYWwgc3RhdGUuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gICAqIHRvIGh5ZHJhdGUgdGhlIHN0YXRlIGZyb20gdGhlIHNlcnZlciBpbiB1bml2ZXJzYWwgYXBwcywgb3IgdG8gcmVzdG9yZSBhXG4gICAqIHByZXZpb3VzbHkgc2VyaWFsaXplZCB1c2VyIHNlc3Npb24uXG4gICAqIElmIHlvdSB1c2UgYGNvbWJpbmVSZWR1Y2Vyc2AgdG8gcHJvZHVjZSB0aGUgcm9vdCByZWR1Y2VyIGZ1bmN0aW9uLCB0aGlzIG11c3QgYmVcbiAgICogYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgYGNvbWJpbmVSZWR1Y2Vyc2Aga2V5cy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2VuaGFuY2VyXSBUaGUgc3RvcmUgZW5oYW5jZXIuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gICAqIHRvIGVuaGFuY2UgdGhlIHN0b3JlIHdpdGggdGhpcmQtcGFydHkgY2FwYWJpbGl0aWVzIHN1Y2ggYXMgbWlkZGxld2FyZSxcbiAgICogdGltZSB0cmF2ZWwsIHBlcnNpc3RlbmNlLCBldGMuIFRoZSBvbmx5IHN0b3JlIGVuaGFuY2VyIHRoYXQgc2hpcHMgd2l0aCBSZWR1eFxuICAgKiBpcyBgYXBwbHlNaWRkbGV3YXJlKClgLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RvcmV9IEEgUmVkdXggc3RvcmUgdGhhdCBsZXRzIHlvdSByZWFkIHRoZSBzdGF0ZSwgZGlzcGF0Y2ggYWN0aW9uc1xuICAgKiBhbmQgc3Vic2NyaWJlIHRvIGNoYW5nZXMuXG4gICAqL1xufTtleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVTdG9yZShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgdmFyIF9yZWYyO1xuXG4gIGlmICh0eXBlb2YgcHJlbG9hZGVkU3RhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVuaGFuY2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIGVuaGFuY2VyID0gcHJlbG9hZGVkU3RhdGU7XG4gICAgcHJlbG9hZGVkU3RhdGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIGVuaGFuY2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuaGFuY2VyKGNyZWF0ZVN0b3JlKShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSByZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgY3VycmVudFJlZHVjZXIgPSByZWR1Y2VyO1xuICB2YXIgY3VycmVudFN0YXRlID0gcHJlbG9hZGVkU3RhdGU7XG4gIHZhciBjdXJyZW50TGlzdGVuZXJzID0gW107XG4gIHZhciBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycztcbiAgdmFyIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCkge1xuICAgIGlmIChuZXh0TGlzdGVuZXJzID09PSBjdXJyZW50TGlzdGVuZXJzKSB7XG4gICAgICBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycy5zbGljZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgc3RhdGUgdHJlZSBtYW5hZ2VkIGJ5IHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHJldHVybnMge2FueX0gVGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY2hhbmdlIGxpc3RlbmVyLiBJdCB3aWxsIGJlIGNhbGxlZCBhbnkgdGltZSBhbiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCxcbiAgICogYW5kIHNvbWUgcGFydCBvZiB0aGUgc3RhdGUgdHJlZSBtYXkgcG90ZW50aWFsbHkgaGF2ZSBjaGFuZ2VkLiBZb3UgbWF5IHRoZW5cbiAgICogY2FsbCBgZ2V0U3RhdGUoKWAgdG8gcmVhZCB0aGUgY3VycmVudCBzdGF0ZSB0cmVlIGluc2lkZSB0aGUgY2FsbGJhY2suXG4gICAqXG4gICAqIFlvdSBtYXkgY2FsbCBgZGlzcGF0Y2goKWAgZnJvbSBhIGNoYW5nZSBsaXN0ZW5lciwgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIGNhdmVhdHM6XG4gICAqXG4gICAqIDEuIFRoZSBzdWJzY3JpcHRpb25zIGFyZSBzbmFwc2hvdHRlZCBqdXN0IGJlZm9yZSBldmVyeSBgZGlzcGF0Y2goKWAgY2FsbC5cbiAgICogSWYgeW91IHN1YnNjcmliZSBvciB1bnN1YnNjcmliZSB3aGlsZSB0aGUgbGlzdGVuZXJzIGFyZSBiZWluZyBpbnZva2VkLCB0aGlzXG4gICAqIHdpbGwgbm90IGhhdmUgYW55IGVmZmVjdCBvbiB0aGUgYGRpc3BhdGNoKClgIHRoYXQgaXMgY3VycmVudGx5IGluIHByb2dyZXNzLlxuICAgKiBIb3dldmVyLCB0aGUgbmV4dCBgZGlzcGF0Y2goKWAgY2FsbCwgd2hldGhlciBuZXN0ZWQgb3Igbm90LCB3aWxsIHVzZSBhIG1vcmVcbiAgICogcmVjZW50IHNuYXBzaG90IG9mIHRoZSBzdWJzY3JpcHRpb24gbGlzdC5cbiAgICpcbiAgICogMi4gVGhlIGxpc3RlbmVyIHNob3VsZCBub3QgZXhwZWN0IHRvIHNlZSBhbGwgc3RhdGUgY2hhbmdlcywgYXMgdGhlIHN0YXRlXG4gICAqIG1pZ2h0IGhhdmUgYmVlbiB1cGRhdGVkIG11bHRpcGxlIHRpbWVzIGR1cmluZyBhIG5lc3RlZCBgZGlzcGF0Y2goKWAgYmVmb3JlXG4gICAqIHRoZSBsaXN0ZW5lciBpcyBjYWxsZWQuIEl0IGlzLCBob3dldmVyLCBndWFyYW50ZWVkIHRoYXQgYWxsIHN1YnNjcmliZXJzXG4gICAqIHJlZ2lzdGVyZWQgYmVmb3JlIHRoZSBgZGlzcGF0Y2goKWAgc3RhcnRlZCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBsYXRlc3RcbiAgICogc3RhdGUgYnkgdGhlIHRpbWUgaXQgZXhpdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIEEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBvbiBldmVyeSBkaXNwYXRjaC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRvIHJlbW92ZSB0aGlzIGNoYW5nZSBsaXN0ZW5lci5cbiAgICovXG4gIGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgaXNTdWJzY3JpYmVkID0gdHJ1ZTtcblxuICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICBuZXh0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgaWYgKCFpc1N1YnNjcmliZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcblxuICAgICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgICAgdmFyIGluZGV4ID0gbmV4dExpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgIG5leHRMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYW4gYWN0aW9uLiBJdCBpcyB0aGUgb25seSB3YXkgdG8gdHJpZ2dlciBhIHN0YXRlIGNoYW5nZS5cbiAgICpcbiAgICogVGhlIGByZWR1Y2VyYCBmdW5jdGlvbiwgdXNlZCB0byBjcmVhdGUgdGhlIHN0b3JlLCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZVxuICAgKiBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBnaXZlbiBgYWN0aW9uYC4gSXRzIHJldHVybiB2YWx1ZSB3aWxsXG4gICAqIGJlIGNvbnNpZGVyZWQgdGhlICoqbmV4dCoqIHN0YXRlIG9mIHRoZSB0cmVlLCBhbmQgdGhlIGNoYW5nZSBsaXN0ZW5lcnNcbiAgICogd2lsbCBiZSBub3RpZmllZC5cbiAgICpcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBwbGFpbiBvYmplY3QgYWN0aW9ucy4gSWYgeW91IHdhbnQgdG9cbiAgICogZGlzcGF0Y2ggYSBQcm9taXNlLCBhbiBPYnNlcnZhYmxlLCBhIHRodW5rLCBvciBzb21ldGhpbmcgZWxzZSwgeW91IG5lZWQgdG9cbiAgICogd3JhcCB5b3VyIHN0b3JlIGNyZWF0aW5nIGZ1bmN0aW9uIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgbWlkZGxld2FyZS4gRm9yXG4gICAqIGV4YW1wbGUsIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIGByZWR1eC10aHVua2AgcGFja2FnZS4gRXZlbiB0aGVcbiAgICogbWlkZGxld2FyZSB3aWxsIGV2ZW50dWFsbHkgZGlzcGF0Y2ggcGxhaW4gb2JqZWN0IGFjdGlvbnMgdXNpbmcgdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gQSBwbGFpbiBvYmplY3QgcmVwcmVzZW50aW5nIOKAnHdoYXQgY2hhbmdlZOKAnS4gSXQgaXNcbiAgICogYSBnb29kIGlkZWEgdG8ga2VlcCBhY3Rpb25zIHNlcmlhbGl6YWJsZSBzbyB5b3UgY2FuIHJlY29yZCBhbmQgcmVwbGF5IHVzZXJcbiAgICogc2Vzc2lvbnMsIG9yIHVzZSB0aGUgdGltZSB0cmF2ZWxsaW5nIGByZWR1eC1kZXZ0b29sc2AuIEFuIGFjdGlvbiBtdXN0IGhhdmVcbiAgICogYSBgdHlwZWAgcHJvcGVydHkgd2hpY2ggbWF5IG5vdCBiZSBgdW5kZWZpbmVkYC4gSXQgaXMgYSBnb29kIGlkZWEgdG8gdXNlXG4gICAqIHN0cmluZyBjb25zdGFudHMgZm9yIGFjdGlvbiB0eXBlcy5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gRm9yIGNvbnZlbmllbmNlLCB0aGUgc2FtZSBhY3Rpb24gb2JqZWN0IHlvdSBkaXNwYXRjaGVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQsIGlmIHlvdSB1c2UgYSBjdXN0b20gbWlkZGxld2FyZSwgaXQgbWF5IHdyYXAgYGRpc3BhdGNoKClgIHRvXG4gICAqIHJldHVybiBzb21ldGhpbmcgZWxzZSAoZm9yIGV4YW1wbGUsIGEgUHJvbWlzZSB5b3UgY2FuIGF3YWl0KS5cbiAgICovXG4gIGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbXVzdCBiZSBwbGFpbiBvYmplY3RzLiAnICsgJ1VzZSBjdXN0b20gbWlkZGxld2FyZSBmb3IgYXN5bmMgYWN0aW9ucy4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGFjdGlvbi50eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb25zIG1heSBub3QgaGF2ZSBhbiB1bmRlZmluZWQgXCJ0eXBlXCIgcHJvcGVydHkuICcgKyAnSGF2ZSB5b3UgbWlzc3BlbGxlZCBhIGNvbnN0YW50PycpO1xuICAgIH1cblxuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXJzIG1heSBub3QgZGlzcGF0Y2ggYWN0aW9ucy4nKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IHRydWU7XG4gICAgICBjdXJyZW50U3RhdGUgPSBjdXJyZW50UmVkdWNlcihjdXJyZW50U3RhdGUsIGFjdGlvbik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycyA9IG5leHRMaXN0ZW5lcnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgcmVkdWNlciBjdXJyZW50bHkgdXNlZCBieSB0aGUgc3RvcmUgdG8gY2FsY3VsYXRlIHRoZSBzdGF0ZS5cbiAgICpcbiAgICogWW91IG1pZ2h0IG5lZWQgdGhpcyBpZiB5b3VyIGFwcCBpbXBsZW1lbnRzIGNvZGUgc3BsaXR0aW5nIGFuZCB5b3Ugd2FudCB0b1xuICAgKiBsb2FkIHNvbWUgb2YgdGhlIHJlZHVjZXJzIGR5bmFtaWNhbGx5LiBZb3UgbWlnaHQgYWxzbyBuZWVkIHRoaXMgaWYgeW91XG4gICAqIGltcGxlbWVudCBhIGhvdCByZWxvYWRpbmcgbWVjaGFuaXNtIGZvciBSZWR1eC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dFJlZHVjZXIgVGhlIHJlZHVjZXIgZm9yIHRoZSBzdG9yZSB0byB1c2UgaW5zdGVhZC5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmdW5jdGlvbiByZXBsYWNlUmVkdWNlcihuZXh0UmVkdWNlcikge1xuICAgIGlmICh0eXBlb2YgbmV4dFJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIG5leHRSZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgY3VycmVudFJlZHVjZXIgPSBuZXh0UmVkdWNlcjtcbiAgICBkaXNwYXRjaCh7IHR5cGU6IEFjdGlvblR5cGVzLklOSVQgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJvcGVyYWJpbGl0eSBwb2ludCBmb3Igb2JzZXJ2YWJsZS9yZWFjdGl2ZSBsaWJyYXJpZXMuXG4gICAqIEByZXR1cm5zIHtvYnNlcnZhYmxlfSBBIG1pbmltYWwgb2JzZXJ2YWJsZSBvZiBzdGF0ZSBjaGFuZ2VzLlxuICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZSBvYnNlcnZhYmxlIHByb3Bvc2FsOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYnNlcnZhYmxlXG4gICAqL1xuICBmdW5jdGlvbiBvYnNlcnZhYmxlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIG91dGVyU3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgIHJldHVybiBfcmVmID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbWluaW1hbCBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBtZXRob2QuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JzZXJ2ZXIgQW55IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIG9ic2VydmVyLlxuICAgICAgICogVGhlIG9ic2VydmVyIG9iamVjdCBzaG91bGQgaGF2ZSBhIGBuZXh0YCBtZXRob2QuXG4gICAgICAgKiBAcmV0dXJucyB7c3Vic2NyaXB0aW9ufSBBbiBvYmplY3Qgd2l0aCBhbiBgdW5zdWJzY3JpYmVgIG1ldGhvZCB0aGF0IGNhblxuICAgICAgICogYmUgdXNlZCB0byB1bnN1YnNjcmliZSB0aGUgb2JzZXJ2YWJsZSBmcm9tIHRoZSBzdG9yZSwgYW5kIHByZXZlbnQgZnVydGhlclxuICAgICAgICogZW1pc3Npb24gb2YgdmFsdWVzIGZyb20gdGhlIG9ic2VydmFibGUuXG4gICAgICAgKi9cbiAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXIgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdGhlIG9ic2VydmVyIHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9ic2VydmVTdGF0ZSgpIHtcbiAgICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChnZXRTdGF0ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZlU3RhdGUoKTtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gb3V0ZXJTdWJzY3JpYmUob2JzZXJ2ZVN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHsgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlIH07XG4gICAgICB9XG4gICAgfSwgX3JlZlskJG9ic2VydmFibGVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgX3JlZjtcbiAgfVxuXG4gIC8vIFdoZW4gYSBzdG9yZSBpcyBjcmVhdGVkLCBhbiBcIklOSVRcIiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCBzbyB0aGF0IGV2ZXJ5XG4gIC8vIHJlZHVjZXIgcmV0dXJucyB0aGVpciBpbml0aWFsIHN0YXRlLiBUaGlzIGVmZmVjdGl2ZWx5IHBvcHVsYXRlc1xuICAvLyB0aGUgaW5pdGlhbCBzdGF0ZSB0cmVlLlxuICBkaXNwYXRjaCh7IHR5cGU6IEFjdGlvblR5cGVzLklOSVQgfSk7XG5cbiAgcmV0dXJuIF9yZWYyID0ge1xuICAgIGRpc3BhdGNoOiBkaXNwYXRjaCxcbiAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcbiAgICBnZXRTdGF0ZTogZ2V0U3RhdGUsXG4gICAgcmVwbGFjZVJlZHVjZXI6IHJlcGxhY2VSZWR1Y2VyXG4gIH0sIF9yZWYyWyQkb2JzZXJ2YWJsZV0gPSBvYnNlcnZhYmxlLCBfcmVmMjtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVkdXgvZXMvY3JlYXRlU3RvcmUuanMiLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bWJvbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N5bWJvbC5qcyIsIi8qKlxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IGlmIHlvdSBlbmFibGVcbiAgICAvLyBcImJyZWFrIG9uIGFsbCBleGNlcHRpb25zXCIgaW4geW91ciBjb25zb2xlLFxuICAgIC8vIGl0IHdvdWxkIHBhdXNlIHRoZSBleGVjdXRpb24gYXQgdGhpcyBsaW5lLlxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuICB9IGNhdGNoIChlKSB7fVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWVtcHR5ICovXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlZHV4L2VzL3V0aWxzL3dhcm5pbmcuanMiLCIvKipcbiAqIENvbXBvc2VzIHNpbmdsZS1hcmd1bWVudCBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LiBUaGUgcmlnaHRtb3N0XG4gKiBmdW5jdGlvbiBjYW4gdGFrZSBtdWx0aXBsZSBhcmd1bWVudHMgYXMgaXQgcHJvdmlkZXMgdGhlIHNpZ25hdHVyZSBmb3JcbiAqIHRoZSByZXN1bHRpbmcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGZ1bmNzIFRoZSBmdW5jdGlvbnMgdG8gY29tcG9zZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiBvYnRhaW5lZCBieSBjb21wb3NpbmcgdGhlIGFyZ3VtZW50IGZ1bmN0aW9uc1xuICogZnJvbSByaWdodCB0byBsZWZ0LiBGb3IgZXhhbXBsZSwgY29tcG9zZShmLCBnLCBoKSBpcyBpZGVudGljYWwgdG8gZG9pbmdcbiAqICguLi5hcmdzKSA9PiBmKGcoaCguLi5hcmdzKSkpLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGZ1bmNzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH07XG4gIH1cblxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZ1bmNzWzBdO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmNzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYShiLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfSk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2NvbXBvc2UuanMiLCJpbXBvcnQgdmVyaWZ5UGxhaW5PYmplY3QgZnJvbSAnLi4vdXRpbHMvdmVyaWZ5UGxhaW5PYmplY3QnO1xuXG5leHBvcnQgZnVuY3Rpb24gd3JhcE1hcFRvUHJvcHNDb25zdGFudChnZXRDb25zdGFudCkge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdENvbnN0YW50U2VsZWN0b3IoZGlzcGF0Y2gsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29uc3RhbnQgPSBnZXRDb25zdGFudChkaXNwYXRjaCwgb3B0aW9ucyk7XG5cbiAgICBmdW5jdGlvbiBjb25zdGFudFNlbGVjdG9yKCkge1xuICAgICAgcmV0dXJuIGNvbnN0YW50O1xuICAgIH1cbiAgICBjb25zdGFudFNlbGVjdG9yLmRlcGVuZHNPbk93blByb3BzID0gZmFsc2U7XG4gICAgcmV0dXJuIGNvbnN0YW50U2VsZWN0b3I7XG4gIH07XG59XG5cbi8vIGRlcGVuZHNPbk93blByb3BzIGlzIHVzZWQgYnkgY3JlYXRlTWFwVG9Qcm9wc1Byb3h5IHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHBhc3MgcHJvcHMgYXMgYXJnc1xuLy8gdG8gdGhlIG1hcFRvUHJvcHMgZnVuY3Rpb24gYmVpbmcgd3JhcHBlZC4gSXQgaXMgYWxzbyB1c2VkIGJ5IG1ha2VQdXJlUHJvcHNTZWxlY3RvciB0byBkZXRlcm1pbmVcbi8vIHdoZXRoZXIgbWFwVG9Qcm9wcyBuZWVkcyB0byBiZSBpbnZva2VkIHdoZW4gcHJvcHMgaGF2ZSBjaGFuZ2VkLlxuLy8gXG4vLyBBIGxlbmd0aCBvZiBvbmUgc2lnbmFscyB0aGF0IG1hcFRvUHJvcHMgZG9lcyBub3QgZGVwZW5kIG9uIHByb3BzIGZyb20gdGhlIHBhcmVudCBjb21wb25lbnQuXG4vLyBBIGxlbmd0aCBvZiB6ZXJvIGlzIGFzc3VtZWQgdG8gbWVhbiBtYXBUb1Byb3BzIGlzIGdldHRpbmcgYXJncyB2aWEgYXJndW1lbnRzIG9yIC4uLmFyZ3MgYW5kXG4vLyB0aGVyZWZvcmUgbm90IHJlcG9ydGluZyBpdHMgbGVuZ3RoIGFjY3VyYXRlbHkuLlxuZXhwb3J0IGZ1bmN0aW9uIGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpIHtcbiAgcmV0dXJuIG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMgIT09IG51bGwgJiYgbWFwVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcyAhPT0gdW5kZWZpbmVkID8gQm9vbGVhbihtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKSA6IG1hcFRvUHJvcHMubGVuZ3RoICE9PSAxO1xufVxuXG4vLyBVc2VkIGJ5IHdoZW5NYXBTdGF0ZVRvUHJvcHNJc0Z1bmN0aW9uIGFuZCB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNGdW5jdGlvbixcbi8vIHRoaXMgZnVuY3Rpb24gd3JhcHMgbWFwVG9Qcm9wcyBpbiBhIHByb3h5IGZ1bmN0aW9uIHdoaWNoIGRvZXMgc2V2ZXJhbCB0aGluZ3M6XG4vLyBcbi8vICAqIERldGVjdHMgd2hldGhlciB0aGUgbWFwVG9Qcm9wcyBmdW5jdGlvbiBiZWluZyBjYWxsZWQgZGVwZW5kcyBvbiBwcm9wcywgd2hpY2hcbi8vICAgIGlzIHVzZWQgYnkgc2VsZWN0b3JGYWN0b3J5IHRvIGRlY2lkZSBpZiBpdCBzaG91bGQgcmVpbnZva2Ugb24gcHJvcHMgY2hhbmdlcy5cbi8vICAgIFxuLy8gICogT24gZmlyc3QgY2FsbCwgaGFuZGxlcyBtYXBUb1Byb3BzIGlmIHJldHVybnMgYW5vdGhlciBmdW5jdGlvbiwgYW5kIHRyZWF0cyB0aGF0XG4vLyAgICBuZXcgZnVuY3Rpb24gYXMgdGhlIHRydWUgbWFwVG9Qcm9wcyBmb3Igc3Vic2VxdWVudCBjYWxscy5cbi8vICAgIFxuLy8gICogT24gZmlyc3QgY2FsbCwgdmVyaWZpZXMgdGhlIGZpcnN0IHJlc3VsdCBpcyBhIHBsYWluIG9iamVjdCwgaW4gb3JkZXIgdG8gd2FyblxuLy8gICAgdGhlIGRldmVsb3BlciB0aGF0IHRoZWlyIG1hcFRvUHJvcHMgZnVuY3Rpb24gaXMgbm90IHJldHVybmluZyBhIHZhbGlkIHJlc3VsdC5cbi8vICAgIFxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBUb1Byb3BzLCBtZXRob2ROYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0UHJveHlTZWxlY3RvcihkaXNwYXRjaCwgX3JlZikge1xuICAgIHZhciBkaXNwbGF5TmFtZSA9IF9yZWYuZGlzcGxheU5hbWU7XG5cbiAgICB2YXIgcHJveHkgPSBmdW5jdGlvbiBtYXBUb1Byb3BzUHJveHkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykge1xuICAgICAgcmV0dXJuIHByb3h5LmRlcGVuZHNPbk93blByb3BzID8gcHJveHkubWFwVG9Qcm9wcyhzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSA6IHByb3h5Lm1hcFRvUHJvcHMoc3RhdGVPckRpc3BhdGNoKTtcbiAgICB9O1xuXG4gICAgLy8gYWxsb3cgZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeSB0byBnZXQgb3duUHJvcHNcbiAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IHRydWU7XG5cbiAgICBwcm94eS5tYXBUb1Byb3BzID0gZnVuY3Rpb24gZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSB7XG4gICAgICBwcm94eS5tYXBUb1Byb3BzID0gbWFwVG9Qcm9wcztcbiAgICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHMobWFwVG9Qcm9wcyk7XG4gICAgICB2YXIgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcblxuICAgICAgaWYgKHR5cGVvZiBwcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm94eS5tYXBUb1Byb3BzID0gcHJvcHM7XG4gICAgICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHMocHJvcHMpO1xuICAgICAgICBwcm9wcyA9IHByb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgdmVyaWZ5UGxhaW5PYmplY3QocHJvcHMsIGRpc3BsYXlOYW1lLCBtZXRob2ROYW1lKTtcblxuICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH07XG5cbiAgICByZXR1cm4gcHJveHk7XG4gIH07XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3Qvd3JhcE1hcFRvUHJvcHMuanMiLCJpbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICdsb2Rhc2gtZXMvaXNQbGFpbk9iamVjdCc7XG5pbXBvcnQgd2FybmluZyBmcm9tICcuL3dhcm5pbmcnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2ZXJpZnlQbGFpbk9iamVjdCh2YWx1ZSwgZGlzcGxheU5hbWUsIG1ldGhvZE5hbWUpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHdhcm5pbmcobWV0aG9kTmFtZSArICcoKSBpbiAnICsgZGlzcGxheU5hbWUgKyAnIG11c3QgcmV0dXJuIGEgcGxhaW4gb2JqZWN0LiBJbnN0ZWFkIHJlY2VpdmVkICcgKyB2YWx1ZSArICcuJyk7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvdmVyaWZ5UGxhaW5PYmplY3QuanMiLCJleHBvcnQgY29uc3QgU0VUX0NPVU5URVIgPSAnU0VUX0NPVU5URVInXG5leHBvcnQgY29uc3QgSU5DUkVNRU5UX0NPVU5URVIgPSAnSU5DUkVNRU5UX0NPVU5URVInXG5leHBvcnQgY29uc3QgREVDUkVNRU5UX0NPVU5URVIgPSAnREVDUkVNRU5UX0NPVU5URVInXG5cbmV4cG9ydCBjb25zdCBzZXQgPSAodmFsdWUpID0+IHtcbiAgdHlwZTogU0VUX0NPVU5URVIsXG4gIHZhbHVlXG59XG5cbmV4cG9ydCBjb25zdCBpbmNyZW1lbnQgPSAoKSA9PiB7XG4gIHR5cGU6IElOQ1JFTUVOVF9DT1VOVEVSXG59XG5cbmV4cG9ydCBjb25zdCBkZWNyZW1lbnQgPSAoKSA9PiB7XG4gIHR5cGU6IERFQ1JFTUVOVF9DT1VOVEVSXG59XG5cbmV4cG9ydCBjb25zdCBpbmNyZW1lbnRJZk9kZCA9ICgpID0+IChkaXNwYXRjaCwgZ2V0U3RhdGUpID0+IHtcbiAgY29uc3QgeyBjb3VudGVyIH0gPSBnZXRTdGF0ZSgpXG5cbiAgaWYgKGNvdW50ZXIgJSAyID09PSAwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBkaXNwYXRjaChpbmNyZW1lbnQoKSlcbn1cblxuZXhwb3J0IGNvbnN0IGluY3JlbWVudEFzeW5jID0gKGRlbGF5ID0gMTAwMCkgPT4gZGlzcGF0Y2ggPT4ge1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBkaXNwYXRjaChpbmNyZW1lbnQoKSlcbiAgfSwgZGVsYXkpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21tb24vYWN0aW9ucy9pbmRleC5qcyIsIi8qZXNsaW50LWVudiBicm93c2VyKi9cbi8qZ2xvYmFsIF9fcmVzb3VyY2VRdWVyeSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyovXG5cbnZhciBvcHRpb25zID0ge1xuICBwYXRoOiBcIi9fX3dlYnBhY2tfaG1yXCIsXG4gIHRpbWVvdXQ6IDIwICogMTAwMCxcbiAgb3ZlcmxheTogdHJ1ZSxcbiAgcmVsb2FkOiBmYWxzZSxcbiAgbG9nOiB0cnVlLFxuICB3YXJuOiB0cnVlLFxuICBuYW1lOiAnJ1xufTtcbmlmIChfX3Jlc291cmNlUXVlcnkpIHtcbiAgdmFyIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcbiAgdmFyIG92ZXJyaWRlcyA9IHF1ZXJ5c3RyaW5nLnBhcnNlKF9fcmVzb3VyY2VRdWVyeS5zbGljZSgxKSk7XG4gIGlmIChvdmVycmlkZXMucGF0aCkgb3B0aW9ucy5wYXRoID0gb3ZlcnJpZGVzLnBhdGg7XG4gIGlmIChvdmVycmlkZXMudGltZW91dCkgb3B0aW9ucy50aW1lb3V0ID0gb3ZlcnJpZGVzLnRpbWVvdXQ7XG4gIGlmIChvdmVycmlkZXMub3ZlcmxheSkgb3B0aW9ucy5vdmVybGF5ID0gb3ZlcnJpZGVzLm92ZXJsYXkgIT09ICdmYWxzZSc7XG4gIGlmIChvdmVycmlkZXMucmVsb2FkKSBvcHRpb25zLnJlbG9hZCA9IG92ZXJyaWRlcy5yZWxvYWQgIT09ICdmYWxzZSc7XG4gIGlmIChvdmVycmlkZXMubm9JbmZvICYmIG92ZXJyaWRlcy5ub0luZm8gIT09ICdmYWxzZScpIHtcbiAgICBvcHRpb25zLmxvZyA9IGZhbHNlO1xuICB9XG4gIGlmIChvdmVycmlkZXMubmFtZSkge1xuICAgIG9wdGlvbnMubmFtZSA9IG92ZXJyaWRlcy5uYW1lO1xuICB9XG4gIGlmIChvdmVycmlkZXMucXVpZXQgJiYgb3ZlcnJpZGVzLnF1aWV0ICE9PSAnZmFsc2UnKSB7XG4gICAgb3B0aW9ucy5sb2cgPSBmYWxzZTtcbiAgICBvcHRpb25zLndhcm4gPSBmYWxzZTtcbiAgfVxuICBpZiAob3ZlcnJpZGVzLmR5bmFtaWNQdWJsaWNQYXRoKSB7XG4gICAgb3B0aW9ucy5wYXRoID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBvcHRpb25zLnBhdGg7XG4gIH1cbn1cblxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIGRvIG5vdGhpbmdcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdy5FdmVudFNvdXJjZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgY29uc29sZS53YXJuKFxuICAgIFwid2VicGFjay1ob3QtbWlkZGxld2FyZSdzIGNsaWVudCByZXF1aXJlcyBFdmVudFNvdXJjZSB0byB3b3JrLiBcIiArXG4gICAgXCJZb3Ugc2hvdWxkIGluY2x1ZGUgYSBwb2x5ZmlsbCBpZiB5b3Ugd2FudCB0byBzdXBwb3J0IHRoaXMgYnJvd3NlcjogXCIgK1xuICAgIFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZlci1zZW50X2V2ZW50cyNUb29sc1wiXG4gICk7XG59IGVsc2Uge1xuICBjb25uZWN0KCk7XG59XG5cbmZ1bmN0aW9uIEV2ZW50U291cmNlV3JhcHBlcigpIHtcbiAgdmFyIHNvdXJjZTtcbiAgdmFyIGxhc3RBY3Rpdml0eSA9IG5ldyBEYXRlKCk7XG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcblxuICBpbml0KCk7XG4gIHZhciB0aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgIGlmICgobmV3IERhdGUoKSAtIGxhc3RBY3Rpdml0eSkgPiBvcHRpb25zLnRpbWVvdXQpIHtcbiAgICAgIGhhbmRsZURpc2Nvbm5lY3QoKTtcbiAgICB9XG4gIH0sIG9wdGlvbnMudGltZW91dCAvIDIpO1xuXG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgc291cmNlID0gbmV3IHdpbmRvdy5FdmVudFNvdXJjZShvcHRpb25zLnBhdGgpO1xuICAgIHNvdXJjZS5vbm9wZW4gPSBoYW5kbGVPbmxpbmU7XG4gICAgc291cmNlLm9uZXJyb3IgPSBoYW5kbGVEaXNjb25uZWN0O1xuICAgIHNvdXJjZS5vbm1lc3NhZ2UgPSBoYW5kbGVNZXNzYWdlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlT25saW5lKCkge1xuICAgIGlmIChvcHRpb25zLmxvZykgY29uc29sZS5sb2coXCJbSE1SXSBjb25uZWN0ZWRcIik7XG4gICAgbGFzdEFjdGl2aXR5ID0gbmV3IERhdGUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UoZXZlbnQpIHtcbiAgICBsYXN0QWN0aXZpdHkgPSBuZXcgRGF0ZSgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0oZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZURpc2Nvbm5lY3QoKSB7XG4gICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgc291cmNlLmNsb3NlKCk7XG4gICAgc2V0VGltZW91dChpbml0LCBvcHRpb25zLnRpbWVvdXQpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhZGRNZXNzYWdlTGlzdGVuZXI6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICBsaXN0ZW5lcnMucHVzaChmbik7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudFNvdXJjZVdyYXBwZXIoKSB7XG4gIGlmICghd2luZG93Ll9fd2htRXZlbnRTb3VyY2VXcmFwcGVyKSB7XG4gICAgd2luZG93Ll9fd2htRXZlbnRTb3VyY2VXcmFwcGVyID0ge307XG4gIH1cbiAgaWYgKCF3aW5kb3cuX193aG1FdmVudFNvdXJjZVdyYXBwZXJbb3B0aW9ucy5wYXRoXSkge1xuICAgIC8vIGNhY2hlIHRoZSB3cmFwcGVyIGZvciBvdGhlciBlbnRyaWVzIGxvYWRlZCBvblxuICAgIC8vIHRoZSBzYW1lIHBhZ2Ugd2l0aCB0aGUgc2FtZSBvcHRpb25zLnBhdGhcbiAgICB3aW5kb3cuX193aG1FdmVudFNvdXJjZVdyYXBwZXJbb3B0aW9ucy5wYXRoXSA9IEV2ZW50U291cmNlV3JhcHBlcigpO1xuICB9XG4gIHJldHVybiB3aW5kb3cuX193aG1FdmVudFNvdXJjZVdyYXBwZXJbb3B0aW9ucy5wYXRoXTtcbn1cblxuZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgZ2V0RXZlbnRTb3VyY2VXcmFwcGVyKCkuYWRkTWVzc2FnZUxpc3RlbmVyKGhhbmRsZU1lc3NhZ2UpO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuZGF0YSA9PSBcIlxcdUQ4M0RcXHVEQzkzXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHByb2Nlc3NNZXNzYWdlKEpTT04ucGFyc2UoZXZlbnQuZGF0YSkpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAob3B0aW9ucy53YXJuKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgSE1SIG1lc3NhZ2U6IFwiICsgZXZlbnQuZGF0YSArIFwiXFxuXCIgKyBleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHRoZSByZXBvcnRlciBuZWVkcyB0byBiZSBhIHNpbmdsZXRvbiBvbiB0aGUgcGFnZVxuLy8gaW4gY2FzZSB0aGUgY2xpZW50IGlzIGJlaW5nIHVzZWQgYnkgbXVsdGlwbGUgYnVuZGxlc1xuLy8gd2Ugb25seSB3YW50IHRvIHJlcG9ydCBvbmNlLlxuLy8gYWxsIHRoZSBlcnJvcnMgd2lsbCBnbyB0byBhbGwgY2xpZW50c1xudmFyIHNpbmdsZXRvbktleSA9ICdfX3dlYnBhY2tfaG90X21pZGRsZXdhcmVfcmVwb3J0ZXJfXyc7XG52YXIgcmVwb3J0ZXI7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgaWYgKCF3aW5kb3dbc2luZ2xldG9uS2V5XSkge1xuICAgIHdpbmRvd1tzaW5nbGV0b25LZXldID0gY3JlYXRlUmVwb3J0ZXIoKTtcbiAgfVxuICByZXBvcnRlciA9IHdpbmRvd1tzaW5nbGV0b25LZXldO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSZXBvcnRlcigpIHtcbiAgdmFyIHN0cmlwID0gcmVxdWlyZSgnc3RyaXAtYW5zaScpO1xuXG4gIHZhciBvdmVybGF5O1xuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBvcHRpb25zLm92ZXJsYXkpIHtcbiAgICBvdmVybGF5ID0gcmVxdWlyZSgnLi9jbGllbnQtb3ZlcmxheScpO1xuICB9XG5cbiAgdmFyIHN0eWxlcyA9IHtcbiAgICBlcnJvcnM6IFwiY29sb3I6ICNmZjAwMDA7XCIsXG4gICAgd2FybmluZ3M6IFwiY29sb3I6ICM5OTk5MzM7XCJcbiAgfTtcbiAgdmFyIHByZXZpb3VzUHJvYmxlbXMgPSBudWxsO1xuICBmdW5jdGlvbiBsb2codHlwZSwgb2JqKSB7XG4gICAgdmFyIG5ld1Byb2JsZW1zID0gb2JqW3R5cGVdLm1hcChmdW5jdGlvbihtc2cpIHsgcmV0dXJuIHN0cmlwKG1zZyk7IH0pLmpvaW4oJ1xcbicpO1xuICAgIGlmIChwcmV2aW91c1Byb2JsZW1zID09IG5ld1Byb2JsZW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXZpb3VzUHJvYmxlbXMgPSBuZXdQcm9ibGVtcztcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSBzdHlsZXNbdHlwZV07XG4gICAgdmFyIG5hbWUgPSBvYmoubmFtZSA/IFwiJ1wiICsgb2JqLm5hbWUgKyBcIicgXCIgOiBcIlwiO1xuICAgIHZhciB0aXRsZSA9IFwiW0hNUl0gYnVuZGxlIFwiICsgbmFtZSArIFwiaGFzIFwiICsgb2JqW3R5cGVdLmxlbmd0aCArIFwiIFwiICsgdHlwZTtcbiAgICAvLyBOT1RFOiBjb25zb2xlLndhcm4gb3IgY29uc29sZS5lcnJvciB3aWxsIHByaW50IHRoZSBzdGFjayB0cmFjZVxuICAgIC8vIHdoaWNoIGlzbid0IGhlbHBmdWwgaGVyZSwgc28gdXNpbmcgY29uc29sZS5sb2cgdG8gZXNjYXBlIGl0LlxuICAgIGlmIChjb25zb2xlLmdyb3VwICYmIGNvbnNvbGUuZ3JvdXBFbmQpIHtcbiAgICAgIGNvbnNvbGUuZ3JvdXAoXCIlY1wiICsgdGl0bGUsIHN0eWxlKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiJWNcIiArIG5ld1Byb2JsZW1zLCBzdHlsZSk7XG4gICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBcIiVjXCIgKyB0aXRsZSArIFwiXFxuXFx0JWNcIiArIG5ld1Byb2JsZW1zLnJlcGxhY2UoL1xcbi9nLCBcIlxcblxcdFwiKSxcbiAgICAgICAgc3R5bGUgKyBcImZvbnQtd2VpZ2h0OiBib2xkO1wiLFxuICAgICAgICBzdHlsZSArIFwiZm9udC13ZWlnaHQ6IG5vcm1hbDtcIlxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNsZWFuUHJvYmxlbXNDYWNoZTogZnVuY3Rpb24gKCkge1xuICAgICAgcHJldmlvdXNQcm9ibGVtcyA9IG51bGw7XG4gICAgfSxcbiAgICBwcm9ibGVtczogZnVuY3Rpb24odHlwZSwgb2JqKSB7XG4gICAgICBpZiAob3B0aW9ucy53YXJuKSB7XG4gICAgICAgIGxvZyh0eXBlLCBvYmopO1xuICAgICAgfVxuICAgICAgaWYgKG92ZXJsYXkgJiYgdHlwZSAhPT0gJ3dhcm5pbmdzJykgb3ZlcmxheS5zaG93UHJvYmxlbXModHlwZSwgb2JqW3R5cGVdKTtcbiAgICB9LFxuICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKG92ZXJsYXkpIG92ZXJsYXkuY2xlYXIoKTtcbiAgICB9LFxuICAgIHVzZUN1c3RvbU92ZXJsYXk6IGZ1bmN0aW9uKGN1c3RvbU92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkgPSBjdXN0b21PdmVybGF5O1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHByb2Nlc3NVcGRhdGUgPSByZXF1aXJlKCcuL3Byb2Nlc3MtdXBkYXRlJyk7XG5cbnZhciBjdXN0b21IYW5kbGVyO1xudmFyIHN1YnNjcmliZUFsbEhhbmRsZXI7XG5mdW5jdGlvbiBwcm9jZXNzTWVzc2FnZShvYmopIHtcbiAgc3dpdGNoKG9iai5hY3Rpb24pIHtcbiAgICBjYXNlIFwiYnVpbGRpbmdcIjpcbiAgICAgIGlmIChvcHRpb25zLmxvZykge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBcIltITVJdIGJ1bmRsZSBcIiArIChvYmoubmFtZSA/IFwiJ1wiICsgb2JqLm5hbWUgKyBcIicgXCIgOiBcIlwiKSArXG4gICAgICAgICAgXCJyZWJ1aWxkaW5nXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJidWlsdFwiOlxuICAgICAgaWYgKG9wdGlvbnMubG9nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIFwiW0hNUl0gYnVuZGxlIFwiICsgKG9iai5uYW1lID8gXCInXCIgKyBvYmoubmFtZSArIFwiJyBcIiA6IFwiXCIpICtcbiAgICAgICAgICBcInJlYnVpbHQgaW4gXCIgKyBvYmoudGltZSArIFwibXNcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgY2FzZSBcInN5bmNcIjpcbiAgICAgIGlmIChvYmoubmFtZSAmJiBvcHRpb25zLm5hbWUgJiYgb2JqLm5hbWUgIT09IG9wdGlvbnMubmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAob2JqLmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChyZXBvcnRlcikgcmVwb3J0ZXIucHJvYmxlbXMoJ2Vycm9ycycsIG9iaik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVwb3J0ZXIpIHtcbiAgICAgICAgICBpZiAob2JqLndhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlcG9ydGVyLnByb2JsZW1zKCd3YXJuaW5ncycsIG9iaik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcG9ydGVyLmNsZWFuUHJvYmxlbXNDYWNoZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXBvcnRlci5zdWNjZXNzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc1VwZGF0ZShvYmouaGFzaCwgb2JqLm1vZHVsZXMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChjdXN0b21IYW5kbGVyKSB7XG4gICAgICAgIGN1c3RvbUhhbmRsZXIob2JqKTtcbiAgICAgIH1cbiAgfVxuXG4gIGlmIChzdWJzY3JpYmVBbGxIYW5kbGVyKSB7XG4gICAgc3Vic2NyaWJlQWxsSGFuZGxlcihvYmopO1xuICB9XG59XG5cbmlmIChtb2R1bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc3Vic2NyaWJlQWxsOiBmdW5jdGlvbiBzdWJzY3JpYmVBbGwoaGFuZGxlcikge1xuICAgICAgc3Vic2NyaWJlQWxsSGFuZGxlciA9IGhhbmRsZXI7XG4gICAgfSxcbiAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShoYW5kbGVyKSB7XG4gICAgICBjdXN0b21IYW5kbGVyID0gaGFuZGxlcjtcbiAgICB9LFxuICAgIHVzZUN1c3RvbU92ZXJsYXk6IGZ1bmN0aW9uIHVzZUN1c3RvbU92ZXJsYXkoY3VzdG9tT3ZlcmxheSkge1xuICAgICAgaWYgKHJlcG9ydGVyKSByZXBvcnRlci51c2VDdXN0b21PdmVybGF5KGN1c3RvbU92ZXJsYXkpO1xuICAgIH1cbiAgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAod2VicGFjayktaG90LW1pZGRsZXdhcmUvY2xpZW50LmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFuc2lSZWdleCA9IHJlcXVpcmUoJ2Fuc2ktcmVnZXgnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnID8gc3RyLnJlcGxhY2UoYW5zaVJlZ2V4LCAnJykgOiBzdHI7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3N0cmlwLWFuc2kvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIC9bXFx1MDAxYlxcdTAwOWJdW1soKSM7P10qKD86WzAtOV17MSw0fSg/OjtbMC05XXswLDR9KSopP1swLTlBLVBSWmNmLW5xcnk9PjxdL2c7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2Fuc2ktcmVnZXgvaW5kZXguanMiLCIvKmVzbGludC1lbnYgYnJvd3NlciovXG5cbnZhciBjbGllbnRPdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5jbGllbnRPdmVybGF5LmlkID0gJ3dlYnBhY2staG90LW1pZGRsZXdhcmUtY2xpZW50T3ZlcmxheSc7XG52YXIgc3R5bGVzID0ge1xuICBiYWNrZ3JvdW5kOiAncmdiYSgwLDAsMCwwLjg1KScsXG4gIGNvbG9yOiAnI0U4RThFOCcsXG4gIGxpbmVIZWlnaHQ6ICcxLjInLFxuICB3aGl0ZVNwYWNlOiAncHJlJyxcbiAgZm9udEZhbWlseTogJ01lbmxvLCBDb25zb2xhcywgbW9ub3NwYWNlJyxcbiAgZm9udFNpemU6ICcxM3B4JyxcbiAgcG9zaXRpb246ICdmaXhlZCcsXG4gIHpJbmRleDogOTk5OSxcbiAgcGFkZGluZzogJzEwcHgnLFxuICBsZWZ0OiAwLFxuICByaWdodDogMCxcbiAgdG9wOiAwLFxuICBib3R0b206IDAsXG4gIG92ZXJmbG93OiAnYXV0bycsXG4gIGRpcjogJ2x0cicsXG4gIHRleHRBbGlnbjogJ2xlZnQnXG59O1xuZm9yICh2YXIga2V5IGluIHN0eWxlcykge1xuICBjbGllbnRPdmVybGF5LnN0eWxlW2tleV0gPSBzdHlsZXNba2V5XTtcbn1cblxudmFyIGFuc2lIVE1MID0gcmVxdWlyZSgnYW5zaS1odG1sJyk7XG52YXIgY29sb3JzID0ge1xuICByZXNldDogWyd0cmFuc3BhcmVudCcsICd0cmFuc3BhcmVudCddLFxuICBibGFjazogJzE4MTgxOCcsXG4gIHJlZDogJ0UzNjA0OScsXG4gIGdyZWVuOiAnQjNDQjc0JyxcbiAgeWVsbG93OiAnRkZEMDgwJyxcbiAgYmx1ZTogJzdDQUZDMicsXG4gIG1hZ2VudGE6ICc3RkFDQ0EnLFxuICBjeWFuOiAnQzNDMkVGJyxcbiAgbGlnaHRncmV5OiAnRUJFN0UzJyxcbiAgZGFya2dyZXk6ICc2RDc4OTEnXG59O1xuYW5zaUhUTUwuc2V0Q29sb3JzKGNvbG9ycyk7XG5cbnZhciBFbnRpdGllcyA9IHJlcXVpcmUoJ2h0bWwtZW50aXRpZXMnKS5BbGxIdG1sRW50aXRpZXM7XG52YXIgZW50aXRpZXMgPSBuZXcgRW50aXRpZXMoKTtcblxuZXhwb3J0cy5zaG93UHJvYmxlbXMgPVxuZnVuY3Rpb24gc2hvd1Byb2JsZW1zKHR5cGUsIGxpbmVzKSB7XG4gIGNsaWVudE92ZXJsYXkuaW5uZXJIVE1MID0gJyc7XG4gIGxpbmVzLmZvckVhY2goZnVuY3Rpb24obXNnKSB7XG4gICAgbXNnID0gYW5zaUhUTUwoZW50aXRpZXMuZW5jb2RlKG1zZykpO1xuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuc3R5bGUubWFyZ2luQm90dG9tID0gJzI2cHgnO1xuICAgIGRpdi5pbm5lckhUTUwgPSBwcm9ibGVtVHlwZSh0eXBlKSArICcgaW4gJyArIG1zZztcbiAgICBjbGllbnRPdmVybGF5LmFwcGVuZENoaWxkKGRpdik7XG4gIH0pO1xuICBpZiAoZG9jdW1lbnQuYm9keSkge1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2xpZW50T3ZlcmxheSk7XG4gIH1cbn07XG5cbmV4cG9ydHMuY2xlYXIgPVxuZnVuY3Rpb24gY2xlYXIoKSB7XG4gIGlmIChkb2N1bWVudC5ib2R5ICYmIGNsaWVudE92ZXJsYXkucGFyZW50Tm9kZSkge1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoY2xpZW50T3ZlcmxheSk7XG4gIH1cbn07XG5cbnZhciBwcm9ibGVtQ29sb3JzID0ge1xuICBlcnJvcnM6IGNvbG9ycy5yZWQsXG4gIHdhcm5pbmdzOiBjb2xvcnMueWVsbG93XG59O1xuXG5mdW5jdGlvbiBwcm9ibGVtVHlwZSAodHlwZSkge1xuICB2YXIgY29sb3IgPSBwcm9ibGVtQ29sb3JzW3R5cGVdIHx8IGNvbG9ycy5yZWQ7XG4gIHJldHVybiAoXG4gICAgJzxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjojJyArIGNvbG9yICsgJzsgY29sb3I6I2ZmZjsgcGFkZGluZzoycHggNHB4OyBib3JkZXItcmFkaXVzOiAycHhcIj4nICtcbiAgICAgIHR5cGUuc2xpY2UoMCwgLTEpLnRvVXBwZXJDYXNlKCkgK1xuICAgICc8L3NwYW4+J1xuICApO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS1ob3QtbWlkZGxld2FyZS9jbGllbnQtb3ZlcmxheS5qcyIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFuc2lIVE1MXG5cbi8vIFJlZmVyZW5jZSB0byBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2Fuc2ktcmVnZXhcbnZhciBfcmVnQU5TSSA9IC8oPzooPzpcXHUwMDFiXFxbKXxcXHUwMDliKSg/Oig/OlswLTldezEsM30pPyg/Oig/OjtbMC05XXswLDN9KSopP1tBLU18Zi1tXSl8XFx1MDAxYltBLU1dL1xuXG52YXIgX2RlZkNvbG9ycyA9IHtcbiAgcmVzZXQ6IFsnZmZmJywgJzAwMCddLCAvLyBbRk9SRUdST1VEX0NPTE9SLCBCQUNLR1JPVU5EX0NPTE9SXVxuICBibGFjazogJzAwMCcsXG4gIHJlZDogJ2ZmMDAwMCcsXG4gIGdyZWVuOiAnMjA5ODA1JyxcbiAgeWVsbG93OiAnZThiZjAzJyxcbiAgYmx1ZTogJzAwMDBmZicsXG4gIG1hZ2VudGE6ICdmZjAwZmYnLFxuICBjeWFuOiAnMDBmZmVlJyxcbiAgbGlnaHRncmV5OiAnZjBmMGYwJyxcbiAgZGFya2dyZXk6ICc4ODgnXG59XG52YXIgX3N0eWxlcyA9IHtcbiAgMzA6ICdibGFjaycsXG4gIDMxOiAncmVkJyxcbiAgMzI6ICdncmVlbicsXG4gIDMzOiAneWVsbG93JyxcbiAgMzQ6ICdibHVlJyxcbiAgMzU6ICdtYWdlbnRhJyxcbiAgMzY6ICdjeWFuJyxcbiAgMzc6ICdsaWdodGdyZXknXG59XG52YXIgX29wZW5UYWdzID0ge1xuICAnMSc6ICdmb250LXdlaWdodDpib2xkJywgLy8gYm9sZFxuICAnMic6ICdvcGFjaXR5OjAuNScsIC8vIGRpbVxuICAnMyc6ICc8aT4nLCAvLyBpdGFsaWNcbiAgJzQnOiAnPHU+JywgLy8gdW5kZXJzY29yZVxuICAnOCc6ICdkaXNwbGF5Om5vbmUnLCAvLyBoaWRkZW5cbiAgJzknOiAnPGRlbD4nIC8vIGRlbGV0ZVxufVxudmFyIF9jbG9zZVRhZ3MgPSB7XG4gICcyMyc6ICc8L2k+JywgLy8gcmVzZXQgaXRhbGljXG4gICcyNCc6ICc8L3U+JywgLy8gcmVzZXQgdW5kZXJzY29yZVxuICAnMjknOiAnPC9kZWw+JyAvLyByZXNldCBkZWxldGVcbn1cblxuO1swLCAyMSwgMjIsIDI3LCAyOCwgMzksIDQ5XS5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gIF9jbG9zZVRhZ3Nbbl0gPSAnPC9zcGFuPidcbn0pXG5cbi8qKlxuICogQ29udmVydHMgdGV4dCB3aXRoIEFOU0kgY29sb3IgY29kZXMgdG8gSFRNTCBtYXJrdXAuXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGFuc2lIVE1MICh0ZXh0KSB7XG4gIC8vIFJldHVybnMgdGhlIHRleHQgaWYgdGhlIHN0cmluZyBoYXMgbm8gQU5TSSBlc2NhcGUgY29kZS5cbiAgaWYgKCFfcmVnQU5TSS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuIHRleHRcbiAgfVxuXG4gIC8vIENhY2hlIG9wZW5lZCBzZXF1ZW5jZS5cbiAgdmFyIGFuc2lDb2RlcyA9IFtdXG4gIC8vIFJlcGxhY2Ugd2l0aCBtYXJrdXAuXG4gIHZhciByZXQgPSB0ZXh0LnJlcGxhY2UoL1xcMDMzXFxbKFxcZCspKm0vZywgZnVuY3Rpb24gKG1hdGNoLCBzZXEpIHtcbiAgICB2YXIgb3QgPSBfb3BlblRhZ3Nbc2VxXVxuICAgIGlmIChvdCkge1xuICAgICAgLy8gSWYgY3VycmVudCBzZXF1ZW5jZSBoYXMgYmVlbiBvcGVuZWQsIGNsb3NlIGl0LlxuICAgICAgaWYgKCEhfmFuc2lDb2Rlcy5pbmRleE9mKHNlcSkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1leHRyYS1ib29sZWFuLWNhc3RcbiAgICAgICAgYW5zaUNvZGVzLnBvcCgpXG4gICAgICAgIHJldHVybiAnPC9zcGFuPidcbiAgICAgIH1cbiAgICAgIC8vIE9wZW4gdGFnLlxuICAgICAgYW5zaUNvZGVzLnB1c2goc2VxKVxuICAgICAgcmV0dXJuIG90WzBdID09PSAnPCcgPyBvdCA6ICc8c3BhbiBzdHlsZT1cIicgKyBvdCArICc7XCI+J1xuICAgIH1cblxuICAgIHZhciBjdCA9IF9jbG9zZVRhZ3Nbc2VxXVxuICAgIGlmIChjdCkge1xuICAgICAgLy8gUG9wIHNlcXVlbmNlXG4gICAgICBhbnNpQ29kZXMucG9wKClcbiAgICAgIHJldHVybiBjdFxuICAgIH1cbiAgICByZXR1cm4gJydcbiAgfSlcblxuICAvLyBNYWtlIHN1cmUgdGFncyBhcmUgY2xvc2VkLlxuICB2YXIgbCA9IGFuc2lDb2Rlcy5sZW5ndGhcbiAgOyhsID4gMCkgJiYgKHJldCArPSBBcnJheShsICsgMSkuam9pbignPC9zcGFuPicpKVxuXG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBDdXN0b21pemUgY29sb3JzLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbG9ycyByZWZlcmVuY2UgdG8gX2RlZkNvbG9yc1xuICovXG5hbnNpSFRNTC5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoY29sb3JzKSB7XG4gIGlmICh0eXBlb2YgY29sb3JzICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignYGNvbG9yc2AgcGFyYW1ldGVyIG11c3QgYmUgYW4gT2JqZWN0LicpXG4gIH1cblxuICB2YXIgX2ZpbmFsQ29sb3JzID0ge31cbiAgZm9yICh2YXIga2V5IGluIF9kZWZDb2xvcnMpIHtcbiAgICB2YXIgaGV4ID0gY29sb3JzLmhhc093blByb3BlcnR5KGtleSkgPyBjb2xvcnNba2V5XSA6IG51bGxcbiAgICBpZiAoIWhleCkge1xuICAgICAgX2ZpbmFsQ29sb3JzW2tleV0gPSBfZGVmQ29sb3JzW2tleV1cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmICgncmVzZXQnID09PSBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICBoZXggPSBbaGV4XVxuICAgICAgfVxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGhleCkgfHwgaGV4Lmxlbmd0aCA9PT0gMCB8fCBoZXguc29tZShmdW5jdGlvbiAoaCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGggIT09ICdzdHJpbmcnXG4gICAgICB9KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB2YWx1ZSBvZiBgJyArIGtleSArICdgIHByb3BlcnR5IG11c3QgYmUgYW4gQXJyYXkgYW5kIGVhY2ggaXRlbSBjb3VsZCBvbmx5IGJlIGEgaGV4IHN0cmluZywgZS5nLjogRkYwMDAwJylcbiAgICAgIH1cbiAgICAgIHZhciBkZWZIZXhDb2xvciA9IF9kZWZDb2xvcnNba2V5XVxuICAgICAgaWYgKCFoZXhbMF0pIHtcbiAgICAgICAgaGV4WzBdID0gZGVmSGV4Q29sb3JbMF1cbiAgICAgIH1cbiAgICAgIGlmIChoZXgubGVuZ3RoID09PSAxIHx8ICFoZXhbMV0pIHtcbiAgICAgICAgaGV4ID0gW2hleFswXV1cbiAgICAgICAgaGV4LnB1c2goZGVmSGV4Q29sb3JbMV0pXG4gICAgICB9XG5cbiAgICAgIGhleCA9IGhleC5zbGljZSgwLCAyKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHZhbHVlIG9mIGAnICsga2V5ICsgJ2AgcHJvcGVydHkgbXVzdCBiZSBhIGhleCBzdHJpbmcsIGUuZy46IEZGMDAwMCcpXG4gICAgfVxuICAgIF9maW5hbENvbG9yc1trZXldID0gaGV4XG4gIH1cbiAgX3NldFRhZ3MoX2ZpbmFsQ29sb3JzKVxufVxuXG4vKipcbiAqIFJlc2V0IGNvbG9ycy5cbiAqL1xuYW5zaUhUTUwucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIF9zZXRUYWdzKF9kZWZDb2xvcnMpXG59XG5cbi8qKlxuICogRXhwb3NlIHRhZ3MsIGluY2x1ZGluZyBvcGVuIGFuZCBjbG9zZS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmFuc2lIVE1MLnRhZ3MgPSB7fVxuXG5pZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhbnNpSFRNTC50YWdzLCAnb3BlbicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9vcGVuVGFncyB9XG4gIH0pXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhbnNpSFRNTC50YWdzLCAnY2xvc2UnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfY2xvc2VUYWdzIH1cbiAgfSlcbn0gZWxzZSB7XG4gIGFuc2lIVE1MLnRhZ3Mub3BlbiA9IF9vcGVuVGFnc1xuICBhbnNpSFRNTC50YWdzLmNsb3NlID0gX2Nsb3NlVGFnc1xufVxuXG5mdW5jdGlvbiBfc2V0VGFncyAoY29sb3JzKSB7XG4gIC8vIHJlc2V0IGFsbFxuICBfb3BlblRhZ3NbJzAnXSA9ICdmb250LXdlaWdodDpub3JtYWw7b3BhY2l0eToxO2NvbG9yOiMnICsgY29sb3JzLnJlc2V0WzBdICsgJztiYWNrZ3JvdW5kOiMnICsgY29sb3JzLnJlc2V0WzFdXG4gIC8vIGludmVyc2VcbiAgX29wZW5UYWdzWyc3J10gPSAnY29sb3I6IycgKyBjb2xvcnMucmVzZXRbMV0gKyAnO2JhY2tncm91bmQ6IycgKyBjb2xvcnMucmVzZXRbMF1cbiAgLy8gZGFyayBncmV5XG4gIF9vcGVuVGFnc1snOTAnXSA9ICdjb2xvcjojJyArIGNvbG9ycy5kYXJrZ3JleVxuXG4gIGZvciAodmFyIGNvZGUgaW4gX3N0eWxlcykge1xuICAgIHZhciBjb2xvciA9IF9zdHlsZXNbY29kZV1cbiAgICB2YXIgb3JpQ29sb3IgPSBjb2xvcnNbY29sb3JdIHx8ICcwMDAnXG4gICAgX29wZW5UYWdzW2NvZGVdID0gJ2NvbG9yOiMnICsgb3JpQ29sb3JcbiAgICBjb2RlID0gcGFyc2VJbnQoY29kZSlcbiAgICBfb3BlblRhZ3NbKGNvZGUgKyAxMCkudG9TdHJpbmcoKV0gPSAnYmFja2dyb3VuZDojJyArIG9yaUNvbG9yXG4gIH1cbn1cblxuYW5zaUhUTUwucmVzZXQoKVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2Fuc2ktaHRtbC9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBYbWxFbnRpdGllczogcmVxdWlyZSgnLi9saWIveG1sLWVudGl0aWVzLmpzJyksXG4gIEh0bWw0RW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL2h0bWw0LWVudGl0aWVzLmpzJyksXG4gIEh0bWw1RW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL2h0bWw1LWVudGl0aWVzLmpzJyksXG4gIEFsbEh0bWxFbnRpdGllczogcmVxdWlyZSgnLi9saWIvaHRtbDUtZW50aXRpZXMuanMnKVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2luZGV4LmpzIiwidmFyIEFMUEhBX0lOREVYID0ge1xuICAgICcmbHQnOiAnPCcsXG4gICAgJyZndCc6ICc+JyxcbiAgICAnJnF1b3QnOiAnXCInLFxuICAgICcmYXBvcyc6ICdcXCcnLFxuICAgICcmYW1wJzogJyYnLFxuICAgICcmbHQ7JzogJzwnLFxuICAgICcmZ3Q7JzogJz4nLFxuICAgICcmcXVvdDsnOiAnXCInLFxuICAgICcmYXBvczsnOiAnXFwnJyxcbiAgICAnJmFtcDsnOiAnJidcbn07XG5cbnZhciBDSEFSX0lOREVYID0ge1xuICAgIDYwOiAnbHQnLFxuICAgIDYyOiAnZ3QnLFxuICAgIDM0OiAncXVvdCcsXG4gICAgMzk6ICdhcG9zJyxcbiAgICAzODogJ2FtcCdcbn07XG5cbnZhciBDSEFSX1NfSU5ERVggPSB7XG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgJ1xcJyc6ICcmYXBvczsnLFxuICAgICcmJzogJyZhbXA7J1xufTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gWG1sRW50aXRpZXMoKSB7fVxuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblhtbEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvPHw+fFwifCd8Ji9nLCBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBDSEFSX1NfSU5ERVhbc107XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBYbWxFbnRpdGllcy5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IFhtbEVudGl0aWVzKCkuZW5jb2RlKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5YbWxFbnRpdGllcy5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYjP1swLTlhLXpBLVpdKzs/L2csIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgaWYgKHMuY2hhckF0KDEpID09PSAnIycpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gcy5jaGFyQXQoMikudG9Mb3dlckNhc2UoKSA9PT0gJ3gnID9cbiAgICAgICAgICAgICAgICBwYXJzZUludChzLnN1YnN0cigzKSwgMTYpIDpcbiAgICAgICAgICAgICAgICBwYXJzZUludChzLnN1YnN0cigyKSk7XG5cbiAgICAgICAgICAgIGlmIChpc05hTihjb2RlKSB8fCBjb2RlIDwgLTMyNzY4IHx8IGNvZGUgPiA2NTUzNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBTFBIQV9JTkRFWFtzXSB8fCBzO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gWG1sRW50aXRpZXMuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmRlY29kZShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuWG1sRW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgYWxwaGEgPSBDSEFSX0lOREVYW2NdO1xuICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA8IDMyIHx8IGMgPiAxMjYpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIFhtbEVudGl0aWVzLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5lbmNvZGVOb25VVEYoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblhtbEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmdodCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmdodCkge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8PSAyNTUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHJbaSsrXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gWG1sRW50aXRpZXMuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IFhtbEVudGl0aWVzKCkuZW5jb2RlTm9uQVNDSUkoc3RyKTtcbiB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhtbEVudGl0aWVzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL3htbC1lbnRpdGllcy5qcyIsInZhciBIVE1MX0FMUEhBID0gWydhcG9zJywgJ25ic3AnLCAnaWV4Y2wnLCAnY2VudCcsICdwb3VuZCcsICdjdXJyZW4nLCAneWVuJywgJ2JydmJhcicsICdzZWN0JywgJ3VtbCcsICdjb3B5JywgJ29yZGYnLCAnbGFxdW8nLCAnbm90JywgJ3NoeScsICdyZWcnLCAnbWFjcicsICdkZWcnLCAncGx1c21uJywgJ3N1cDInLCAnc3VwMycsICdhY3V0ZScsICdtaWNybycsICdwYXJhJywgJ21pZGRvdCcsICdjZWRpbCcsICdzdXAxJywgJ29yZG0nLCAncmFxdW8nLCAnZnJhYzE0JywgJ2ZyYWMxMicsICdmcmFjMzQnLCAnaXF1ZXN0JywgJ0FncmF2ZScsICdBYWN1dGUnLCAnQWNpcmMnLCAnQXRpbGRlJywgJ0F1bWwnLCAnQXJpbmcnLCAnQWVsaWcnLCAnQ2NlZGlsJywgJ0VncmF2ZScsICdFYWN1dGUnLCAnRWNpcmMnLCAnRXVtbCcsICdJZ3JhdmUnLCAnSWFjdXRlJywgJ0ljaXJjJywgJ0l1bWwnLCAnRVRIJywgJ050aWxkZScsICdPZ3JhdmUnLCAnT2FjdXRlJywgJ09jaXJjJywgJ090aWxkZScsICdPdW1sJywgJ3RpbWVzJywgJ09zbGFzaCcsICdVZ3JhdmUnLCAnVWFjdXRlJywgJ1VjaXJjJywgJ1V1bWwnLCAnWWFjdXRlJywgJ1RIT1JOJywgJ3N6bGlnJywgJ2FncmF2ZScsICdhYWN1dGUnLCAnYWNpcmMnLCAnYXRpbGRlJywgJ2F1bWwnLCAnYXJpbmcnLCAnYWVsaWcnLCAnY2NlZGlsJywgJ2VncmF2ZScsICdlYWN1dGUnLCAnZWNpcmMnLCAnZXVtbCcsICdpZ3JhdmUnLCAnaWFjdXRlJywgJ2ljaXJjJywgJ2l1bWwnLCAnZXRoJywgJ250aWxkZScsICdvZ3JhdmUnLCAnb2FjdXRlJywgJ29jaXJjJywgJ290aWxkZScsICdvdW1sJywgJ2RpdmlkZScsICdvc2xhc2gnLCAndWdyYXZlJywgJ3VhY3V0ZScsICd1Y2lyYycsICd1dW1sJywgJ3lhY3V0ZScsICd0aG9ybicsICd5dW1sJywgJ3F1b3QnLCAnYW1wJywgJ2x0JywgJ2d0JywgJ09FbGlnJywgJ29lbGlnJywgJ1NjYXJvbicsICdzY2Fyb24nLCAnWXVtbCcsICdjaXJjJywgJ3RpbGRlJywgJ2Vuc3AnLCAnZW1zcCcsICd0aGluc3AnLCAnenduaicsICd6d2onLCAnbHJtJywgJ3JsbScsICduZGFzaCcsICdtZGFzaCcsICdsc3F1bycsICdyc3F1bycsICdzYnF1bycsICdsZHF1bycsICdyZHF1bycsICdiZHF1bycsICdkYWdnZXInLCAnRGFnZ2VyJywgJ3Blcm1pbCcsICdsc2FxdW8nLCAncnNhcXVvJywgJ2V1cm8nLCAnZm5vZicsICdBbHBoYScsICdCZXRhJywgJ0dhbW1hJywgJ0RlbHRhJywgJ0Vwc2lsb24nLCAnWmV0YScsICdFdGEnLCAnVGhldGEnLCAnSW90YScsICdLYXBwYScsICdMYW1iZGEnLCAnTXUnLCAnTnUnLCAnWGknLCAnT21pY3JvbicsICdQaScsICdSaG8nLCAnU2lnbWEnLCAnVGF1JywgJ1Vwc2lsb24nLCAnUGhpJywgJ0NoaScsICdQc2knLCAnT21lZ2EnLCAnYWxwaGEnLCAnYmV0YScsICdnYW1tYScsICdkZWx0YScsICdlcHNpbG9uJywgJ3pldGEnLCAnZXRhJywgJ3RoZXRhJywgJ2lvdGEnLCAna2FwcGEnLCAnbGFtYmRhJywgJ211JywgJ251JywgJ3hpJywgJ29taWNyb24nLCAncGknLCAncmhvJywgJ3NpZ21hZicsICdzaWdtYScsICd0YXUnLCAndXBzaWxvbicsICdwaGknLCAnY2hpJywgJ3BzaScsICdvbWVnYScsICd0aGV0YXN5bScsICd1cHNpaCcsICdwaXYnLCAnYnVsbCcsICdoZWxsaXAnLCAncHJpbWUnLCAnUHJpbWUnLCAnb2xpbmUnLCAnZnJhc2wnLCAnd2VpZXJwJywgJ2ltYWdlJywgJ3JlYWwnLCAndHJhZGUnLCAnYWxlZnN5bScsICdsYXJyJywgJ3VhcnInLCAncmFycicsICdkYXJyJywgJ2hhcnInLCAnY3JhcnInLCAnbEFycicsICd1QXJyJywgJ3JBcnInLCAnZEFycicsICdoQXJyJywgJ2ZvcmFsbCcsICdwYXJ0JywgJ2V4aXN0JywgJ2VtcHR5JywgJ25hYmxhJywgJ2lzaW4nLCAnbm90aW4nLCAnbmknLCAncHJvZCcsICdzdW0nLCAnbWludXMnLCAnbG93YXN0JywgJ3JhZGljJywgJ3Byb3AnLCAnaW5maW4nLCAnYW5nJywgJ2FuZCcsICdvcicsICdjYXAnLCAnY3VwJywgJ2ludCcsICd0aGVyZTQnLCAnc2ltJywgJ2NvbmcnLCAnYXN5bXAnLCAnbmUnLCAnZXF1aXYnLCAnbGUnLCAnZ2UnLCAnc3ViJywgJ3N1cCcsICduc3ViJywgJ3N1YmUnLCAnc3VwZScsICdvcGx1cycsICdvdGltZXMnLCAncGVycCcsICdzZG90JywgJ2xjZWlsJywgJ3JjZWlsJywgJ2xmbG9vcicsICdyZmxvb3InLCAnbGFuZycsICdyYW5nJywgJ2xveicsICdzcGFkZXMnLCAnY2x1YnMnLCAnaGVhcnRzJywgJ2RpYW1zJ107XG52YXIgSFRNTF9DT0RFUyA9IFszOSwgMTYwLCAxNjEsIDE2MiwgMTYzLCAxNjQsIDE2NSwgMTY2LCAxNjcsIDE2OCwgMTY5LCAxNzAsIDE3MSwgMTcyLCAxNzMsIDE3NCwgMTc1LCAxNzYsIDE3NywgMTc4LCAxNzksIDE4MCwgMTgxLCAxODIsIDE4MywgMTg0LCAxODUsIDE4NiwgMTg3LCAxODgsIDE4OSwgMTkwLCAxOTEsIDE5MiwgMTkzLCAxOTQsIDE5NSwgMTk2LCAxOTcsIDE5OCwgMTk5LCAyMDAsIDIwMSwgMjAyLCAyMDMsIDIwNCwgMjA1LCAyMDYsIDIwNywgMjA4LCAyMDksIDIxMCwgMjExLCAyMTIsIDIxMywgMjE0LCAyMTUsIDIxNiwgMjE3LCAyMTgsIDIxOSwgMjIwLCAyMjEsIDIyMiwgMjIzLCAyMjQsIDIyNSwgMjI2LCAyMjcsIDIyOCwgMjI5LCAyMzAsIDIzMSwgMjMyLCAyMzMsIDIzNCwgMjM1LCAyMzYsIDIzNywgMjM4LCAyMzksIDI0MCwgMjQxLCAyNDIsIDI0MywgMjQ0LCAyNDUsIDI0NiwgMjQ3LCAyNDgsIDI0OSwgMjUwLCAyNTEsIDI1MiwgMjUzLCAyNTQsIDI1NSwgMzQsIDM4LCA2MCwgNjIsIDMzOCwgMzM5LCAzNTIsIDM1MywgMzc2LCA3MTAsIDczMiwgODE5NCwgODE5NSwgODIwMSwgODIwNCwgODIwNSwgODIwNiwgODIwNywgODIxMSwgODIxMiwgODIxNiwgODIxNywgODIxOCwgODIyMCwgODIyMSwgODIyMiwgODIyNCwgODIyNSwgODI0MCwgODI0OSwgODI1MCwgODM2NCwgNDAyLCA5MTMsIDkxNCwgOTE1LCA5MTYsIDkxNywgOTE4LCA5MTksIDkyMCwgOTIxLCA5MjIsIDkyMywgOTI0LCA5MjUsIDkyNiwgOTI3LCA5MjgsIDkyOSwgOTMxLCA5MzIsIDkzMywgOTM0LCA5MzUsIDkzNiwgOTM3LCA5NDUsIDk0NiwgOTQ3LCA5NDgsIDk0OSwgOTUwLCA5NTEsIDk1MiwgOTUzLCA5NTQsIDk1NSwgOTU2LCA5NTcsIDk1OCwgOTU5LCA5NjAsIDk2MSwgOTYyLCA5NjMsIDk2NCwgOTY1LCA5NjYsIDk2NywgOTY4LCA5NjksIDk3NywgOTc4LCA5ODIsIDgyMjYsIDgyMzAsIDgyNDIsIDgyNDMsIDgyNTQsIDgyNjAsIDg0NzIsIDg0NjUsIDg0NzYsIDg0ODIsIDg1MDEsIDg1OTIsIDg1OTMsIDg1OTQsIDg1OTUsIDg1OTYsIDg2MjksIDg2NTYsIDg2NTcsIDg2NTgsIDg2NTksIDg2NjAsIDg3MDQsIDg3MDYsIDg3MDcsIDg3MDksIDg3MTEsIDg3MTIsIDg3MTMsIDg3MTUsIDg3MTksIDg3MjEsIDg3MjIsIDg3MjcsIDg3MzAsIDg3MzMsIDg3MzQsIDg3MzYsIDg3NDMsIDg3NDQsIDg3NDUsIDg3NDYsIDg3NDcsIDg3NTYsIDg3NjQsIDg3NzMsIDg3NzYsIDg4MDAsIDg4MDEsIDg4MDQsIDg4MDUsIDg4MzQsIDg4MzUsIDg4MzYsIDg4MzgsIDg4MzksIDg4NTMsIDg4NTUsIDg4NjksIDg5MDEsIDg5NjgsIDg5NjksIDg5NzAsIDg5NzEsIDkwMDEsIDkwMDIsIDk2NzQsIDk4MjQsIDk4MjcsIDk4MjksIDk4MzBdO1xuXG52YXIgYWxwaGFJbmRleCA9IHt9O1xudmFyIG51bUluZGV4ID0ge307XG5cbnZhciBpID0gMDtcbnZhciBsZW5ndGggPSBIVE1MX0FMUEhBLmxlbmd0aDtcbndoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgdmFyIGEgPSBIVE1MX0FMUEhBW2ldO1xuICAgIHZhciBjID0gSFRNTF9DT0RFU1tpXTtcbiAgICBhbHBoYUluZGV4W2FdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICBudW1JbmRleFtjXSA9IGE7XG4gICAgaSsrO1xufVxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBIdG1sNEVudGl0aWVzKCkge31cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJigjP1tcXHdcXGRdKyk7Py9nLCBmdW5jdGlvbihzLCBlbnRpdHkpIHtcbiAgICAgICAgdmFyIGNocjtcbiAgICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IGVudGl0eS5jaGFyQXQoMSkudG9Mb3dlckNhc2UoKSA9PT0gJ3gnID9cbiAgICAgICAgICAgICAgICBwYXJzZUludChlbnRpdHkuc3Vic3RyKDIpLCAxNikgOlxuICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMSkpO1xuXG4gICAgICAgICAgICBpZiAoIShpc05hTihjb2RlKSB8fCBjb2RlIDwgLTMyNzY4IHx8IGNvZGUgPiA2NTUzNSkpIHtcbiAgICAgICAgICAgICAgICBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hyID0gYWxwaGFJbmRleFtlbnRpdHldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaHIgfHwgcztcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5kZWNvZGUoc3RyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBhbHBoYSA9IG51bUluZGV4W3N0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICAgICAgcmVzdWx0ICs9IGFscGhhID8gXCImXCIgKyBhbHBoYSArIFwiO1wiIDogc3RyLmNoYXJBdChpKTtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmVuY29kZShzdHIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGNjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBhbHBoYSA9IG51bUluZGV4W2NjXTtcbiAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICB9IGVsc2UgaWYgKGNjIDwgMzIgfHwgY2MgPiAxMjYpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiYjXCIgKyBjYyArIFwiO1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmVuY29kZU5vblVURihzdHIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8PSAyNTUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHJbaSsrXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZW5jb2RlTm9uQVNDSUkoc3RyKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSHRtbDRFbnRpdGllcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi9odG1sNC1lbnRpdGllcy5qcyIsIi8qKlxuICogQmFzZWQgaGVhdmlseSBvbiBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrL2Jsb2IvXG4gKiAgYzBhZmRmOWM2YWJjMWRkNzA3MDdjNTk0ZTQ3MzgwMmE1NjZmN2I2ZS9ob3Qvb25seS1kZXYtc2VydmVyLmpzXG4gKiBPcmlnaW5hbCBjb3B5cmlnaHQgVG9iaWFzIEtvcHBlcnMgQHNva3JhIChNSVQgbGljZW5zZSlcbiAqL1xuXG4vKiBnbG9iYWwgd2luZG93IF9fd2VicGFja19oYXNoX18gKi9cblxuaWYgKCFtb2R1bGUuaG90KSB7XG4gIHRocm93IG5ldyBFcnJvcihcIltITVJdIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnQgaXMgZGlzYWJsZWQuXCIpO1xufVxuXG52YXIgaG1yRG9jc1VybCA9IFwiaHR0cDovL3dlYnBhY2suZ2l0aHViLmlvL2RvY3MvaG90LW1vZHVsZS1yZXBsYWNlbWVudC13aXRoLXdlYnBhY2suaHRtbFwiOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW5cblxudmFyIGxhc3RIYXNoO1xudmFyIGZhaWx1cmVTdGF0dXNlcyA9IHsgYWJvcnQ6IDEsIGZhaWw6IDEgfTtcbnZhciBhcHBseU9wdGlvbnMgPSB7IGlnbm9yZVVuYWNjZXB0ZWQ6IHRydWUgfTtcblxuZnVuY3Rpb24gdXBUb0RhdGUoaGFzaCkge1xuICBpZiAoaGFzaCkgbGFzdEhhc2ggPSBoYXNoO1xuICByZXR1cm4gbGFzdEhhc2ggPT0gX193ZWJwYWNrX2hhc2hfXztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihoYXNoLCBtb2R1bGVNYXAsIG9wdGlvbnMpIHtcbiAgdmFyIHJlbG9hZCA9IG9wdGlvbnMucmVsb2FkO1xuICBpZiAoIXVwVG9EYXRlKGhhc2gpICYmIG1vZHVsZS5ob3Quc3RhdHVzKCkgPT0gXCJpZGxlXCIpIHtcbiAgICBpZiAob3B0aW9ucy5sb2cpIGNvbnNvbGUubG9nKFwiW0hNUl0gQ2hlY2tpbmcgZm9yIHVwZGF0ZXMgb24gdGhlIHNlcnZlci4uLlwiKTtcbiAgICBjaGVjaygpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2soKSB7XG4gICAgdmFyIGNiID0gZnVuY3Rpb24oZXJyLCB1cGRhdGVkTW9kdWxlcykge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGhhbmRsZUVycm9yKGVycik7XG5cbiAgICAgIGlmKCF1cGRhdGVkTW9kdWxlcykge1xuICAgICAgICBpZiAob3B0aW9ucy53YXJuKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiW0hNUl0gQ2Fubm90IGZpbmQgdXBkYXRlIChGdWxsIHJlbG9hZCBuZWVkZWQpXCIpO1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIltITVJdIChQcm9iYWJseSBiZWNhdXNlIG9mIHJlc3RhcnRpbmcgdGhlIHNlcnZlcilcIik7XG4gICAgICAgIH1cbiAgICAgICAgcGVyZm9ybVJlbG9hZCgpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGFwcGx5Q2FsbGJhY2sgPSBmdW5jdGlvbihhcHBseUVyciwgcmVuZXdlZE1vZHVsZXMpIHtcbiAgICAgICAgaWYgKGFwcGx5RXJyKSByZXR1cm4gaGFuZGxlRXJyb3IoYXBwbHlFcnIpO1xuXG4gICAgICAgIGlmICghdXBUb0RhdGUoKSkgY2hlY2soKTtcblxuICAgICAgICBsb2dVcGRhdGVzKHVwZGF0ZWRNb2R1bGVzLCByZW5ld2VkTW9kdWxlcyk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgYXBwbHlSZXN1bHQgPSBtb2R1bGUuaG90LmFwcGx5KGFwcGx5T3B0aW9ucywgYXBwbHlDYWxsYmFjayk7XG4gICAgICAvLyB3ZWJwYWNrIDIgcHJvbWlzZVxuICAgICAgaWYgKGFwcGx5UmVzdWx0ICYmIGFwcGx5UmVzdWx0LnRoZW4pIHtcbiAgICAgICAgLy8gSG90TW9kdWxlUmVwbGFjZW1lbnQucnVudGltZS5qcyByZWZlcnMgdG8gdGhlIHJlc3VsdCBhcyBgb3V0ZGF0ZWRNb2R1bGVzYFxuICAgICAgICBhcHBseVJlc3VsdC50aGVuKGZ1bmN0aW9uKG91dGRhdGVkTW9kdWxlcykge1xuICAgICAgICAgIGFwcGx5Q2FsbGJhY2sobnVsbCwgb3V0ZGF0ZWRNb2R1bGVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFwcGx5UmVzdWx0LmNhdGNoKGFwcGx5Q2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgfTtcblxuICAgIHZhciByZXN1bHQgPSBtb2R1bGUuaG90LmNoZWNrKGZhbHNlLCBjYik7XG4gICAgLy8gd2VicGFjayAyIHByb21pc2VcbiAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG4gICAgICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uKHVwZGF0ZWRNb2R1bGVzKSB7XG4gICAgICAgICAgICBjYihudWxsLCB1cGRhdGVkTW9kdWxlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQuY2F0Y2goY2IpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGxvZ1VwZGF0ZXModXBkYXRlZE1vZHVsZXMsIHJlbmV3ZWRNb2R1bGVzKSB7XG4gICAgdmFyIHVuYWNjZXB0ZWRNb2R1bGVzID0gdXBkYXRlZE1vZHVsZXMuZmlsdGVyKGZ1bmN0aW9uKG1vZHVsZUlkKSB7XG4gICAgICByZXR1cm4gcmVuZXdlZE1vZHVsZXMgJiYgcmVuZXdlZE1vZHVsZXMuaW5kZXhPZihtb2R1bGVJZCkgPCAwO1xuICAgIH0pO1xuXG4gICAgaWYodW5hY2NlcHRlZE1vZHVsZXMubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKG9wdGlvbnMud2Fybikge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJbSE1SXSBUaGUgZm9sbG93aW5nIG1vZHVsZXMgY291bGRuJ3QgYmUgaG90IHVwZGF0ZWQ6IFwiICtcbiAgICAgICAgICBcIihGdWxsIHJlbG9hZCBuZWVkZWQpXFxuXCIgK1xuICAgICAgICAgIFwiVGhpcyBpcyB1c3VhbGx5IGJlY2F1c2UgdGhlIG1vZHVsZXMgd2hpY2ggaGF2ZSBjaGFuZ2VkIFwiICtcbiAgICAgICAgICBcIihhbmQgdGhlaXIgcGFyZW50cykgZG8gbm90IGtub3cgaG93IHRvIGhvdCByZWxvYWQgdGhlbXNlbHZlcy4gXCIgK1xuICAgICAgICAgIFwiU2VlIFwiICsgaG1yRG9jc1VybCArIFwiIGZvciBtb3JlIGRldGFpbHMuXCJcbiAgICAgICAgKTtcbiAgICAgICAgdW5hY2NlcHRlZE1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbihtb2R1bGVJZCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIltITVJdICAtIFwiICsgbW9kdWxlTWFwW21vZHVsZUlkXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcGVyZm9ybVJlbG9hZCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmxvZykge1xuICAgICAgaWYoIXJlbmV3ZWRNb2R1bGVzIHx8IHJlbmV3ZWRNb2R1bGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltITVJdIE5vdGhpbmcgaG90IHVwZGF0ZWQuXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJbSE1SXSBVcGRhdGVkIG1vZHVsZXM6XCIpO1xuICAgICAgICByZW5ld2VkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uKG1vZHVsZUlkKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJbSE1SXSAgLSBcIiArIG1vZHVsZU1hcFttb2R1bGVJZF0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHVwVG9EYXRlKCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJbSE1SXSBBcHAgaXMgdXAgdG8gZGF0ZS5cIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyKSB7XG4gICAgaWYgKG1vZHVsZS5ob3Quc3RhdHVzKCkgaW4gZmFpbHVyZVN0YXR1c2VzKSB7XG4gICAgICBpZiAob3B0aW9ucy53YXJuKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIltITVJdIENhbm5vdCBjaGVjayBmb3IgdXBkYXRlIChGdWxsIHJlbG9hZCBuZWVkZWQpXCIpO1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbSE1SXSBcIiArIGVyci5zdGFjayB8fCBlcnIubWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBwZXJmb3JtUmVsb2FkKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcHRpb25zLndhcm4pIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltITVJdIFVwZGF0ZSBjaGVjayBmYWlsZWQ6IFwiICsgZXJyLnN0YWNrIHx8IGVyci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtUmVsb2FkKCkge1xuICAgIGlmIChyZWxvYWQpIHtcbiAgICAgIGlmIChvcHRpb25zLndhcm4pIGNvbnNvbGUud2FybihcIltITVJdIFJlbG9hZGluZyBwYWdlXCIpO1xuICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAod2VicGFjayktaG90LW1pZGRsZXdhcmUvcHJvY2Vzcy11cGRhdGUuanMiLCJpbXBvcnQgJ2JhYmVsLXBvbHlmaWxsJ1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSAncmVhY3QtZG9tJ1xuaW1wb3J0IHsgUHJvdmlkZXIgfSBmcm9tICdyZWFjdC1yZWR1eCdcbmltcG9ydCBjb25maWd1cmVTdG9yZSBmcm9tICcuLi9jb21tb24vc3RvcmUvY29uZmlndXJlU3RvcmUnXG5pbXBvcnQgQXBwIGZyb20gJy4uL2NvbW1vbi9jb250YWluZXJzL0FwcCdcblxuY29uc3QgcHJlbG9hZGVkU3RhdGUgPSB3aW5kb3cuX19QUkVMT0FERURfU1RBVEVfX1xuY29uc3Qgc3RvcmUgPSBjb25maWd1cmVTdG9yZShwcmVsb2FkZWRTdGF0ZSlcbmNvbnN0IHJvb3RFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcCcpXG5cbnJlbmRlcihcbiAgPFByb3ZpZGVyIHN0b3JlPXtzdG9yZX0+XG4gICAgPEFwcC8+XG4gIDwvUHJvdmlkZXI+LFxuICByb290RWxlbWVudFxuKVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY2xpZW50L2luZGV4LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL3NoaW1cIik7XG5cbnJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWVcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL2ZuL3JlZ2V4cC9lc2NhcGVcIik7XG5cbmlmIChnbG9iYWwuX2JhYmVsUG9seWZpbGwpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwib25seSBvbmUgaW5zdGFuY2Ugb2YgYmFiZWwtcG9seWZpbGwgaXMgYWxsb3dlZFwiKTtcbn1cbmdsb2JhbC5fYmFiZWxQb2x5ZmlsbCA9IHRydWU7XG5cbnZhciBERUZJTkVfUFJPUEVSVFkgPSBcImRlZmluZVByb3BlcnR5XCI7XG5mdW5jdGlvbiBkZWZpbmUoTywga2V5LCB2YWx1ZSkge1xuICBPW2tleV0gfHwgT2JqZWN0W0RFRklORV9QUk9QRVJUWV0oTywga2V5LCB7XG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9KTtcbn1cblxuZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIFwicGFkTGVmdFwiLCBcIlwiLnBhZFN0YXJ0KTtcbmRlZmluZShTdHJpbmcucHJvdG90eXBlLCBcInBhZFJpZ2h0XCIsIFwiXCIucGFkRW5kKTtcblxuXCJwb3AscmV2ZXJzZSxzaGlmdCxrZXlzLHZhbHVlcyxlbnRyaWVzLGluZGV4T2YsZXZlcnksc29tZSxmb3JFYWNoLG1hcCxmaWx0ZXIsZmluZCxmaW5kSW5kZXgsaW5jbHVkZXMsam9pbixzbGljZSxjb25jYXQscHVzaCxzcGxpY2UsdW5zaGlmdCxzb3J0LGxhc3RJbmRleE9mLHJlZHVjZSxyZWR1Y2VSaWdodCxjb3B5V2l0aGluLGZpbGxcIi5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFtdW2tleV0gJiYgZGVmaW5lKEFycmF5LCBrZXksIEZ1bmN0aW9uLmNhbGwuYmluZChbXVtrZXldKSk7XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcG9seWZpbGwvbGliL2luZGV4LmpzIiwicmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnNlYWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5iaW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnBhcnNlLWludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hY29zaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmFzaW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYXRhbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jYnJ0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY2x6MzInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jb3NoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguZXhwbTEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5mcm91bmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5oeXBvdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmltdWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cxMCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnNpZ24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5zaW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgudGFuaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnRydW5jJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnJhdycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYmlnJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5ibGluaycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYm9sZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZml4ZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udHNpemUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLml0YWxpY3MnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmxpbmsnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnNtYWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdHJpa2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN1YicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3VwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUubm93Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tanNvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1wcmltaXRpdmUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaXMtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5qb2luJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNvcnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkubWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zb21lJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UtcmlnaHQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkubGFzdC1pbmRleC1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3RvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LndlYWstbWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LndlYWstc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5kYXRhLXZpZXcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDE2LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQxNi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZmxvYXQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuYXBwbHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5kZWxldGUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuaGFzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuaXMtZXh0ZW5zaWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hcnJheS5mbGF0LW1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hcnJheS5mbGF0dGVuJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLXN0YXJ0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtZW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tcmlnaHQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLm1hdGNoLWFsbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LnZhbHVlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLWdldHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLXNldHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLWdldHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLXNldHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXAudG8tanNvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zZXQudG8tanNvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXAub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc2V0Lm9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LndlYWstbWFwLm9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LndlYWstc2V0Lm9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hcC5mcm9tJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnNldC5mcm9tJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LndlYWstbWFwLmZyb20nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcud2Vhay1zZXQuZnJvbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5nbG9iYWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5lcnJvci5pcy1lcnJvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmNsYW1wJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguZGVnLXBlci1yYWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5kZWdyZWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguZnNjYWxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaWFkZGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pc3ViaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmltdWxoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGgucmFkLXBlci1kZWcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5yYWRpYW5zJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguc2NhbGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC51bXVsaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnNpZ25iaXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnByb21pc2UudHJ5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVsZXRlLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLWtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS1rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW93bi1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lm1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFzYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JzZXJ2YWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi50aW1lcnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIuaW1tZWRpYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21vZHVsZXMvX2NvcmUnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL3NoaW0uanMiLCIndXNlIHN0cmljdCc7XG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgTUVUQSA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVk7XG52YXIgJGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIHdrc0RlZmluZSA9IHJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKTtcbnZhciBlbnVtS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBfY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGdPUE5FeHQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKTtcbnZhciAkR09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgJERQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUEQgPSAkR09QRC5mO1xudmFyIGRQID0gJERQLmY7XG52YXIgZ09QTiA9IGdPUE5FeHQuZjtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkSlNPTiA9IGdsb2JhbC5KU09OO1xudmFyIF9zdHJpbmdpZnkgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgSElEREVOID0gd2tzKCdfaGlkZGVuJyk7XG52YXIgVE9fUFJJTUlUSVZFID0gd2tzKCd0b1ByaW1pdGl2ZScpO1xudmFyIGlzRW51bSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT1BTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciBVU0VfTkFUSVZFID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24gKGl0LCBrZXksIEQpIHtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmIChwcm90b0Rlc2MpIGRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYgKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pIGRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZykge1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCkge1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvKSAkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUQuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXMoaXQsIEhJRERFTikpIGRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSBpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHsgZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCkge1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGwgPiBpKSAkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKSB7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICBpdCA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZiAoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSBELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHZhciBuYW1lcyA9IGdPUE4odG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICB2YXIgSVNfT1AgPSBpdCA9PT0gT2JqZWN0UHJvdG87XG4gIHZhciBuYW1lcyA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSkgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8pICRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmIChoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKSB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmIChERVNDUklQVE9SUyAmJiBzZXR0ZXIpIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldCB9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZiAoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSkge1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgU3ltYm9sOiAkU3ltYm9sIH0pO1xuXG5mb3IgKHZhciBlczZTeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGogPSAwOyBlczZTeW1ib2xzLmxlbmd0aCA+IGo7KXdrcyhlczZTeW1ib2xzW2orK10pO1xuXG5mb3IgKHZhciB3ZWxsS25vd25TeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIHdrc0RlZmluZSh3ZWxsS25vd25TeW1ib2xzW2srK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICAgIGZvciAodmFyIGtleSBpbiBTeW1ib2xSZWdpc3RyeSkgaWYgKFN5bWJvbFJlZ2lzdHJ5W2tleV0gPT09IHN5bSkgcmV0dXJuIGtleTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBTID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHsgYTogUyB9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpIHtcbiAgICBpZiAoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpIHJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIHZhciBhcmdzID0gW2l0XTtcbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpICRyZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgIGlmICgkcmVwbGFjZXIgfHwgIWlzQXJyYXkocmVwbGFjZXIpKSByZXBsYWNlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoJHJlcGxhY2VyKSB2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wuanMiLCIvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciByZXN1bHQgPSBnZXRLZXlzKGl0KTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIGlmIChnZXRTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KTtcbiAgICB2YXIgaXNFbnVtID0gcElFLmY7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKHN5bWJvbHMubGVuZ3RoID4gaSkgaWYgKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IGNyZWF0ZTogcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpIH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qcyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHsgZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi4zIC8gMTUuMi4zLjcgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7IGRlZmluZVByb3BlcnRpZXM6IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKSB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qcyIsIi8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSU9iamVjdChpdCksIGtleSk7XG4gIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCIvLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyICRnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRQcm90b3R5cGVPZicsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KSB7XG4gICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2tleXMnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBrZXlzKGl0KSB7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzLmpzIiwiLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlOYW1lcycsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpLmY7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwiLy8gMTkuMS4yLjUgT2JqZWN0LmZyZWV6ZShPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdmcmVlemUnLCBmdW5jdGlvbiAoJGZyZWV6ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gZnJlZXplKGl0KSB7XG4gICAgcmV0dXJuICRmcmVlemUgJiYgaXNPYmplY3QoaXQpID8gJGZyZWV6ZShtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZS5qcyIsIi8vIDE5LjEuMi4xNyBPYmplY3Quc2VhbChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdzZWFsJywgZnVuY3Rpb24gKCRzZWFsKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzZWFsKGl0KSB7XG4gICAgcmV0dXJuICRzZWFsICYmIGlzT2JqZWN0KGl0KSA/ICRzZWFsKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2VhbC5qcyIsIi8vIDE5LjEuMi4xNSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgncHJldmVudEV4dGVuc2lvbnMnLCBmdW5jdGlvbiAoJHByZXZlbnRFeHRlbnNpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyhpdCkge1xuICAgIHJldHVybiAkcHJldmVudEV4dGVuc2lvbnMgJiYgaXNPYmplY3QoaXQpID8gJHByZXZlbnRFeHRlbnNpb25zKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zLmpzIiwiLy8gMTkuMS4yLjEyIE9iamVjdC5pc0Zyb3plbihPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNGcm96ZW4nLCBmdW5jdGlvbiAoJGlzRnJvemVuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpc0Zyb3plbihpdCkge1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNGcm96ZW4gPyAkaXNGcm96ZW4oaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuLmpzIiwiLy8gMTkuMS4yLjEzIE9iamVjdC5pc1NlYWxlZChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNTZWFsZWQnLCBmdW5jdGlvbiAoJGlzU2VhbGVkKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpc1NlYWxlZChpdCkge1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNTZWFsZWQgPyAkaXNTZWFsZWQoaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtc2VhbGVkLmpzIiwiLy8gMTkuMS4yLjExIE9iamVjdC5pc0V4dGVuc2libGUoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzRXh0ZW5zaWJsZScsIGZ1bmN0aW9uICgkaXNFeHRlbnNpYmxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpc0V4dGVuc2libGUoaXQpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUoaXQpIDogdHJ1ZSA6IGZhbHNlO1xuICB9O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZS5qcyIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHsgYXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJykgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwiLy8gMTkuMS4zLjEwIE9iamVjdC5pcyh2YWx1ZTEsIHZhbHVlMilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgaXM6IHJlcXVpcmUoJy4vX3NhbWUtdmFsdWUnKSB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy5qcyIsIi8vIDcuMi45IFNhbWVWYWx1ZSh4LCB5KVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuaXMgfHwgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHJldHVybiB4ID09PSB5ID8geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkgOiB4ICE9IHggJiYgeSAhPSB5O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NhbWUtdmFsdWUuanMiLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0IH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIHRlc3QgPSB7fTtcbnRlc3RbcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyldID0gJ3onO1xuaWYgKHRlc3QgKyAnJyAhPSAnW29iamVjdCB6XScpIHtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XG4gIH0sIHRydWUpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyIsIi8vIDE5LjIuMy4yIC8gMTUuMy40LjUgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQodGhpc0FyZywgYXJncy4uLilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnRnVuY3Rpb24nLCB7IGJpbmQ6IHJlcXVpcmUoJy4vX2JpbmQnKSB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQuanMiLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIEZQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBuYW1lUkUgPSAvXlxccypmdW5jdGlvbiAoW14gKF0qKS87XG52YXIgTkFNRSA9ICduYW1lJztcblxuLy8gMTkuMi40LjIgbmFtZVxuTkFNRSBpbiBGUHJvdG8gfHwgcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiBkUChGUHJvdG8sIE5BTUUsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuICgnJyArIHRoaXMpLm1hdGNoKG5hbWVSRSlbMV07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgSEFTX0lOU1RBTkNFID0gcmVxdWlyZSgnLi9fd2tzJykoJ2hhc0luc3RhbmNlJyk7XG52YXIgRnVuY3Rpb25Qcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIDE5LjIuMy42IEZ1bmN0aW9uLnByb3RvdHlwZVtAQGhhc0luc3RhbmNlXShWKVxuaWYgKCEoSEFTX0lOU1RBTkNFIGluIEZ1bmN0aW9uUHJvdG8pKSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKEZ1bmN0aW9uUHJvdG8sIEhBU19JTlNUQU5DRSwgeyB2YWx1ZTogZnVuY3Rpb24gKE8pIHtcbiAgaWYgKHR5cGVvZiB0aGlzICE9ICdmdW5jdGlvbicgfHwgIWlzT2JqZWN0KE8pKSByZXR1cm4gZmFsc2U7XG4gIGlmICghaXNPYmplY3QodGhpcy5wcm90b3R5cGUpKSByZXR1cm4gTyBpbnN0YW5jZW9mIHRoaXM7XG4gIC8vIGZvciBlbnZpcm9ubWVudCB3L28gbmF0aXZlIGBAQGhhc0luc3RhbmNlYCBsb2dpYyBlbm91Z2ggYGluc3RhbmNlb2ZgLCBidXQgYWRkIHRoaXM6XG4gIHdoaWxlIChPID0gZ2V0UHJvdG90eXBlT2YoTykpIGlmICh0aGlzLnByb3RvdHlwZSA9PT0gTykgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn0gfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5oYXMtaW5zdGFuY2UuanMiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX3BhcnNlLWludCcpO1xuLy8gMTguMi41IHBhcnNlSW50KHN0cmluZywgcmFkaXgpXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuRiAqIChwYXJzZUludCAhPSAkcGFyc2VJbnQpLCB7IHBhcnNlSW50OiAkcGFyc2VJbnQgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1pbnQuanMiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fcGFyc2UtZmxvYXQnKTtcbi8vIDE4LjIuNCBwYXJzZUZsb2F0KHN0cmluZylcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5GICogKHBhcnNlRmxvYXQgIT0gJHBhcnNlRmxvYXQpLCB7IHBhcnNlRmxvYXQ6ICRwYXJzZUZsb2F0IH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucGFyc2UtZmxvYXQuanMiLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciAkdHJpbSA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbTtcbnZhciBOVU1CRVIgPSAnTnVtYmVyJztcbnZhciAkTnVtYmVyID0gZ2xvYmFsW05VTUJFUl07XG52YXIgQmFzZSA9ICROdW1iZXI7XG52YXIgcHJvdG8gPSAkTnVtYmVyLnByb3RvdHlwZTtcbi8vIE9wZXJhIH4xMiBoYXMgYnJva2VuIE9iamVjdCN0b1N0cmluZ1xudmFyIEJST0tFTl9DT0YgPSBjb2YocmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpKHByb3RvKSkgPT0gTlVNQkVSO1xudmFyIFRSSU0gPSAndHJpbScgaW4gU3RyaW5nLnByb3RvdHlwZTtcblxuLy8gNy4xLjMgVG9OdW1iZXIoYXJndW1lbnQpXG52YXIgdG9OdW1iZXIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIGl0ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsIGZhbHNlKTtcbiAgaWYgKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyAmJiBpdC5sZW5ndGggPiAyKSB7XG4gICAgaXQgPSBUUklNID8gaXQudHJpbSgpIDogJHRyaW0oaXQsIDMpO1xuICAgIHZhciBmaXJzdCA9IGl0LmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIHRoaXJkLCByYWRpeCwgbWF4Q29kZTtcbiAgICBpZiAoZmlyc3QgPT09IDQzIHx8IGZpcnN0ID09PSA0NSkge1xuICAgICAgdGhpcmQgPSBpdC5jaGFyQ29kZUF0KDIpO1xuICAgICAgaWYgKHRoaXJkID09PSA4OCB8fCB0aGlyZCA9PT0gMTIwKSByZXR1cm4gTmFOOyAvLyBOdW1iZXIoJysweDEnKSBzaG91bGQgYmUgTmFOLCBvbGQgVjggZml4XG4gICAgfSBlbHNlIGlmIChmaXJzdCA9PT0gNDgpIHtcbiAgICAgIHN3aXRjaCAoaXQuY2hhckNvZGVBdCgxKSkge1xuICAgICAgICBjYXNlIDY2OiBjYXNlIDk4OiByYWRpeCA9IDI7IG1heENvZGUgPSA0OTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wYlswMV0rJC9pXG4gICAgICAgIGNhc2UgNzk6IGNhc2UgMTExOiByYWRpeCA9IDg7IG1heENvZGUgPSA1NTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wb1swLTddKyQvaVxuICAgICAgICBkZWZhdWx0OiByZXR1cm4gK2l0O1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgZGlnaXRzID0gaXQuc2xpY2UoMiksIGkgPSAwLCBsID0gZGlnaXRzLmxlbmd0aCwgY29kZTsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb2RlID0gZGlnaXRzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIC8vIHBhcnNlSW50IHBhcnNlcyBhIHN0cmluZyB0byBhIGZpcnN0IHVuYXZhaWxhYmxlIHN5bWJvbFxuICAgICAgICAvLyBidXQgVG9OdW1iZXIgc2hvdWxkIHJldHVybiBOYU4gaWYgYSBzdHJpbmcgY29udGFpbnMgdW5hdmFpbGFibGUgc3ltYm9sc1xuICAgICAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiBtYXhDb2RlKSByZXR1cm4gTmFOO1xuICAgICAgfSByZXR1cm4gcGFyc2VJbnQoZGlnaXRzLCByYWRpeCk7XG4gICAgfVxuICB9IHJldHVybiAraXQ7XG59O1xuXG5pZiAoISROdW1iZXIoJyAwbzEnKSB8fCAhJE51bWJlcignMGIxJykgfHwgJE51bWJlcignKzB4MScpKSB7XG4gICROdW1iZXIgPSBmdW5jdGlvbiBOdW1iZXIodmFsdWUpIHtcbiAgICB2YXIgaXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMSA/IDAgOiB2YWx1ZTtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgcmV0dXJuIHRoYXQgaW5zdGFuY2VvZiAkTnVtYmVyXG4gICAgICAvLyBjaGVjayBvbiAxLi5jb25zdHJ1Y3Rvcihmb28pIGNhc2VcbiAgICAgICYmIChCUk9LRU5fQ09GID8gZmFpbHMoZnVuY3Rpb24gKCkgeyBwcm90by52YWx1ZU9mLmNhbGwodGhhdCk7IH0pIDogY29mKHRoYXQpICE9IE5VTUJFUilcbiAgICAgICAgPyBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSh0b051bWJlcihpdCkpLCB0aGF0LCAkTnVtYmVyKSA6IHRvTnVtYmVyKGl0KTtcbiAgfTtcbiAgZm9yICh2YXIga2V5cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BOKEJhc2UpIDogKFxuICAgIC8vIEVTMzpcbiAgICAnTUFYX1ZBTFVFLE1JTl9WQUxVRSxOYU4sTkVHQVRJVkVfSU5GSU5JVFksUE9TSVRJVkVfSU5GSU5JVFksJyArXG4gICAgLy8gRVM2IChpbiBjYXNlLCBpZiBtb2R1bGVzIHdpdGggRVM2IE51bWJlciBzdGF0aWNzIHJlcXVpcmVkIGJlZm9yZSk6XG4gICAgJ0VQU0lMT04saXNGaW5pdGUsaXNJbnRlZ2VyLGlzTmFOLGlzU2FmZUludGVnZXIsTUFYX1NBRkVfSU5URUdFUiwnICtcbiAgICAnTUlOX1NBRkVfSU5URUdFUixwYXJzZUZsb2F0LHBhcnNlSW50LGlzSW50ZWdlcidcbiAgKS5zcGxpdCgnLCcpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7IGorKykge1xuICAgIGlmIChoYXMoQmFzZSwga2V5ID0ga2V5c1tqXSkgJiYgIWhhcygkTnVtYmVyLCBrZXkpKSB7XG4gICAgICBkUCgkTnVtYmVyLCBrZXksIGdPUEQoQmFzZSwga2V5KSk7XG4gICAgfVxuICB9XG4gICROdW1iZXIucHJvdG90eXBlID0gcHJvdG87XG4gIHByb3RvLmNvbnN0cnVjdG9yID0gJE51bWJlcjtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShnbG9iYWwsIE5VTUJFUiwgJE51bWJlcik7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3IuanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBhTnVtYmVyVmFsdWUgPSByZXF1aXJlKCcuL19hLW51bWJlci12YWx1ZScpO1xudmFyIHJlcGVhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKTtcbnZhciAkdG9GaXhlZCA9IDEuMC50b0ZpeGVkO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBkYXRhID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xudmFyIEVSUk9SID0gJ051bWJlci50b0ZpeGVkOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnO1xudmFyIFpFUk8gPSAnMCc7XG5cbnZhciBtdWx0aXBseSA9IGZ1bmN0aW9uIChuLCBjKSB7XG4gIHZhciBpID0gLTE7XG4gIHZhciBjMiA9IGM7XG4gIHdoaWxlICgrK2kgPCA2KSB7XG4gICAgYzIgKz0gbiAqIGRhdGFbaV07XG4gICAgZGF0YVtpXSA9IGMyICUgMWU3O1xuICAgIGMyID0gZmxvb3IoYzIgLyAxZTcpO1xuICB9XG59O1xudmFyIGRpdmlkZSA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciBpID0gNjtcbiAgdmFyIGMgPSAwO1xuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICBjICs9IGRhdGFbaV07XG4gICAgZGF0YVtpXSA9IGZsb29yKGMgLyBuKTtcbiAgICBjID0gKGMgJSBuKSAqIDFlNztcbiAgfVxufTtcbnZhciBudW1Ub1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGkgPSA2O1xuICB2YXIgcyA9ICcnO1xuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICBpZiAocyAhPT0gJycgfHwgaSA9PT0gMCB8fCBkYXRhW2ldICE9PSAwKSB7XG4gICAgICB2YXIgdCA9IFN0cmluZyhkYXRhW2ldKTtcbiAgICAgIHMgPSBzID09PSAnJyA/IHQgOiBzICsgcmVwZWF0LmNhbGwoWkVSTywgNyAtIHQubGVuZ3RoKSArIHQ7XG4gICAgfVxuICB9IHJldHVybiBzO1xufTtcbnZhciBwb3cgPSBmdW5jdGlvbiAoeCwgbiwgYWNjKSB7XG4gIHJldHVybiBuID09PSAwID8gYWNjIDogbiAlIDIgPT09IDEgPyBwb3coeCwgbiAtIDEsIGFjYyAqIHgpIDogcG93KHggKiB4LCBuIC8gMiwgYWNjKTtcbn07XG52YXIgbG9nID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIG4gPSAwO1xuICB2YXIgeDIgPSB4O1xuICB3aGlsZSAoeDIgPj0gNDA5Nikge1xuICAgIG4gKz0gMTI7XG4gICAgeDIgLz0gNDA5NjtcbiAgfVxuICB3aGlsZSAoeDIgPj0gMikge1xuICAgIG4gKz0gMTtcbiAgICB4MiAvPSAyO1xuICB9IHJldHVybiBuO1xufTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoISEkdG9GaXhlZCAmJiAoXG4gIDAuMDAwMDgudG9GaXhlZCgzKSAhPT0gJzAuMDAwJyB8fFxuICAwLjkudG9GaXhlZCgwKSAhPT0gJzEnIHx8XG4gIDEuMjU1LnRvRml4ZWQoMikgIT09ICcxLjI1JyB8fFxuICAxMDAwMDAwMDAwMDAwMDAwMTI4LjAudG9GaXhlZCgwKSAhPT0gJzEwMDAwMDAwMDAwMDAwMDAxMjgnXG4pIHx8ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgJHRvRml4ZWQuY2FsbCh7fSk7XG59KSksICdOdW1iZXInLCB7XG4gIHRvRml4ZWQ6IGZ1bmN0aW9uIHRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpIHtcbiAgICB2YXIgeCA9IGFOdW1iZXJWYWx1ZSh0aGlzLCBFUlJPUik7XG4gICAgdmFyIGYgPSB0b0ludGVnZXIoZnJhY3Rpb25EaWdpdHMpO1xuICAgIHZhciBzID0gJyc7XG4gICAgdmFyIG0gPSBaRVJPO1xuICAgIHZhciBlLCB6LCBqLCBrO1xuICAgIGlmIChmIDwgMCB8fCBmID4gMjApIHRocm93IFJhbmdlRXJyb3IoRVJST1IpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoeCAhPSB4KSByZXR1cm4gJ05hTic7XG4gICAgaWYgKHggPD0gLTFlMjEgfHwgeCA+PSAxZTIxKSByZXR1cm4gU3RyaW5nKHgpO1xuICAgIGlmICh4IDwgMCkge1xuICAgICAgcyA9ICctJztcbiAgICAgIHggPSAteDtcbiAgICB9XG4gICAgaWYgKHggPiAxZS0yMSkge1xuICAgICAgZSA9IGxvZyh4ICogcG93KDIsIDY5LCAxKSkgLSA2OTtcbiAgICAgIHogPSBlIDwgMCA/IHggKiBwb3coMiwgLWUsIDEpIDogeCAvIHBvdygyLCBlLCAxKTtcbiAgICAgIHogKj0gMHgxMDAwMDAwMDAwMDAwMDtcbiAgICAgIGUgPSA1MiAtIGU7XG4gICAgICBpZiAoZSA+IDApIHtcbiAgICAgICAgbXVsdGlwbHkoMCwgeik7XG4gICAgICAgIGogPSBmO1xuICAgICAgICB3aGlsZSAoaiA+PSA3KSB7XG4gICAgICAgICAgbXVsdGlwbHkoMWU3LCAwKTtcbiAgICAgICAgICBqIC09IDc7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHkocG93KDEwLCBqLCAxKSwgMCk7XG4gICAgICAgIGogPSBlIC0gMTtcbiAgICAgICAgd2hpbGUgKGogPj0gMjMpIHtcbiAgICAgICAgICBkaXZpZGUoMSA8PCAyMyk7XG4gICAgICAgICAgaiAtPSAyMztcbiAgICAgICAgfVxuICAgICAgICBkaXZpZGUoMSA8PCBqKTtcbiAgICAgICAgbXVsdGlwbHkoMSwgMSk7XG4gICAgICAgIGRpdmlkZSgyKTtcbiAgICAgICAgbSA9IG51bVRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgbXVsdGlwbHkoMSA8PCAtZSwgMCk7XG4gICAgICAgIG0gPSBudW1Ub1N0cmluZygpICsgcmVwZWF0LmNhbGwoWkVSTywgZik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmID4gMCkge1xuICAgICAgayA9IG0ubGVuZ3RoO1xuICAgICAgbSA9IHMgKyAoayA8PSBmID8gJzAuJyArIHJlcGVhdC5jYWxsKFpFUk8sIGYgLSBrKSArIG0gOiBtLnNsaWNlKDAsIGsgLSBmKSArICcuJyArIG0uc2xpY2UoayAtIGYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHMgKyBtO1xuICAgIH0gcmV0dXJuIG07XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGFOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4vX2EtbnVtYmVyLXZhbHVlJyk7XG52YXIgJHRvUHJlY2lzaW9uID0gMS4wLnRvUHJlY2lzaW9uO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICgkZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBJRTctXG4gIHJldHVybiAkdG9QcmVjaXNpb24uY2FsbCgxLCB1bmRlZmluZWQpICE9PSAnMSc7XG59KSB8fCAhJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgJHRvUHJlY2lzaW9uLmNhbGwoe30pO1xufSkpLCAnTnVtYmVyJywge1xuICB0b1ByZWNpc2lvbjogZnVuY3Rpb24gdG9QcmVjaXNpb24ocHJlY2lzaW9uKSB7XG4gICAgdmFyIHRoYXQgPSBhTnVtYmVyVmFsdWUodGhpcywgJ051bWJlciN0b1ByZWNpc2lvbjogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gICAgcmV0dXJuIHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gJHRvUHJlY2lzaW9uLmNhbGwodGhhdCkgOiAkdG9QcmVjaXNpb24uY2FsbCh0aGF0LCBwcmVjaXNpb24pO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24uanMiLCIvLyAyMC4xLjIuMSBOdW1iZXIuRVBTSUxPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7IEVQU0lMT046IE1hdGgucG93KDIsIC01MikgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuZXBzaWxvbi5qcyIsIi8vIDIwLjEuMi4yIE51bWJlci5pc0Zpbml0ZShudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIF9pc0Zpbml0ZSA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmlzRmluaXRlO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNGaW5pdGU6IGZ1bmN0aW9uIGlzRmluaXRlKGl0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnbnVtYmVyJyAmJiBfaXNGaW5pdGUoaXQpO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUuanMiLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBpc0ludGVnZXI6IHJlcXVpcmUoJy4vX2lzLWludGVnZXInKSB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyLmpzIiwiLy8gMjAuMS4yLjQgTnVtYmVyLmlzTmFOKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc05hTjogZnVuY3Rpb24gaXNOYU4obnVtYmVyKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHJldHVybiBudW1iZXIgIT0gbnVtYmVyO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4uanMiLCIvLyAyMC4xLjIuNSBOdW1iZXIuaXNTYWZlSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4vX2lzLWludGVnZXInKTtcbnZhciBhYnMgPSBNYXRoLmFicztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzU2FmZUludGVnZXI6IGZ1bmN0aW9uIGlzU2FmZUludGVnZXIobnVtYmVyKSB7XG4gICAgcmV0dXJuIGlzSW50ZWdlcihudW1iZXIpICYmIGFicyhudW1iZXIpIDw9IDB4MWZmZmZmZmZmZmZmZmY7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLXNhZmUtaW50ZWdlci5qcyIsIi8vIDIwLjEuMi42IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHsgTUFYX1NBRkVfSU5URUdFUjogMHgxZmZmZmZmZmZmZmZmZiB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5tYXgtc2FmZS1pbnRlZ2VyLmpzIiwiLy8gMjAuMS4yLjEwIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHsgTUlOX1NBRkVfSU5URUdFUjogLTB4MWZmZmZmZmZmZmZmZmYgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWluLXNhZmUtaW50ZWdlci5qcyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19wYXJzZS1mbG9hdCcpO1xuLy8gMjAuMS4yLjEyIE51bWJlci5wYXJzZUZsb2F0KHN0cmluZylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE51bWJlci5wYXJzZUZsb2F0ICE9ICRwYXJzZUZsb2F0KSwgJ051bWJlcicsIHsgcGFyc2VGbG9hdDogJHBhcnNlRmxvYXQgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtZmxvYXQuanMiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX3BhcnNlLWludCcpO1xuLy8gMjAuMS4yLjEzIE51bWJlci5wYXJzZUludChzdHJpbmcsIHJhZGl4KVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTnVtYmVyLnBhcnNlSW50ICE9ICRwYXJzZUludCksICdOdW1iZXInLCB7IHBhcnNlSW50OiAkcGFyc2VJbnQgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtaW50LmpzIiwiLy8gMjAuMi4yLjMgTWF0aC5hY29zaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBsb2cxcCA9IHJlcXVpcmUoJy4vX21hdGgtbG9nMXAnKTtcbnZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xudmFyICRhY29zaCA9IE1hdGguYWNvc2g7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYWNvc2hcbiAgLy8gVjggYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzUwOVxuICAmJiBNYXRoLmZsb29yKCRhY29zaChOdW1iZXIuTUFYX1ZBTFVFKSkgPT0gNzEwXG4gIC8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hY29zaChJbmZpbml0eSkgLT4gTmFOXG4gICYmICRhY29zaChJbmZpbml0eSkgPT0gSW5maW5pdHlcbiksICdNYXRoJywge1xuICBhY29zaDogZnVuY3Rpb24gYWNvc2goeCkge1xuICAgIHJldHVybiAoeCA9ICt4KSA8IDEgPyBOYU4gOiB4ID4gOTQ5MDYyNjUuNjI0MjUxNTZcbiAgICAgID8gTWF0aC5sb2coeCkgKyBNYXRoLkxOMlxuICAgICAgOiBsb2cxcCh4IC0gMSArIHNxcnQoeCAtIDEpICogc3FydCh4ICsgMSkpO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYWNvc2guanMiLCIvLyAyMC4yLjIuNSBNYXRoLmFzaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRhc2luaCA9IE1hdGguYXNpbmg7XG5cbmZ1bmN0aW9uIGFzaW5oKHgpIHtcbiAgcmV0dXJuICFpc0Zpbml0ZSh4ID0gK3gpIHx8IHggPT0gMCA/IHggOiB4IDwgMCA/IC1hc2luaCgteCkgOiBNYXRoLmxvZyh4ICsgTWF0aC5zcXJ0KHggKiB4ICsgMSkpO1xufVxuXG4vLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYXNpbmgoMCkgLT4gLTBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXNpbmggJiYgMSAvICRhc2luaCgwKSA+IDApLCAnTWF0aCcsIHsgYXNpbmg6IGFzaW5oIH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hc2luaC5qcyIsIi8vIDIwLjIuMi43IE1hdGguYXRhbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGF0YW5oID0gTWF0aC5hdGFuaDtcblxuLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmF0YW5oKC0wKSAtPiAwXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGF0YW5oICYmIDEgLyAkYXRhbmgoLTApIDwgMCksICdNYXRoJywge1xuICBhdGFuaDogZnVuY3Rpb24gYXRhbmgoeCkge1xuICAgIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IE1hdGgubG9nKCgxICsgeCkgLyAoMSAtIHgpKSAvIDI7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hdGFuaC5qcyIsIi8vIDIwLjIuMi45IE1hdGguY2JydCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBzaWduID0gcmVxdWlyZSgnLi9fbWF0aC1zaWduJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2JydDogZnVuY3Rpb24gY2JydCh4KSB7XG4gICAgcmV0dXJuIHNpZ24oeCA9ICt4KSAqIE1hdGgucG93KE1hdGguYWJzKHgpLCAxIC8gMyk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jYnJ0LmpzIiwiLy8gMjAuMi4yLjExIE1hdGguY2x6MzIoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2x6MzI6IGZ1bmN0aW9uIGNsejMyKHgpIHtcbiAgICByZXR1cm4gKHggPj4+PSAwKSA/IDMxIC0gTWF0aC5mbG9vcihNYXRoLmxvZyh4ICsgMC41KSAqIE1hdGguTE9HMkUpIDogMzI7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jbHozMi5qcyIsIi8vIDIwLjIuMi4xMiBNYXRoLmNvc2goeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZXhwID0gTWF0aC5leHA7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY29zaDogZnVuY3Rpb24gY29zaCh4KSB7XG4gICAgcmV0dXJuIChleHAoeCA9ICt4KSArIGV4cCgteCkpIC8gMjtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNvc2guanMiLCIvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZXhwbTEgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCRleHBtMSAhPSBNYXRoLmV4cG0xKSwgJ01hdGgnLCB7IGV4cG0xOiAkZXhwbTEgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmV4cG0xLmpzIiwiLy8gMjAuMi4yLjE2IE1hdGguZnJvdW5kKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IGZyb3VuZDogcmVxdWlyZSgnLi9fbWF0aC1mcm91bmQnKSB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kLmpzIiwiLy8gMjAuMi4yLjE3IE1hdGguaHlwb3QoW3ZhbHVlMVssIHZhbHVlMlssIOKApiBdXV0pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFicyA9IE1hdGguYWJzO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGh5cG90OiBmdW5jdGlvbiBoeXBvdCh2YWx1ZTEsIHZhbHVlMikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbGFyZyA9IDA7XG4gICAgdmFyIGFyZywgZGl2O1xuICAgIHdoaWxlIChpIDwgYUxlbikge1xuICAgICAgYXJnID0gYWJzKGFyZ3VtZW50c1tpKytdKTtcbiAgICAgIGlmIChsYXJnIDwgYXJnKSB7XG4gICAgICAgIGRpdiA9IGxhcmcgLyBhcmc7XG4gICAgICAgIHN1bSA9IHN1bSAqIGRpdiAqIGRpdiArIDE7XG4gICAgICAgIGxhcmcgPSBhcmc7XG4gICAgICB9IGVsc2UgaWYgKGFyZyA+IDApIHtcbiAgICAgICAgZGl2ID0gYXJnIC8gbGFyZztcbiAgICAgICAgc3VtICs9IGRpdiAqIGRpdjtcbiAgICAgIH0gZWxzZSBzdW0gKz0gYXJnO1xuICAgIH1cbiAgICByZXR1cm4gbGFyZyA9PT0gSW5maW5pdHkgPyBJbmZpbml0eSA6IGxhcmcgKiBNYXRoLnNxcnQoc3VtKTtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmh5cG90LmpzIiwiLy8gMjAuMi4yLjE4IE1hdGguaW11bCh4LCB5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkaW11bCA9IE1hdGguaW11bDtcblxuLy8gc29tZSBXZWJLaXQgdmVyc2lvbnMgZmFpbHMgd2l0aCBiaWcgbnVtYmVycywgc29tZSBoYXMgd3JvbmcgYXJpdHlcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAkaW11bCgweGZmZmZmZmZmLCA1KSAhPSAtNSB8fCAkaW11bC5sZW5ndGggIT0gMjtcbn0pLCAnTWF0aCcsIHtcbiAgaW11bDogZnVuY3Rpb24gaW11bCh4LCB5KSB7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZjtcbiAgICB2YXIgeG4gPSAreDtcbiAgICB2YXIgeW4gPSAreTtcbiAgICB2YXIgeGwgPSBVSU5UMTYgJiB4bjtcbiAgICB2YXIgeWwgPSBVSU5UMTYgJiB5bjtcbiAgICByZXR1cm4gMCB8IHhsICogeWwgKyAoKFVJTlQxNiAmIHhuID4+PiAxNikgKiB5bCArIHhsICogKFVJTlQxNiAmIHluID4+PiAxNikgPDwgMTYgPj4+IDApO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaW11bC5qcyIsIi8vIDIwLjIuMi4yMSBNYXRoLmxvZzEwKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGxvZzEwOiBmdW5jdGlvbiBsb2cxMCh4KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpICogTWF0aC5MT0cxMEU7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxMC5qcyIsIi8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IGxvZzFwOiByZXF1aXJlKCcuL19tYXRoLWxvZzFwJykgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwLmpzIiwiLy8gMjAuMi4yLjIyIE1hdGgubG9nMih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cyOiBmdW5jdGlvbiBsb2cyKHgpIHtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMjtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzIuanMiLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IHNpZ246IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpIH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaWduLmpzIiwiLy8gMjAuMi4yLjMwIE1hdGguc2luaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBleHBtMSA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKTtcbnZhciBleHAgPSBNYXRoLmV4cDtcblxuLy8gVjggbmVhciBDaHJvbWl1bSAzOCBoYXMgYSBwcm9ibGVtIHdpdGggdmVyeSBzbWFsbCBudW1iZXJzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIU1hdGguc2luaCgtMmUtMTcpICE9IC0yZS0xNztcbn0pLCAnTWF0aCcsIHtcbiAgc2luaDogZnVuY3Rpb24gc2luaCh4KSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHggPSAreCkgPCAxXG4gICAgICA/IChleHBtMSh4KSAtIGV4cG0xKC14KSkgLyAyXG4gICAgICA6IChleHAoeCAtIDEpIC0gZXhwKC14IC0gMSkpICogKE1hdGguRSAvIDIpO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2luaC5qcyIsIi8vIDIwLjIuMi4zMyBNYXRoLnRhbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZXhwbTEgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJyk7XG52YXIgZXhwID0gTWF0aC5leHA7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdGFuaDogZnVuY3Rpb24gdGFuaCh4KSB7XG4gICAgdmFyIGEgPSBleHBtMSh4ID0gK3gpO1xuICAgIHZhciBiID0gZXhwbTEoLXgpO1xuICAgIHJldHVybiBhID09IEluZmluaXR5ID8gMSA6IGIgPT0gSW5maW5pdHkgPyAtMSA6IChhIC0gYikgLyAoZXhwKHgpICsgZXhwKC14KSk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50YW5oLmpzIiwiLy8gMjAuMi4yLjM0IE1hdGgudHJ1bmMoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdHJ1bmM6IGZ1bmN0aW9uIHRydW5jKGl0KSB7XG4gICAgcmV0dXJuIChpdCA+IDAgPyBNYXRoLmZsb29yIDogTWF0aC5jZWlsKShpdCk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50cnVuYy5qcyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xudmFyICRmcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG5cbi8vIGxlbmd0aCBzaG91bGQgYmUgMSwgb2xkIEZGIHByb2JsZW1cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCEhJGZyb21Db2RlUG9pbnQgJiYgJGZyb21Db2RlUG9pbnQubGVuZ3RoICE9IDEpLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjIuMiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jb2RlUG9pbnRzKVxuICBmcm9tQ29kZVBvaW50OiBmdW5jdGlvbiBmcm9tQ29kZVBvaW50KHgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciByZXMgPSBbXTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBjb2RlO1xuICAgIHdoaWxlIChhTGVuID4gaSkge1xuICAgICAgY29kZSA9ICthcmd1bWVudHNbaSsrXTtcbiAgICAgIGlmICh0b0Fic29sdXRlSW5kZXgoY29kZSwgMHgxMGZmZmYpICE9PSBjb2RlKSB0aHJvdyBSYW5nZUVycm9yKGNvZGUgKyAnIGlzIG5vdCBhIHZhbGlkIGNvZGUgcG9pbnQnKTtcbiAgICAgIHJlcy5wdXNoKGNvZGUgPCAweDEwMDAwXG4gICAgICAgID8gZnJvbUNoYXJDb2RlKGNvZGUpXG4gICAgICAgIDogZnJvbUNoYXJDb2RlKCgoY29kZSAtPSAweDEwMDAwKSA+PiAxMCkgKyAweGQ4MDAsIGNvZGUgJSAweDQwMCArIDB4ZGMwMClcbiAgICAgICk7XG4gICAgfSByZXR1cm4gcmVzLmpvaW4oJycpO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQuanMiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjQgU3RyaW5nLnJhdyhjYWxsU2l0ZSwgLi4uc3Vic3RpdHV0aW9ucylcbiAgcmF3OiBmdW5jdGlvbiByYXcoY2FsbFNpdGUpIHtcbiAgICB2YXIgdHBsID0gdG9JT2JqZWN0KGNhbGxTaXRlLnJhdyk7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKHRwbC5sZW5ndGgpO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgcmVzID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChsZW4gPiBpKSB7XG4gICAgICByZXMucHVzaChTdHJpbmcodHBsW2krK10pKTtcbiAgICAgIGlmIChpIDwgYUxlbikgcmVzLnB1c2goU3RyaW5nKGFyZ3VtZW50c1tpXSkpO1xuICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmF3LmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjEuMS4zLjI1IFN0cmluZy5wcm90b3R5cGUudHJpbSgpXG5yZXF1aXJlKCcuL19zdHJpbmctdHJpbScpKCd0cmltJywgZnVuY3Rpb24gKCR0cmltKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltKCkge1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAzKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0uanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIgaW5kZXggPSB0aGlzLl9pO1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBPLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykoZmFsc2UpO1xuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4zIFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQocG9zKVxuICBjb2RlUG9pbnRBdDogZnVuY3Rpb24gY29kZVBvaW50QXQocG9zKSB7XG4gICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0LmpzIiwiLy8gMjEuMS4zLjYgU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aChzZWFyY2hTdHJpbmcgWywgZW5kUG9zaXRpb25dKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpO1xudmFyIEVORFNfV0lUSCA9ICdlbmRzV2l0aCc7XG52YXIgJGVuZHNXaXRoID0gJydbRU5EU19XSVRIXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShFTkRTX1dJVEgpLCAnU3RyaW5nJywge1xuICBlbmRzV2l0aDogZnVuY3Rpb24gZW5kc1dpdGgoc2VhcmNoU3RyaW5nIC8qICwgZW5kUG9zaXRpb24gPSBAbGVuZ3RoICovKSB7XG4gICAgdmFyIHRoYXQgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgRU5EU19XSVRIKTtcbiAgICB2YXIgZW5kUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgodGhhdC5sZW5ndGgpO1xuICAgIHZhciBlbmQgPSBlbmRQb3NpdGlvbiA9PT0gdW5kZWZpbmVkID8gbGVuIDogTWF0aC5taW4odG9MZW5ndGgoZW5kUG9zaXRpb24pLCBsZW4pO1xuICAgIHZhciBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJGVuZHNXaXRoXG4gICAgICA/ICRlbmRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgZW5kKVxuICAgICAgOiB0aGF0LnNsaWNlKGVuZCAtIHNlYXJjaC5sZW5ndGgsIGVuZCkgPT09IHNlYXJjaDtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoLmpzIiwiLy8gMjEuMS4zLjcgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyhzZWFyY2hTdHJpbmcsIHBvc2l0aW9uID0gMClcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29udGV4dCA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0Jyk7XG52YXIgSU5DTFVERVMgPSAnaW5jbHVkZXMnO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKElOQ0xVREVTKSwgJ1N0cmluZycsIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFN0cmluZyAvKiAsIHBvc2l0aW9uID0gMCAqLykge1xuICAgIHJldHVybiAhIX5jb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgSU5DTFVERVMpXG4gICAgICAuaW5kZXhPZihzZWFyY2hTdHJpbmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanMiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjEzIFN0cmluZy5wcm90b3R5cGUucmVwZWF0KGNvdW50KVxuICByZXBlYXQ6IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmVwZWF0LmpzIiwiLy8gMjEuMS4zLjE4IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgWywgcG9zaXRpb24gXSlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBjb250ZXh0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKTtcbnZhciBTVEFSVFNfV0lUSCA9ICdzdGFydHNXaXRoJztcbnZhciAkc3RhcnRzV2l0aCA9ICcnW1NUQVJUU19XSVRIXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShTVEFSVFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIHN0YXJ0c1dpdGg6IGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIC8qICwgcG9zaXRpb24gPSAwICovKSB7XG4gICAgdmFyIHRoYXQgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgU1RBUlRTX1dJVEgpO1xuICAgIHZhciBpbmRleCA9IHRvTGVuZ3RoKE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0aGF0Lmxlbmd0aCkpO1xuICAgIHZhciBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJHN0YXJ0c1dpdGhcbiAgICAgID8gJHN0YXJ0c1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGluZGV4KVxuICAgICAgOiB0aGF0LnNsaWNlKGluZGV4LCBpbmRleCArIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0YXJ0cy13aXRoLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMiBTdHJpbmcucHJvdG90eXBlLmFuY2hvcihuYW1lKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYW5jaG9yJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFuY2hvcihuYW1lKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2EnLCAnbmFtZScsIG5hbWUpO1xuICB9O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYW5jaG9yLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMyBTdHJpbmcucHJvdG90eXBlLmJpZygpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdiaWcnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gYmlnKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdiaWcnLCAnJywgJycpO1xuICB9O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYmlnLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNCBTdHJpbmcucHJvdG90eXBlLmJsaW5rKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JsaW5rJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJsaW5rKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdibGluaycsICcnLCAnJyk7XG4gIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ibGluay5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjUgU3RyaW5nLnByb3RvdHlwZS5ib2xkKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JvbGQnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gYm9sZCgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYicsICcnLCAnJyk7XG4gIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNiBTdHJpbmcucHJvdG90eXBlLmZpeGVkKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZpeGVkJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZpeGVkKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICd0dCcsICcnLCAnJyk7XG4gIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZC5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjcgU3RyaW5nLnByb3RvdHlwZS5mb250Y29sb3IoY29sb3IpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmb250Y29sb3InLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gZm9udGNvbG9yKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2ZvbnQnLCAnY29sb3InLCBjb2xvcik7XG4gIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250Y29sb3IuanMiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy44IFN0cmluZy5wcm90b3R5cGUuZm9udHNpemUoc2l6ZSlcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZvbnRzaXplJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbnRzaXplKHNpemUpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnZm9udCcsICdzaXplJywgc2l6ZSk7XG4gIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZS5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjkgU3RyaW5nLnByb3RvdHlwZS5pdGFsaWNzKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2l0YWxpY3MnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gaXRhbGljcygpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnaScsICcnLCAnJyk7XG4gIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGFsaWNzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTAgU3RyaW5nLnByb3RvdHlwZS5saW5rKHVybClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2xpbmsnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gbGluayh1cmwpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYScsICdocmVmJywgdXJsKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmxpbmsuanMiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMSBTdHJpbmcucHJvdG90eXBlLnNtYWxsKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3NtYWxsJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNtYWxsKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzbWFsbCcsICcnLCAnJyk7XG4gIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zbWFsbC5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjEyIFN0cmluZy5wcm90b3R5cGUuc3RyaWtlKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N0cmlrZScsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzdHJpa2UoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N0cmlrZScsICcnLCAnJyk7XG4gIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdHJpa2UuanMiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMyBTdHJpbmcucHJvdG90eXBlLnN1YigpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdWInLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gc3ViKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdWInLCAnJywgJycpO1xuICB9O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3ViLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTQgU3RyaW5nLnByb3RvdHlwZS5zdXAoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3VwJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN1cCgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3VwJywgJycsICcnKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1cC5qcyIsIi8vIDIwLjMuMy4xIC8gMTUuOS40LjQgRGF0ZS5ub3coKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdEYXRlJywgeyBub3c6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9IH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS5ub3cuanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKE5hTikudG9KU09OKCkgIT09IG51bGxcbiAgICB8fCBEYXRlLnByb3RvdHlwZS50b0pTT04uY2FsbCh7IHRvSVNPU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiAxOyB9IH0pICE9PSAxO1xufSksICdEYXRlJywge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oa2V5KSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgcHYgPSB0b1ByaW1pdGl2ZShPKTtcbiAgICByZXR1cm4gdHlwZW9mIHB2ID09ICdudW1iZXInICYmICFpc0Zpbml0ZShwdikgPyBudWxsIDogTy50b0lTT1N0cmluZygpO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tanNvbi5qcyIsIi8vIDIwLjMuNC4zNiAvIDE1LjkuNS40MyBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZygpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvSVNPU3RyaW5nID0gcmVxdWlyZSgnLi9fZGF0ZS10by1pc28tc3RyaW5nJyk7XG5cbi8vIFBoYW50b21KUyAvIG9sZCBXZWJLaXQgaGFzIGEgYnJva2VuIGltcGxlbWVudGF0aW9uc1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgIT09IHRvSVNPU3RyaW5nKSwgJ0RhdGUnLCB7XG4gIHRvSVNPU3RyaW5nOiB0b0lTT1N0cmluZ1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcuanMiLCIndXNlIHN0cmljdCc7XG4vLyAyMC4zLjQuMzYgLyAxNS45LjUuNDMgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcoKVxudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBnZXRUaW1lID0gRGF0ZS5wcm90b3R5cGUuZ2V0VGltZTtcbnZhciAkdG9JU09TdHJpbmcgPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZztcblxudmFyIGx6ID0gZnVuY3Rpb24gKG51bSkge1xuICByZXR1cm4gbnVtID4gOSA/IG51bSA6ICcwJyArIG51bTtcbn07XG5cbi8vIFBoYW50b21KUyAvIG9sZCBXZWJLaXQgaGFzIGEgYnJva2VuIGltcGxlbWVudGF0aW9uc1xubW9kdWxlLmV4cG9ydHMgPSAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJHRvSVNPU3RyaW5nLmNhbGwobmV3IERhdGUoLTVlMTMgLSAxKSkgIT0gJzAzODUtMDctMjVUMDc6MDY6MzkuOTk5Wic7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAkdG9JU09TdHJpbmcuY2FsbChuZXcgRGF0ZShOYU4pKTtcbn0pKSA/IGZ1bmN0aW9uIHRvSVNPU3RyaW5nKCkge1xuICBpZiAoIWlzRmluaXRlKGdldFRpbWUuY2FsbCh0aGlzKSkpIHRocm93IFJhbmdlRXJyb3IoJ0ludmFsaWQgdGltZSB2YWx1ZScpO1xuICB2YXIgZCA9IHRoaXM7XG4gIHZhciB5ID0gZC5nZXRVVENGdWxsWWVhcigpO1xuICB2YXIgbSA9IGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gIHZhciBzID0geSA8IDAgPyAnLScgOiB5ID4gOTk5OSA/ICcrJyA6ICcnO1xuICByZXR1cm4gcyArICgnMDAwMDAnICsgTWF0aC5hYnMoeSkpLnNsaWNlKHMgPyAtNiA6IC00KSArXG4gICAgJy0nICsgbHooZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgKyBseihkLmdldFVUQ0RhdGUoKSkgK1xuICAgICdUJyArIGx6KGQuZ2V0VVRDSG91cnMoKSkgKyAnOicgKyBseihkLmdldFVUQ01pbnV0ZXMoKSkgK1xuICAgICc6JyArIGx6KGQuZ2V0VVRDU2Vjb25kcygpKSArICcuJyArIChtID4gOTkgPyBtIDogJzAnICsgbHoobSkpICsgJ1onO1xufSA6ICR0b0lTT1N0cmluZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RhdGUtdG8taXNvLXN0cmluZy5qcyIsInZhciBEYXRlUHJvdG8gPSBEYXRlLnByb3RvdHlwZTtcbnZhciBJTlZBTElEX0RBVEUgPSAnSW52YWxpZCBEYXRlJztcbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyICR0b1N0cmluZyA9IERhdGVQcm90b1tUT19TVFJJTkddO1xudmFyIGdldFRpbWUgPSBEYXRlUHJvdG8uZ2V0VGltZTtcbmlmIChuZXcgRGF0ZShOYU4pICsgJycgIT0gSU5WQUxJRF9EQVRFKSB7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoRGF0ZVByb3RvLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciB2YWx1ZSA9IGdldFRpbWUuY2FsbCh0aGlzKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/ICR0b1N0cmluZy5jYWxsKHRoaXMpIDogSU5WQUxJRF9EQVRFO1xuICB9KTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nLmpzIiwidmFyIFRPX1BSSU1JVElWRSA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1ByaW1pdGl2ZScpO1xudmFyIHByb3RvID0gRGF0ZS5wcm90b3R5cGU7XG5cbmlmICghKFRPX1BSSU1JVElWRSBpbiBwcm90bykpIHJlcXVpcmUoJy4vX2hpZGUnKShwcm90bywgVE9fUFJJTUlUSVZFLCByZXF1aXJlKCcuL19kYXRlLXRvLXByaW1pdGl2ZScpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tcHJpbWl0aXZlLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBOVU1CRVIgPSAnbnVtYmVyJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaGludCkge1xuICBpZiAoaGludCAhPT0gJ3N0cmluZycgJiYgaGludCAhPT0gTlVNQkVSICYmIGhpbnQgIT09ICdkZWZhdWx0JykgdGhyb3cgVHlwZUVycm9yKCdJbmNvcnJlY3QgaGludCcpO1xuICByZXR1cm4gdG9QcmltaXRpdmUoYW5PYmplY3QodGhpcyksIGhpbnQgIT0gTlVNQkVSKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kYXRlLXRvLXByaW1pdGl2ZS5qcyIsIi8vIDIyLjEuMi4yIC8gMTUuNC4zLjIgQXJyYXkuaXNBcnJheShhcmcpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0FycmF5JywgeyBpc0FycmF5OiByZXF1aXJlKCcuL19pcy1hcnJheScpIH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXMtYXJyYXkuanMiLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAobWFwcGluZykgbWFwZm4gPSBjdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEMoKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yIChyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcblxuLy8gV2ViS2l0IEFycmF5Lm9mIGlzbid0IGdlbmVyaWNcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuICEoQXJyYXkub2YuY2FsbChGKSBpbnN0YW5jZW9mIEYpO1xufSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjMgQXJyYXkub2YoIC4uLml0ZW1zKVxuICBvZjogZnVuY3Rpb24gb2YoLyogLi4uYXJncyAqLykge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBuZXcgKHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXkpKGFMZW4pO1xuICAgIHdoaWxlIChhTGVuID4gaW5kZXgpIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGFMZW47XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5vZi5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUuam9pbihzZXBhcmF0b3IpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUpvaW4gPSBbXS5qb2luO1xuXG4vLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2Ugc3RyaW5nc1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAocmVxdWlyZSgnLi9faW9iamVjdCcpICE9IE9iamVjdCB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKGFycmF5Sm9pbikpLCAnQXJyYXknLCB7XG4gIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7XG4gICAgcmV0dXJuIGFycmF5Sm9pbi5jYWxsKHRvSU9iamVjdCh0aGlzKSwgc2VwYXJhdG9yID09PSB1bmRlZmluZWQgPyAnLCcgOiBzZXBhcmF0b3IpO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmpvaW4uanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuL19odG1sJyk7XG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFycmF5U2xpY2UgPSBbXS5zbGljZTtcblxuLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIEVTMyBzdHJpbmdzIGFuZCBET00gb2JqZWN0c1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgaWYgKGh0bWwpIGFycmF5U2xpY2UuY2FsbChodG1sKTtcbn0pLCAnQXJyYXknLCB7XG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShiZWdpbiwgZW5kKSB7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKHRoaXMubGVuZ3RoKTtcbiAgICB2YXIga2xhc3MgPSBjb2YodGhpcyk7XG4gICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQ7XG4gICAgaWYgKGtsYXNzID09ICdBcnJheScpIHJldHVybiBhcnJheVNsaWNlLmNhbGwodGhpcywgYmVnaW4sIGVuZCk7XG4gICAgdmFyIHN0YXJ0ID0gdG9BYnNvbHV0ZUluZGV4KGJlZ2luLCBsZW4pO1xuICAgIHZhciB1cFRvID0gdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuKTtcbiAgICB2YXIgc2l6ZSA9IHRvTGVuZ3RoKHVwVG8gLSBzdGFydCk7XG4gICAgdmFyIGNsb25lZCA9IEFycmF5KHNpemUpO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgaSA8IHNpemU7IGkrKykgY2xvbmVkW2ldID0ga2xhc3MgPT0gJ1N0cmluZydcbiAgICAgID8gdGhpcy5jaGFyQXQoc3RhcnQgKyBpKVxuICAgICAgOiB0aGlzW3N0YXJ0ICsgaV07XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zbGljZS5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyICRzb3J0ID0gW10uc29ydDtcbnZhciB0ZXN0ID0gWzEsIDIsIDNdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIElFOC1cbiAgdGVzdC5zb3J0KHVuZGVmaW5lZCk7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBWOCBidWdcbiAgdGVzdC5zb3J0KG51bGwpO1xuICAvLyBPbGQgV2ViS2l0XG59KSB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRzb3J0KSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjI1IEFycmF5LnByb3RvdHlwZS5zb3J0KGNvbXBhcmVmbilcbiAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pIHtcbiAgICByZXR1cm4gY29tcGFyZWZuID09PSB1bmRlZmluZWRcbiAgICAgID8gJHNvcnQuY2FsbCh0b09iamVjdCh0aGlzKSlcbiAgICAgIDogJHNvcnQuY2FsbCh0b09iamVjdCh0aGlzKSwgYUZ1bmN0aW9uKGNvbXBhcmVmbikpO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvcnQuanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmb3JFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApO1xudmFyIFNUUklDVCA9IHJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5mb3JFYWNoLCB0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhU1RSSUNULCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMCAvIDE1LjQuNC4xOCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRmb3JFYWNoKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2guanMiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsKSkge1xuICAgIEMgPSBvcmlnaW5hbC5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmICh0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGlzT2JqZWN0KEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRtYXAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5tYXAsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xNSAvIDE1LjQuNC4xOSBBcnJheS5wcm90b3R5cGUubWFwKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRtYXAodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5tYXAuanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMik7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5maWx0ZXIsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy43IC8gMTUuNC40LjIwIEFycmF5LnByb3RvdHlwZS5maWx0ZXIoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJGZpbHRlcih0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbHRlci5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHNvbWUgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5zb21lLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMjMgLyAxNS40LjQuMTcgQXJyYXkucHJvdG90eXBlLnNvbWUoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkc29tZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvbWUuanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRldmVyeSA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg0KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmV2ZXJ5LCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuNSAvIDE1LjQuNC4xNiBBcnJheS5wcm90b3R5cGUuZXZlcnkoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRldmVyeSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5LmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5yZWR1Y2UsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xOCAvIDE1LjQuNC4yMSBBcnJheS5wcm90b3R5cGUucmVkdWNlKGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c1sxXSwgZmFsc2UpO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5LXJlZHVjZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ucmVkdWNlUmlnaHQsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xOSAvIDE1LjQuNC4yMiBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQoY2FsbGJhY2tmbiBbLCBpbml0aWFsVmFsdWVdKVxuICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c1sxXSwgdHJ1ZSk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLXJpZ2h0LmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkaW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyICRuYXRpdmUgPSBbXS5pbmRleE9mO1xudmFyIE5FR0FUSVZFX1pFUk8gPSAhISRuYXRpdmUgJiYgMSAvIFsxXS5pbmRleE9mKDEsIC0wKSA8IDA7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKE5FR0FUSVZFX1pFUk8gfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkbmF0aXZlKSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjExIC8gMTUuNC40LjE0IEFycmF5LnByb3RvdHlwZS5pbmRleE9mKHNlYXJjaEVsZW1lbnQgWywgZnJvbUluZGV4XSlcbiAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ID0gMCAqLykge1xuICAgIHJldHVybiBORUdBVElWRV9aRVJPXG4gICAgICAvLyBjb252ZXJ0IC0wIHRvICswXG4gICAgICA/ICRuYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwXG4gICAgICA6ICRpbmRleE9mKHRoaXMsIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YuanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciAkbmF0aXZlID0gW10ubGFzdEluZGV4T2Y7XG52YXIgTkVHQVRJVkVfWkVSTyA9ICEhJG5hdGl2ZSAmJiAxIC8gWzFdLmxhc3RJbmRleE9mKDEsIC0wKSA8IDA7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKE5FR0FUSVZFX1pFUk8gfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkbmF0aXZlKSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE0IC8gMTUuNC40LjE1IEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IFssIGZyb21JbmRleF0pXG4gIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ID0gQFsqLTFdICovKSB7XG4gICAgLy8gY29udmVydCAtMCB0byArMFxuICAgIGlmIChORUdBVElWRV9aRVJPKSByZXR1cm4gJG5hdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDA7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QodGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSBsZW5ndGggLSAxO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgaW5kZXggPSBNYXRoLm1pbihpbmRleCwgdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSkpO1xuICAgIGlmIChpbmRleCA8IDApIGluZGV4ID0gbGVuZ3RoICsgaW5kZXg7XG4gICAgZm9yICg7aW5kZXggPj0gMDsgaW5kZXgtLSkgaWYgKGluZGV4IGluIE8pIGlmIChPW2luZGV4XSA9PT0gc2VhcmNoRWxlbWVudCkgcmV0dXJuIGluZGV4IHx8IDA7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YuanMiLCIvLyAyMi4xLjMuMyBBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0LCBlbmQgPSB0aGlzLmxlbmd0aClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7IGNvcHlXaXRoaW46IHJlcXVpcmUoJy4vX2FycmF5LWNvcHktd2l0aGluJykgfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdjb3B5V2l0aGluJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbi5qcyIsIi8vIDIyLjEuMy42IEFycmF5LnByb3RvdHlwZS5maWxsKHZhbHVlLCBzdGFydCA9IDAsIGVuZCA9IHRoaXMubGVuZ3RoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHsgZmlsbDogcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpIH0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnZmlsbCcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsbC5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy44IEFycmF5LnByb3RvdHlwZS5maW5kKHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZpbmQgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNSk7XG52YXIgS0VZID0gJ2ZpbmQnO1xudmFyIGZvcmNlZCA9IHRydWU7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYgKEtFWSBpbiBbXSkgQXJyYXkoMSlbS0VZXShmdW5jdGlvbiAoKSB7IGZvcmNlZCA9IGZhbHNlOyB9KTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZm9yY2VkLCAnQXJyYXknLCB7XG4gIGZpbmQ6IGZ1bmN0aW9uIGZpbmQoY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKEtFWSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjkgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmaW5kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDYpO1xudmFyIEtFWSA9ICdmaW5kSW5kZXgnO1xudmFyIGZvcmNlZCA9IHRydWU7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYgKEtFWSBpbiBbXSkgQXJyYXkoMSlbS0VZXShmdW5jdGlvbiAoKSB7IGZvcmNlZCA9IGZhbHNlOyB9KTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZm9yY2VkLCAnQXJyYXknLCB7XG4gIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKShLRVkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleC5qcyIsInJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ0FycmF5Jyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzLmpzIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG52YXIgJGZsYWdzID0gcmVxdWlyZSgnLi9fZmxhZ3MnKTtcbnZhciAkUmVnRXhwID0gZ2xvYmFsLlJlZ0V4cDtcbnZhciBCYXNlID0gJFJlZ0V4cDtcbnZhciBwcm90byA9ICRSZWdFeHAucHJvdG90eXBlO1xudmFyIHJlMSA9IC9hL2c7XG52YXIgcmUyID0gL2EvZztcbi8vIFwibmV3XCIgY3JlYXRlcyBhIG5ldyBvYmplY3QsIG9sZCB3ZWJraXQgYnVnZ3kgaGVyZVxudmFyIENPUlJFQ1RfTkVXID0gbmV3ICRSZWdFeHAocmUxKSAhPT0gcmUxO1xuXG5pZiAocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAoIUNPUlJFQ1RfTkVXIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZTJbcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyldID0gZmFsc2U7XG4gIC8vIFJlZ0V4cCBjb25zdHJ1Y3RvciBjYW4gYWx0ZXIgZmxhZ3MgYW5kIElzUmVnRXhwIHdvcmtzIGNvcnJlY3Qgd2l0aCBAQG1hdGNoXG4gIHJldHVybiAkUmVnRXhwKHJlMSkgIT0gcmUxIHx8ICRSZWdFeHAocmUyKSA9PSByZTIgfHwgJFJlZ0V4cChyZTEsICdpJykgIT0gJy9hL2knO1xufSkpKSB7XG4gICRSZWdFeHAgPSBmdW5jdGlvbiBSZWdFeHAocCwgZikge1xuICAgIHZhciB0aVJFID0gdGhpcyBpbnN0YW5jZW9mICRSZWdFeHA7XG4gICAgdmFyIHBpUkUgPSBpc1JlZ0V4cChwKTtcbiAgICB2YXIgZmlVID0gZiA9PT0gdW5kZWZpbmVkO1xuICAgIHJldHVybiAhdGlSRSAmJiBwaVJFICYmIHAuY29uc3RydWN0b3IgPT09ICRSZWdFeHAgJiYgZmlVID8gcFxuICAgICAgOiBpbmhlcml0SWZSZXF1aXJlZChDT1JSRUNUX05FV1xuICAgICAgICA/IG5ldyBCYXNlKHBpUkUgJiYgIWZpVSA/IHAuc291cmNlIDogcCwgZilcbiAgICAgICAgOiBCYXNlKChwaVJFID0gcCBpbnN0YW5jZW9mICRSZWdFeHApID8gcC5zb3VyY2UgOiBwLCBwaVJFICYmIGZpVSA/ICRmbGFncy5jYWxsKHApIDogZilcbiAgICAgICwgdGlSRSA/IHRoaXMgOiBwcm90bywgJFJlZ0V4cCk7XG4gIH07XG4gIHZhciBwcm94eSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBrZXkgaW4gJFJlZ0V4cCB8fCBkUCgkUmVnRXhwLCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQmFzZVtrZXldOyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAoaXQpIHsgQmFzZVtrZXldID0gaXQ7IH1cbiAgICB9KTtcbiAgfTtcbiAgZm9yICh2YXIga2V5cyA9IGdPUE4oQmFzZSksIGkgPSAwOyBrZXlzLmxlbmd0aCA+IGk7KSBwcm94eShrZXlzW2krK10pO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICRSZWdFeHA7XG4gICRSZWdFeHAucHJvdG90eXBlID0gcHJvdG87XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCAnUmVnRXhwJywgJFJlZ0V4cCk7XG59XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ1JlZ0V4cCcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yLmpzIiwiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi9lczYucmVnZXhwLmZsYWdzJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciAkZmxhZ3MgPSByZXF1aXJlKCcuL19mbGFncycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyICR0b1N0cmluZyA9IC8uL1tUT19TVFJJTkddO1xuXG52YXIgZGVmaW5lID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoUmVnRXhwLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmbiwgdHJ1ZSk7XG59O1xuXG4vLyAyMS4yLjUuMTQgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZygpXG5pZiAocmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7IHJldHVybiAkdG9TdHJpbmcuY2FsbCh7IHNvdXJjZTogJ2EnLCBmbGFnczogJ2InIH0pICE9ICcvYS9iJzsgfSkpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciBSID0gYW5PYmplY3QodGhpcyk7XG4gICAgcmV0dXJuICcvJy5jb25jYXQoUi5zb3VyY2UsICcvJyxcbiAgICAgICdmbGFncycgaW4gUiA/IFIuZmxhZ3MgOiAhREVTQ1JJUFRPUlMgJiYgUiBpbnN0YW5jZW9mIFJlZ0V4cCA/ICRmbGFncy5jYWxsKFIpIDogdW5kZWZpbmVkKTtcbiAgfSk7XG4vLyBGRjQ0LSBSZWdFeHAjdG9TdHJpbmcgaGFzIGEgd3JvbmcgbmFtZVxufSBlbHNlIGlmICgkdG9TdHJpbmcubmFtZSAhPSBUT19TVFJJTkcpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbiAgfSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAudG8tc3RyaW5nLmpzIiwiLy8gQEBtYXRjaCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdtYXRjaCcsIDEsIGZ1bmN0aW9uIChkZWZpbmVkLCBNQVRDSCwgJG1hdGNoKSB7XG4gIC8vIDIxLjEuMy4xMSBTdHJpbmcucHJvdG90eXBlLm1hdGNoKHJlZ2V4cClcbiAgcmV0dXJuIFtmdW5jdGlvbiBtYXRjaChyZWdleHApIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgIHZhciBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbTUFUQ0hdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW01BVENIXShTdHJpbmcoTykpO1xuICB9LCAkbWF0Y2hdO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2guanMiLCIvLyBAQHJlcGxhY2UgbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgncmVwbGFjZScsIDIsIGZ1bmN0aW9uIChkZWZpbmVkLCBSRVBMQUNFLCAkcmVwbGFjZSkge1xuICAvLyAyMS4xLjMuMTQgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpXG4gIHJldHVybiBbZnVuY3Rpb24gcmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICB2YXIgZm4gPSBzZWFyY2hWYWx1ZSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZWFyY2hWYWx1ZVtSRVBMQUNFXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZFxuICAgICAgPyBmbi5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXG4gICAgICA6ICRyZXBsYWNlLmNhbGwoU3RyaW5nKE8pLCBzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKTtcbiAgfSwgJHJlcGxhY2VdO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAucmVwbGFjZS5qcyIsIi8vIEBAc2VhcmNoIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3NlYXJjaCcsIDEsIGZ1bmN0aW9uIChkZWZpbmVkLCBTRUFSQ0gsICRzZWFyY2gpIHtcbiAgLy8gMjEuMS4zLjE1IFN0cmluZy5wcm90b3R5cGUuc2VhcmNoKHJlZ2V4cClcbiAgcmV0dXJuIFtmdW5jdGlvbiBzZWFyY2gocmVnZXhwKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICB2YXIgZm4gPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW1NFQVJDSF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbU0VBUkNIXShTdHJpbmcoTykpO1xuICB9LCAkc2VhcmNoXTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaC5qcyIsIi8vIEBAc3BsaXQgbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnc3BsaXQnLCAyLCBmdW5jdGlvbiAoZGVmaW5lZCwgU1BMSVQsICRzcGxpdCkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xuICB2YXIgX3NwbGl0ID0gJHNwbGl0O1xuICB2YXIgJHB1c2ggPSBbXS5wdXNoO1xuICB2YXIgJFNQTElUID0gJ3NwbGl0JztcbiAgdmFyIExFTkdUSCA9ICdsZW5ndGgnO1xuICB2YXIgTEFTVF9JTkRFWCA9ICdsYXN0SW5kZXgnO1xuICBpZiAoXG4gICAgJ2FiYmMnWyRTUExJVF0oLyhiKSovKVsxXSA9PSAnYycgfHxcbiAgICAndGVzdCdbJFNQTElUXSgvKD86KS8sIC0xKVtMRU5HVEhdICE9IDQgfHxcbiAgICAnYWInWyRTUExJVF0oLyg/OmFiKSovKVtMRU5HVEhdICE9IDIgfHxcbiAgICAnLidbJFNQTElUXSgvKC4/KSguPykvKVtMRU5HVEhdICE9IDQgfHxcbiAgICAnLidbJFNQTElUXSgvKCkoKS8pW0xFTkdUSF0gPiAxIHx8XG4gICAgJydbJFNQTElUXSgvLj8vKVtMRU5HVEhdXG4gICkge1xuICAgIHZhciBOUENHID0gLygpPz8vLmV4ZWMoJycpWzFdID09PSB1bmRlZmluZWQ7IC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG4gICAgLy8gYmFzZWQgb24gZXM1LXNoaW0gaW1wbGVtZW50YXRpb24sIG5lZWQgdG8gcmV3b3JrIGl0XG4gICAgJHNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcodGhpcyk7XG4gICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDApIHJldHVybiBbXTtcbiAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICBpZiAoIWlzUmVnRXhwKHNlcGFyYXRvcikpIHJldHVybiBfc3BsaXQuY2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgdmFyIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IudW5pY29kZSA/ICd1JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnN0aWNreSA/ICd5JyA6ICcnKTtcbiAgICAgIHZhciBsYXN0TGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBzcGxpdExpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IDQyOTQ5NjcyOTUgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICB2YXIgc2VwYXJhdG9yQ29weSA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgdmFyIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGgsIGk7XG4gICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgIGlmICghTlBDRykgc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoJ14nICsgc2VwYXJhdG9yQ29weS5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvckNvcHkuZXhlYyhzdHJpbmcpKSB7XG4gICAgICAgIC8vIGBzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXVtMRU5HVEhdO1xuICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvciBOUENHXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvb3AtZnVuY1xuICAgICAgICAgIGlmICghTlBDRyAmJiBtYXRjaFtMRU5HVEhdID4gMSkgbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzW0xFTkdUSF0gLSAyOyBpKyspIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKG1hdGNoW0xFTkdUSF0gPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nW0xFTkdUSF0pICRwdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXVtMRU5HVEhdO1xuICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgaWYgKG91dHB1dFtMRU5HVEhdID49IHNwbGl0TGltaXQpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdID09PSBtYXRjaC5pbmRleCkgc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICB9XG4gICAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nW0xFTkdUSF0pIHtcbiAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvckNvcHkudGVzdCgnJykpIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgIH0gZWxzZSBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgICAgcmV0dXJuIG91dHB1dFtMRU5HVEhdID4gc3BsaXRMaW1pdCA/IG91dHB1dC5zbGljZSgwLCBzcGxpdExpbWl0KSA6IG91dHB1dDtcbiAgICB9O1xuICAvLyBDaGFrcmEsIFY4XG4gIH0gZWxzZSBpZiAoJzAnWyRTUExJVF0odW5kZWZpbmVkLCAwKVtMRU5HVEhdKSB7XG4gICAgJHNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHJldHVybiBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCA/IFtdIDogX3NwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbiAgfVxuICAvLyAyMS4xLjMuMTcgU3RyaW5nLnByb3RvdHlwZS5zcGxpdChzZXBhcmF0b3IsIGxpbWl0KVxuICByZXR1cm4gW2Z1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgdmFyIGZuID0gc2VwYXJhdG9yID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlcGFyYXRvcltTUExJVF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHNlcGFyYXRvciwgTywgbGltaXQpIDogJHNwbGl0LmNhbGwoU3RyaW5nKE8pLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgfSwgJHNwbGl0XTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNwbGl0LmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi9fcGVyZm9ybScpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG52YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciAkUHJvbWlzZSA9IGdsb2JhbFtQUk9NSVNFXTtcbnZhciBpc05vZGUgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJztcbnZhciBlbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBJbnRlcm5hbCwgbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5LCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgV3JhcHBlcjtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmY7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgLy8gY29ycmVjdCBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gICAgdmFyIHByb21pc2UgPSAkUHJvbWlzZS5yZXNvbHZlKDEpO1xuICAgIHZhciBGYWtlUHJvbWlzZSA9IChwcm9taXNlLmNvbnN0cnVjdG9yID0ge30pW3JlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyldID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICAgIGV4ZWMoZW1wdHksIGVtcHR5KTtcbiAgICB9O1xuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICByZXR1cm4gKGlzTm9kZSB8fCB0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID09ICdmdW5jdGlvbicpICYmIHByb21pc2UudGhlbihlbXB0eSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChwcm9taXNlLCBpc1JlamVjdCkge1xuICBpZiAocHJvbWlzZS5fbikgcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciBvayA9IHByb21pc2UuX3MgPT0gMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uIChyZWFjdGlvbikge1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbDtcbiAgICAgIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgICAgIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gICAgICB2YXIgZG9tYWluID0gcmVhY3Rpb24uZG9tYWluO1xuICAgICAgdmFyIHJlc3VsdCwgdGhlbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2ggPT0gMikgb25IYW5kbGVVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlLl9oID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaSkgcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIHByb21pc2UuX2MgPSBbXTtcbiAgICBwcm9taXNlLl9uID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFwcm9taXNlLl9oKSBvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIHVuaGFuZGxlZCA9IGlzVW5oYW5kbGVkKHByb21pc2UpO1xuICAgIHZhciByZXN1bHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYgKHVuaGFuZGxlZCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKSB7XG4gICAgICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWUgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgcHJvbWlzZS5faCA9IGlzTm9kZSB8fCBpc1VuaGFuZGxlZChwcm9taXNlKSA/IDIgOiAxO1xuICAgIH0gcHJvbWlzZS5fYSA9IHVuZGVmaW5lZDtcbiAgICBpZiAodW5oYW5kbGVkICYmIHJlc3VsdC5lKSB0aHJvdyByZXN1bHQudjtcbiAgfSk7XG59O1xudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgaWYgKHByb21pc2UuX2ggPT0gMSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9hIHx8IHByb21pc2UuX2M7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlYWN0aW9uO1xuICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaSkge1xuICAgIHJlYWN0aW9uID0gY2hhaW5baSsrXTtcbiAgICBpZiAocmVhY3Rpb24uZmFpbCB8fCAhaXNVbmhhbmRsZWQocmVhY3Rpb24ucHJvbWlzZSkpIHJldHVybiBmYWxzZTtcbiAgfSByZXR1cm4gdHJ1ZTtcbn07XG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCkge1xuICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogcHJvbWlzZS5fdiB9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICBwcm9taXNlLl92ID0gdmFsdWU7XG4gIHByb21pc2UuX3MgPSAyO1xuICBpZiAoIXByb21pc2UuX2EpIHByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICB2YXIgdGhlbjtcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICB0cnkge1xuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSkge1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfTsgLy8gd3JhcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAkcmVqZWN0LmNhbGwoeyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XG4gICAgYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICBJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHRoaXMsIDEpLCBjdHgoJHJlamVjdCwgdGhpcywgMSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgdGhpcy5fYyA9IFtdOyAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICB0aGlzLl9hID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXG4gICAgdGhpcy5fcyA9IDA7ICAgICAgICAgICAgICAvLyA8LSBzdGF0ZVxuICAgIHRoaXMuX2QgPSBmYWxzZTsgICAgICAgICAgLy8gPC0gZG9uZVxuICAgIHRoaXMuX3YgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gdmFsdWVcbiAgICB0aGlzLl9oID0gMDsgICAgICAgICAgICAgIC8vIDwtIHJlamVjdGlvbiBzdGF0ZSwgMCAtIGRlZmF1bHQsIDEgLSBoYW5kbGVkLCAyIC0gdW5oYW5kbGVkXG4gICAgdGhpcy5fbiA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBub3RpZnlcbiAgfTtcbiAgSW50ZXJuYWwucHJvdG90eXBlID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJykoJFByb21pc2UucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX2EpIHRoaXMuX2EucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fcykgbm90aWZ5KHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIE93blByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IEludGVybmFsKCk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ID0gY3R4KCRyZWplY3QsIHByb21pc2UsIDEpO1xuICB9O1xuICBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICAgIHJldHVybiBDID09PSAkUHJvbWlzZSB8fCBDID09PSBXcmFwcGVyXG4gICAgICA/IG5ldyBPd25Qcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgOiBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgUHJvbWlzZTogJFByb21pc2UgfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpO1xuICAgIHZhciAkJHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShMSUJSQVJZICYmIHRoaXMgPT09IFdyYXBwZXIgPyAkUHJvbWlzZSA6IHRoaXMsIHgpO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24gKGl0ZXIpIHtcbiAgJFByb21pc2UuYWxsKGl0ZXIpWydjYXRjaCddKGVtcHR5KTtcbn0pKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuMSBQcm9taXNlLmFsbChpdGVyYWJsZSlcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB2YXIgJGluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSByZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzWyRpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciB3ZWFrID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi13ZWFrJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgV0VBS19TRVQgPSAnV2Vha1NldCc7XG5cbi8vIDIzLjQgV2Vha1NldCBPYmplY3RzXG5yZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoV0VBS19TRVQsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtTZXQoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy40LjMuMSBXZWFrU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHZhbGlkYXRlKHRoaXMsIFdFQUtfU0VUKSwgdmFsdWUsIHRydWUpO1xuICB9XG59LCB3ZWFrLCBmYWxzZSwgdHJ1ZSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLXNldC5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHR5cGVkID0gcmVxdWlyZSgnLi9fdHlwZWQnKTtcbnZhciBidWZmZXIgPSByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIEFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuQXJyYXlCdWZmZXI7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyICRBcnJheUJ1ZmZlciA9IGJ1ZmZlci5BcnJheUJ1ZmZlcjtcbnZhciAkRGF0YVZpZXcgPSBidWZmZXIuRGF0YVZpZXc7XG52YXIgJGlzVmlldyA9ICR0eXBlZC5BQlYgJiYgQXJyYXlCdWZmZXIuaXNWaWV3O1xudmFyICRzbGljZSA9ICRBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2U7XG52YXIgVklFVyA9ICR0eXBlZC5WSUVXO1xudmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEFycmF5QnVmZmVyICE9PSAkQXJyYXlCdWZmZXIpLCB7IEFycmF5QnVmZmVyOiAkQXJyYXlCdWZmZXIgfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISR0eXBlZC5DT05TVFIsIEFSUkFZX0JVRkZFUiwge1xuICAvLyAyNC4xLjMuMSBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJnKVxuICBpc1ZpZXc6IGZ1bmN0aW9uIGlzVmlldyhpdCkge1xuICAgIHJldHVybiAkaXNWaWV3ICYmICRpc1ZpZXcoaXQpIHx8IGlzT2JqZWN0KGl0KSAmJiBWSUVXIGluIGl0O1xuICB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlUgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICFuZXcgJEFycmF5QnVmZmVyKDIpLnNsaWNlKDEsIHVuZGVmaW5lZCkuYnl0ZUxlbmd0aDtcbn0pLCBBUlJBWV9CVUZGRVIsIHtcbiAgLy8gMjQuMS40LjMgQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgaWYgKCRzbGljZSAhPT0gdW5kZWZpbmVkICYmIGVuZCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJHNsaWNlLmNhbGwoYW5PYmplY3QodGhpcyksIHN0YXJ0KTsgLy8gRkYgZml4XG4gICAgdmFyIGxlbiA9IGFuT2JqZWN0KHRoaXMpLmJ5dGVMZW5ndGg7XG4gICAgdmFyIGZpcnN0ID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW4pO1xuICAgIHZhciBmaW5hbCA9IHRvQWJzb2x1dGVJbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IGVuZCwgbGVuKTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJEFycmF5QnVmZmVyKSkodG9MZW5ndGgoZmluYWwgLSBmaXJzdCkpO1xuICAgIHZhciB2aWV3UyA9IG5ldyAkRGF0YVZpZXcodGhpcyk7XG4gICAgdmFyIHZpZXdUID0gbmV3ICREYXRhVmlldyhyZXN1bHQpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgd2hpbGUgKGZpcnN0IDwgZmluYWwpIHtcbiAgICAgIHZpZXdULnNldFVpbnQ4KGluZGV4KyssIHZpZXdTLmdldFVpbnQ4KGZpcnN0KyspKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKEFSUkFZX0JVRkZFUik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5hcnJheS1idWZmZXIuanMiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fdHlwZWQnKS5BQlYsIHtcbiAgRGF0YVZpZXc6IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpLkRhdGFWaWV3XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmRhdGEtdmlldy5qcyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXkuanMiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50OCcsIDEsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWFycmF5LmpzIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhDbGFtcGVkQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0sIHRydWUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtY2xhbXBlZC1hcnJheS5qcyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDE2JywgMiwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXkuanMiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50MTYnLCAyLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5LmpzIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheS5qcyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQzMicsIDQsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXkuanMiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdGbG9hdDMyJywgNCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDMyLWFycmF5LmpzIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnRmxvYXQ2NCcsIDgsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBGbG9hdDY0QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQ2NC1hcnJheS5qcyIsIi8vIDI2LjEuMSBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciByQXBwbHkgPSAocmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdCB8fCB7fSkuYXBwbHk7XG52YXIgZkFwcGx5ID0gRnVuY3Rpb24uYXBwbHk7XG4vLyBNUyBFZGdlIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByQXBwbHkoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbn0pLCAnUmVmbGVjdCcsIHtcbiAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KSB7XG4gICAgdmFyIFQgPSBhRnVuY3Rpb24odGFyZ2V0KTtcbiAgICB2YXIgTCA9IGFuT2JqZWN0KGFyZ3VtZW50c0xpc3QpO1xuICAgIHJldHVybiByQXBwbHkgPyByQXBwbHkoVCwgdGhpc0FyZ3VtZW50LCBMKSA6IGZBcHBseS5jYWxsKFQsIHRoaXNBcmd1bWVudCwgTCk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5hcHBseS5qcyIsIi8vIDI2LjEuMiBSZWZsZWN0LmNvbnN0cnVjdCh0YXJnZXQsIGFyZ3VtZW50c0xpc3QgWywgbmV3VGFyZ2V0XSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL19iaW5kJyk7XG52YXIgckNvbnN0cnVjdCA9IChyZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0IHx8IHt9KS5jb25zdHJ1Y3Q7XG5cbi8vIE1TIEVkZ2Ugc3VwcG9ydHMgb25seSAyIGFyZ3VtZW50cyBhbmQgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuLy8gRkYgTmlnaHRseSBzZXRzIHRoaXJkIGFyZ3VtZW50IGFzIGBuZXcudGFyZ2V0YCwgYnV0IGRvZXMgbm90IGNyZWF0ZSBgdGhpc2AgZnJvbSBpdFxudmFyIE5FV19UQVJHRVRfQlVHID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiAhKHJDb25zdHJ1Y3QoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCBbXSwgRikgaW5zdGFuY2VvZiBGKTtcbn0pO1xudmFyIEFSR1NfQlVHID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgckNvbnN0cnVjdChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE5FV19UQVJHRVRfQlVHIHx8IEFSR1NfQlVHKSwgJ1JlZmxlY3QnLCB7XG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gY29uc3RydWN0KFRhcmdldCwgYXJncyAvKiAsIG5ld1RhcmdldCAqLykge1xuICAgIGFGdW5jdGlvbihUYXJnZXQpO1xuICAgIGFuT2JqZWN0KGFyZ3MpO1xuICAgIHZhciBuZXdUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IFRhcmdldCA6IGFGdW5jdGlvbihhcmd1bWVudHNbMl0pO1xuICAgIGlmIChBUkdTX0JVRyAmJiAhTkVXX1RBUkdFVF9CVUcpIHJldHVybiByQ29uc3RydWN0KFRhcmdldCwgYXJncywgbmV3VGFyZ2V0KTtcbiAgICBpZiAoVGFyZ2V0ID09IG5ld1RhcmdldCkge1xuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBvcHRpbWl6YXRpb24gZm9yIDAtNCBhcmd1bWVudHNcbiAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IFRhcmdldCgpO1xuICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0pO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgfVxuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBsb3Qgb2YgYXJndW1lbnRzIGNhc2VcbiAgICAgIHZhciAkYXJncyA9IFtudWxsXTtcbiAgICAgICRhcmdzLnB1c2guYXBwbHkoJGFyZ3MsIGFyZ3MpO1xuICAgICAgcmV0dXJuIG5ldyAoYmluZC5hcHBseShUYXJnZXQsICRhcmdzKSkoKTtcbiAgICB9XG4gICAgLy8gd2l0aCBhbHRlcmVkIG5ld1RhcmdldCwgbm90IHN1cHBvcnQgYnVpbHQtaW4gY29uc3RydWN0b3JzXG4gICAgdmFyIHByb3RvID0gbmV3VGFyZ2V0LnByb3RvdHlwZTtcbiAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGUoaXNPYmplY3QocHJvdG8pID8gcHJvdG8gOiBPYmplY3QucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gRnVuY3Rpb24uYXBwbHkuY2FsbChUYXJnZXQsIGluc3RhbmNlLCBhcmdzKTtcbiAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IGluc3RhbmNlO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuY29uc3RydWN0LmpzIiwiLy8gMjYuMS4zIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcylcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG5cbi8vIE1TIEVkZ2UgaGFzIGJyb2tlbiBSZWZsZWN0LmRlZmluZVByb3BlcnR5IC0gdGhyb3dpbmcgaW5zdGVhZCBvZiByZXR1cm5pbmcgZmFsc2VcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KGRQLmYoe30sIDEsIHsgdmFsdWU6IDEgfSksIDEsIHsgdmFsdWU6IDIgfSk7XG59KSwgJ1JlZmxlY3QnLCB7XG4gIGRlZmluZVByb3BlcnR5OiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKSB7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICBwcm9wZXJ0eUtleSA9IHRvUHJpbWl0aXZlKHByb3BlcnR5S2V5LCB0cnVlKTtcbiAgICBhbk9iamVjdChhdHRyaWJ1dGVzKTtcbiAgICB0cnkge1xuICAgICAgZFAuZih0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCIvLyAyNi4xLjQgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICB2YXIgZGVzYyA9IGdPUEQoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICAgIHJldHVybiBkZXNjICYmICFkZXNjLmNvbmZpZ3VyYWJsZSA/IGZhbHNlIDogZGVsZXRlIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5kZWxldGUtcHJvcGVydHkuanMiLCIndXNlIHN0cmljdCc7XG4vLyAyNi4xLjUgUmVmbGVjdC5lbnVtZXJhdGUodGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIEVudW1lcmF0ZSA9IGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICB0aGlzLl90ID0gYW5PYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB2YXIga2V5cyA9IHRoaXMuX2sgPSBbXTsgICAgICAvLyBrZXlzXG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIGl0ZXJhdGVkKSBrZXlzLnB1c2goa2V5KTtcbn07XG5yZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpKEVudW1lcmF0ZSwgJ09iamVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuICB2YXIga2V5cyA9IHRoYXQuX2s7XG4gIHZhciBrZXk7XG4gIGRvIHtcbiAgICBpZiAodGhhdC5faSA+PSBrZXlzLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9IHdoaWxlICghKChrZXkgPSBrZXlzW3RoYXQuX2krK10pIGluIHRoYXQuX3QpKTtcbiAgcmV0dXJuIHsgdmFsdWU6IGtleSwgZG9uZTogZmFsc2UgfTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGVudW1lcmF0ZTogZnVuY3Rpb24gZW51bWVyYXRlKHRhcmdldCkge1xuICAgIHJldHVybiBuZXcgRW51bWVyYXRlKHRhcmdldCk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUuanMiLCIvLyAyNi4xLjYgUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSBbLCByZWNlaXZlcl0pXG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuZnVuY3Rpb24gZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkgLyogLCByZWNlaXZlciAqLykge1xuICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IGFyZ3VtZW50c1syXTtcbiAgdmFyIGRlc2MsIHByb3RvO1xuICBpZiAoYW5PYmplY3QodGFyZ2V0KSA9PT0gcmVjZWl2ZXIpIHJldHVybiB0YXJnZXRbcHJvcGVydHlLZXldO1xuICBpZiAoZGVzYyA9IGdPUEQuZih0YXJnZXQsIHByb3BlcnR5S2V5KSkgcmV0dXJuIGhhcyhkZXNjLCAndmFsdWUnKVxuICAgID8gZGVzYy52YWx1ZVxuICAgIDogZGVzYy5nZXQgIT09IHVuZGVmaW5lZFxuICAgICAgPyBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIGlmIChpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKSByZXR1cm4gZ2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgcmVjZWl2ZXIpO1xufVxuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7IGdldDogZ2V0IH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQuanMiLCIvLyAyNi4xLjcgUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgcmV0dXJuIGdPUEQuZihhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCIvLyAyNi4xLjggUmVmbGVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGdldFByb3RvID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKHRhcmdldCkge1xuICAgIHJldHVybiBnZXRQcm90byhhbk9iamVjdCh0YXJnZXQpKTtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCIvLyAyNi4xLjkgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgaGFzOiBmdW5jdGlvbiBoYXModGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHJldHVybiBwcm9wZXJ0eUtleSBpbiB0YXJnZXQ7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5oYXMuanMiLCIvLyAyNi4xLjEwIFJlZmxlY3QuaXNFeHRlbnNpYmxlKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciAkaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBpc0V4dGVuc2libGU6IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZSh0YXJnZXQpIHtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHJldHVybiAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZSh0YXJnZXQpIDogdHJ1ZTtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUuanMiLCIvLyAyNi4xLjExIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7IG93bktleXM6IHJlcXVpcmUoJy4vX293bi1rZXlzJykgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzLmpzIiwiLy8gMjYuMS4xMiBSZWZsZWN0LnByZXZlbnRFeHRlbnNpb25zKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciAkcHJldmVudEV4dGVuc2lvbnMgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgcHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCkge1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICgkcHJldmVudEV4dGVuc2lvbnMpICRwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qcyIsIi8vIDI2LjEuMTMgUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgViBbLCByZWNlaXZlcl0pXG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWIC8qICwgcmVjZWl2ZXIgKi8pIHtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDQgPyB0YXJnZXQgOiBhcmd1bWVudHNbM107XG4gIHZhciBvd25EZXNjID0gZ09QRC5mKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgdmFyIGV4aXN0aW5nRGVzY3JpcHRvciwgcHJvdG87XG4gIGlmICghb3duRGVzYykge1xuICAgIGlmIChpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKSB7XG4gICAgICByZXR1cm4gc2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgViwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgICBvd25EZXNjID0gY3JlYXRlRGVzYygwKTtcbiAgfVxuICBpZiAoaGFzKG93bkRlc2MsICd2YWx1ZScpKSB7XG4gICAgaWYgKG93bkRlc2Mud3JpdGFibGUgPT09IGZhbHNlIHx8ICFpc09iamVjdChyZWNlaXZlcikpIHJldHVybiBmYWxzZTtcbiAgICBleGlzdGluZ0Rlc2NyaXB0b3IgPSBnT1BELmYocmVjZWl2ZXIsIHByb3BlcnR5S2V5KSB8fCBjcmVhdGVEZXNjKDApO1xuICAgIGV4aXN0aW5nRGVzY3JpcHRvci52YWx1ZSA9IFY7XG4gICAgZFAuZihyZWNlaXZlciwgcHJvcGVydHlLZXksIGV4aXN0aW5nRGVzY3JpcHRvcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIG93bkRlc2Muc2V0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IChvd25EZXNjLnNldC5jYWxsKHJlY2VpdmVyLCBWKSwgdHJ1ZSk7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHsgc2V0OiBzZXQgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC5qcyIsIi8vIDI2LjEuMTQgUmVmbGVjdC5zZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBzZXRQcm90byA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpO1xuXG5pZiAoc2V0UHJvdG8pICRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgc2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pIHtcbiAgICBzZXRQcm90by5jaGVjayh0YXJnZXQsIHByb3RvKTtcbiAgICB0cnkge1xuICAgICAgc2V0UHJvdG8uc2V0KHRhcmdldCwgcHJvdG8pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9BcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKGVsIC8qICwgZnJvbUluZGV4ID0gMCAqLykge1xuICAgIHJldHVybiAkaW5jbHVkZXModGhpcywgZWwsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdpbmNsdWRlcycpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanMiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLWZsYXRNYXAvI3NlYy1BcnJheS5wcm90b3R5cGUuZmxhdE1hcFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBmbGF0dGVuSW50b0FycmF5ID0gcmVxdWlyZSgnLi9fZmxhdHRlbi1pbnRvLWFycmF5Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBmbGF0TWFwOiBmdW5jdGlvbiBmbGF0TWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgc291cmNlTGVuLCBBO1xuICAgIGFGdW5jdGlvbihjYWxsYmFja2ZuKTtcbiAgICBzb3VyY2VMZW4gPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgQSA9IGFycmF5U3BlY2llc0NyZWF0ZShPLCAwKTtcbiAgICBmbGF0dGVuSW50b0FycmF5KEEsIE8sIE8sIHNvdXJjZUxlbiwgMCwgMSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgICByZXR1cm4gQTtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdmbGF0TWFwJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5mbGF0LW1hcC5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtZmxhdE1hcC8jc2VjLUFycmF5LnByb3RvdHlwZS5mbGF0dGVuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGZsYXR0ZW5JbnRvQXJyYXkgPSByZXF1aXJlKCcuL19mbGF0dGVuLWludG8tYXJyYXknKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7XG4gIGZsYXR0ZW46IGZ1bmN0aW9uIGZsYXR0ZW4oLyogZGVwdGhBcmcgPSAxICovKSB7XG4gICAgdmFyIGRlcHRoQXJnID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIHNvdXJjZUxlbiA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgQSA9IGFycmF5U3BlY2llc0NyZWF0ZShPLCAwKTtcbiAgICBmbGF0dGVuSW50b0FycmF5KEEsIE8sIE8sIHNvdXJjZUxlbiwgMCwgZGVwdGhBcmcgPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGhBcmcpKTtcbiAgICByZXR1cm4gQTtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdmbGF0dGVuJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5mbGF0dGVuLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIGF0OiBmdW5jdGlvbiBhdChwb3MpIHtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLmF0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhZCA9IHJlcXVpcmUoJy4vX3N0cmluZy1wYWQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIHBhZFN0YXJ0OiBmdW5jdGlvbiBwYWRTdGFydChtYXhMZW5ndGggLyogLCBmaWxsU3RyaW5nID0gJyAnICovKSB7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydC5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYWQgPSByZXF1aXJlKCcuL19zdHJpbmctcGFkJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBwYWRFbmQ6IGZ1bmN0aW9uIHBhZEVuZChtYXhMZW5ndGggLyogLCBmaWxsU3RyaW5nID0gJyAnICovKSB7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgZmFsc2UpO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtZW5kLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbUxlZnQnLCBmdW5jdGlvbiAoJHRyaW0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW1MZWZ0KCkge1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAxKTtcbiAgfTtcbn0sICd0cmltU3RhcnQnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQuanMiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2VibWFya2JhZ2UvZWNtYXNjcmlwdC1zdHJpbmctbGVmdC1yaWdodC10cmltXG5yZXF1aXJlKCcuL19zdHJpbmctdHJpbScpKCd0cmltUmlnaHQnLCBmdW5jdGlvbiAoJHRyaW0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW1SaWdodCgpIHtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMik7XG4gIH07XG59LCAndHJpbUVuZCcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tcmlnaHQuanMiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL1N0cmluZy5wcm90b3R5cGUubWF0Y2hBbGwvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xudmFyIGdldEZsYWdzID0gcmVxdWlyZSgnLi9fZmxhZ3MnKTtcbnZhciBSZWdFeHBQcm90byA9IFJlZ0V4cC5wcm90b3R5cGU7XG5cbnZhciAkUmVnRXhwU3RyaW5nSXRlcmF0b3IgPSBmdW5jdGlvbiAocmVnZXhwLCBzdHJpbmcpIHtcbiAgdGhpcy5fciA9IHJlZ2V4cDtcbiAgdGhpcy5fcyA9IHN0cmluZztcbn07XG5cbnJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJykoJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yLCAnUmVnRXhwIFN0cmluZycsIGZ1bmN0aW9uIG5leHQoKSB7XG4gIHZhciBtYXRjaCA9IHRoaXMuX3IuZXhlYyh0aGlzLl9zKTtcbiAgcmV0dXJuIHsgdmFsdWU6IG1hdGNoLCBkb25lOiBtYXRjaCA9PT0gbnVsbCB9O1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBtYXRjaEFsbDogZnVuY3Rpb24gbWF0Y2hBbGwocmVnZXhwKSB7XG4gICAgZGVmaW5lZCh0aGlzKTtcbiAgICBpZiAoIWlzUmVnRXhwKHJlZ2V4cCkpIHRocm93IFR5cGVFcnJvcihyZWdleHAgKyAnIGlzIG5vdCBhIHJlZ2V4cCEnKTtcbiAgICB2YXIgUyA9IFN0cmluZyh0aGlzKTtcbiAgICB2YXIgZmxhZ3MgPSAnZmxhZ3MnIGluIFJlZ0V4cFByb3RvID8gU3RyaW5nKHJlZ2V4cC5mbGFncykgOiBnZXRGbGFncy5jYWxsKHJlZ2V4cCk7XG4gICAgdmFyIHJ4ID0gbmV3IFJlZ0V4cChyZWdleHAuc291cmNlLCB+ZmxhZ3MuaW5kZXhPZignZycpID8gZmxhZ3MgOiAnZycgKyBmbGFncyk7XG4gICAgcngubGFzdEluZGV4ID0gdG9MZW5ndGgocmVnZXhwLmxhc3RJbmRleCk7XG4gICAgcmV0dXJuIG5ldyAkUmVnRXhwU3RyaW5nSXRlcmF0b3IocngsIFMpO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5tYXRjaC1hbGwuanMiLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUuanMiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBvd25LZXlzID0gcmVxdWlyZSgnLi9fb3duLWtleXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqZWN0KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgICB2YXIgZ2V0RGVzYyA9IGdPUEQuZjtcbiAgICB2YXIga2V5cyA9IG93bktleXMoTyk7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIga2V5LCBkZXNjO1xuICAgIHdoaWxlIChrZXlzLmxlbmd0aCA+IGkpIHtcbiAgICAgIGRlc2MgPSBnZXREZXNjKE8sIGtleSA9IGtleXNbaSsrXSk7XG4gICAgICBpZiAoZGVzYyAhPT0gdW5kZWZpbmVkKSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGtleSwgZGVzYyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMuanMiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtdmFsdWVzLWVudHJpZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHZhbHVlcyA9IHJlcXVpcmUoJy4vX29iamVjdC10by1hcnJheScpKGZhbHNlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKGl0KSB7XG4gICAgcmV0dXJuICR2YWx1ZXMoaXQpO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMuanMiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtdmFsdWVzLWVudHJpZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGVudHJpZXMgPSByZXF1aXJlKCcuL19vYmplY3QtdG8tYXJyYXknKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoaXQpIHtcbiAgICByZXR1cm4gJGVudHJpZXMoaXQpO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcblxuLy8gQi4yLjIuMiBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX18oUCwgZ2V0dGVyKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fZGVmaW5lR2V0dGVyX186IGZ1bmN0aW9uIF9fZGVmaW5lR2V0dGVyX18oUCwgZ2V0dGVyKSB7XG4gICAgJGRlZmluZVByb3BlcnR5LmYodG9PYmplY3QodGhpcyksIFAsIHsgZ2V0OiBhRnVuY3Rpb24oZ2V0dGVyKSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtZ2V0dGVyLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcblxuLy8gQi4yLjIuMyBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lU2V0dGVyX18oUCwgc2V0dGVyKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fZGVmaW5lU2V0dGVyX186IGZ1bmN0aW9uIF9fZGVmaW5lU2V0dGVyX18oUCwgc2V0dGVyKSB7XG4gICAgJGRlZmluZVByb3BlcnR5LmYodG9PYmplY3QodGhpcyksIFAsIHsgc2V0OiBhRnVuY3Rpb24oc2V0dGVyKSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtc2V0dGVyLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG4vLyBCLjIuMi40IE9iamVjdC5wcm90b3R5cGUuX19sb29rdXBHZXR0ZXJfXyhQKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fbG9va3VwR2V0dGVyX186IGZ1bmN0aW9uIF9fbG9va3VwR2V0dGVyX18oUCkge1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIEsgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgICB2YXIgRDtcbiAgICBkbyB7XG4gICAgICBpZiAoRCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBLKSkgcmV0dXJuIEQuZ2V0O1xuICAgIH0gd2hpbGUgKE8gPSBnZXRQcm90b3R5cGVPZihPKSk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXIuanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbi8vIEIuMi4yLjUgT2JqZWN0LnByb3RvdHlwZS5fX2xvb2t1cFNldHRlcl9fKFApXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19sb29rdXBTZXR0ZXJfXzogZnVuY3Rpb24gX19sb29rdXBTZXR0ZXJfXyhQKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgSyA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICAgIHZhciBEO1xuICAgIGRvIHtcbiAgICAgIGlmIChEID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIEspKSByZXR1cm4gRC5zZXQ7XG4gICAgfSB3aGlsZSAoTyA9IGdldFByb3RvdHlwZU9mKE8pKTtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLXNldHRlci5qcyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnTWFwJywgeyB0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdNYXAnKSB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC50by1qc29uLmpzIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdTZXQnLCB7IHRvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ1NldCcpIH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc2V0LnRvLWpzb24uanMiLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1tYXAub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ01hcCcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWFwLm9mLmpzIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtc2V0Lm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdTZXQnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC5vZi5qcyIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWttYXAub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ1dlYWtNYXAnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstbWFwLm9mLmpzIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha3NldC5vZlxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tb2YnKSgnV2Vha1NldCcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcud2Vhay1zZXQub2YuanMiLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1tYXAuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdNYXAnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC5mcm9tLmpzIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtc2V0LmZyb21cbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLWZyb20nKSgnU2V0Jyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQuZnJvbS5qcyIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWttYXAuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdXZWFrTWFwJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLW1hcC5mcm9tLmpzIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha3NldC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ1dlYWtTZXQnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstc2V0LmZyb20uanMiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1nbG9iYWxcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5HLCB7IGdsb2JhbDogcmVxdWlyZSgnLi9fZ2xvYmFsJykgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5nbG9iYWwuanMiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1nbG9iYWxcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnU3lzdGVtJywgeyBnbG9iYWw6IHJlcXVpcmUoJy4vX2dsb2JhbCcpIH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbC5qcyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvcHJvcG9zYWwtaXMtZXJyb3JcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnRXJyb3InLCB7XG4gIGlzRXJyb3I6IGZ1bmN0aW9uIGlzRXJyb3IoaXQpIHtcbiAgICByZXR1cm4gY29mKGl0KSA9PT0gJ0Vycm9yJztcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5lcnJvci5pcy1lcnJvci5qcyIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2xhbXA6IGZ1bmN0aW9uIGNsYW1wKHgsIGxvd2VyLCB1cHBlcikge1xuICAgIHJldHVybiBNYXRoLm1pbih1cHBlciwgTWF0aC5tYXgobG93ZXIsIHgpKTtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmNsYW1wLmpzIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBERUdfUEVSX1JBRDogTWF0aC5QSSAvIDE4MCB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguZGVnLXBlci1yYWQuanMiLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIFJBRF9QRVJfREVHID0gMTgwIC8gTWF0aC5QSTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBkZWdyZWVzOiBmdW5jdGlvbiBkZWdyZWVzKHJhZGlhbnMpIHtcbiAgICByZXR1cm4gcmFkaWFucyAqIFJBRF9QRVJfREVHO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguZGVncmVlcy5qcyIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgc2NhbGUgPSByZXF1aXJlKCcuL19tYXRoLXNjYWxlJyk7XG52YXIgZnJvdW5kID0gcmVxdWlyZSgnLi9fbWF0aC1mcm91bmQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBmc2NhbGU6IGZ1bmN0aW9uIGZzY2FsZSh4LCBpbkxvdywgaW5IaWdoLCBvdXRMb3csIG91dEhpZ2gpIHtcbiAgICByZXR1cm4gZnJvdW5kKHNjYWxlKHgsIGluTG93LCBpbkhpZ2gsIG91dExvdywgb3V0SGlnaCkpO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguZnNjYWxlLmpzIiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaWFkZGg6IGZ1bmN0aW9uIGlhZGRoKHgwLCB4MSwgeTAsIHkxKSB7XG4gICAgdmFyICR4MCA9IHgwID4+PiAwO1xuICAgIHZhciAkeDEgPSB4MSA+Pj4gMDtcbiAgICB2YXIgJHkwID0geTAgPj4+IDA7XG4gICAgcmV0dXJuICR4MSArICh5MSA+Pj4gMCkgKyAoKCR4MCAmICR5MCB8ICgkeDAgfCAkeTApICYgfigkeDAgKyAkeTAgPj4+IDApKSA+Pj4gMzEpIHwgMDtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmlhZGRoLmpzIiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaXN1Ymg6IGZ1bmN0aW9uIGlzdWJoKHgwLCB4MSwgeTAsIHkxKSB7XG4gICAgdmFyICR4MCA9IHgwID4+PiAwO1xuICAgIHZhciAkeDEgPSB4MSA+Pj4gMDtcbiAgICB2YXIgJHkwID0geTAgPj4+IDA7XG4gICAgcmV0dXJuICR4MSAtICh5MSA+Pj4gMCkgLSAoKH4keDAgJiAkeTAgfCB+KCR4MCBeICR5MCkgJiAkeDAgLSAkeTAgPj4+IDApID4+PiAzMSkgfCAwO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaXN1YmguanMiLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpbXVsaDogZnVuY3Rpb24gaW11bGgodSwgdikge1xuICAgIHZhciBVSU5UMTYgPSAweGZmZmY7XG4gICAgdmFyICR1ID0gK3U7XG4gICAgdmFyICR2ID0gK3Y7XG4gICAgdmFyIHUwID0gJHUgJiBVSU5UMTY7XG4gICAgdmFyIHYwID0gJHYgJiBVSU5UMTY7XG4gICAgdmFyIHUxID0gJHUgPj4gMTY7XG4gICAgdmFyIHYxID0gJHYgPj4gMTY7XG4gICAgdmFyIHQgPSAodTEgKiB2MCA+Pj4gMCkgKyAodTAgKiB2MCA+Pj4gMTYpO1xuICAgIHJldHVybiB1MSAqIHYxICsgKHQgPj4gMTYpICsgKCh1MCAqIHYxID4+PiAwKSArICh0ICYgVUlOVDE2KSA+PiAxNik7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pbXVsaC5qcyIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgUkFEX1BFUl9ERUc6IDE4MCAvIE1hdGguUEkgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnJhZC1wZXItZGVnLmpzIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBERUdfUEVSX1JBRCA9IE1hdGguUEkgLyAxODA7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgcmFkaWFuczogZnVuY3Rpb24gcmFkaWFucyhkZWdyZWVzKSB7XG4gICAgcmV0dXJuIGRlZ3JlZXMgKiBERUdfUEVSX1JBRDtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnJhZGlhbnMuanMiLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IHNjYWxlOiByZXF1aXJlKCcuL19tYXRoLXNjYWxlJykgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnNjYWxlLmpzIiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdW11bGg6IGZ1bmN0aW9uIHVtdWxoKHUsIHYpIHtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmO1xuICAgIHZhciAkdSA9ICt1O1xuICAgIHZhciAkdiA9ICt2O1xuICAgIHZhciB1MCA9ICR1ICYgVUlOVDE2O1xuICAgIHZhciB2MCA9ICR2ICYgVUlOVDE2O1xuICAgIHZhciB1MSA9ICR1ID4+PiAxNjtcbiAgICB2YXIgdjEgPSAkdiA+Pj4gMTY7XG4gICAgdmFyIHQgPSAodTEgKiB2MCA+Pj4gMCkgKyAodTAgKiB2MCA+Pj4gMTYpO1xuICAgIHJldHVybiB1MSAqIHYxICsgKHQgPj4+IDE2KSArICgodTAgKiB2MSA+Pj4gMCkgKyAodCAmIFVJTlQxNikgPj4+IDE2KTtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnVtdWxoLmpzIiwiLy8gaHR0cDovL2pmYmFzdGllbi5naXRodWIuaW8vcGFwZXJzL01hdGguc2lnbmJpdC5odG1sXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IHNpZ25iaXQ6IGZ1bmN0aW9uIHNpZ25iaXQoeCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHJldHVybiAoeCA9ICt4KSAhPSB4ID8geCA6IHggPT0gMCA/IDEgLyB4ID09IEluZmluaXR5IDogeCA+IDA7XG59IH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5zaWduYml0LmpzIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS1maW5hbGx5XG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnUHJvbWlzZScsIHsgJ2ZpbmFsbHknOiBmdW5jdGlvbiAob25GaW5hbGx5KSB7XG4gIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIGNvcmUuUHJvbWlzZSB8fCBnbG9iYWwuUHJvbWlzZSk7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIG9uRmluYWxseSA9PSAnZnVuY3Rpb24nO1xuICByZXR1cm4gdGhpcy50aGVuKFxuICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHg7IH0pO1xuICAgIH0gOiBvbkZpbmFsbHksXG4gICAgaXNGdW5jdGlvbiA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyB0aHJvdyBlOyB9KTtcbiAgICB9IDogb25GaW5hbGx5XG4gICk7XG59IH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5LmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS10cnlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG52YXIgcGVyZm9ybSA9IHJlcXVpcmUoJy4vX3BlcmZvcm0nKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdQcm9taXNlJywgeyAndHJ5JzogZnVuY3Rpb24gKGNhbGxiYWNrZm4pIHtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZih0aGlzKTtcbiAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oY2FsbGJhY2tmbik7XG4gIChyZXN1bHQuZSA/IHByb21pc2VDYXBhYmlsaXR5LnJlamVjdCA6IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmUpKHJlc3VsdC52KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59IH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucHJvbWlzZS50cnkuanMiLCJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xudmFyIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5zZXQ7XG5cbm1ldGFkYXRhLmV4cCh7IGRlZmluZU1ldGFkYXRhOiBmdW5jdGlvbiBkZWZpbmVNZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCB0YXJnZXRLZXkpIHtcbiAgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgYW5PYmplY3QodGFyZ2V0KSwgdG9NZXRhS2V5KHRhcmdldEtleSkpO1xufSB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhLmpzIiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcbnZhciBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwID0gbWV0YWRhdGEubWFwO1xudmFyIHN0b3JlID0gbWV0YWRhdGEuc3RvcmU7XG5cbm1ldGFkYXRhLmV4cCh7IGRlbGV0ZU1ldGFkYXRhOiBmdW5jdGlvbiBkZWxldGVNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHZhciB0YXJnZXRLZXkgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pO1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKGFuT2JqZWN0KHRhcmdldCksIHRhcmdldEtleSwgZmFsc2UpO1xuICBpZiAobWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCB8fCAhbWV0YWRhdGFNYXBbJ2RlbGV0ZSddKG1ldGFkYXRhS2V5KSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobWV0YWRhdGFNYXAuc2l6ZSkgcmV0dXJuIHRydWU7XG4gIHZhciB0YXJnZXRNZXRhZGF0YSA9IHN0b3JlLmdldCh0YXJnZXQpO1xuICB0YXJnZXRNZXRhZGF0YVsnZGVsZXRlJ10odGFyZ2V0S2V5KTtcbiAgcmV0dXJuICEhdGFyZ2V0TWV0YWRhdGEuc2l6ZSB8fCBzdG9yZVsnZGVsZXRlJ10odGFyZ2V0KTtcbn0gfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlbGV0ZS1tZXRhZGF0YS5qcyIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzO1xudmFyIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBtZXRhZGF0YS5nZXQ7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlHZXRNZXRhZGF0YSA9IGZ1bmN0aW9uIChNZXRhZGF0YUtleSwgTywgUCkge1xuICB2YXIgaGFzT3duID0gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIGlmIChoYXNPd24pIHJldHVybiBvcmRpbmFyeUdldE93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgdmFyIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICByZXR1cm4gcGFyZW50ICE9PSBudWxsID8gb3JkaW5hcnlHZXRNZXRhZGF0YShNZXRhZGF0YUtleSwgcGFyZW50LCBQKSA6IHVuZGVmaW5lZDtcbn07XG5cbm1ldGFkYXRhLmV4cCh7IGdldE1ldGFkYXRhOiBmdW5jdGlvbiBnZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHJldHVybiBvcmRpbmFyeUdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn0gfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS5qcyIsInZhciBTZXQgPSByZXF1aXJlKCcuL2VzNi5zZXQnKTtcbnZhciBmcm9tID0gcmVxdWlyZSgnLi9fYXJyYXktZnJvbS1pdGVyYWJsZScpO1xudmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5cztcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeU1ldGFkYXRhS2V5cyA9IGZ1bmN0aW9uIChPLCBQKSB7XG4gIHZhciBvS2V5cyA9IG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApO1xuICB2YXIgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIGlmIChwYXJlbnQgPT09IG51bGwpIHJldHVybiBvS2V5cztcbiAgdmFyIHBLZXlzID0gb3JkaW5hcnlNZXRhZGF0YUtleXMocGFyZW50LCBQKTtcbiAgcmV0dXJuIHBLZXlzLmxlbmd0aCA/IG9LZXlzLmxlbmd0aCA/IGZyb20obmV3IFNldChvS2V5cy5jb25jYXQocEtleXMpKSkgOiBwS2V5cyA6IG9LZXlzO1xufTtcblxubWV0YWRhdGEuZXhwKHsgZ2V0TWV0YWRhdGFLZXlzOiBmdW5jdGlvbiBnZXRNZXRhZGF0YUtleXModGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHJldHVybiBvcmRpbmFyeU1ldGFkYXRhS2V5cyhhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMV0pKTtcbn0gfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS1rZXlzLmpzIiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBtZXRhZGF0YS5nZXQ7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoeyBnZXRPd25NZXRhZGF0YTogZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiAsIHRhcmdldEtleSAqLykge1xuICByZXR1cm4gb3JkaW5hcnlHZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KVxuICAgICwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59IH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLmpzIiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5cztcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbm1ldGFkYXRhLmV4cCh7IGdldE93bk1ldGFkYXRhS2V5czogZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGFLZXlzKHRhcmdldCAvKiAsIHRhcmdldEtleSAqLykge1xuICByZXR1cm4gb3JkaW5hcnlPd25NZXRhZGF0YUtleXMoYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzFdKSk7XG59IH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLWtleXMuanMiLCJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhcztcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeUhhc01ldGFkYXRhID0gZnVuY3Rpb24gKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gIHZhciBoYXNPd24gPSBvcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgaWYgKGhhc093bikgcmV0dXJuIHRydWU7XG4gIHZhciBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IG9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCkgOiBmYWxzZTtcbn07XG5cbm1ldGFkYXRhLmV4cCh7IGhhc01ldGFkYXRhOiBmdW5jdGlvbiBoYXNNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHJldHVybiBvcmRpbmFyeUhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn0gfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1tZXRhZGF0YS5qcyIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzO1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcblxubWV0YWRhdGEuZXhwKHsgaGFzT3duTWV0YWRhdGE6IGZ1bmN0aW9uIGhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyogLCB0YXJnZXRLZXkgKi8pIHtcbiAgcmV0dXJuIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldClcbiAgICAsIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufSB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW93bi1tZXRhZGF0YS5qcyIsInZhciAkbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIHRvTWV0YUtleSA9ICRtZXRhZGF0YS5rZXk7XG52YXIgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9ICRtZXRhZGF0YS5zZXQ7XG5cbiRtZXRhZGF0YS5leHAoeyBtZXRhZGF0YTogZnVuY3Rpb24gbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGRlY29yYXRvcih0YXJnZXQsIHRhcmdldEtleSkge1xuICAgIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEoXG4gICAgICBtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSxcbiAgICAgICh0YXJnZXRLZXkgIT09IHVuZGVmaW5lZCA/IGFuT2JqZWN0IDogYUZ1bmN0aW9uKSh0YXJnZXQpLFxuICAgICAgdG9NZXRhS2V5KHRhcmdldEtleSlcbiAgICApO1xuICB9O1xufSB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEuanMiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vcndhbGRyb24vdGMzOS1ub3Rlcy9ibG9iL21hc3Rlci9lczYvMjAxNC0wOS9zZXB0LTI1Lm1kIzUxMC1nbG9iYWxhc2FwLWZvci1lbnF1ZXVpbmctYS1taWNyb3Rhc2tcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcbnZhciBwcm9jZXNzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucHJvY2VzcztcbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbiRleHBvcnQoJGV4cG9ydC5HLCB7XG4gIGFzYXA6IGZ1bmN0aW9uIGFzYXAoZm4pIHtcbiAgICB2YXIgZG9tYWluID0gaXNOb2RlICYmIHByb2Nlc3MuZG9tYWluO1xuICAgIG1pY3JvdGFzayhkb21haW4gPyBkb21haW4uYmluZChmbikgOiBmbik7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXNhcC5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5wYXJzaW5nL2VzLW9ic2VydmFibGVcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBtaWNyb3Rhc2sgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpO1xudmFyIE9CU0VSVkFCTEUgPSByZXF1aXJlKCcuL193a3MnKSgnb2JzZXJ2YWJsZScpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIFJFVFVSTiA9IGZvck9mLlJFVFVSTjtcblxudmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZm4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFGdW5jdGlvbihmbik7XG59O1xuXG52YXIgY2xlYW51cFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgdmFyIGNsZWFudXAgPSBzdWJzY3JpcHRpb24uX2M7XG4gIGlmIChjbGVhbnVwKSB7XG4gICAgc3Vic2NyaXB0aW9uLl9jID0gdW5kZWZpbmVkO1xuICAgIGNsZWFudXAoKTtcbiAgfVxufTtcblxudmFyIHN1YnNjcmlwdGlvbkNsb3NlZCA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgcmV0dXJuIHN1YnNjcmlwdGlvbi5fbyA9PT0gdW5kZWZpbmVkO1xufTtcblxudmFyIGNsb3NlU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICBpZiAoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKSB7XG4gICAgc3Vic2NyaXB0aW9uLl9vID0gdW5kZWZpbmVkO1xuICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgfVxufTtcblxudmFyIFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChvYnNlcnZlciwgc3Vic2NyaWJlcikge1xuICBhbk9iamVjdChvYnNlcnZlcik7XG4gIHRoaXMuX2MgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX28gPSBvYnNlcnZlcjtcbiAgb2JzZXJ2ZXIgPSBuZXcgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIodGhpcyk7XG4gIHRyeSB7XG4gICAgdmFyIGNsZWFudXAgPSBzdWJzY3JpYmVyKG9ic2VydmVyKTtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gY2xlYW51cDtcbiAgICBpZiAoY2xlYW51cCAhPSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIGNsZWFudXAudW5zdWJzY3JpYmUgPT09ICdmdW5jdGlvbicpIGNsZWFudXAgPSBmdW5jdGlvbiAoKSB7IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpOyB9O1xuICAgICAgZWxzZSBhRnVuY3Rpb24oY2xlYW51cCk7XG4gICAgICB0aGlzLl9jID0gY2xlYW51cDtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICByZXR1cm47XG4gIH0gaWYgKHN1YnNjcmlwdGlvbkNsb3NlZCh0aGlzKSkgY2xlYW51cFN1YnNjcmlwdGlvbih0aGlzKTtcbn07XG5cblN1YnNjcmlwdGlvbi5wcm90b3R5cGUgPSByZWRlZmluZUFsbCh7fSwge1xuICB1bnN1YnNjcmliZTogZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7IGNsb3NlU3Vic2NyaXB0aW9uKHRoaXMpOyB9XG59KTtcblxudmFyIFN1YnNjcmlwdGlvbk9ic2VydmVyID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICB0aGlzLl9zID0gc3Vic2NyaXB0aW9uO1xufTtcblxuU3Vic2NyaXB0aW9uT2JzZXJ2ZXIucHJvdG90eXBlID0gcmVkZWZpbmVBbGwoe30sIHtcbiAgbmV4dDogZnVuY3Rpb24gbmV4dCh2YWx1ZSkge1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zO1xuICAgIGlmICghc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpIHtcbiAgICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLm5leHQpO1xuICAgICAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNsb3NlU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKHZhbHVlKSB7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYgKHN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKSB0aHJvdyB2YWx1ZTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX287XG4gICAgc3Vic2NyaXB0aW9uLl9vID0gdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICB2YXIgbSA9IGdldE1ldGhvZChvYnNlcnZlci5lcnJvcik7XG4gICAgICBpZiAoIW0pIHRocm93IHZhbHVlO1xuICAgICAgdmFsdWUgPSBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHZhbHVlKSB7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYgKCFzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSkge1xuICAgICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgICAgc3Vic2NyaXB0aW9uLl9vID0gdW5kZWZpbmVkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIuY29tcGxldGUpO1xuICAgICAgICB2YWx1ZSA9IG0gPyBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKSA6IHVuZGVmaW5lZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfSBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59KTtcblxudmFyICRPYnNlcnZhYmxlID0gZnVuY3Rpb24gT2JzZXJ2YWJsZShzdWJzY3JpYmVyKSB7XG4gIGFuSW5zdGFuY2UodGhpcywgJE9ic2VydmFibGUsICdPYnNlcnZhYmxlJywgJ19mJykuX2YgPSBhRnVuY3Rpb24oc3Vic2NyaWJlcik7XG59O1xuXG5yZWRlZmluZUFsbCgkT2JzZXJ2YWJsZS5wcm90b3R5cGUsIHtcbiAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbihvYnNlcnZlciwgdGhpcy5fZik7XG4gIH0sXG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyAoY29yZS5Qcm9taXNlIHx8IGdsb2JhbC5Qcm9taXNlKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBhRnVuY3Rpb24oZm4pO1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoYXQuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbih2YWx1ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogcmVqZWN0LFxuICAgICAgICBjb21wbGV0ZTogcmVzb2x2ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5yZWRlZmluZUFsbCgkT2JzZXJ2YWJsZSwge1xuICBmcm9tOiBmdW5jdGlvbiBmcm9tKHgpIHtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09PSAnZnVuY3Rpb24nID8gdGhpcyA6ICRPYnNlcnZhYmxlO1xuICAgIHZhciBtZXRob2QgPSBnZXRNZXRob2QoYW5PYmplY3QoeClbT0JTRVJWQUJMRV0pO1xuICAgIGlmIChtZXRob2QpIHtcbiAgICAgIHZhciBvYnNlcnZhYmxlID0gYW5PYmplY3QobWV0aG9kLmNhbGwoeCkpO1xuICAgICAgcmV0dXJuIG9ic2VydmFibGUuY29uc3RydWN0b3IgPT09IEMgPyBvYnNlcnZhYmxlIDogbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZm9yT2YoeCwgZmFsc2UsIGZ1bmN0aW9uIChpdCkge1xuICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0KTtcbiAgICAgICAgICAgICAgaWYgKGRvbmUpIHJldHVybiBSRVRVUk47XG4gICAgICAgICAgICB9KSA9PT0gUkVUVVJOKSByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHRocm93IGU7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgZG9uZSA9IHRydWU7IH07XG4gICAgfSk7XG4gIH0sXG4gIG9mOiBmdW5jdGlvbiBvZigpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZW1zID0gQXJyYXkobCk7IGkgPCBsOykgaXRlbXNbaV0gPSBhcmd1bWVudHNbaSsrXTtcbiAgICByZXR1cm4gbmV3ICh0eXBlb2YgdGhpcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiAkT2JzZXJ2YWJsZSkoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChpdGVtc1tqXSk7XG4gICAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIH0gb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyBkb25lID0gdHJ1ZTsgfTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbmhpZGUoJE9ic2VydmFibGUucHJvdG90eXBlLCBPQlNFUlZBQkxFLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxuJGV4cG9ydCgkZXhwb3J0LkcsIHsgT2JzZXJ2YWJsZTogJE9ic2VydmFibGUgfSk7XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ09ic2VydmFibGUnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9ic2VydmFibGUuanMiLCIvLyBpZTktIHNldFRpbWVvdXQgJiBzZXRJbnRlcnZhbCBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZml4XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIG5hdmlnYXRvciA9IGdsb2JhbC5uYXZpZ2F0b3I7XG52YXIgc2xpY2UgPSBbXS5zbGljZTtcbnZhciBNU0lFID0gISFuYXZpZ2F0b3IgJiYgL01TSUUgLlxcLi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gPC0gZGlydHkgaWU5LSBjaGVja1xudmFyIHdyYXAgPSBmdW5jdGlvbiAoc2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZm4sIHRpbWUgLyogLCAuLi5hcmdzICovKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIHZhciBhcmdzID0gYm91bmRBcmdzID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogZmFsc2U7XG4gICAgcmV0dXJuIHNldChib3VuZEFyZ3MgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICAgICh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pKS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IDogZm4sIHRpbWUpO1xuICB9O1xufTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5CICsgJGV4cG9ydC5GICogTVNJRSwge1xuICBzZXRUaW1lb3V0OiB3cmFwKGdsb2JhbC5zZXRUaW1lb3V0KSxcbiAgc2V0SW50ZXJ2YWw6IHdyYXAoZ2xvYmFsLnNldEludGVydmFsKVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi50aW1lcnMuanMiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICR0YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpO1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkIsIHtcbiAgc2V0SW1tZWRpYXRlOiAkdGFzay5zZXQsXG4gIGNsZWFySW1tZWRpYXRlOiAkdGFzay5jbGVhclxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5pbW1lZGlhdGUuanMiLCJ2YXIgJGl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgSVRFUkFUT1IgPSB3a3MoJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEl0ZXJhdG9ycy5BcnJheTtcblxudmFyIERPTUl0ZXJhYmxlcyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiBmYWxzZSxcbiAgQ1NTVmFsdWVMaXN0OiBmYWxzZSxcbiAgQ2xpZW50UmVjdExpc3Q6IGZhbHNlLFxuICBET01SZWN0TGlzdDogZmFsc2UsXG4gIERPTVN0cmluZ0xpc3Q6IGZhbHNlLFxuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiBmYWxzZSxcbiAgRmlsZUxpc3Q6IGZhbHNlLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTEZvcm1FbGVtZW50OiBmYWxzZSxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IGZhbHNlLFxuICBNZWRpYUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBNaW1lVHlwZUFycmF5OiBmYWxzZSxcbiAgTmFtZWROb2RlTWFwOiBmYWxzZSxcbiAgTm9kZUxpc3Q6IHRydWUsXG4gIFBhaW50UmVxdWVzdExpc3Q6IGZhbHNlLFxuICBQbHVnaW46IGZhbHNlLFxuICBQbHVnaW5BcnJheTogZmFsc2UsXG4gIFNWR0xlbmd0aExpc3Q6IGZhbHNlLFxuICBTVkdOdW1iZXJMaXN0OiBmYWxzZSxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IGZhbHNlLFxuICBTVkdQb2ludExpc3Q6IGZhbHNlLFxuICBTVkdTdHJpbmdMaXN0OiBmYWxzZSxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogZmFsc2UsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IGZhbHNlLFxuICBTdHlsZVNoZWV0TGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIFRleHRUcmFja0N1ZUxpc3Q6IGZhbHNlLFxuICBUZXh0VHJhY2tMaXN0OiBmYWxzZSxcbiAgVG91Y2hMaXN0OiBmYWxzZVxufTtcblxuZm9yICh2YXIgY29sbGVjdGlvbnMgPSBnZXRLZXlzKERPTUl0ZXJhYmxlcyksIGkgPSAwOyBpIDwgY29sbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBjb2xsZWN0aW9uc1tpXTtcbiAgdmFyIGV4cGxpY2l0ID0gRE9NSXRlcmFibGVzW05BTUVdO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGtleTtcbiAgaWYgKHByb3RvKSB7XG4gICAgaWYgKCFwcm90b1tJVEVSQVRPUl0pIGhpZGUocHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgaWYgKCFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7XG4gICAgaWYgKGV4cGxpY2l0KSBmb3IgKGtleSBpbiAkaXRlcmF0b3JzKSBpZiAoIXByb3RvW2tleV0pIHJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZ2xvYmFsLnByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgZ2xvYmFsLnByb2Nlc3MuZG9tYWluKSB7XG4gICAgICBpbnZva2UgPSBnbG9iYWwucHJvY2Vzcy5kb21haW4uYmluZChpbnZva2UpO1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHJ1bnRpbWUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gQW1vbmcgdGhlIHZhcmlvdXMgdHJpY2tzIGZvciBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbFxuICAvLyBvYmplY3QsIHRoaXMgc2VlbXMgdG8gYmUgdGhlIG1vc3QgcmVsaWFibGUgdGVjaG5pcXVlIHRoYXQgZG9lcyBub3RcbiAgLy8gdXNlIGluZGlyZWN0IGV2YWwgKHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzXG4pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXBvbHlmaWxsL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2NvcmUucmVnZXhwLmVzY2FwZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuUmVnRXhwLmVzY2FwZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ZuL3JlZ2V4cC9lc2NhcGUuanMiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vYmVuamFtaW5nci9SZXhFeHAuZXNjYXBlXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRyZSA9IHJlcXVpcmUoJy4vX3JlcGxhY2VyJykoL1tcXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVnRXhwJywgeyBlc2NhcGU6IGZ1bmN0aW9uIGVzY2FwZShpdCkgeyByZXR1cm4gJHJlKGl0KTsgfSB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5yZWdleHAuZXNjYXBlLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocmVnRXhwLCByZXBsYWNlKSB7XG4gIHZhciByZXBsYWNlciA9IHJlcGxhY2UgPT09IE9iamVjdChyZXBsYWNlKSA/IGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgcmV0dXJuIHJlcGxhY2VbcGFydF07XG4gIH0gOiByZXBsYWNlO1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIFN0cmluZyhpdCkucmVwbGFjZShyZWdFeHAsIHJlcGxhY2VyKTtcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZXBsYWNlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XG5cbnZhciB0d29Bcmd1bWVudFBvb2xlciA9IFBvb2xlZENsYXNzLnR3b0FyZ3VtZW50UG9vbGVyO1xudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IFBvb2xlZENsYXNzLmZvdXJBcmd1bWVudFBvb2xlcjtcblxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG5cbi8qKlxuICogUG9vbGVkQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBib29ra2VlcGluZyBhc3NvY2lhdGVkIHdpdGggcGVyZm9ybWluZyBhIGNoaWxkXG4gKiB0cmF2ZXJzYWwuIEFsbG93cyBhdm9pZGluZyBiaW5kaW5nIGNhbGxiYWNrcy5cbiAqXG4gKiBAY29uc3RydWN0b3IgRm9yRWFjaEJvb2tLZWVwaW5nXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gZm9yRWFjaEZ1bmN0aW9uIEZ1bmN0aW9uIHRvIHBlcmZvcm0gdHJhdmVyc2FsIHdpdGguXG4gKiBAcGFyYW0gez8qfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IHRvIHBlcmZvcm0gY29udGV4dCB3aXRoLlxuICovXG5mdW5jdGlvbiBGb3JFYWNoQm9va0tlZXBpbmcoZm9yRWFjaEZ1bmN0aW9uLCBmb3JFYWNoQ29udGV4dCkge1xuICB0aGlzLmZ1bmMgPSBmb3JFYWNoRnVuY3Rpb247XG4gIHRoaXMuY29udGV4dCA9IGZvckVhY2hDb250ZXh0O1xuICB0aGlzLmNvdW50ID0gMDtcbn1cbkZvckVhY2hCb29rS2VlcGluZy5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5mdW5jID0gbnVsbDtcbiAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5jb3VudCA9IDA7XG59O1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKEZvckVhY2hCb29rS2VlcGluZywgdHdvQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGQoYm9va0tlZXBpbmcsIGNoaWxkLCBuYW1lKSB7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG4gIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmZvcmVhY2hcbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBGb3JFYWNoQm9va0tlZXBpbmcuZ2V0UG9vbGVkKGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgRm9yRWFjaEJvb2tLZWVwaW5nLnJlbGVhc2UodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBQb29sZWRDbGFzcyByZXByZXNlbnRpbmcgdGhlIGJvb2trZWVwaW5nIGFzc29jaWF0ZWQgd2l0aCBwZXJmb3JtaW5nIGEgY2hpbGRcbiAqIG1hcHBpbmcuIEFsbG93cyBhdm9pZGluZyBiaW5kaW5nIGNhbGxiYWNrcy5cbiAqXG4gKiBAY29uc3RydWN0b3IgTWFwQm9va0tlZXBpbmdcbiAqIEBwYXJhbSB7ISp9IG1hcFJlc3VsdCBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBtYXBGdW5jdGlvbiBGdW5jdGlvbiB0byBwZXJmb3JtIG1hcHBpbmcgd2l0aC5cbiAqIEBwYXJhbSB7Pyp9IG1hcENvbnRleHQgQ29udGV4dCB0byBwZXJmb3JtIG1hcHBpbmcgd2l0aC5cbiAqL1xuZnVuY3Rpb24gTWFwQm9va0tlZXBpbmcobWFwUmVzdWx0LCBrZXlQcmVmaXgsIG1hcEZ1bmN0aW9uLCBtYXBDb250ZXh0KSB7XG4gIHRoaXMucmVzdWx0ID0gbWFwUmVzdWx0O1xuICB0aGlzLmtleVByZWZpeCA9IGtleVByZWZpeDtcbiAgdGhpcy5mdW5jID0gbWFwRnVuY3Rpb247XG4gIHRoaXMuY29udGV4dCA9IG1hcENvbnRleHQ7XG4gIHRoaXMuY291bnQgPSAwO1xufVxuTWFwQm9va0tlZXBpbmcucHJvdG90eXBlLmRlc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVzdWx0ID0gbnVsbDtcbiAgdGhpcy5rZXlQcmVmaXggPSBudWxsO1xuICB0aGlzLmZ1bmMgPSBudWxsO1xuICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB0aGlzLmNvdW50ID0gMDtcbn07XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oTWFwQm9va0tlZXBpbmcsIGZvdXJBcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQoYm9va0tlZXBpbmcsIGNoaWxkLCBjaGlsZEtleSkge1xuICB2YXIgcmVzdWx0ID0gYm9va0tlZXBpbmcucmVzdWx0LFxuICAgICAga2V5UHJlZml4ID0gYm9va0tlZXBpbmcua2V5UHJlZml4LFxuICAgICAgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuXG4gIHZhciBtYXBwZWRDaGlsZCA9IGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG4gIGlmIChBcnJheS5pc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwobWFwcGVkQ2hpbGQsIHJlc3VsdCwgY2hpbGRLZXksIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XG4gIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICBtYXBwZWRDaGlsZCA9IFJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsXG4gICAgICAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICBrZXlQcmVmaXggKyAobWFwcGVkQ2hpbGQua2V5ICYmICghY2hpbGQgfHwgY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG1hcHBlZENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBlc2NhcGVkUHJlZml4ID0gJyc7XG4gIGlmIChwcmVmaXggIT0gbnVsbCkge1xuICAgIGVzY2FwZWRQcmVmaXggPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkocHJlZml4KSArICcvJztcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gTWFwQm9va0tlZXBpbmcuZ2V0UG9vbGVkKGFycmF5LCBlc2NhcGVkUHJlZml4LCBmdW5jLCBjb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgTWFwQm9va0tlZXBpbmcucmVsZWFzZSh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5tYXBcbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGtleSwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZnVuYywgY29udGV4dCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZER1bW15KHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5jb3VudFxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuLCBjb250ZXh0KSB7XG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGREdW1teSwgbnVsbCk7XG59XG5cbi8qKlxuICogRmxhdHRlbiBhIGNoaWxkcmVuIG9iamVjdCAodHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gKSBhbmRcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLnRvYXJyYXlcbiAqL1xuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIFJlYWN0Q2hpbGRyZW4gPSB7XG4gIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgbWFwOiBtYXBDaGlsZHJlbixcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbDogbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbCxcbiAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gIHRvQXJyYXk6IHRvQXJyYXlcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDaGlsZHJlbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q2hpbGRyZW4uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBTdGF0aWMgcG9vbGVycy4gU2V2ZXJhbCBjdXN0b20gdmVyc2lvbnMgZm9yIGVhY2ggcG90ZW50aWFsIG51bWJlciBvZlxuICogYXJndW1lbnRzLiBBIGNvbXBsZXRlbHkgZ2VuZXJpYyBwb29sZXIgaXMgZWFzeSB0byBpbXBsZW1lbnQsIGJ1dCB3b3VsZFxuICogcmVxdWlyZSBhY2Nlc3NpbmcgdGhlIGBhcmd1bWVudHNgIG9iamVjdC4gSW4gZWFjaCBvZiB0aGVzZSwgYHRoaXNgIHJlZmVycyB0b1xuICogdGhlIENsYXNzIGl0c2VsZiwgbm90IGFuIGluc3RhbmNlLiBJZiBhbnkgb3RoZXJzIGFyZSBuZWVkZWQsIHNpbXBseSBhZGQgdGhlbVxuICogaGVyZSwgb3IgaW4gdGhlaXIgb3duIGZpbGVzLlxuICovXG52YXIgb25lQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoY29weUZpZWxkc0Zyb20pIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgY29weUZpZWxkc0Zyb20pO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGNvcHlGaWVsZHNGcm9tKTtcbiAgfVxufTtcblxudmFyIHR3b0FyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMikge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMik7XG4gIH1cbn07XG5cbnZhciB0aHJlZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMyk7XG4gIH1cbn07XG5cbnZhciBmb3VyQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMywgYTQpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0KTtcbiAgfVxufTtcblxudmFyIHN0YW5kYXJkUmVsZWFzZXIgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgIShpbnN0YW5jZSBpbnN0YW5jZW9mIEtsYXNzKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUcnlpbmcgdG8gcmVsZWFzZSBhbiBpbnN0YW5jZSBpbnRvIGEgcG9vbCBvZiBhIGRpZmZlcmVudCB0eXBlLicpIDogX3Byb2RJbnZhcmlhbnQoJzI1JykgOiB2b2lkIDA7XG4gIGluc3RhbmNlLmRlc3RydWN0b3IoKTtcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGggPCBLbGFzcy5wb29sU2l6ZSkge1xuICAgIEtsYXNzLmluc3RhbmNlUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufTtcblxudmFyIERFRkFVTFRfUE9PTF9TSVpFID0gMTA7XG52YXIgREVGQVVMVF9QT09MRVIgPSBvbmVBcmd1bWVudFBvb2xlcjtcblxuLyoqXG4gKiBBdWdtZW50cyBgQ29weUNvbnN0cnVjdG9yYCB0byBiZSBhIHBvb2xhYmxlIGNsYXNzLCBhdWdtZW50aW5nIG9ubHkgdGhlIGNsYXNzXG4gKiBpdHNlbGYgKHN0YXRpY2FsbHkpIG5vdCBhZGRpbmcgYW55IHByb3RvdHlwaWNhbCBmaWVsZHMuIEFueSBDb3B5Q29uc3RydWN0b3JcbiAqIHlvdSBnaXZlIHRoaXMgbWF5IGhhdmUgYSBgcG9vbFNpemVgIHByb3BlcnR5LCBhbmQgd2lsbCBsb29rIGZvciBhXG4gKiBwcm90b3R5cGljYWwgYGRlc3RydWN0b3JgIG9uIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDb3B5Q29uc3RydWN0b3IgQ29uc3RydWN0b3IgdGhhdCBjYW4gYmUgdXNlZCB0byByZXNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBvb2xlciBDdXN0b21pemFibGUgcG9vbGVyLlxuICovXG52YXIgYWRkUG9vbGluZ1RvID0gZnVuY3Rpb24gKENvcHlDb25zdHJ1Y3RvciwgcG9vbGVyKSB7XG4gIC8vIENhc3RpbmcgYXMgYW55IHNvIHRoYXQgZmxvdyBpZ25vcmVzIHRoZSBhY3R1YWwgaW1wbGVtZW50YXRpb24gYW5kIHRydXN0c1xuICAvLyBpdCB0byBtYXRjaCB0aGUgdHlwZSB3ZSBkZWNsYXJlZFxuICB2YXIgTmV3S2xhc3MgPSBDb3B5Q29uc3RydWN0b3I7XG4gIE5ld0tsYXNzLmluc3RhbmNlUG9vbCA9IFtdO1xuICBOZXdLbGFzcy5nZXRQb29sZWQgPSBwb29sZXIgfHwgREVGQVVMVF9QT09MRVI7XG4gIGlmICghTmV3S2xhc3MucG9vbFNpemUpIHtcbiAgICBOZXdLbGFzcy5wb29sU2l6ZSA9IERFRkFVTFRfUE9PTF9TSVpFO1xuICB9XG4gIE5ld0tsYXNzLnJlbGVhc2UgPSBzdGFuZGFyZFJlbGVhc2VyO1xuICByZXR1cm4gTmV3S2xhc3M7XG59O1xuXG52YXIgUG9vbGVkQ2xhc3MgPSB7XG4gIGFkZFBvb2xpbmdUbzogYWRkUG9vbGluZ1RvLFxuICBvbmVBcmd1bWVudFBvb2xlcjogb25lQXJndW1lbnRQb29sZXIsXG4gIHR3b0FyZ3VtZW50UG9vbGVyOiB0d29Bcmd1bWVudFBvb2xlcixcbiAgdGhyZWVBcmd1bWVudFBvb2xlcjogdGhyZWVBcmd1bWVudFBvb2xlcixcbiAgZm91ckFyZ3VtZW50UG9vbGVyOiBmb3VyQXJndW1lbnRQb29sZXJcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9vbGVkQ2xhc3M7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9Qb29sZWRDbGFzcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFN5bWJvbCcpO1xuXG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIEtleUVzY2FwZVV0aWxzID0gcmVxdWlyZSgnLi9LZXlFc2NhcGVVdGlscycpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIFRoaXMgaXMgaW5saW5lZCBmcm9tIFJlYWN0RWxlbWVudCBzaW5jZSB0aGlzIGZpbGUgaXMgc2hhcmVkIGJldHdlZW5cbiAqIGlzb21vcnBoaWMgYW5kIHJlbmRlcmVycy4gV2UgY291bGQgZXh0cmFjdCB0aGlzIHRvIGFcbiAqXG4gKi9cblxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgY29tcG9uZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGNvbXBvbmVudCBBIGNvbXBvbmVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRLZXkoY29tcG9uZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKGNvbXBvbmVudCAmJiB0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBjb21wb25lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gS2V5RXNjYXBlVXRpbHMuZXNjYXBlKGNvbXBvbmVudC5rZXkpO1xuICB9XG4gIC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbi8qKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVTb0ZhciBOYW1lIG9mIHRoZSBrZXkgcGF0aCBzbyBmYXIuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBVc2VkIHRvIHBhc3MgaW5mb3JtYXRpb24gdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXG4gKiBwcm9jZXNzLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCBuYW1lU29GYXIsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCB8fCB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fFxuICAvLyBUaGUgZm9sbG93aW5nIGlzIGlubGluZWQgZnJvbSBSZWFjdEVsZW1lbnQuIFRoaXMgbWVhbnMgd2UgY2FuIG9wdGltaXplXG4gIC8vIHNvbWUgY2hlY2tzLiBSZWFjdCBGaWJlciBhbHNvIGlubGluZXMgdGhpcyBsb2dpYyBmb3Igc2ltaWxhciBwdXJwb3Nlcy5cbiAgdHlwZSA9PT0gJ29iamVjdCcgJiYgY2hpbGRyZW4uJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sXG4gICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzLlxuICAgIG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IGNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGlpID0gMDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSA9ICcnO1xuICAgICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgbWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICAgICAgICAgIGlmIChtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSkge1xuICAgICAgICAgICAgICBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtID0gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lICsgJ2AuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHlldCBmdWxseSBzdXBwb3J0ZWQuIEl0IGlzIGFuICcgKyAnZXhwZXJpbWVudGFsIGZlYXR1cmUgdGhhdCBtaWdodCBiZSByZW1vdmVkLiBDb252ZXJ0IGl0IHRvIGEgJyArICdzZXF1ZW5jZSAvIGl0ZXJhYmxlIG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0pIDogdm9pZCAwO1xuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIGNoaWxkID0gZW50cnlbMV07XG4gICAgICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgS2V5RXNjYXBlVXRpbHMuZXNjYXBlKGVudHJ5WzBdKSArIFNVQlNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZCwgMCk7XG4gICAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZCBvciB3cmFwIHRoZSBvYmplY3QgdXNpbmcgY3JlYXRlRnJhZ21lbnQob2JqZWN0KSBmcm9tIHRoZSAnICsgJ1JlYWN0IGFkZC1vbnMuJztcbiAgICAgICAgaWYgKGNoaWxkcmVuLl9pc1JlYWN0RWxlbWVudCkge1xuICAgICAgICAgIGFkZGVuZHVtID0gXCIgSXQgbG9va3MgbGlrZSB5b3UncmUgdXNpbmcgYW4gZWxlbWVudCBjcmVhdGVkIGJ5IGEgZGlmZmVyZW50IFwiICsgJ3ZlcnNpb24gb2YgUmVhY3QuIE1ha2Ugc3VyZSB0byB1c2Ugb25seSBvbmUgY29weSBvZiBSZWFjdC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgYWRkZW5kdW0gKz0gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogX3Byb2RJbnZhcmlhbnQoJzMxJywgY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nLCBhZGRlbmR1bSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLCBidXRcbiAqIG1pZ2h0IGFsc28gYmUgc3BlY2lmaWVkIHRocm91Z2ggYXR0cmlidXRlczpcbiAqXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4sIC4uLilgXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMubGVmdFBhbmVsQ2hpbGRyZW4sIC4uLilgXG4gKlxuICogVGhlIGB0cmF2ZXJzZUNvbnRleHRgIGlzIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHRoYXQgaXMgcGFzc2VkIHRocm91Z2ggdGhlXG4gKiBlbnRpcmUgdHJhdmVyc2FsLiBJdCBjYW4gYmUgdXNlZCB0byBzdG9yZSBhY2N1bXVsYXRpb25zIG9yIGFueXRoaW5nIGVsc2UgdGhhdFxuICogdGhlIGNhbGxiYWNrIG1pZ2h0IGZpbmQgcmVsZXZhbnQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBvYmplY3QuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgVG8gaW52b2tlIHVwb24gdHJhdmVyc2luZyBlYWNoIGNoaWxkLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgZm9yIHRyYXZlcnNhbC5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sICcnLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0cmF2ZXJzZUFsbENoaWxkcmVuO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcblxuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cblxuLyoqXG4gKiBVbmVzY2FwZSBhbmQgdW53cmFwIGtleSBmb3IgaHVtYW4tcmVhZGFibGUgZGlzcGxheVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gdW5lc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSB1bmVzY2FwZWQga2V5LlxuICovXG5mdW5jdGlvbiB1bmVzY2FwZShrZXkpIHtcbiAgdmFyIHVuZXNjYXBlUmVnZXggPSAvKD0wfD0yKS9nO1xuICB2YXIgdW5lc2NhcGVyTG9va3VwID0ge1xuICAgICc9MCc6ICc9JyxcbiAgICAnPTInOiAnOidcbiAgfTtcbiAgdmFyIGtleVN1YnN0cmluZyA9IGtleVswXSA9PT0gJy4nICYmIGtleVsxXSA9PT0gJyQnID8ga2V5LnN1YnN0cmluZygyKSA6IGtleS5zdWJzdHJpbmcoMSk7XG5cbiAgcmV0dXJuICgnJyArIGtleVN1YnN0cmluZykucmVwbGFjZSh1bmVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gdW5lc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG59XG5cbnZhciBLZXlFc2NhcGVVdGlscyA9IHtcbiAgZXNjYXBlOiBlc2NhcGUsXG4gIHVuZXNjYXBlOiB1bmVzY2FwZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlFc2NhcGVVdGlscztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL0tleUVzY2FwZVV0aWxzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgZmFjdG9yeSB0aGF0IGNyZWF0ZXMgSFRNTCB0YWcgZWxlbWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIGNyZWF0ZURPTUZhY3RvcnkgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFZhbGlkYXRvcicpO1xuICBjcmVhdGVET01GYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUZhY3Rvcnk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcHBpbmcgZnJvbSBzdXBwb3J0ZWQgSFRNTCB0YWdzIHRvIGBSZWFjdERPTUNvbXBvbmVudGAgY2xhc3Nlcy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBSZWFjdERPTUZhY3RvcmllcyA9IHtcbiAgYTogY3JlYXRlRE9NRmFjdG9yeSgnYScpLFxuICBhYmJyOiBjcmVhdGVET01GYWN0b3J5KCdhYmJyJyksXG4gIGFkZHJlc3M6IGNyZWF0ZURPTUZhY3RvcnkoJ2FkZHJlc3MnKSxcbiAgYXJlYTogY3JlYXRlRE9NRmFjdG9yeSgnYXJlYScpLFxuICBhcnRpY2xlOiBjcmVhdGVET01GYWN0b3J5KCdhcnRpY2xlJyksXG4gIGFzaWRlOiBjcmVhdGVET01GYWN0b3J5KCdhc2lkZScpLFxuICBhdWRpbzogY3JlYXRlRE9NRmFjdG9yeSgnYXVkaW8nKSxcbiAgYjogY3JlYXRlRE9NRmFjdG9yeSgnYicpLFxuICBiYXNlOiBjcmVhdGVET01GYWN0b3J5KCdiYXNlJyksXG4gIGJkaTogY3JlYXRlRE9NRmFjdG9yeSgnYmRpJyksXG4gIGJkbzogY3JlYXRlRE9NRmFjdG9yeSgnYmRvJyksXG4gIGJpZzogY3JlYXRlRE9NRmFjdG9yeSgnYmlnJyksXG4gIGJsb2NrcXVvdGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2Jsb2NrcXVvdGUnKSxcbiAgYm9keTogY3JlYXRlRE9NRmFjdG9yeSgnYm9keScpLFxuICBicjogY3JlYXRlRE9NRmFjdG9yeSgnYnInKSxcbiAgYnV0dG9uOiBjcmVhdGVET01GYWN0b3J5KCdidXR0b24nKSxcbiAgY2FudmFzOiBjcmVhdGVET01GYWN0b3J5KCdjYW52YXMnKSxcbiAgY2FwdGlvbjogY3JlYXRlRE9NRmFjdG9yeSgnY2FwdGlvbicpLFxuICBjaXRlOiBjcmVhdGVET01GYWN0b3J5KCdjaXRlJyksXG4gIGNvZGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2NvZGUnKSxcbiAgY29sOiBjcmVhdGVET01GYWN0b3J5KCdjb2wnKSxcbiAgY29sZ3JvdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ2NvbGdyb3VwJyksXG4gIGRhdGE6IGNyZWF0ZURPTUZhY3RvcnkoJ2RhdGEnKSxcbiAgZGF0YWxpc3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ2RhdGFsaXN0JyksXG4gIGRkOiBjcmVhdGVET01GYWN0b3J5KCdkZCcpLFxuICBkZWw6IGNyZWF0ZURPTUZhY3RvcnkoJ2RlbCcpLFxuICBkZXRhaWxzOiBjcmVhdGVET01GYWN0b3J5KCdkZXRhaWxzJyksXG4gIGRmbjogY3JlYXRlRE9NRmFjdG9yeSgnZGZuJyksXG4gIGRpYWxvZzogY3JlYXRlRE9NRmFjdG9yeSgnZGlhbG9nJyksXG4gIGRpdjogY3JlYXRlRE9NRmFjdG9yeSgnZGl2JyksXG4gIGRsOiBjcmVhdGVET01GYWN0b3J5KCdkbCcpLFxuICBkdDogY3JlYXRlRE9NRmFjdG9yeSgnZHQnKSxcbiAgZW06IGNyZWF0ZURPTUZhY3RvcnkoJ2VtJyksXG4gIGVtYmVkOiBjcmVhdGVET01GYWN0b3J5KCdlbWJlZCcpLFxuICBmaWVsZHNldDogY3JlYXRlRE9NRmFjdG9yeSgnZmllbGRzZXQnKSxcbiAgZmlnY2FwdGlvbjogY3JlYXRlRE9NRmFjdG9yeSgnZmlnY2FwdGlvbicpLFxuICBmaWd1cmU6IGNyZWF0ZURPTUZhY3RvcnkoJ2ZpZ3VyZScpLFxuICBmb290ZXI6IGNyZWF0ZURPTUZhY3RvcnkoJ2Zvb3RlcicpLFxuICBmb3JtOiBjcmVhdGVET01GYWN0b3J5KCdmb3JtJyksXG4gIGgxOiBjcmVhdGVET01GYWN0b3J5KCdoMScpLFxuICBoMjogY3JlYXRlRE9NRmFjdG9yeSgnaDInKSxcbiAgaDM6IGNyZWF0ZURPTUZhY3RvcnkoJ2gzJyksXG4gIGg0OiBjcmVhdGVET01GYWN0b3J5KCdoNCcpLFxuICBoNTogY3JlYXRlRE9NRmFjdG9yeSgnaDUnKSxcbiAgaDY6IGNyZWF0ZURPTUZhY3RvcnkoJ2g2JyksXG4gIGhlYWQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2hlYWQnKSxcbiAgaGVhZGVyOiBjcmVhdGVET01GYWN0b3J5KCdoZWFkZXInKSxcbiAgaGdyb3VwOiBjcmVhdGVET01GYWN0b3J5KCdoZ3JvdXAnKSxcbiAgaHI6IGNyZWF0ZURPTUZhY3RvcnkoJ2hyJyksXG4gIGh0bWw6IGNyZWF0ZURPTUZhY3RvcnkoJ2h0bWwnKSxcbiAgaTogY3JlYXRlRE9NRmFjdG9yeSgnaScpLFxuICBpZnJhbWU6IGNyZWF0ZURPTUZhY3RvcnkoJ2lmcmFtZScpLFxuICBpbWc6IGNyZWF0ZURPTUZhY3RvcnkoJ2ltZycpLFxuICBpbnB1dDogY3JlYXRlRE9NRmFjdG9yeSgnaW5wdXQnKSxcbiAgaW5zOiBjcmVhdGVET01GYWN0b3J5KCdpbnMnKSxcbiAga2JkOiBjcmVhdGVET01GYWN0b3J5KCdrYmQnKSxcbiAga2V5Z2VuOiBjcmVhdGVET01GYWN0b3J5KCdrZXlnZW4nKSxcbiAgbGFiZWw6IGNyZWF0ZURPTUZhY3RvcnkoJ2xhYmVsJyksXG4gIGxlZ2VuZDogY3JlYXRlRE9NRmFjdG9yeSgnbGVnZW5kJyksXG4gIGxpOiBjcmVhdGVET01GYWN0b3J5KCdsaScpLFxuICBsaW5rOiBjcmVhdGVET01GYWN0b3J5KCdsaW5rJyksXG4gIG1haW46IGNyZWF0ZURPTUZhY3RvcnkoJ21haW4nKSxcbiAgbWFwOiBjcmVhdGVET01GYWN0b3J5KCdtYXAnKSxcbiAgbWFyazogY3JlYXRlRE9NRmFjdG9yeSgnbWFyaycpLFxuICBtZW51OiBjcmVhdGVET01GYWN0b3J5KCdtZW51JyksXG4gIG1lbnVpdGVtOiBjcmVhdGVET01GYWN0b3J5KCdtZW51aXRlbScpLFxuICBtZXRhOiBjcmVhdGVET01GYWN0b3J5KCdtZXRhJyksXG4gIG1ldGVyOiBjcmVhdGVET01GYWN0b3J5KCdtZXRlcicpLFxuICBuYXY6IGNyZWF0ZURPTUZhY3RvcnkoJ25hdicpLFxuICBub3NjcmlwdDogY3JlYXRlRE9NRmFjdG9yeSgnbm9zY3JpcHQnKSxcbiAgb2JqZWN0OiBjcmVhdGVET01GYWN0b3J5KCdvYmplY3QnKSxcbiAgb2w6IGNyZWF0ZURPTUZhY3RvcnkoJ29sJyksXG4gIG9wdGdyb3VwOiBjcmVhdGVET01GYWN0b3J5KCdvcHRncm91cCcpLFxuICBvcHRpb246IGNyZWF0ZURPTUZhY3RvcnkoJ29wdGlvbicpLFxuICBvdXRwdXQ6IGNyZWF0ZURPTUZhY3RvcnkoJ291dHB1dCcpLFxuICBwOiBjcmVhdGVET01GYWN0b3J5KCdwJyksXG4gIHBhcmFtOiBjcmVhdGVET01GYWN0b3J5KCdwYXJhbScpLFxuICBwaWN0dXJlOiBjcmVhdGVET01GYWN0b3J5KCdwaWN0dXJlJyksXG4gIHByZTogY3JlYXRlRE9NRmFjdG9yeSgncHJlJyksXG4gIHByb2dyZXNzOiBjcmVhdGVET01GYWN0b3J5KCdwcm9ncmVzcycpLFxuICBxOiBjcmVhdGVET01GYWN0b3J5KCdxJyksXG4gIHJwOiBjcmVhdGVET01GYWN0b3J5KCdycCcpLFxuICBydDogY3JlYXRlRE9NRmFjdG9yeSgncnQnKSxcbiAgcnVieTogY3JlYXRlRE9NRmFjdG9yeSgncnVieScpLFxuICBzOiBjcmVhdGVET01GYWN0b3J5KCdzJyksXG4gIHNhbXA6IGNyZWF0ZURPTUZhY3RvcnkoJ3NhbXAnKSxcbiAgc2NyaXB0OiBjcmVhdGVET01GYWN0b3J5KCdzY3JpcHQnKSxcbiAgc2VjdGlvbjogY3JlYXRlRE9NRmFjdG9yeSgnc2VjdGlvbicpLFxuICBzZWxlY3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ3NlbGVjdCcpLFxuICBzbWFsbDogY3JlYXRlRE9NRmFjdG9yeSgnc21hbGwnKSxcbiAgc291cmNlOiBjcmVhdGVET01GYWN0b3J5KCdzb3VyY2UnKSxcbiAgc3BhbjogY3JlYXRlRE9NRmFjdG9yeSgnc3BhbicpLFxuICBzdHJvbmc6IGNyZWF0ZURPTUZhY3RvcnkoJ3N0cm9uZycpLFxuICBzdHlsZTogY3JlYXRlRE9NRmFjdG9yeSgnc3R5bGUnKSxcbiAgc3ViOiBjcmVhdGVET01GYWN0b3J5KCdzdWInKSxcbiAgc3VtbWFyeTogY3JlYXRlRE9NRmFjdG9yeSgnc3VtbWFyeScpLFxuICBzdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ3N1cCcpLFxuICB0YWJsZTogY3JlYXRlRE9NRmFjdG9yeSgndGFibGUnKSxcbiAgdGJvZHk6IGNyZWF0ZURPTUZhY3RvcnkoJ3Rib2R5JyksXG4gIHRkOiBjcmVhdGVET01GYWN0b3J5KCd0ZCcpLFxuICB0ZXh0YXJlYTogY3JlYXRlRE9NRmFjdG9yeSgndGV4dGFyZWEnKSxcbiAgdGZvb3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ3Rmb290JyksXG4gIHRoOiBjcmVhdGVET01GYWN0b3J5KCd0aCcpLFxuICB0aGVhZDogY3JlYXRlRE9NRmFjdG9yeSgndGhlYWQnKSxcbiAgdGltZTogY3JlYXRlRE9NRmFjdG9yeSgndGltZScpLFxuICB0aXRsZTogY3JlYXRlRE9NRmFjdG9yeSgndGl0bGUnKSxcbiAgdHI6IGNyZWF0ZURPTUZhY3RvcnkoJ3RyJyksXG4gIHRyYWNrOiBjcmVhdGVET01GYWN0b3J5KCd0cmFjaycpLFxuICB1OiBjcmVhdGVET01GYWN0b3J5KCd1JyksXG4gIHVsOiBjcmVhdGVET01GYWN0b3J5KCd1bCcpLFxuICAndmFyJzogY3JlYXRlRE9NRmFjdG9yeSgndmFyJyksXG4gIHZpZGVvOiBjcmVhdGVET01GYWN0b3J5KCd2aWRlbycpLFxuICB3YnI6IGNyZWF0ZURPTUZhY3RvcnkoJ3dicicpLFxuXG4gIC8vIFNWR1xuICBjaXJjbGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2NpcmNsZScpLFxuICBjbGlwUGF0aDogY3JlYXRlRE9NRmFjdG9yeSgnY2xpcFBhdGgnKSxcbiAgZGVmczogY3JlYXRlRE9NRmFjdG9yeSgnZGVmcycpLFxuICBlbGxpcHNlOiBjcmVhdGVET01GYWN0b3J5KCdlbGxpcHNlJyksXG4gIGc6IGNyZWF0ZURPTUZhY3RvcnkoJ2cnKSxcbiAgaW1hZ2U6IGNyZWF0ZURPTUZhY3RvcnkoJ2ltYWdlJyksXG4gIGxpbmU6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpbmUnKSxcbiAgbGluZWFyR3JhZGllbnQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpbmVhckdyYWRpZW50JyksXG4gIG1hc2s6IGNyZWF0ZURPTUZhY3RvcnkoJ21hc2snKSxcbiAgcGF0aDogY3JlYXRlRE9NRmFjdG9yeSgncGF0aCcpLFxuICBwYXR0ZXJuOiBjcmVhdGVET01GYWN0b3J5KCdwYXR0ZXJuJyksXG4gIHBvbHlnb246IGNyZWF0ZURPTUZhY3RvcnkoJ3BvbHlnb24nKSxcbiAgcG9seWxpbmU6IGNyZWF0ZURPTUZhY3RvcnkoJ3BvbHlsaW5lJyksXG4gIHJhZGlhbEdyYWRpZW50OiBjcmVhdGVET01GYWN0b3J5KCdyYWRpYWxHcmFkaWVudCcpLFxuICByZWN0OiBjcmVhdGVET01GYWN0b3J5KCdyZWN0JyksXG4gIHN0b3A6IGNyZWF0ZURPTUZhY3RvcnkoJ3N0b3AnKSxcbiAgc3ZnOiBjcmVhdGVET01GYWN0b3J5KCdzdmcnKSxcbiAgdGV4dDogY3JlYXRlRE9NRmFjdG9yeSgndGV4dCcpLFxuICB0c3BhbjogY3JlYXRlRE9NRmFjdG9yeSgndHNwYW4nKVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUZhY3RvcmllcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NRmFjdG9yaWVzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0Jykge1xuICAvLyBUZW1wb3JhcnkgaGFjay5cbiAgLy8gSW5saW5lIHJlcXVpcmVzIGRvbid0IHdvcmsgd2VsbCB3aXRoIEplc3Q6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI0MFxuICAvLyBSZW1vdmUgdGhlIGlubGluZSByZXF1aXJlcyB3aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBhbnltb3JlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTc4XG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9vYmplY3R9IGVsZW1lbnQgVGhlIFJlYWN0IGVsZW1lbnQgdGhhdCBpcyBiZWluZyB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7P251bWJlcn0gZGVidWdJRCBUaGUgUmVhY3QgY29tcG9uZW50IGluc3RhbmNlIHRoYXQgaXMgYmVpbmcgdHlwZS1jaGVja2VkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1JlYWN0VHlwZVNwZWModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50LCBkZWJ1Z0lEKSB7XG4gIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgIHZhciBlcnJvcjtcbiAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAhKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSBSZWFjdC5Qcm9wVHlwZXMuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSkgOiBfcHJvZEludmFyaWFudCgnODQnLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGVycm9yID0gZXg7XG4gICAgICB9XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcikgOiB2b2lkIDA7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICB2YXIgY29tcG9uZW50U3RhY2tJbmZvID0gJyc7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoIVJlYWN0Q29tcG9uZW50VHJlZUhvb2spIHtcbiAgICAgICAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlYnVnSUQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrSW5mbyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21wb25lbnRTdGFja0luZm8gPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEN1cnJlbnRTdGFja0FkZGVuZHVtKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgY29tcG9uZW50U3RhY2tJbmZvKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1JlYWN0VHlwZVNwZWM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHtcbiAgICBwcm9wOiAncHJvcCcsXG4gICAgY29udGV4dDogJ2NvbnRleHQnLFxuICAgIGNoaWxkQ29udGV4dDogJ2NoaWxkIGNvbnRleHQnXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKSxcbiAgICBpc1ZhbGlkRWxlbWVudCA9IF9yZXF1aXJlLmlzVmFsaWRFbGVtZW50O1xuXG52YXIgZmFjdG9yeSA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMvZmFjdG9yeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoaXNWYWxpZEVsZW1lbnQpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbiAgdmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaW52YXJpYW50KHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICdSZWFjdC5Qcm9wVHlwZXMuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lKTtcbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yKTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAnMTUuNi4xJztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0VmVyc2lvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vUmVhY3RCYXNlQ2xhc3NlcycpLFxuICAgIENvbXBvbmVudCA9IF9yZXF1aXJlLkNvbXBvbmVudDtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50JyksXG4gICAgaXNWYWxpZEVsZW1lbnQgPSBfcmVxdWlyZTIuaXNWYWxpZEVsZW1lbnQ7XG5cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3ROb29wVXBkYXRlUXVldWUnKTtcbnZhciBmYWN0b3J5ID0gcmVxdWlyZSgnY3JlYXRlLXJlYWN0LWNsYXNzL2ZhY3RvcnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KENvbXBvbmVudCwgaXNWYWxpZEVsZW1lbnQsIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2NyZWF0ZUNsYXNzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbn1cblxudmFyIE1JWElOU19LRVkgPSAnbWl4aW5zJztcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGFsbG93IHRoZSBjcmVhdGlvbiBvZiBhbm9ueW1vdXMgZnVuY3Rpb25zIHdoaWNoIGRvIG5vdFxuLy8gaGF2ZSAubmFtZSBzZXQgdG8gdGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIGJlaW5nIGFzc2lnbmVkIHRvLlxuZnVuY3Rpb24gaWRlbnRpdHkoZm4pIHtcbiAgcmV0dXJuIGZuO1xufVxuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXM7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHtcbiAgICBwcm9wOiAncHJvcCcsXG4gICAgY29udGV4dDogJ2NvbnRleHQnLFxuICAgIGNoaWxkQ29udGV4dDogJ2NoaWxkIGNvbnRleHQnXG4gIH07XG59IGVsc2Uge1xuICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBmYWN0b3J5KFJlYWN0Q29tcG9uZW50LCBpc1ZhbGlkRWxlbWVudCwgUmVhY3ROb29wVXBkYXRlUXVldWUpIHtcbiAgLyoqXG4gICAqIFBvbGljaWVzIHRoYXQgZGVzY3JpYmUgbWV0aG9kcyBpbiBgUmVhY3RDbGFzc0ludGVyZmFjZWAuXG4gICAqL1xuXG4gIHZhciBpbmplY3RlZE1peGlucyA9IFtdO1xuXG4gIC8qKlxuICAgKiBDb21wb3NpdGUgY29tcG9uZW50cyBhcmUgaGlnaGVyLWxldmVsIGNvbXBvbmVudHMgdGhhdCBjb21wb3NlIG90aGVyIGNvbXBvc2l0ZVxuICAgKiBvciBob3N0IGNvbXBvbmVudHMuXG4gICAqXG4gICAqIFRvIGNyZWF0ZSBhIG5ldyB0eXBlIG9mIGBSZWFjdENsYXNzYCwgcGFzcyBhIHNwZWNpZmljYXRpb24gb2ZcbiAgICogeW91ciBuZXcgY2xhc3MgdG8gYFJlYWN0LmNyZWF0ZUNsYXNzYC4gVGhlIG9ubHkgcmVxdWlyZW1lbnQgb2YgeW91ciBjbGFzc1xuICAgKiBzcGVjaWZpY2F0aW9uIGlzIHRoYXQgeW91IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC5cbiAgICpcbiAgICogICB2YXIgTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgICByZXR1cm4gPGRpdj5IZWxsbyBXb3JsZDwvZGl2PjtcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogVGhlIGNsYXNzIHNwZWNpZmljYXRpb24gc3VwcG9ydHMgYSBzcGVjaWZpYyBwcm90b2NvbCBvZiBtZXRob2RzIHRoYXQgaGF2ZVxuICAgKiBzcGVjaWFsIG1lYW5pbmcgKGUuZy4gYHJlbmRlcmApLiBTZWUgYFJlYWN0Q2xhc3NJbnRlcmZhY2VgIGZvclxuICAgKiBtb3JlIHRoZSBjb21wcmVoZW5zaXZlIHByb3RvY29sLiBBbnkgb3RoZXIgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBpbiB0aGVcbiAgICogY2xhc3Mgc3BlY2lmaWNhdGlvbiB3aWxsIGJlIGF2YWlsYWJsZSBvbiB0aGUgcHJvdG90eXBlLlxuICAgKlxuICAgKiBAaW50ZXJmYWNlIFJlYWN0Q2xhc3NJbnRlcmZhY2VcbiAgICogQGludGVybmFsXG4gICAqL1xuICB2YXIgUmVhY3RDbGFzc0ludGVyZmFjZSA9IHtcbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBNaXhpbiBvYmplY3RzIHRvIGluY2x1ZGUgd2hlbiBkZWZpbmluZyB5b3VyIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHthcnJheX1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBtaXhpbnM6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHRoYXQgc2hvdWxkIGJlIGRlZmluZWQgb25cbiAgICAgKiB0aGUgY29tcG9uZW50J3MgY29uc3RydWN0b3IgaW5zdGVhZCBvZiBpdHMgcHJvdG90eXBlIChzdGF0aWMgbWV0aG9kcykuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIHN0YXRpY3M6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbml0aW9uIG9mIHByb3AgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBwcm9wVHlwZXM6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb250ZXh0VHlwZXM6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgdGhpcyBjb21wb25lbnQgc2V0cyBmb3IgaXRzIGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjaGlsZENvbnRleHRUeXBlczogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8vID09PT0gRGVmaW5pdGlvbiBtZXRob2RzID09PT1cblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFZhbHVlcyBpbiB0aGUgbWFwcGluZyB3aWxsIGJlIHNldCBvblxuICAgICAqIGB0aGlzLnByb3BzYCBpZiB0aGF0IHByb3AgaXMgbm90IHNwZWNpZmllZCAoaS5lLiB1c2luZyBhbiBgaW5gIGNoZWNrKS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgYmVmb3JlIGBnZXRJbml0aWFsU3RhdGVgIGFuZCB0aGVyZWZvcmUgY2Fubm90IHJlbHlcbiAgICAgKiBvbiBgdGhpcy5zdGF0ZWAgb3IgdXNlIGB0aGlzLnNldFN0YXRlYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBnZXREZWZhdWx0UHJvcHM6ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCBvbmNlIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkXG4gICAgICogYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgYHRoaXMuc3RhdGVgLlxuICAgICAqXG4gICAgICogICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICByZXR1cm4ge1xuICAgICAqICAgICAgIGlzT246IGZhbHNlLFxuICAgICAqICAgICAgIGZvb0JhejogbmV3IEJhekZvbygpXG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBnZXRJbml0aWFsU3RhdGU6ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGdldENoaWxkQ29udGV4dDogJ0RFRklORV9NQU5ZX01FUkdFRCcsXG5cbiAgICAvKipcbiAgICAgKiBVc2VzIHByb3BzIGZyb20gYHRoaXMucHJvcHNgIGFuZCBzdGF0ZSBmcm9tIGB0aGlzLnN0YXRlYCB0byByZW5kZXIgdGhlXG4gICAgICogc3RydWN0dXJlIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBObyBndWFyYW50ZWVzIGFyZSBtYWRlIGFib3V0IHdoZW4gb3IgaG93IG9mdGVuIHRoaXMgbWV0aG9kIGlzIGludm9rZWQsIHNvXG4gICAgICogaXQgbXVzdCBub3QgaGF2ZSBzaWRlIGVmZmVjdHMuXG4gICAgICpcbiAgICAgKiAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICogICAgIHZhciBuYW1lID0gdGhpcy5wcm9wcy5uYW1lO1xuICAgICAqICAgICByZXR1cm4gPGRpdj5IZWxsbywge25hbWV9ITwvZGl2PjtcbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fVxuICAgICAqIEByZXF1aXJlZFxuICAgICAqL1xuICAgIHJlbmRlcjogJ0RFRklORV9PTkNFJyxcblxuICAgIC8vID09PT0gRGVsZWdhdGUgbWV0aG9kcyA9PT09XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBpbml0aWFsbHkgY3JlYXRlZCBhbmQgYWJvdXQgdG8gYmUgbW91bnRlZC5cbiAgICAgKiBUaGlzIG1heSBoYXZlIHNpZGUgZWZmZWN0cywgYnV0IGFueSBleHRlcm5hbCBzdWJzY3JpcHRpb25zIG9yIGRhdGEgY3JlYXRlZFxuICAgICAqIGJ5IHRoaXMgbWV0aG9kIG11c3QgYmUgY2xlYW5lZCB1cCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgLlxuICAgICAqXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbE1vdW50OiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCBhbmQgaGFzIGEgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEhvd2V2ZXIsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBET00gbm9kZSBpcyBpbiB0aGUgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xuICAgICAqIGJlZW4gbW91bnRlZCAoaW5pdGlhbGl6ZWQgYW5kIHJlbmRlcmVkKSBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGNvbXBvbmVudERpZE1vdW50OiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCByZWNlaXZlcyBuZXcgcHJvcHMuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byByZWFjdCB0byBhIHByb3AgdHJhbnNpdGlvbiBieSB1cGRhdGluZyB0aGVcbiAgICAgKiBzdGF0ZSB1c2luZyBgdGhpcy5zZXRTdGF0ZWAuIEN1cnJlbnQgcHJvcHMgYXJlIGFjY2Vzc2VkIHZpYSBgdGhpcy5wcm9wc2AuXG4gICAgICpcbiAgICAgKiAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dENvbnRleHQpIHtcbiAgICAgKiAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICogICAgICAgbGlrZXNJbmNyZWFzaW5nOiBuZXh0UHJvcHMubGlrZUNvdW50ID4gdGhpcy5wcm9wcy5saWtlQ291bnRcbiAgICAgKiAgICAgfSk7XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGVyZSBpcyBubyBlcXVpdmFsZW50IGBjb21wb25lbnRXaWxsUmVjZWl2ZVN0YXRlYC4gQW4gaW5jb21pbmcgcHJvcFxuICAgICAqIHRyYW5zaXRpb24gbWF5IGNhdXNlIGEgc3RhdGUgY2hhbmdlLCBidXQgdGhlIG9wcG9zaXRlIGlzIG5vdCB0cnVlLiBJZiB5b3VcbiAgICAgKiBuZWVkIGl0LCB5b3UgYXJlIHByb2JhYmx5IGxvb2tpbmcgZm9yIGBjb21wb25lbnRXaWxsVXBkYXRlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGlsZSBkZWNpZGluZyBpZiB0aGUgY29tcG9uZW50IHNob3VsZCBiZSB1cGRhdGVkIGFzIGEgcmVzdWx0IG9mXG4gICAgICogcmVjZWl2aW5nIG5ldyBwcm9wcywgc3RhdGUgYW5kL29yIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBgcmV0dXJuIGZhbHNlYCB3aGVuIHlvdSdyZSBjZXJ0YWluIHRoYXQgdGhlXG4gICAgICogdHJhbnNpdGlvbiB0byB0aGUgbmV3IHByb3BzL3N0YXRlL2NvbnRleHQgd2lsbCBub3QgcmVxdWlyZSBhIGNvbXBvbmVudFxuICAgICAqIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpIHtcbiAgICAgKiAgICAgcmV0dXJuICFlcXVhbChuZXh0UHJvcHMsIHRoaXMucHJvcHMpIHx8XG4gICAgICogICAgICAgIWVxdWFsKG5leHRTdGF0ZSwgdGhpcy5zdGF0ZSkgfHxcbiAgICAgKiAgICAgICAhZXF1YWwobmV4dENvbnRleHQsIHRoaXMuY29udGV4dCk7XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29tcG9uZW50IHNob3VsZCB1cGRhdGUuXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiAnREVGSU5FX09OQ0UnLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gdXBkYXRlIGR1ZSB0byBhIHRyYW5zaXRpb24gZnJvbVxuICAgICAqIGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YCB0byBgbmV4dFByb3BzYCwgYG5leHRTdGF0ZWBcbiAgICAgKiBhbmQgYG5leHRDb250ZXh0YC5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHBlcmZvcm0gcHJlcGFyYXRpb24gYmVmb3JlIGFuIHVwZGF0ZSBvY2N1cnMuXG4gICAgICpcbiAgICAgKiBOT1RFOiBZb3UgKipjYW5ub3QqKiB1c2UgYHRoaXMuc2V0U3RhdGUoKWAgaW4gdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGNvbXBvbmVudFdpbGxVcGRhdGU6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCdzIERPTSByZXByZXNlbnRhdGlvbiBoYXMgYmVlbiB1cGRhdGVkLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICAgKiBiZWVuIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJldlByb3BzXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2U3RhdGVcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZDb250ZXh0XG4gICAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRVcGRhdGU6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhYm91dCB0byBiZSByZW1vdmVkIGZyb20gaXRzIHBhcmVudCBhbmQgaGF2ZVxuICAgICAqIGl0cyBET00gcmVwcmVzZW50YXRpb24gZGVzdHJveWVkLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gZGVhbGxvY2F0ZSBhbnkgZXh0ZXJuYWwgcmVzb3VyY2VzLlxuICAgICAqXG4gICAgICogTk9URTogVGhlcmUgaXMgbm8gYGNvbXBvbmVudERpZFVubW91bnRgIHNpbmNlIHlvdXIgY29tcG9uZW50IHdpbGwgaGF2ZSBiZWVuXG4gICAgICogZGVzdHJveWVkIGJ5IHRoYXQgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudDogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8vID09PT0gQWR2YW5jZWQgbWV0aG9kcyA9PT09XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQncyBjdXJyZW50bHkgbW91bnRlZCBET00gcmVwcmVzZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICAgKiBTb3BoaXN0aWNhdGVkIGNsaWVudHMgbWF5IHdpc2ggdG8gb3ZlcnJpZGUgdGhpcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAb3ZlcnJpZGFibGVcbiAgICAgKi9cbiAgICB1cGRhdGVDb21wb25lbnQ6ICdPVkVSUklERV9CQVNFJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gY2xhc3Mgc3BlY2lmaWNhdGlvbiBrZXlzIHRvIHNwZWNpYWwgcHJvY2Vzc2luZyBmdW5jdGlvbnMuXG4gICAqXG4gICAqIEFsdGhvdWdoIHRoZXNlIGFyZSBkZWNsYXJlZCBsaWtlIGluc3RhbmNlIHByb3BlcnRpZXMgaW4gdGhlIHNwZWNpZmljYXRpb25cbiAgICogd2hlbiBkZWZpbmluZyBjbGFzc2VzIHVzaW5nIGBSZWFjdC5jcmVhdGVDbGFzc2AsIHRoZXkgYXJlIGFjdHVhbGx5IHN0YXRpY1xuICAgKiBhbmQgYXJlIGFjY2Vzc2libGUgb24gdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgdGhlIHByb3RvdHlwZS4gRGVzcGl0ZVxuICAgKiBiZWluZyBzdGF0aWMsIHRoZXkgbXVzdCBiZSBkZWZpbmVkIG91dHNpZGUgb2YgdGhlIFwic3RhdGljc1wiIGtleSB1bmRlclxuICAgKiB3aGljaCBhbGwgb3RoZXIgc3RhdGljIG1ldGhvZHMgYXJlIGRlZmluZWQuXG4gICAqL1xuICB2YXIgUkVTRVJWRURfU1BFQ19LRVlTID0ge1xuICAgIGRpc3BsYXlOYW1lOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgZGlzcGxheU5hbWUpIHtcbiAgICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgfSxcbiAgICBtaXhpbnM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBtaXhpbnMpIHtcbiAgICAgIGlmIChtaXhpbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXhpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3RvciwgbWl4aW5zW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY2hpbGRDb250ZXh0VHlwZXM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcywgJ2NoaWxkQ29udGV4dCcpO1xuICAgICAgfVxuICAgICAgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMgPSBfYXNzaWduKFxuICAgICAgICB7fSxcbiAgICAgICAgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMsXG4gICAgICAgIGNoaWxkQ29udGV4dFR5cGVzXG4gICAgICApO1xuICAgIH0sXG4gICAgY29udGV4dFR5cGVzOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcywgJ2NvbnRleHQnKTtcbiAgICAgIH1cbiAgICAgIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcyA9IF9hc3NpZ24oXG4gICAgICAgIHt9LFxuICAgICAgICBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMsXG4gICAgICAgIGNvbnRleHRUeXBlc1xuICAgICAgKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNwZWNpYWwgY2FzZSBnZXREZWZhdWx0UHJvcHMgd2hpY2ggc2hvdWxkIG1vdmUgaW50byBzdGF0aWNzIGJ1dCByZXF1aXJlc1xuICAgICAqIGF1dG9tYXRpYyBtZXJnaW5nLlxuICAgICAqL1xuICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIGdldERlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihcbiAgICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMsXG4gICAgICAgICAgZ2V0RGVmYXVsdFByb3BzXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBnZXREZWZhdWx0UHJvcHM7XG4gICAgICB9XG4gICAgfSxcbiAgICBwcm9wVHlwZXM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgcHJvcFR5cGVzLCAncHJvcCcpO1xuICAgICAgfVxuICAgICAgQ29uc3RydWN0b3IucHJvcFR5cGVzID0gX2Fzc2lnbih7fSwgQ29uc3RydWN0b3IucHJvcFR5cGVzLCBwcm9wVHlwZXMpO1xuICAgIH0sXG4gICAgc3RhdGljczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgICAgIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKTtcbiAgICB9LFxuICAgIGF1dG9iaW5kOiBmdW5jdGlvbigpIHt9XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCB0eXBlRGVmLCBsb2NhdGlvbikge1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHR5cGVEZWYpIHtcbiAgICAgIGlmICh0eXBlRGVmLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAvLyB1c2UgYSB3YXJuaW5nIGluc3RlYWQgb2YgYW4gX2ludmFyaWFudCBzbyBjb21wb25lbnRzXG4gICAgICAgIC8vIGRvbid0IHNob3cgdXAgaW4gcHJvZCBidXQgb25seSBpbiBfX0RFVl9fXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgIHR5cGVvZiB0eXBlRGVmW3Byb3BOYW1lXSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgK1xuICAgICAgICAgICAgICAnUmVhY3QuUHJvcFR5cGVzLicsXG4gICAgICAgICAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDbGFzcycsXG4gICAgICAgICAgICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sXG4gICAgICAgICAgICBwcm9wTmFtZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKGlzQWxyZWFkeURlZmluZWQsIG5hbWUpIHtcbiAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgID8gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXVxuICAgICAgOiBudWxsO1xuXG4gICAgLy8gRGlzYWxsb3cgb3ZlcnJpZGluZyBvZiBiYXNlIGNsYXNzIG1ldGhvZHMgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgICBpZiAoUmVhY3RDbGFzc01peGluLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBfaW52YXJpYW50KFxuICAgICAgICBzcGVjUG9saWN5ID09PSAnT1ZFUlJJREVfQkFTRScsXG4gICAgICAgICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gb3ZlcnJpZGUgJyArXG4gICAgICAgICAgJ2Alc2AgZnJvbSB5b3VyIGNsYXNzIHNwZWNpZmljYXRpb24uIEVuc3VyZSB0aGF0IHlvdXIgbWV0aG9kIG5hbWVzICcgK1xuICAgICAgICAgICdkbyBub3Qgb3ZlcmxhcCB3aXRoIFJlYWN0IG1ldGhvZHMuJyxcbiAgICAgICAgbmFtZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBEaXNhbGxvdyBkZWZpbmluZyBtZXRob2RzIG1vcmUgdGhhbiBvbmNlIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXG4gICAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAgIF9pbnZhcmlhbnQoXG4gICAgICAgIHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWScgfHwgc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZX01FUkdFRCcsXG4gICAgICAgICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lICcgK1xuICAgICAgICAgICdgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgJyArXG4gICAgICAgICAgJ3RvIGEgbWl4aW4uJyxcbiAgICAgICAgbmFtZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWl4aW4gaGVscGVyIHdoaWNoIGhhbmRsZXMgcG9saWN5IHZhbGlkYXRpb24gYW5kIHJlc2VydmVkXG4gICAqIHNwZWNpZmljYXRpb24ga2V5cyB3aGVuIGJ1aWxkaW5nIFJlYWN0IGNsYXNzZXMuXG4gICAqL1xuICBmdW5jdGlvbiBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYykge1xuICAgIGlmICghc3BlYykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIHR5cGVvZlNwZWMgPSB0eXBlb2Ygc3BlYztcbiAgICAgICAgdmFyIGlzTWl4aW5WYWxpZCA9IHR5cGVvZlNwZWMgPT09ICdvYmplY3QnICYmIHNwZWMgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgaXNNaXhpblZhbGlkLFxuICAgICAgICAgICAgXCIlczogWW91J3JlIGF0dGVtcHRpbmcgdG8gaW5jbHVkZSBhIG1peGluIHRoYXQgaXMgZWl0aGVyIG51bGwgXCIgK1xuICAgICAgICAgICAgICAnb3Igbm90IGFuIG9iamVjdC4gQ2hlY2sgdGhlIG1peGlucyBpbmNsdWRlZCBieSB0aGUgY29tcG9uZW50LCAnICtcbiAgICAgICAgICAgICAgJ2FzIHdlbGwgYXMgYW55IG1peGlucyB0aGV5IGluY2x1ZGUgdGhlbXNlbHZlcy4gJyArXG4gICAgICAgICAgICAgICdFeHBlY3RlZCBvYmplY3QgYnV0IGdvdCAlcy4nLFxuICAgICAgICAgICAgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q2xhc3MnLFxuICAgICAgICAgICAgc3BlYyA9PT0gbnVsbCA/IG51bGwgOiB0eXBlb2ZTcGVjXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX2ludmFyaWFudChcbiAgICAgIHR5cGVvZiBzcGVjICE9PSAnZnVuY3Rpb24nLFxuICAgICAgXCJSZWFjdENsYXNzOiBZb3UncmUgYXR0ZW1wdGluZyB0byBcIiArXG4gICAgICAgICd1c2UgYSBjb21wb25lbnQgY2xhc3Mgb3IgZnVuY3Rpb24gYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSAnICtcbiAgICAgICAgJ3JlZ3VsYXIgb2JqZWN0LidcbiAgICApO1xuICAgIF9pbnZhcmlhbnQoXG4gICAgICAhaXNWYWxpZEVsZW1lbnQoc3BlYyksXG4gICAgICBcIlJlYWN0Q2xhc3M6IFlvdSdyZSBhdHRlbXB0aW5nIHRvIFwiICtcbiAgICAgICAgJ3VzZSBhIGNvbXBvbmVudCBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LidcbiAgICApO1xuXG4gICAgdmFyIHByb3RvID0gQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIHZhciBhdXRvQmluZFBhaXJzID0gcHJvdG8uX19yZWFjdEF1dG9CaW5kUGFpcnM7XG5cbiAgICAvLyBCeSBoYW5kbGluZyBtaXhpbnMgYmVmb3JlIGFueSBvdGhlciBwcm9wZXJ0aWVzLCB3ZSBlbnN1cmUgdGhlIHNhbWVcbiAgICAvLyBjaGFpbmluZyBvcmRlciBpcyBhcHBsaWVkIHRvIG1ldGhvZHMgd2l0aCBERUZJTkVfTUFOWSBwb2xpY3ksIHdoZXRoZXJcbiAgICAvLyBtaXhpbnMgYXJlIGxpc3RlZCBiZWZvcmUgb3IgYWZ0ZXIgdGhlc2UgbWV0aG9kcyBpbiB0aGUgc3BlYy5cbiAgICBpZiAoc3BlYy5oYXNPd25Qcm9wZXJ0eShNSVhJTlNfS0VZKSkge1xuICAgICAgUkVTRVJWRURfU1BFQ19LRVlTLm1peGlucyhDb25zdHJ1Y3Rvciwgc3BlYy5taXhpbnMpO1xuICAgIH1cblxuICAgIGZvciAodmFyIG5hbWUgaW4gc3BlYykge1xuICAgICAgaWYgKCFzcGVjLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSA9PT0gTUlYSU5TX0tFWSkge1xuICAgICAgICAvLyBXZSBoYXZlIGFscmVhZHkgaGFuZGxlZCBtaXhpbnMgaW4gYSBzcGVjaWFsIGNhc2UgYWJvdmUuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcGVydHkgPSBzcGVjW25hbWVdO1xuICAgICAgdmFyIGlzQWxyZWFkeURlZmluZWQgPSBwcm90by5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICAgIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUoaXNBbHJlYWR5RGVmaW5lZCwgbmFtZSk7XG5cbiAgICAgIGlmIChSRVNFUlZFRF9TUEVDX0tFWVMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgUkVTRVJWRURfU1BFQ19LRVlTW25hbWVdKENvbnN0cnVjdG9yLCBwcm9wZXJ0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTZXR1cCBtZXRob2RzIG9uIHByb3RvdHlwZTpcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBtZW1iZXIgbWV0aG9kcyBzaG91bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgYm91bmQ6XG4gICAgICAgIC8vIDEuIEV4cGVjdGVkIFJlYWN0Q2xhc3MgbWV0aG9kcyAoaW4gdGhlIFwiaW50ZXJmYWNlXCIpLlxuICAgICAgICAvLyAyLiBPdmVycmlkZGVuIG1ldGhvZHMgKHRoYXQgd2VyZSBtaXhlZCBpbikuXG4gICAgICAgIHZhciBpc1JlYWN0Q2xhc3NNZXRob2QgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgdmFyIHNob3VsZEF1dG9CaW5kID1cbiAgICAgICAgICBpc0Z1bmN0aW9uICYmXG4gICAgICAgICAgIWlzUmVhY3RDbGFzc01ldGhvZCAmJlxuICAgICAgICAgICFpc0FscmVhZHlEZWZpbmVkICYmXG4gICAgICAgICAgc3BlYy5hdXRvYmluZCAhPT0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNob3VsZEF1dG9CaW5kKSB7XG4gICAgICAgICAgYXV0b0JpbmRQYWlycy5wdXNoKG5hbWUsIHByb3BlcnR5KTtcbiAgICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV07XG5cbiAgICAgICAgICAgIC8vIFRoZXNlIGNhc2VzIHNob3VsZCBhbHJlYWR5IGJlIGNhdWdodCBieSB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlLlxuICAgICAgICAgICAgX2ludmFyaWFudChcbiAgICAgICAgICAgICAgaXNSZWFjdENsYXNzTWV0aG9kICYmXG4gICAgICAgICAgICAgICAgKHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWV9NRVJHRUQnIHx8XG4gICAgICAgICAgICAgICAgICBzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTlknKSxcbiAgICAgICAgICAgICAgJ1JlYWN0Q2xhc3M6IFVuZXhwZWN0ZWQgc3BlYyBwb2xpY3kgJXMgZm9yIGtleSAlcyAnICtcbiAgICAgICAgICAgICAgICAnd2hlbiBtaXhpbmcgaW4gY29tcG9uZW50IHNwZWNzLicsXG4gICAgICAgICAgICAgIHNwZWNQb2xpY3ksXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIEZvciBtZXRob2RzIHdoaWNoIGFyZSBkZWZpbmVkIG1vcmUgdGhhbiBvbmNlLCBjYWxsIHRoZSBleGlzdGluZ1xuICAgICAgICAgICAgLy8gbWV0aG9kcyBiZWZvcmUgY2FsbGluZyB0aGUgbmV3IHByb3BlcnR5LCBtZXJnaW5nIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICAgICAgaWYgKHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWV9NRVJHRUQnKSB7XG4gICAgICAgICAgICAgIHByb3RvW25hbWVdID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZJykge1xuICAgICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgLy8gQWRkIHZlcmJvc2UgZGlzcGxheU5hbWUgdG8gdGhlIGZ1bmN0aW9uLCB3aGljaCBoZWxwcyB3aGVuIGxvb2tpbmdcbiAgICAgICAgICAgICAgLy8gYXQgcHJvZmlsaW5nIHRvb2xzLlxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nICYmIHNwZWMuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgICAgICBwcm90b1tuYW1lXS5kaXNwbGF5TmFtZSA9IHNwZWMuZGlzcGxheU5hbWUgKyAnXycgKyBuYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgICBpZiAoIXN0YXRpY3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgbmFtZSBpbiBzdGF0aWNzKSB7XG4gICAgICB2YXIgcHJvcGVydHkgPSBzdGF0aWNzW25hbWVdO1xuICAgICAgaWYgKCFzdGF0aWNzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNSZXNlcnZlZCA9IG5hbWUgaW4gUkVTRVJWRURfU1BFQ19LRVlTO1xuICAgICAgX2ludmFyaWFudChcbiAgICAgICAgIWlzUmVzZXJ2ZWQsXG4gICAgICAgICdSZWFjdENsYXNzOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lIGEgcmVzZXJ2ZWQgJyArXG4gICAgICAgICAgJ3Byb3BlcnR5LCBgJXNgLCB0aGF0IHNob3VsZG5cXCd0IGJlIG9uIHRoZSBcInN0YXRpY3NcIiBrZXkuIERlZmluZSBpdCAnICtcbiAgICAgICAgICAnYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgaW5zdGVhZDsgaXQgd2lsbCBzdGlsbCBiZSBhY2Nlc3NpYmxlIG9uIHRoZSAnICtcbiAgICAgICAgICAnY29uc3RydWN0b3IuJyxcbiAgICAgICAgbmFtZVxuICAgICAgKTtcblxuICAgICAgdmFyIGlzSW5oZXJpdGVkID0gbmFtZSBpbiBDb25zdHJ1Y3RvcjtcbiAgICAgIF9pbnZhcmlhbnQoXG4gICAgICAgICFpc0luaGVyaXRlZCxcbiAgICAgICAgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgJyArXG4gICAgICAgICAgJ2Alc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlICcgK1xuICAgICAgICAgICdkdWUgdG8gYSBtaXhpbi4nLFxuICAgICAgICBuYW1lXG4gICAgICApO1xuICAgICAgQ29uc3RydWN0b3JbbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgdHdvIG9iamVjdHMsIGJ1dCB0aHJvdyBpZiBib3RoIGNvbnRhaW4gdGhlIHNhbWUga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb25lIFRoZSBmaXJzdCBvYmplY3QsIHdoaWNoIGlzIG11dGF0ZWQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0d28gVGhlIHNlY29uZCBvYmplY3RcbiAgICogQHJldHVybiB7b2JqZWN0fSBvbmUgYWZ0ZXIgaXQgaGFzIGJlZW4gbXV0YXRlZCB0byBjb250YWluIGV2ZXJ5dGhpbmcgaW4gdHdvLlxuICAgKi9cbiAgZnVuY3Rpb24gbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhvbmUsIHR3bykge1xuICAgIF9pbnZhcmlhbnQoXG4gICAgICBvbmUgJiYgdHdvICYmIHR5cGVvZiBvbmUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0d28gPT09ICdvYmplY3QnLFxuICAgICAgJ21lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogQ2Fubm90IG1lcmdlIG5vbi1vYmplY3RzLidcbiAgICApO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHR3bykge1xuICAgICAgaWYgKHR3by5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIF9pbnZhcmlhbnQoXG4gICAgICAgICAgb25lW2tleV0gPT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAnbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cygpOiAnICtcbiAgICAgICAgICAgICdUcmllZCB0byBtZXJnZSB0d28gb2JqZWN0cyB3aXRoIHRoZSBzYW1lIGtleTogYCVzYC4gVGhpcyBjb25mbGljdCAnICtcbiAgICAgICAgICAgICdtYXkgYmUgZHVlIHRvIGEgbWl4aW47IGluIHBhcnRpY3VsYXIsIHRoaXMgbWF5IGJlIGNhdXNlZCBieSB0d28gJyArXG4gICAgICAgICAgICAnZ2V0SW5pdGlhbFN0YXRlKCkgb3IgZ2V0RGVmYXVsdFByb3BzKCkgbWV0aG9kcyByZXR1cm5pbmcgb2JqZWN0cyAnICtcbiAgICAgICAgICAgICd3aXRoIGNsYXNoaW5nIGtleXMuJyxcbiAgICAgICAgICBrZXlcbiAgICAgICAgKTtcbiAgICAgICAgb25lW2tleV0gPSB0d29ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9uZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIG1lcmdlcyB0aGVpciByZXR1cm4gdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZFJlc3VsdCgpIHtcbiAgICAgIHZhciBhID0gb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB2YXIgYiA9IHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKGEgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuICAgICAgdmFyIGMgPSB7fTtcbiAgICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYSk7XG4gICAgICBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKGMsIGIpO1xuICAgICAgcmV0dXJuIGM7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIGlnbm9yZXMgdGhlaXIgcmV0dXJuIHZhbGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluZWRGdW5jdGlvbihvbmUsIHR3bykge1xuICAgIHJldHVybiBmdW5jdGlvbiBjaGFpbmVkRnVuY3Rpb24oKSB7XG4gICAgICBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQmluZHMgYSBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgTWV0aG9kIHRvIGJlIGJvdW5kLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGJvdW5kIG1ldGhvZC5cbiAgICovXG4gIGZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCkge1xuICAgIHZhciBib3VuZE1ldGhvZCA9IG1ldGhvZC5iaW5kKGNvbXBvbmVudCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBudWxsO1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuY29uc3RydWN0b3IuZGlzcGxheU5hbWU7XG4gICAgICB2YXIgX2JpbmQgPSBib3VuZE1ldGhvZC5iaW5kO1xuICAgICAgYm91bmRNZXRob2QuYmluZCA9IGZ1bmN0aW9uKG5ld1RoaXMpIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLFxuICAgICAgICAgICAgX2tleSA9IDE7XG4gICAgICAgICAgX2tleSA8IF9sZW47XG4gICAgICAgICAgX2tleSsrXG4gICAgICAgICkge1xuICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlciBpcyB0cnlpbmcgdG8gYmluZCgpIGFuIGF1dG9ib3VuZCBtZXRob2Q7IHdlIGVmZmVjdGl2ZWx5IHdpbGxcbiAgICAgICAgLy8gaWdub3JlIHRoZSB2YWx1ZSBvZiBcInRoaXNcIiB0aGF0IHRoZSB1c2VyIGlzIHRyeWluZyB0byB1c2UsIHNvXG4gICAgICAgIC8vIGxldCdzIHdhcm4uXG4gICAgICAgIGlmIChuZXdUaGlzICE9PSBjb21wb25lbnQgJiYgbmV3VGhpcyAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ2JpbmQoKTogUmVhY3QgY29tcG9uZW50IG1ldGhvZHMgbWF5IG9ubHkgYmUgYm91bmQgdG8gdGhlICcgK1xuICAgICAgICAgICAgICAgICdjb21wb25lbnQgaW5zdGFuY2UuIFNlZSAlcycsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ2JpbmQoKTogWW91IGFyZSBiaW5kaW5nIGEgY29tcG9uZW50IG1ldGhvZCB0byB0aGUgY29tcG9uZW50LiAnICtcbiAgICAgICAgICAgICAgICAnUmVhY3QgZG9lcyB0aGlzIGZvciB5b3UgYXV0b21hdGljYWxseSBpbiBhIGhpZ2gtcGVyZm9ybWFuY2UgJyArXG4gICAgICAgICAgICAgICAgJ3dheSwgc28geW91IGNhbiBzYWZlbHkgcmVtb3ZlIHRoaXMgY2FsbC4gU2VlICVzJyxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGJvdW5kTWV0aG9kO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWJvdW5kTWV0aG9kID0gX2JpbmQuYXBwbHkoYm91bmRNZXRob2QsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gYXJncztcbiAgICAgICAgcmV0dXJuIHJlYm91bmRNZXRob2Q7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYm91bmRNZXRob2Q7XG4gIH1cblxuICAvKipcbiAgICogQmluZHMgYWxsIGF1dG8tYm91bmQgbWV0aG9kcyBpbiBhIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICAgKi9cbiAgZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kcyhjb21wb25lbnQpIHtcbiAgICB2YXIgcGFpcnMgPSBjb21wb25lbnQuX19yZWFjdEF1dG9CaW5kUGFpcnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgdmFyIGF1dG9CaW5kS2V5ID0gcGFpcnNbaV07XG4gICAgICB2YXIgbWV0aG9kID0gcGFpcnNbaSArIDFdO1xuICAgICAgY29tcG9uZW50W2F1dG9CaW5kS2V5XSA9IGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIElzTW91bnRlZFByZU1peGluID0ge1xuICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX19pc01vdW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgSXNNb3VudGVkUG9zdE1peGluID0ge1xuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX19pc01vdW50ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBtb3JlIHRvIHRoZSBSZWFjdENsYXNzIGJhc2UgY2xhc3MuIFRoZXNlIGFyZSBhbGwgbGVnYWN5IGZlYXR1cmVzIGFuZFxuICAgKiB0aGVyZWZvcmUgbm90IGFscmVhZHkgcGFydCBvZiB0aGUgbW9kZXJuIFJlYWN0Q29tcG9uZW50LlxuICAgKi9cbiAgdmFyIFJlYWN0Q2xhc3NNaXhpbiA9IHtcbiAgICAvKipcbiAgICAgKiBUT0RPOiBUaGlzIHdpbGwgYmUgZGVwcmVjYXRlZCBiZWNhdXNlIHN0YXRlIHNob3VsZCBhbHdheXMga2VlcCBhIGNvbnNpc3RlbnRcbiAgICAgKiB0eXBlIHNpZ25hdHVyZSBhbmQgdGhlIG9ubHkgdXNlIGNhc2UgZm9yIHRoaXMsIGlzIHRvIGF2b2lkIHRoYXQuXG4gICAgICovXG4gICAgcmVwbGFjZVN0YXRlOiBmdW5jdGlvbihuZXdTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKHRoaXMsIG5ld1N0YXRlLCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGZpbmFsXG4gICAgICovXG4gICAgaXNNb3VudGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgdGhpcy5fX2RpZFdhcm5Jc01vdW50ZWQsXG4gICAgICAgICAgJyVzOiBpc01vdW50ZWQgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwICcgK1xuICAgICAgICAgICAgJ3N1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gY29tcG9uZW50V2lsbFVubW91bnQgdG8gJyArXG4gICAgICAgICAgICAncHJldmVudCBtZW1vcnkgbGVha3MuJyxcbiAgICAgICAgICAodGhpcy5jb25zdHJ1Y3RvciAmJiB0aGlzLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lKSB8fFxuICAgICAgICAgICAgdGhpcy5uYW1lIHx8XG4gICAgICAgICAgICAnQ29tcG9uZW50J1xuICAgICAgICApO1xuICAgICAgICB0aGlzLl9fZGlkV2FybklzTW91bnRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gISF0aGlzLl9faXNNb3VudGVkO1xuICAgIH1cbiAgfTtcblxuICB2YXIgUmVhY3RDbGFzc0NvbXBvbmVudCA9IGZ1bmN0aW9uKCkge307XG4gIF9hc3NpZ24oXG4gICAgUmVhY3RDbGFzc0NvbXBvbmVudC5wcm90b3R5cGUsXG4gICAgUmVhY3RDb21wb25lbnQucHJvdG90eXBlLFxuICAgIFJlYWN0Q2xhc3NNaXhpblxuICApO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29tcG9zaXRlIGNvbXBvbmVudCBjbGFzcyBnaXZlbiBhIGNsYXNzIHNwZWNpZmljYXRpb24uXG4gICAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jcmVhdGVjbGFzc1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc3BlYyBDbGFzcyBzcGVjaWZpY2F0aW9uICh3aGljaCBtdXN0IGRlZmluZSBgcmVuZGVyYCkuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBDb21wb25lbnQgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUNsYXNzKHNwZWMpIHtcbiAgICAvLyBUbyBrZWVwIG91ciB3YXJuaW5ncyBtb3JlIHVuZGVyc3RhbmRhYmxlLCB3ZSdsbCB1c2UgYSBsaXR0bGUgaGFjayBoZXJlIHRvXG4gICAgLy8gZW5zdXJlIHRoYXQgQ29uc3RydWN0b3IubmFtZSAhPT0gJ0NvbnN0cnVjdG9yJy4gVGhpcyBtYWtlcyBzdXJlIHdlIGRvbid0XG4gICAgLy8gdW5uZWNlc3NhcmlseSBpZGVudGlmeSBhIGNsYXNzIHdpdGhvdXQgZGlzcGxheU5hbWUgYXMgJ0NvbnN0cnVjdG9yJy5cbiAgICB2YXIgQ29uc3RydWN0b3IgPSBpZGVudGl0eShmdW5jdGlvbihwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAgICAgLy8gVGhpcyBjb25zdHJ1Y3RvciBnZXRzIG92ZXJyaWRkZW4gYnkgbW9ja3MuIFRoZSBhcmd1bWVudCBpcyB1c2VkXG4gICAgICAvLyBieSBtb2NrcyB0byBhc3NlcnQgb24gd2hhdCBnZXRzIG1vdW50ZWQuXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgdGhpcyBpbnN0YW5jZW9mIENvbnN0cnVjdG9yLFxuICAgICAgICAgICdTb21ldGhpbmcgaXMgY2FsbGluZyBhIFJlYWN0IGNvbXBvbmVudCBkaXJlY3RseS4gVXNlIGEgZmFjdG9yeSBvciAnICtcbiAgICAgICAgICAgICdKU1ggaW5zdGVhZC4gU2VlOiBodHRwczovL2ZiLm1lL3JlYWN0LWxlZ2FjeWZhY3RvcnknXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdpcmUgdXAgYXV0by1iaW5kaW5nXG4gICAgICBpZiAodGhpcy5fX3JlYWN0QXV0b0JpbmRQYWlycy5sZW5ndGgpIHtcbiAgICAgICAgYmluZEF1dG9CaW5kTWV0aG9kcyh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcblxuICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG5cbiAgICAgIC8vIFJlYWN0Q2xhc3NlcyBkb2Vzbid0IGhhdmUgY29uc3RydWN0b3JzLiBJbnN0ZWFkLCB0aGV5IHVzZSB0aGVcbiAgICAgIC8vIGdldEluaXRpYWxTdGF0ZSBhbmQgY29tcG9uZW50V2lsbE1vdW50IG1ldGhvZHMgZm9yIGluaXRpYWxpemF0aW9uLlxuXG4gICAgICB2YXIgaW5pdGlhbFN0YXRlID0gdGhpcy5nZXRJbml0aWFsU3RhdGUgPyB0aGlzLmdldEluaXRpYWxTdGF0ZSgpIDogbnVsbDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgICBpZiAoXG4gICAgICAgICAgaW5pdGlhbFN0YXRlID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICB0aGlzLmdldEluaXRpYWxTdGF0ZS5faXNNb2NrRnVuY3Rpb25cbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBiYWQgcHJhY3RpY2UuIENvbnNpZGVyIHdhcm5pbmcgaGVyZSBhbmRcbiAgICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICAgIGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9pbnZhcmlhbnQoXG4gICAgICAgIHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGluaXRpYWxTdGF0ZSksXG4gICAgICAgICclcy5nZXRJbml0aWFsU3RhdGUoKTogbXVzdCByZXR1cm4gYW4gb2JqZWN0IG9yIG51bGwnLFxuICAgICAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnXG4gICAgICApO1xuXG4gICAgICB0aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgIH0pO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IG5ldyBSZWFjdENsYXNzQ29tcG9uZW50KCk7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLl9fcmVhY3RBdXRvQmluZFBhaXJzID0gW107XG5cbiAgICBpbmplY3RlZE1peGlucy5mb3JFYWNoKG1peFNwZWNJbnRvQ29tcG9uZW50LmJpbmQobnVsbCwgQ29uc3RydWN0b3IpKTtcblxuICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBJc01vdW50ZWRQcmVNaXhpbik7XG4gICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpO1xuICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBJc01vdW50ZWRQb3N0TWl4aW4pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgZGVmYXVsdFByb3BzIHByb3BlcnR5IGFmdGVyIGFsbCBtaXhpbnMgaGF2ZSBiZWVuIG1lcmdlZC5cbiAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICBDb25zdHJ1Y3Rvci5kZWZhdWx0UHJvcHMgPSBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMoKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gVGhpcyBpcyBhIHRhZyB0byBpbmRpY2F0ZSB0aGF0IHRoZSB1c2Ugb2YgdGhlc2UgbWV0aG9kIG5hbWVzIGlzIG9rLFxuICAgICAgLy8gc2luY2UgaXQncyB1c2VkIHdpdGggY3JlYXRlQ2xhc3MuIElmIGl0J3Mgbm90LCB0aGVuIGl0J3MgbGlrZWx5IGFcbiAgICAgIC8vIG1pc3Rha2Ugc28gd2UnbGwgd2FybiB5b3UgdG8gdXNlIHRoZSBzdGF0aWMgcHJvcGVydHksIHByb3BlcnR5XG4gICAgICAvLyBpbml0aWFsaXplciBvciBjb25zdHJ1Y3RvciByZXNwZWN0aXZlbHkuXG4gICAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKENvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUpIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA9IHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgIF9pbnZhcmlhbnQoXG4gICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUucmVuZGVyLFxuICAgICAgJ2NyZWF0ZUNsYXNzKC4uLik6IENsYXNzIHNwZWNpZmljYXRpb24gbXVzdCBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuJ1xuICAgICk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRTaG91bGRVcGRhdGUsXG4gICAgICAgICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgK1xuICAgICAgICAgICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICtcbiAgICAgICAgICAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgK1xuICAgICAgICAgICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLFxuICAgICAgICBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCdcbiAgICAgICk7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICAhQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMsXG4gICAgICAgICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgK1xuICAgICAgICAgICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JyxcbiAgICAgICAgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFJlZHVjZSB0aW1lIHNwZW50IGRvaW5nIGxvb2t1cHMgYnkgc2V0dGluZyB0aGVzZSBvbiB0aGUgcHJvdG90eXBlLlxuICAgIGZvciAodmFyIG1ldGhvZE5hbWUgaW4gUmVhY3RDbGFzc0ludGVyZmFjZSkge1xuICAgICAgaWYgKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlQ2xhc3M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmFjdG9yeTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jcmVhdGUtcmVhY3QtY2xhc3MvZmFjdG9yeS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLicpIDogX3Byb2RJbnZhcmlhbnQoJzE0MycpIDogdm9pZCAwO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb25seUNoaWxkO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvb25seUNoaWxkLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL1JlYWN0RE9NJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbi8qIGdsb2JhbHMgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdERlZmF1bHRJbmplY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdEluamVjdGlvbicpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG52YXIgUmVhY3RWZXJzaW9uID0gcmVxdWlyZSgnLi9SZWFjdFZlcnNpb24nKTtcblxudmFyIGZpbmRET01Ob2RlID0gcmVxdWlyZSgnLi9maW5kRE9NTm9kZScpO1xudmFyIGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlID0gcmVxdWlyZSgnLi9nZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZScpO1xudmFyIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyID0gcmVxdWlyZSgnLi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cblJlYWN0RGVmYXVsdEluamVjdGlvbi5pbmplY3QoKTtcblxudmFyIFJlYWN0RE9NID0ge1xuICBmaW5kRE9NTm9kZTogZmluZERPTU5vZGUsXG4gIHJlbmRlcjogUmVhY3RNb3VudC5yZW5kZXIsXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IFJlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZSxcbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzLFxuICB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogcmVuZGVyU3VidHJlZUludG9Db250YWluZXJcbiAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cbn07XG5cbi8vIEluamVjdCB0aGUgcnVudGltZSBpbnRvIGEgZGV2dG9vbHMgZ2xvYmFsIGhvb2sgcmVnYXJkbGVzcyBvZiBicm93c2VyLlxuLy8gQWxsb3dzIGZvciBkZWJ1Z2dpbmcgd2hlbiB0aGUgaG9vayBpcyBpbmplY3RlZCBvbiB0aGUgcGFnZS5cbmlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uaW5qZWN0KHtcbiAgICBDb21wb25lbnRUcmVlOiB7XG4gICAgICBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZTogUmVhY3RET01Db21wb25lbnRUcmVlLmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuICAgICAgZ2V0Tm9kZUZyb21JbnN0YW5jZTogZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgLy8gaW5zdCBpcyBhbiBpbnRlcm5hbCBpbnN0YW5jZSAoYnV0IGNvdWxkIGJlIGEgY29tcG9zaXRlKVxuICAgICAgICBpZiAoaW5zdC5fcmVuZGVyZWRDb21wb25lbnQpIHtcbiAgICAgICAgICBpbnN0ID0gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUoaW5zdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgICByZXR1cm4gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIE1vdW50OiBSZWFjdE1vdW50LFxuICAgIFJlY29uY2lsZXI6IFJlYWN0UmVjb25jaWxlclxuICB9KTtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbiAgaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB3aW5kb3cudG9wID09PSB3aW5kb3cuc2VsZikge1xuICAgIC8vIEZpcnN0IGNoZWNrIGlmIGRldnRvb2xzIGlzIG5vdCBpbnN0YWxsZWRcbiAgICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIElmIHdlJ3JlIGluIENocm9tZSBvciBGaXJlZm94LCBwcm92aWRlIGEgZG93bmxvYWQgbGluayBpZiBub3QgaW5zdGFsbGVkLlxuICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA9PT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPiAtMSkge1xuICAgICAgICAvLyBGaXJlZm94IGRvZXMgbm90IGhhdmUgdGhlIGlzc3VlIHdpdGggZGV2dG9vbHMgbG9hZGVkIG92ZXIgZmlsZTovL1xuICAgICAgICB2YXIgc2hvd0ZpbGVVcmxNZXNzYWdlID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sLmluZGV4T2YoJ2h0dHAnKSA9PT0gLTEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xO1xuICAgICAgICBjb25zb2xlLmRlYnVnKCdEb3dubG9hZCB0aGUgUmVhY3QgRGV2VG9vbHMgJyArIChzaG93RmlsZVVybE1lc3NhZ2UgPyAnYW5kIHVzZSBhbiBIVFRQIHNlcnZlciAoaW5zdGVhZCBvZiBhIGZpbGU6IFVSTCkgJyA6ICcnKSArICdmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRlc3RGdW5jID0gZnVuY3Rpb24gdGVzdEZuKCkge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoKHRlc3RGdW5jLm5hbWUgfHwgdGVzdEZ1bmMudG9TdHJpbmcoKSkuaW5kZXhPZigndGVzdEZuJykgIT09IC0xLCBcIkl0IGxvb2tzIGxpa2UgeW91J3JlIHVzaW5nIGEgbWluaWZpZWQgY29weSBvZiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgXCIgKyAnb2YgUmVhY3QuIFdoZW4gZGVwbG95aW5nIFJlYWN0IGFwcHMgdG8gcHJvZHVjdGlvbiwgbWFrZSBzdXJlIHRvIHVzZSAnICsgJ3RoZSBwcm9kdWN0aW9uIGJ1aWxkIHdoaWNoIHNraXBzIGRldmVsb3BtZW50IHdhcm5pbmdzIGFuZCBpcyBmYXN0ZXIuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtbWluaWZpY2F0aW9uIGZvciBtb3JlIGRldGFpbHMuJykgOiB2b2lkIDA7XG5cbiAgICAvLyBJZiB3ZSdyZSBpbiBJRTgsIGNoZWNrIHRvIHNlZSBpZiB3ZSBhcmUgaW4gY29tcGF0aWJpbGl0eSBtb2RlIGFuZCBwcm92aWRlXG4gICAgLy8gaW5mb3JtYXRpb24gb24gcHJldmVudGluZyBjb21wYXRpYmlsaXR5IG1vZGVcbiAgICB2YXIgaWVDb21wYXRpYmlsaXR5TW9kZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZSAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPCA4O1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWllQ29tcGF0aWJpbGl0eU1vZGUsICdJbnRlcm5ldCBFeHBsb3JlciBpcyBydW5uaW5nIGluIGNvbXBhdGliaWxpdHkgbW9kZTsgcGxlYXNlIGFkZCB0aGUgJyArICdmb2xsb3dpbmcgdGFnIHRvIHlvdXIgSFRNTCB0byBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmc6ICcgKyAnPG1ldGEgaHR0cC1lcXVpdj1cIlgtVUEtQ29tcGF0aWJsZVwiIGNvbnRlbnQ9XCJJRT1lZGdlXCIgLz4nKSA6IHZvaWQgMDtcblxuICAgIHZhciBleHBlY3RlZEZlYXR1cmVzID0gW1xuICAgIC8vIHNoaW1zXG4gICAgQXJyYXkuaXNBcnJheSwgQXJyYXkucHJvdG90eXBlLmV2ZXJ5LCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCwgQXJyYXkucHJvdG90eXBlLmluZGV4T2YsIEFycmF5LnByb3RvdHlwZS5tYXAsIERhdGUubm93LCBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCwgT2JqZWN0LmtleXMsIFN0cmluZy5wcm90b3R5cGUudHJpbV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkRmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghZXhwZWN0ZWRGZWF0dXJlc1tpXSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ09uZSBvciBtb3JlIEVTNSBzaGltcyBleHBlY3RlZCBieSBSZWFjdCBhcmUgbm90IGF2YWlsYWJsZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctcG9seWZpbGxzJykgOiB2b2lkIDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG4gIHZhciBSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vaycpO1xuICB2YXIgUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rID0gcmVxdWlyZSgnLi9SZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2snKTtcbiAgdmFyIFJlYWN0RE9NSW52YWxpZEFSSUFIb29rID0gcmVxdWlyZSgnLi9SZWFjdERPTUludmFsaWRBUklBSG9vaycpO1xuXG4gIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5hZGRIb29rKFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vayk7XG4gIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5hZGRIb29rKFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vayk7XG4gIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5hZGRIb29rKFJlYWN0RE9NSW52YWxpZEFSSUFIb29rKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBUklBRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKCcuL0FSSUFET01Qcm9wZXJ0eUNvbmZpZycpO1xudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4nKTtcbnZhciBDaGFuZ2VFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vQ2hhbmdlRXZlbnRQbHVnaW4nKTtcbnZhciBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlciA9IHJlcXVpcmUoJy4vRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXInKTtcbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0VudGVyTGVhdmVFdmVudFBsdWdpbicpO1xudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZyA9IHJlcXVpcmUoJy4vSFRNTERPTVByb3BlcnR5Q29uZmlnJyk7XG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdERPTUVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdERPTUVtcHR5Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RET01UcmVlVHJhdmVyc2FsID0gcmVxdWlyZSgnLi9SZWFjdERPTVRyZWVUcmF2ZXJzYWwnKTtcbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NVGV4dENvbXBvbmVudCcpO1xudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3knKTtcbnZhciBSZWFjdEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCcuL1JlYWN0RXZlbnRMaXN0ZW5lcicpO1xudmFyIFJlYWN0SW5qZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluamVjdGlvbicpO1xudmFyIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24nKTtcbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHJlcXVpcmUoJy4vU1ZHRE9NUHJvcGVydHlDb25maWcnKTtcbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vU2VsZWN0RXZlbnRQbHVnaW4nKTtcbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vU2ltcGxlRXZlbnRQbHVnaW4nKTtcblxudmFyIGFscmVhZHlJbmplY3RlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpbmplY3QoKSB7XG4gIGlmIChhbHJlYWR5SW5qZWN0ZWQpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGlzIGN1cnJlbnRseSB0cnVlIGJlY2F1c2UgdGhlc2UgaW5qZWN0aW9ucyBhcmUgc2hhcmVkIGJldHdlZW5cbiAgICAvLyB0aGUgY2xpZW50IGFuZCB0aGUgc2VydmVyIHBhY2thZ2UuIFRoZXkgc2hvdWxkIGJlIGJ1aWx0IGluZGVwZW5kZW50bHlcbiAgICAvLyBhbmQgbm90IHNoYXJlIGFueSBpbmplY3Rpb24gc3RhdGUuIFRoZW4gdGhpcyBwcm9ibGVtIHdpbGwgYmUgc29sdmVkLlxuICAgIHJldHVybjtcbiAgfVxuICBhbHJlYWR5SW5qZWN0ZWQgPSB0cnVlO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50RW1pdHRlci5pbmplY3RSZWFjdEV2ZW50TGlzdGVuZXIoUmVhY3RFdmVudExpc3RlbmVyKTtcblxuICAvKipcbiAgICogSW5qZWN0IG1vZHVsZXMgZm9yIHJlc29sdmluZyBET00gaGllcmFyY2h5IGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gICAqL1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RFdmVudFBsdWdpbk9yZGVyKERlZmF1bHRFdmVudFBsdWdpbk9yZGVyKTtcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5VdGlscy5pbmplY3RDb21wb25lbnRUcmVlKFJlYWN0RE9NQ29tcG9uZW50VHJlZSk7XG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luVXRpbHMuaW5qZWN0VHJlZVRyYXZlcnNhbChSZWFjdERPTVRyZWVUcmF2ZXJzYWwpO1xuXG4gIC8qKlxuICAgKiBTb21lIGltcG9ydGFudCBldmVudCBwbHVnaW5zIGluY2x1ZGVkIGJ5IGRlZmF1bHQgKHdpdGhvdXQgaGF2aW5nIHRvIHJlcXVpcmVcbiAgICogdGhlbSkuXG4gICAqL1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoe1xuICAgIFNpbXBsZUV2ZW50UGx1Z2luOiBTaW1wbGVFdmVudFBsdWdpbixcbiAgICBFbnRlckxlYXZlRXZlbnRQbHVnaW46IEVudGVyTGVhdmVFdmVudFBsdWdpbixcbiAgICBDaGFuZ2VFdmVudFBsdWdpbjogQ2hhbmdlRXZlbnRQbHVnaW4sXG4gICAgU2VsZWN0RXZlbnRQbHVnaW46IFNlbGVjdEV2ZW50UGx1Z2luLFxuICAgIEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbiAgfSk7XG5cbiAgUmVhY3RJbmplY3Rpb24uSG9zdENvbXBvbmVudC5pbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3MoUmVhY3RET01Db21wb25lbnQpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkhvc3RDb21wb25lbnQuaW5qZWN0VGV4dENvbXBvbmVudENsYXNzKFJlYWN0RE9NVGV4dENvbXBvbmVudCk7XG5cbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoQVJJQURPTVByb3BlcnR5Q29uZmlnKTtcbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoSFRNTERPTVByb3BlcnR5Q29uZmlnKTtcbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoU1ZHRE9NUHJvcGVydHlDb25maWcpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkVtcHR5Q29tcG9uZW50LmluamVjdEVtcHR5Q29tcG9uZW50RmFjdG9yeShmdW5jdGlvbiAoaW5zdGFudGlhdGUpIHtcbiAgICByZXR1cm4gbmV3IFJlYWN0RE9NRW1wdHlDb21wb25lbnQoaW5zdGFudGlhdGUpO1xuICB9KTtcblxuICBSZWFjdEluamVjdGlvbi5VcGRhdGVzLmluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuICBSZWFjdEluamVjdGlvbi5VcGRhdGVzLmluamVjdEJhdGNoaW5nU3RyYXRlZ3koUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSk7XG5cbiAgUmVhY3RJbmplY3Rpb24uQ29tcG9uZW50LmluamVjdEVudmlyb25tZW50KFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluamVjdDogaW5qZWN0XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RGVmYXVsdEluamVjdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBUklBRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIFByb3BlcnRpZXM6IHtcbiAgICAvLyBHbG9iYWwgU3RhdGVzIGFuZCBQcm9wZXJ0aWVzXG4gICAgJ2FyaWEtY3VycmVudCc6IDAsIC8vIHN0YXRlXG4gICAgJ2FyaWEtZGV0YWlscyc6IDAsXG4gICAgJ2FyaWEtZGlzYWJsZWQnOiAwLCAvLyBzdGF0ZVxuICAgICdhcmlhLWhpZGRlbic6IDAsIC8vIHN0YXRlXG4gICAgJ2FyaWEtaW52YWxpZCc6IDAsIC8vIHN0YXRlXG4gICAgJ2FyaWEta2V5c2hvcnRjdXRzJzogMCxcbiAgICAnYXJpYS1sYWJlbCc6IDAsXG4gICAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogMCxcbiAgICAvLyBXaWRnZXQgQXR0cmlidXRlc1xuICAgICdhcmlhLWF1dG9jb21wbGV0ZSc6IDAsXG4gICAgJ2FyaWEtY2hlY2tlZCc6IDAsXG4gICAgJ2FyaWEtZXhwYW5kZWQnOiAwLFxuICAgICdhcmlhLWhhc3BvcHVwJzogMCxcbiAgICAnYXJpYS1sZXZlbCc6IDAsXG4gICAgJ2FyaWEtbW9kYWwnOiAwLFxuICAgICdhcmlhLW11bHRpbGluZSc6IDAsXG4gICAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogMCxcbiAgICAnYXJpYS1vcmllbnRhdGlvbic6IDAsXG4gICAgJ2FyaWEtcGxhY2Vob2xkZXInOiAwLFxuICAgICdhcmlhLXByZXNzZWQnOiAwLFxuICAgICdhcmlhLXJlYWRvbmx5JzogMCxcbiAgICAnYXJpYS1yZXF1aXJlZCc6IDAsXG4gICAgJ2FyaWEtc2VsZWN0ZWQnOiAwLFxuICAgICdhcmlhLXNvcnQnOiAwLFxuICAgICdhcmlhLXZhbHVlbWF4JzogMCxcbiAgICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICAgJ2FyaWEtdmFsdWVub3cnOiAwLFxuICAgICdhcmlhLXZhbHVldGV4dCc6IDAsXG4gICAgLy8gTGl2ZSBSZWdpb24gQXR0cmlidXRlc1xuICAgICdhcmlhLWF0b21pYyc6IDAsXG4gICAgJ2FyaWEtYnVzeSc6IDAsXG4gICAgJ2FyaWEtbGl2ZSc6IDAsXG4gICAgJ2FyaWEtcmVsZXZhbnQnOiAwLFxuICAgIC8vIERyYWctYW5kLURyb3AgQXR0cmlidXRlc1xuICAgICdhcmlhLWRyb3BlZmZlY3QnOiAwLFxuICAgICdhcmlhLWdyYWJiZWQnOiAwLFxuICAgIC8vIFJlbGF0aW9uc2hpcCBBdHRyaWJ1dGVzXG4gICAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IDAsXG4gICAgJ2FyaWEtY29sY291bnQnOiAwLFxuICAgICdhcmlhLWNvbGluZGV4JzogMCxcbiAgICAnYXJpYS1jb2xzcGFuJzogMCxcbiAgICAnYXJpYS1jb250cm9scyc6IDAsXG4gICAgJ2FyaWEtZGVzY3JpYmVkYnknOiAwLFxuICAgICdhcmlhLWVycm9ybWVzc2FnZSc6IDAsXG4gICAgJ2FyaWEtZmxvd3RvJzogMCxcbiAgICAnYXJpYS1sYWJlbGxlZGJ5JzogMCxcbiAgICAnYXJpYS1vd25zJzogMCxcbiAgICAnYXJpYS1wb3NpbnNldCc6IDAsXG4gICAgJ2FyaWEtcm93Y291bnQnOiAwLFxuICAgICdhcmlhLXJvd2luZGV4JzogMCxcbiAgICAnYXJpYS1yb3dzcGFuJzogMCxcbiAgICAnYXJpYS1zZXRzaXplJzogMFxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge30sXG4gIERPTVByb3BlcnR5TmFtZXM6IHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFSSUFET01Qcm9wZXJ0eUNvbmZpZztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9BUklBRE9NUHJvcGVydHlDb25maWcuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSA9IHJlcXVpcmUoJy4vRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlJyk7XG52YXIgU3ludGhldGljQ29tcG9zaXRpb25FdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljQ29tcG9zaXRpb25FdmVudCcpO1xudmFyIFN5bnRoZXRpY0lucHV0RXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0lucHV0RXZlbnQnKTtcblxudmFyIEVORF9LRVlDT0RFUyA9IFs5LCAxMywgMjcsIDMyXTsgLy8gVGFiLCBSZXR1cm4sIEVzYywgU3BhY2VcbnZhciBTVEFSVF9LRVlDT0RFID0gMjI5O1xuXG52YXIgY2FuVXNlQ29tcG9zaXRpb25FdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnQ29tcG9zaXRpb25FdmVudCcgaW4gd2luZG93O1xuXG52YXIgZG9jdW1lbnRNb2RlID0gbnVsbDtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHtcbiAgZG9jdW1lbnRNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xufVxuXG4vLyBXZWJraXQgb2ZmZXJzIGEgdmVyeSB1c2VmdWwgYHRleHRJbnB1dGAgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0b1xuLy8gZGlyZWN0bHkgcmVwcmVzZW50IGBiZWZvcmVJbnB1dGAuIFRoZSBJRSBgdGV4dGlucHV0YCBldmVudCBpcyBub3QgYXNcbi8vIHVzZWZ1bCwgc28gd2UgZG9uJ3QgdXNlIGl0LlxudmFyIGNhblVzZVRleHRJbnB1dEV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlICYmICFpc1ByZXN0bygpO1xuXG4vLyBJbiBJRTkrLCB3ZSBoYXZlIGFjY2VzcyB0byBjb21wb3NpdGlvbiBldmVudHMsIGJ1dCB0aGUgZGF0YSBzdXBwbGllZFxuLy8gYnkgdGhlIG5hdGl2ZSBjb21wb3NpdGlvbmVuZCBldmVudCBtYXkgYmUgaW5jb3JyZWN0LiBKYXBhbmVzZSBpZGVvZ3JhcGhpY1xuLy8gc3BhY2VzLCBmb3IgaW5zdGFuY2UgKFxcdTMwMDApIGFyZSBub3QgcmVjb3JkZWQgY29ycmVjdGx5LlxudmFyIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICghY2FuVXNlQ29tcG9zaXRpb25FdmVudCB8fCBkb2N1bWVudE1vZGUgJiYgZG9jdW1lbnRNb2RlID4gOCAmJiBkb2N1bWVudE1vZGUgPD0gMTEpO1xuXG4vKipcbiAqIE9wZXJhIDw9IDEyIGluY2x1ZGVzIFRleHRFdmVudCBpbiB3aW5kb3csIGJ1dCBkb2VzIG5vdCBmaXJlXG4gKiB0ZXh0IGlucHV0IGV2ZW50cy4gUmVseSBvbiBrZXlwcmVzcyBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiBpc1ByZXN0bygpIHtcbiAgdmFyIG9wZXJhID0gd2luZG93Lm9wZXJhO1xuICByZXR1cm4gdHlwZW9mIG9wZXJhID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PT0gJ2Z1bmN0aW9uJyAmJiBwYXJzZUludChvcGVyYS52ZXJzaW9uKCksIDEwKSA8PSAxMjtcbn1cblxudmFyIFNQQUNFQkFSX0NPREUgPSAzMjtcbnZhciBTUEFDRUJBUl9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZShTUEFDRUJBUl9DT0RFKTtcblxuLy8gRXZlbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG5hbWVzLlxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGJlZm9yZUlucHV0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkJlZm9yZUlucHV0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25CZWZvcmVJbnB1dENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQ29tcG9zaXRpb25FbmQnLCAndG9wS2V5UHJlc3MnLCAndG9wVGV4dElucHV0JywgJ3RvcFBhc3RlJ11cbiAgfSxcbiAgY29tcG9zaXRpb25FbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25FbmQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uRW5kJywgJ3RvcEtleURvd24nLCAndG9wS2V5UHJlc3MnLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJ11cbiAgfSxcbiAgY29tcG9zaXRpb25TdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvblN0YXJ0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uU3RhcnQnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9LFxuICBjb21wb3NpdGlvblVwZGF0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvblVwZGF0ZScsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25VcGRhdGUnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9XG59O1xuXG4vLyBUcmFjayB3aGV0aGVyIHdlJ3ZlIGV2ZXIgaGFuZGxlZCBhIGtleXByZXNzIG9uIHRoZSBzcGFjZSBrZXkuXG52YXIgaGFzU3BhY2VLZXlwcmVzcyA9IGZhbHNlO1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgbmF0aXZlIGtleXByZXNzIGV2ZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBjb21tYW5kLlxuICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIEZpcmVmb3ggZmlyZXMgYGtleXByZXNzYCBldmVudHMgZm9yIGtleSBjb21tYW5kc1xuICogKGN1dCwgY29weSwgc2VsZWN0LWFsbCwgZXRjLikgZXZlbiB0aG91Z2ggbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLlxuICovXG5mdW5jdGlvbiBpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkge1xuICByZXR1cm4gKG5hdGl2ZUV2ZW50LmN0cmxLZXkgfHwgbmF0aXZlRXZlbnQuYWx0S2V5IHx8IG5hdGl2ZUV2ZW50Lm1ldGFLZXkpICYmXG4gIC8vIGN0cmxLZXkgJiYgYWx0S2V5IGlzIGVxdWl2YWxlbnQgdG8gQWx0R3IsIGFuZCBpcyBub3QgYSBjb21tYW5kLlxuICAhKG5hdGl2ZUV2ZW50LmN0cmxLZXkgJiYgbmF0aXZlRXZlbnQuYWx0S2V5KTtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgbmF0aXZlIHRvcCBsZXZlbCBldmVudHMgaW50byBldmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uU3RhcnQnOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvbkVuZCc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvblVwZGF0ZSc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblVwZGF0ZTtcbiAgfVxufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIGJlc3QtZ3Vlc3MgbW9kZWwgdGhpbmsgdGhpcyBldmVudCBzaWduaWZpZXMgdGhhdFxuICogY29tcG9zaXRpb24gaGFzIGJlZ3VuP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5RG93bicgJiYgbmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gU1RBUlRfS0VZQ09ERTtcbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBtb2RlIHRoaW5rIHRoYXQgdGhpcyBldmVudCBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAvLyBDb21tYW5kIGtleXMgaW5zZXJ0IG9yIGNsZWFyIElNRSBpbnB1dC5cbiAgICAgIHJldHVybiBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSAhPT0gLTE7XG4gICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICAvLyBFeHBlY3QgSU1FIGtleUNvZGUgb24gZWFjaCBrZXlkb3duLiBJZiB3ZSBnZXQgYW55IG90aGVyXG4gICAgICAvLyBjb2RlIHdlIG11c3QgaGF2ZSBleGl0ZWQgZWFybGllci5cbiAgICAgIHJldHVybiBuYXRpdmVFdmVudC5rZXlDb2RlICE9PSBTVEFSVF9LRVlDT0RFO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICBjYXNlICd0b3BNb3VzZURvd24nOlxuICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgLy8gRXZlbnRzIGFyZSBub3QgcG9zc2libGUgd2l0aG91dCBjYW5jZWxsaW5nIElNRS5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBHb29nbGUgSW5wdXQgVG9vbHMgcHJvdmlkZXMgY29tcG9zaXRpb24gZGF0YSB2aWEgYSBDdXN0b21FdmVudCxcbiAqIHdpdGggdGhlIGBkYXRhYCBwcm9wZXJ0eSBwb3B1bGF0ZWQgaW4gdGhlIGBkZXRhaWxgIG9iamVjdC4gSWYgdGhpc1xuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBldmVudCBvYmplY3QsIHVzZSBpdC4gSWYgbm90LCB0aGlzIGlzIGEgcGxhaW5cbiAqIGNvbXBvc2l0aW9uIGV2ZW50IGFuZCB3ZSBoYXZlIG5vdGhpbmcgc3BlY2lhbCB0byBleHRyYWN0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZGV0YWlsID0gbmF0aXZlRXZlbnQuZGV0YWlsO1xuICBpZiAodHlwZW9mIGRldGFpbCA9PT0gJ29iamVjdCcgJiYgJ2RhdGEnIGluIGRldGFpbCkge1xuICAgIHJldHVybiBkZXRhaWwuZGF0YTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gVHJhY2sgdGhlIGN1cnJlbnQgSU1FIGNvbXBvc2l0aW9uIGZhbGxiYWNrIG9iamVjdCwgaWYgYW55LlxudmFyIGN1cnJlbnRDb21wb3NpdGlvbiA9IG51bGw7XG5cbi8qKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRUeXBlO1xuICB2YXIgZmFsbGJhY2tEYXRhO1xuXG4gIGlmIChjYW5Vc2VDb21wb3NpdGlvbkV2ZW50KSB7XG4gICAgZXZlbnRUeXBlID0gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKTtcbiAgfSBlbHNlIGlmICghY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gIH1cblxuICBpZiAoIWV2ZW50VHlwZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQgY29tcG9zaXRpb24gaXMgc3RvcmVkIHN0YXRpY2FsbHkgYW5kIG11c3Qgbm90IGJlXG4gICAgLy8gb3ZlcndyaXR0ZW4gd2hpbGUgY29tcG9zaXRpb24gY29udGludWVzLlxuICAgIGlmICghY3VycmVudENvbXBvc2l0aW9uICYmIGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0KSB7XG4gICAgICBjdXJyZW50Q29tcG9zaXRpb24gPSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUuZ2V0UG9vbGVkKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZCkge1xuICAgICAgaWYgKGN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgICAgICBmYWxsYmFja0RhdGEgPSBjdXJyZW50Q29tcG9zaXRpb24uZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBpZiAoZmFsbGJhY2tEYXRhKSB7XG4gICAgLy8gSW5qZWN0IGRhdGEgZ2VuZXJhdGVkIGZyb20gZmFsbGJhY2sgcGF0aCBpbnRvIHRoZSBzeW50aGV0aWMgZXZlbnQuXG4gICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBwcm9wZXJ0eSBvZiBuYXRpdmUgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZS5cbiAgICBldmVudC5kYXRhID0gZmFsbGJhY2tEYXRhO1xuICB9IGVsc2Uge1xuICAgIHZhciBjdXN0b21EYXRhID0gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgaWYgKGN1c3RvbURhdGEgIT09IG51bGwpIHtcbiAgICAgIGV2ZW50LmRhdGEgPSBjdXN0b21EYXRhO1xuICAgIH1cbiAgfVxuXG4gIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvbkVuZCc6XG4gICAgICByZXR1cm4gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgICAgLyoqXG4gICAgICAgKiBJZiBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRzIGFyZSBhdmFpbGFibGUsIG91ciBnb2FsIGlzIHRvIG1ha2VcbiAgICAgICAqIHVzZSBvZiB0aGVtLiBIb3dldmVyLCB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZTogdGhlIHNwYWNlYmFyIGtleS5cbiAgICAgICAqIEluIFdlYmtpdCwgcHJldmVudGluZyBkZWZhdWx0IG9uIGEgc3BhY2ViYXIgYHRleHRJbnB1dGAgZXZlbnRcbiAgICAgICAqIGNhbmNlbHMgY2hhcmFjdGVyIGluc2VydGlvbiwgYnV0IGl0ICphbHNvKiBjYXVzZXMgdGhlIGJyb3dzZXJcbiAgICAgICAqIHRvIGZhbGwgYmFjayB0byBpdHMgZGVmYXVsdCBzcGFjZWJhciBiZWhhdmlvciBvZiBzY3JvbGxpbmcgdGhlXG4gICAgICAgKiBwYWdlLlxuICAgICAgICpcbiAgICAgICAqIFRyYWNraW5nIGF0OlxuICAgICAgICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM1NTEwM1xuICAgICAgICpcbiAgICAgICAqIFRvIGF2b2lkIHRoaXMgaXNzdWUsIHVzZSB0aGUga2V5cHJlc3MgZXZlbnQgYXMgaWYgbm8gYHRleHRJbnB1dGBcbiAgICAgICAqIGV2ZW50IGlzIGF2YWlsYWJsZS5cbiAgICAgICAqL1xuICAgICAgdmFyIHdoaWNoID0gbmF0aXZlRXZlbnQud2hpY2g7XG4gICAgICBpZiAod2hpY2ggIT09IFNQQUNFQkFSX0NPREUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGhhc1NwYWNlS2V5cHJlc3MgPSB0cnVlO1xuICAgICAgcmV0dXJuIFNQQUNFQkFSX0NIQVI7XG5cbiAgICBjYXNlICd0b3BUZXh0SW5wdXQnOlxuICAgICAgLy8gUmVjb3JkIHRoZSBjaGFyYWN0ZXJzIHRvIGJlIGFkZGVkIHRvIHRoZSBET00uXG4gICAgICB2YXIgY2hhcnMgPSBuYXRpdmVFdmVudC5kYXRhO1xuXG4gICAgICAvLyBJZiBpdCdzIGEgc3BhY2ViYXIgY2hhcmFjdGVyLCBhc3N1bWUgdGhhdCB3ZSBoYXZlIGFscmVhZHkgaGFuZGxlZFxuICAgICAgLy8gaXQgYXQgdGhlIGtleXByZXNzIGxldmVsIGFuZCBiYWlsIGltbWVkaWF0ZWx5LiBBbmRyb2lkIENocm9tZVxuICAgICAgLy8gZG9lc24ndCBnaXZlIHVzIGtleWNvZGVzLCBzbyB3ZSBuZWVkIHRvIGJsYWNrbGlzdCBpdC5cbiAgICAgIGlmIChjaGFycyA9PT0gU1BBQ0VCQVJfQ0hBUiAmJiBoYXNTcGFjZUtleXByZXNzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhcnM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gRm9yIG90aGVyIG5hdGl2ZSBldmVudCB0eXBlcywgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHByb3ZpZGUgdGhlIGB0ZXh0SW5wdXRgIGV2ZW50LCBleHRyYWN0IHRoZVxuICogYXBwcm9wcmlhdGUgc3RyaW5nIHRvIHVzZSBmb3IgU3ludGhldGljSW5wdXRFdmVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgZmFsbGJhY2sgc3RyaW5nIGZvciB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgY29tcG9zaW5nIChJTUUpIGFuZCB1c2luZyBhIGZhbGxiYWNrIHRvIGRvIHNvLFxuICAvLyB0cnkgdG8gZXh0cmFjdCB0aGUgY29tcG9zZWQgY2hhcmFjdGVycyBmcm9tIHRoZSBmYWxsYmFjayBvYmplY3QuXG4gIC8vIElmIGNvbXBvc2l0aW9uIGV2ZW50IGlzIGF2YWlsYWJsZSwgd2UgZXh0cmFjdCBhIHN0cmluZyBvbmx5IGF0XG4gIC8vIGNvbXBvc2l0aW9uZXZlbnQsIG90aGVyd2lzZSBleHRyYWN0IGl0IGF0IGZhbGxiYWNrIGV2ZW50cy5cbiAgaWYgKGN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDb21wb3NpdGlvbkVuZCcgfHwgIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgJiYgaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICB2YXIgY2hhcnMgPSBjdXJyZW50Q29tcG9zaXRpb24uZ2V0RGF0YSgpO1xuICAgICAgRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLnJlbGVhc2UoY3VycmVudENvbXBvc2l0aW9uKTtcbiAgICAgIGN1cnJlbnRDb21wb3NpdGlvbiA9IG51bGw7XG4gICAgICByZXR1cm4gY2hhcnM7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BQYXN0ZSc6XG4gICAgICAvLyBJZiBhIHBhc3RlIGV2ZW50IG9jY3VycyBhZnRlciBhIGtleXByZXNzLCB0aHJvdyBvdXQgdGhlIGlucHV0XG4gICAgICAvLyBjaGFycy4gUGFzdGUgZXZlbnRzIHNob3VsZCBub3QgbGVhZCB0byBCZWZvcmVJbnB1dCBldmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxuICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcbiAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cbiAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICovXG4gICAgICBpZiAobmF0aXZlRXZlbnQud2hpY2ggJiYgIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvbkVuZCc6XG4gICAgICByZXR1cm4gdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPyBudWxsIDogbmF0aXZlRXZlbnQuZGF0YTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IGEgU3ludGhldGljSW5wdXRFdmVudCBmb3IgYGJlZm9yZUlucHV0YCwgYmFzZWQgb24gZWl0aGVyIG5hdGl2ZVxuICogYHRleHRJbnB1dGAgb3IgZmFsbGJhY2sgYmVoYXZpb3IuXG4gKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgY2hhcnM7XG5cbiAgaWYgKGNhblVzZVRleHRJbnB1dEV2ZW50KSB7XG4gICAgY2hhcnMgPSBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIGNoYXJzID0gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9XG5cbiAgLy8gSWYgbm8gY2hhcmFjdGVycyBhcmUgYmVpbmcgaW5zZXJ0ZWQsIG5vIEJlZm9yZUlucHV0IGV2ZW50IHNob3VsZFxuICAvLyBiZSBmaXJlZC5cbiAgaWYgKCFjaGFycykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljSW5wdXRFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5iZWZvcmVJbnB1dCwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBldmVudC5kYXRhID0gY2hhcnM7XG4gIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICpcbiAqIFRoaXMgcGx1Z2luIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGVtaXR0aW5nIGBjb21wb3NpdGlvbmAgZXZlbnRzLCB0aHVzXG4gKiBhbGxvd2luZyB1cyB0byBzaGFyZSBjb21wb3NpdGlvbiBmYWxsYmFjayBjb2RlIGZvciBib3RoIGBiZWZvcmVJbnB1dGAgYW5kXG4gKiBgY29tcG9zaXRpb25gIGV2ZW50IHR5cGVzLlxuICovXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICByZXR1cm4gW2V4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSwgZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpXTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xuXG52YXIgZ2V0VGV4dENvbnRlbnRBY2Nlc3NvciA9IHJlcXVpcmUoJy4vZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcicpO1xuXG4vKipcbiAqIFRoaXMgaGVscGVyIGNsYXNzIHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB0ZXh0IGNvbnRlbnQgb2YgYSB0YXJnZXQgbm9kZSxcbiAqIGFsbG93aW5nIGNvbXBhcmlzb24gb2YgY29udGVudCBiZWZvcmUgYW5kIGFmdGVyIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogSWRlbnRpZnkgdGhlIG5vZGUgd2hlcmUgc2VsZWN0aW9uIGN1cnJlbnRseSBiZWdpbnMsIHRoZW4gb2JzZXJ2ZVxuICogYm90aCBpdHMgdGV4dCBjb250ZW50IGFuZCBpdHMgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgRE9NLiBTaW5jZSB0aGVcbiAqIGJyb3dzZXIgbWF5IG5hdGl2ZWx5IHJlcGxhY2UgdGhlIHRhcmdldCBub2RlIGR1cmluZyBjb21wb3NpdGlvbiwgd2UgY2FuXG4gKiB1c2UgaXRzIHBvc2l0aW9uIHRvIGZpbmQgaXRzIHJlcGxhY2VtZW50LlxuICpcbiAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHJvb3RcbiAqL1xuZnVuY3Rpb24gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlKHJvb3QpIHtcbiAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gIHRoaXMuX3N0YXJ0VGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xuICB0aGlzLl9mYWxsYmFja1RleHQgPSBudWxsO1xufVxuXG5fYXNzaWduKEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5wcm90b3R5cGUsIHtcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgIHRoaXMuX3N0YXJ0VGV4dCA9IG51bGw7XG4gICAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgdGV4dCBvZiBpbnB1dC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0VGV4dDogZnVuY3Rpb24gKCkge1xuICAgIGlmICgndmFsdWUnIGluIHRoaXMuX3Jvb3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yb290LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcm9vdFtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgdGhlIGRpZmZlcmluZyBzdWJzdHJpbmcgYmV0d2VlbiB0aGUgaW5pdGlhbGx5IHN0b3JlZFxuICAgKiB0ZXh0IGNvbnRlbnQgYW5kIHRoZSBjdXJyZW50IGNvbnRlbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fZmFsbGJhY2tUZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUZXh0O1xuICAgIH1cblxuICAgIHZhciBzdGFydDtcbiAgICB2YXIgc3RhcnRWYWx1ZSA9IHRoaXMuX3N0YXJ0VGV4dDtcbiAgICB2YXIgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aDtcbiAgICB2YXIgZW5kO1xuICAgIHZhciBlbmRWYWx1ZSA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgIHZhciBlbmRMZW5ndGggPSBlbmRWYWx1ZS5sZW5ndGg7XG5cbiAgICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBzdGFydExlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRdICE9PSBlbmRWYWx1ZVtzdGFydF0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1pbkVuZCA9IHN0YXJ0TGVuZ3RoIC0gc3RhcnQ7XG4gICAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRMZW5ndGggLSBlbmRdICE9PSBlbmRWYWx1ZVtlbmRMZW5ndGggLSBlbmRdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzbGljZVRhaWwgPSBlbmQgPiAxID8gMSAtIGVuZCA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgc2xpY2VUYWlsKTtcbiAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUZXh0O1xuICB9XG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cbnZhciBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQsIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1XG4gKiAgICAgIC8jZXZlbnRzLWlucHV0ZXZlbnRzXG4gKi9cbnZhciBJbnB1dEV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNJbnB1dEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0lucHV0RXZlbnQsIElucHV0RXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0lucHV0RXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvU3ludGhldGljSW5wdXRFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGlucHV0VmFsdWVUcmFja2luZyA9IHJlcXVpcmUoJy4vaW5wdXRWYWx1ZVRyYWNraW5nJyk7XG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2dldEV2ZW50VGFyZ2V0Jyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xudmFyIGlzVGV4dElucHV0RWxlbWVudCA9IHJlcXVpcmUoJy4vaXNUZXh0SW5wdXRFbGVtZW50Jyk7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBjaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ2hhbmdlJyxcbiAgICAgIGNhcHR1cmVkOiAnb25DaGFuZ2VDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ2hhbmdlJywgJ3RvcENsaWNrJywgJ3RvcEZvY3VzJywgJ3RvcElucHV0JywgJ3RvcEtleURvd24nLCAndG9wS2V5VXAnLCAndG9wU2VsZWN0aW9uQ2hhbmdlJ11cbiAgfVxufTtcblxuZnVuY3Rpb24gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGluc3QsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpIHtcbiAgdmFyIGV2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuY2hhbmdlLCBpbnN0LCBuYXRpdmVFdmVudCwgdGFyZ2V0KTtcbiAgZXZlbnQudHlwZSA9ICdjaGFuZ2UnO1xuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG4vKipcbiAqIEZvciBJRSBzaGltc1xuICovXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2hhbmdlYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDaGFuZ2VFdmVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgPT09ICdzZWxlY3QnIHx8IG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ2ZpbGUnO1xufVxuXG52YXIgZG9lc0NoYW5nZUV2ZW50QnViYmxlID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIFNlZSBgaGFuZGxlQ2hhbmdlYCBjb21tZW50IGJlbG93XG4gIGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2NoYW5nZScpICYmICghZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDgpO1xufVxuXG5mdW5jdGlvbiBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBldmVudCA9IGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChhY3RpdmVFbGVtZW50SW5zdCwgbmF0aXZlRXZlbnQsIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSk7XG5cbiAgLy8gSWYgY2hhbmdlIGFuZCBwcm9wZXJ0eWNoYW5nZSBidWJibGVkLCB3ZSdkIGp1c3QgYmluZCB0byBpdCBsaWtlIGFsbCB0aGVcbiAgLy8gb3RoZXIgZXZlbnRzIGFuZCBoYXZlIGl0IGdvIHRocm91Z2ggUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLiBTaW5jZSBpdFxuICAvLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcbiAgLy8gcHJvY2VzcyB0aGUgYWJzdHJhY3QgZXZlbnQgbWFudWFsbHkuXG4gIC8vXG4gIC8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cbiAgLy8gYmVmb3JlIHRoZSBuZXh0IHJlcmVuZGVyIChpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgdG8gYW5jZXN0b3JcbiAgLy8gZWxlbWVudHMgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgaW5wdXQpLiBXaXRob3V0IHRoaXMsIGNvbnRyb2xsZWRcbiAgLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxuICAvLyB0aGUgY29tcG9uZW50IGlzIHJlcmVuZGVyZWQgYW5kIHRoZSB2YWx1ZSByZXZlcnRlZCBiZWZvcmUgYWxsIHRoZSBldmVudFxuICAvLyBoYW5kbGVycyBjYW4gcnVuLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MDguXG4gIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGV2ZW50KSB7XG4gIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnQpO1xuICBFdmVudFBsdWdpbkh1Yi5wcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCh0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgYWN0aXZlRWxlbWVudCA9IHRhcmdldDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSB0YXJnZXRJbnN0O1xuICBhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbmNoYW5nZScsIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQpO1xufVxuXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQoJ29uY2hhbmdlJywgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCk7XG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCkge1xuICB2YXIgdXBkYXRlZCA9IGlucHV0VmFsdWVUcmFja2luZy51cGRhdGVWYWx1ZUlmQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgdmFyIHNpbXVsYXRlZCA9IG5hdGl2ZUV2ZW50LnNpbXVsYXRlZCA9PT0gdHJ1ZSAmJiBDaGFuZ2VFdmVudFBsdWdpbi5fYWxsb3dTaW11bGF0ZWRQYXNzVGhyb3VnaDtcblxuICBpZiAodXBkYXRlZCB8fCBzaW11bGF0ZWQpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTgodG9wTGV2ZWxUeXBlLCB0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEZvY3VzJykge1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgodGFyZ2V0LCB0YXJnZXRJbnN0KTtcbiAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BCbHVyJykge1xuICAgIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovXG52YXIgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50cy5cblxuICBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBpc0V2ZW50U3VwcG9ydGVkKCdpbnB1dCcpICYmICghKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA5KTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9OSkgU3RhcnRzIHRyYWNraW5nIHByb3BlcnR5Y2hhbmdlIGV2ZW50cyBvbiB0aGUgcGFzc2VkLWluIGVsZW1lbnRcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cbiAqL1xuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuXG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIEhhbmRsZXMgYSBwcm9wZXJ0eWNoYW5nZSBldmVudCwgc2VuZGluZyBhIGBjaGFuZ2VgIGV2ZW50IGlmXG4gKiB0aGUgdmFsdWUgb2YgdGhlIGFjdGl2ZSBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovXG5mdW5jdGlvbiBoYW5kbGVQcm9wZXJ0eUNoYW5nZShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQucHJvcGVydHlOYW1lICE9PSAndmFsdWUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50KSkge1xuICAgIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbCh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wRm9jdXMnKSB7XG4gICAgLy8gSW4gSUU4LCB3ZSBjYW4gY2FwdHVyZSBhbG1vc3QgYWxsIC52YWx1ZSBjaGFuZ2VzIGJ5IGFkZGluZyBhXG4gICAgLy8gcHJvcGVydHljaGFuZ2UgaGFuZGxlciBhbmQgbG9va2luZyBmb3IgZXZlbnRzIHdpdGggcHJvcGVydHlOYW1lXG4gICAgLy8gZXF1YWwgdG8gJ3ZhbHVlJ1xuICAgIC8vIEluIElFOSwgcHJvcGVydHljaGFuZ2UgZmlyZXMgZm9yIG1vc3QgaW5wdXQgZXZlbnRzIGJ1dCBpcyBidWdneSBhbmRcbiAgICAvLyBkb2Vzbid0IGZpcmUgd2hlbiB0ZXh0IGlzIGRlbGV0ZWQsIGJ1dCBjb252ZW5pZW50bHksIHNlbGVjdGlvbmNoYW5nZVxuICAgIC8vIGFwcGVhcnMgdG8gZmlyZSBpbiBhbGwgb2YgdGhlIHJlbWFpbmluZyBjYXNlcyBzbyB3ZSBjYXRjaCB0aG9zZSBhbmRcbiAgICAvLyBmb3J3YXJkIHRoZSBldmVudCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAvLyBJbiBlaXRoZXIgY2FzZSwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIHRoZSBldmVudCBoYW5kbGVyIGlmIHRoZSB2YWx1ZVxuICAgIC8vIGlzIGNoYW5nZWQgZnJvbSBKUyBzbyB3ZSByZWRlZmluZSBhIHNldHRlciBmb3IgYC52YWx1ZWAgdGhhdCB1cGRhdGVzXG4gICAgLy8gb3VyIGFjdGl2ZUVsZW1lbnRWYWx1ZSB2YXJpYWJsZSwgYWxsb3dpbmcgdXMgdG8gaWdub3JlIHRob3NlIGNoYW5nZXNcbiAgICAvL1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KTtcbiAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BCbHVyJykge1xuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gIH1cbn1cblxuLy8gRm9yIElFOCBhbmQgSUU5LlxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRQb2x5ZmlsbCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BTZWxlY3Rpb25DaGFuZ2UnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcEtleVVwJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlEb3duJykge1xuICAgIC8vIE9uIHRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQsIHRoZSB0YXJnZXQgaXMganVzdCBkb2N1bWVudCB3aGljaCBpc24ndFxuICAgIC8vIGhlbHBmdWwgZm9yIHVzIHNvIGp1c3QgY2hlY2sgYWN0aXZlRWxlbWVudCBpbnN0ZWFkLlxuICAgIC8vXG4gICAgLy8gOTklIG9mIHRoZSB0aW1lLCBrZXlkb3duIGFuZCBrZXl1cCBhcmVuJ3QgbmVjZXNzYXJ5LiBJRTggZmFpbHMgdG8gZmlyZVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIG9uIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhZnRlciBzZXR0aW5nIGB2YWx1ZWAgZnJvbSBhXG4gICAgLy8gc2NyaXB0IGFuZCBmaXJlcyBvbmx5IGtleWRvd24sIGtleXByZXNzLCBrZXl1cC4gQ2F0Y2hpbmcga2V5dXAgdXN1YWxseVxuICAgIC8vIGdldHMgaXQgYW5kIGNhdGNoaW5nIGtleWRvd24gbGV0cyB1cyBmaXJlIGFuIGV2ZW50IGZvciB0aGUgZmlyc3RcbiAgICAvLyBrZXlzdHJva2UgaWYgdXNlciBkb2VzIGEga2V5IHJlcGVhdCAoaXQnbGwgYmUgYSBsaXR0bGUgZGVsYXllZDogcmlnaHRcbiAgICAvLyBiZWZvcmUgdGhlIHNlY29uZCBrZXlzdHJva2UpLiBPdGhlciBpbnB1dCBtZXRob2RzIChlLmcuLCBwYXN0ZSkgc2VlbSB0b1xuICAgIC8vIGZpcmUgc2VsZWN0aW9uY2hhbmdlIG5vcm1hbGx5LlxuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNsaWNrRXZlbnQoZWxlbSkge1xuICAvLyBVc2UgdGhlIGBjbGlja2AgZXZlbnQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0cy5cbiAgLy8gVGhpcyBhcHByb2FjaCB3b3JrcyBhY3Jvc3MgYWxsIGJyb3dzZXJzLCB3aGVyZWFzIGBjaGFuZ2VgIGRvZXMgbm90IGZpcmVcbiAgLy8gdW50aWwgYGJsdXJgIGluIElFOC5cbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBlbGVtLnR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDbGljaycpIHtcbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcElucHV0JyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cihpbnN0LCBub2RlKSB7XG4gIC8vIFRPRE86IEluIElFLCBpbnN0IGlzIG9jY2FzaW9uYWxseSBudWxsLiBXaHk/XG4gIGlmIChpbnN0ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGaWJlciBhbmQgUmVhY3RET00ga2VlcCB3cmFwcGVyIHN0YXRlIGluIHNlcGFyYXRlIHBsYWNlc1xuICB2YXIgc3RhdGUgPSBpbnN0Ll93cmFwcGVyU3RhdGUgfHwgbm9kZS5fd3JhcHBlclN0YXRlO1xuXG4gIGlmICghc3RhdGUgfHwgIXN0YXRlLmNvbnRyb2xsZWQgfHwgbm9kZS50eXBlICE9PSAnbnVtYmVyJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIGNvbnRyb2xsZWQsIGFzc2lnbiB0aGUgdmFsdWUgYXR0cmlidXRlIHRvIHRoZSBjdXJyZW50IHZhbHVlIG9uIGJsdXJcbiAgdmFyIHZhbHVlID0gJycgKyBub2RlLnZhbHVlO1xuICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgIT09IHZhbHVlKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgdmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25DaGFuZ2VgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBjaGFuZ2UgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy4gVGhpcyBldmVudCBmaXJlcyBhdCBhIHRpbWUgd2hlbiBpdCdzIHBvc3NpYmxlIHRvXG4gKiBjaGFuZ2UgdGhlIGVsZW1lbnQncyB2YWx1ZSB3aXRob3V0IHNlZWluZyBhIGZsaWNrZXIuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gc2VsZWN0XG4gKi9cbnZhciBDaGFuZ2VFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBfYWxsb3dTaW11bGF0ZWRQYXNzVGhyb3VnaDogdHJ1ZSxcbiAgX2lzSW5wdXRFdmVudFN1cHBvcnRlZDogaXNJbnB1dEV2ZW50U3VwcG9ydGVkLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgdmFyIGdldFRhcmdldEluc3RGdW5jLCBoYW5kbGVFdmVudEZ1bmM7XG4gICAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBpZiAoZG9lc0NoYW5nZUV2ZW50QnViYmxlKSB7XG4gICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlRXZlbnRGdW5jID0gaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGlmIChpc0lucHV0RXZlbnRTdXBwb3J0ZWQpIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsO1xuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzaG91bGRVc2VDbGlja0V2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50O1xuICAgIH1cblxuICAgIGlmIChnZXRUYXJnZXRJbnN0RnVuYykge1xuICAgICAgdmFyIGluc3QgPSBnZXRUYXJnZXRJbnN0RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50KTtcbiAgICAgIGlmIChpbnN0KSB7XG4gICAgICAgIHZhciBldmVudCA9IGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChpbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZUV2ZW50RnVuYykge1xuICAgICAgaGFuZGxlRXZlbnRGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0Tm9kZSwgdGFyZ2V0SW5zdCk7XG4gICAgfVxuXG4gICAgLy8gV2hlbiBibHVycmluZywgc2V0IHRoZSB2YWx1ZSBhdHRyaWJ1dGUgZm9yIG51bWJlciBpbnB1dHNcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQmx1cicpIHtcbiAgICAgIGhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIodGFyZ2V0SW5zdCwgdGFyZ2V0Tm9kZSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYW5nZUV2ZW50UGx1Z2luO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0NoYW5nZUV2ZW50UGx1Z2luLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RPd25lcicpO1xuXG52YXIgUmVhY3RSZWYgPSB7fTtcblxuZnVuY3Rpb24gYXR0YWNoUmVmKHJlZiwgY29tcG9uZW50LCBvd25lcikge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlZihjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTGVnYWN5IHJlZlxuICAgIFJlYWN0T3duZXIuYWRkQ29tcG9uZW50QXNSZWZUbyhjb21wb25lbnQsIHJlZiwgb3duZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGFjaFJlZihyZWYsIGNvbXBvbmVudCwgb3duZXIpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZWYobnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTGVnYWN5IHJlZlxuICAgIFJlYWN0T3duZXIucmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKGNvbXBvbmVudCwgcmVmLCBvd25lcik7XG4gIH1cbn1cblxuUmVhY3RSZWYuYXR0YWNoUmVmcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCB0eXBlb2YgZWxlbWVudCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAocmVmICE9IG51bGwpIHtcbiAgICBhdHRhY2hSZWYocmVmLCBpbnN0YW5jZSwgZWxlbWVudC5fb3duZXIpO1xuICB9XG59O1xuXG5SZWFjdFJlZi5zaG91bGRVcGRhdGVSZWZzID0gZnVuY3Rpb24gKHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkge1xuICAvLyBJZiBlaXRoZXIgdGhlIG93bmVyIG9yIGEgYHJlZmAgaGFzIGNoYW5nZWQsIG1ha2Ugc3VyZSB0aGUgbmV3ZXN0IG93bmVyXG4gIC8vIGhhcyBzdG9yZWQgYSByZWZlcmVuY2UgdG8gYHRoaXNgLCBhbmQgdGhlIHByZXZpb3VzIG93bmVyIChpZiBkaWZmZXJlbnQpXG4gIC8vIGhhcyBmb3Jnb3R0ZW4gdGhlIHJlZmVyZW5jZSB0byBgdGhpc2AuIFdlIHVzZSB0aGUgZWxlbWVudCBpbnN0ZWFkXG4gIC8vIG9mIHRoZSBwdWJsaWMgdGhpcy5wcm9wcyBiZWNhdXNlIHRoZSBwb3N0IHByb2Nlc3NpbmcgY2Fubm90IGRldGVybWluZVxuICAvLyBhIHJlZi4gVGhlIHJlZiBjb25jZXB0dWFsbHkgbGl2ZXMgb24gdGhlIGVsZW1lbnQuXG5cbiAgLy8gVE9ETzogU2hvdWxkIHRoaXMgZXZlbiBiZSBwb3NzaWJsZT8gVGhlIG93bmVyIGNhbm5vdCBjaGFuZ2UgYmVjYXVzZVxuICAvLyBpdCdzIGZvcmJpZGRlbiBieSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC4gVGhlIHJlZiBjYW4gY2hhbmdlXG4gIC8vIGlmIHlvdSBzd2FwIHRoZSBrZXlzIG9mIGJ1dCBub3QgdGhlIHJlZnMuIFJlY29uc2lkZXIgd2hlcmUgdGhpcyBjaGVja1xuICAvLyBpcyBtYWRlLiBJdCBwcm9iYWJseSBiZWxvbmdzIHdoZXJlIHRoZSBrZXkgY2hlY2tpbmcgYW5kXG4gIC8vIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgaXMgZG9uZS5cblxuICB2YXIgcHJldlJlZiA9IG51bGw7XG4gIHZhciBwcmV2T3duZXIgPSBudWxsO1xuICBpZiAocHJldkVsZW1lbnQgIT09IG51bGwgJiYgdHlwZW9mIHByZXZFbGVtZW50ID09PSAnb2JqZWN0Jykge1xuICAgIHByZXZSZWYgPSBwcmV2RWxlbWVudC5yZWY7XG4gICAgcHJldk93bmVyID0gcHJldkVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgdmFyIG5leHRSZWYgPSBudWxsO1xuICB2YXIgbmV4dE93bmVyID0gbnVsbDtcbiAgaWYgKG5leHRFbGVtZW50ICE9PSBudWxsICYmIHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ29iamVjdCcpIHtcbiAgICBuZXh0UmVmID0gbmV4dEVsZW1lbnQucmVmO1xuICAgIG5leHRPd25lciA9IG5leHRFbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIHJldHVybiBwcmV2UmVmICE9PSBuZXh0UmVmIHx8XG4gIC8vIElmIG93bmVyIGNoYW5nZXMgYnV0IHdlIGhhdmUgYW4gdW5jaGFuZ2VkIGZ1bmN0aW9uIHJlZiwgZG9uJ3QgdXBkYXRlIHJlZnNcbiAgdHlwZW9mIG5leHRSZWYgPT09ICdzdHJpbmcnICYmIG5leHRPd25lciAhPT0gcHJldk93bmVyO1xufTtcblxuUmVhY3RSZWYuZGV0YWNoUmVmcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCB0eXBlb2YgZWxlbWVudCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAocmVmICE9IG51bGwpIHtcbiAgICBkZXRhY2hSZWYocmVmLCBpbnN0YW5jZSwgZWxlbWVudC5fb3duZXIpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVmO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0UmVmLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBvd25lci5cbiAqIEBmaW5hbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkT3duZXIob2JqZWN0KSB7XG4gIHJldHVybiAhIShvYmplY3QgJiYgdHlwZW9mIG9iamVjdC5hdHRhY2hSZWYgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iamVjdC5kZXRhY2hSZWYgPT09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIFJlYWN0T3duZXJzIGFyZSBjYXBhYmxlIG9mIHN0b3JpbmcgcmVmZXJlbmNlcyB0byBvd25lZCBjb21wb25lbnRzLlxuICpcbiAqIEFsbCBjb21wb25lbnRzIGFyZSBjYXBhYmxlIG9mIC8vYmVpbmcvLyByZWZlcmVuY2VkIGJ5IG93bmVyIGNvbXBvbmVudHMsIGJ1dFxuICogb25seSBSZWFjdE93bmVyIGNvbXBvbmVudHMgYXJlIGNhcGFibGUgb2YgLy9yZWZlcmVuY2luZy8vIG93bmVkIGNvbXBvbmVudHMuXG4gKiBUaGUgbmFtZWQgcmVmZXJlbmNlIGlzIGtub3duIGFzIGEgXCJyZWZcIi5cbiAqXG4gKiBSZWZzIGFyZSBhdmFpbGFibGUgd2hlbiBtb3VudGVkIGFuZCB1cGRhdGVkIGR1cmluZyByZWNvbmNpbGlhdGlvbi5cbiAqXG4gKiAgIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIChcbiAqICAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrfT5cbiAqICAgICAgICAgICA8Q3VzdG9tQ29tcG9uZW50IHJlZj1cImN1c3RvbVwiIC8+XG4gKiAgICAgICAgIDwvZGl2PlxuICogICAgICAgKTtcbiAqICAgICB9LFxuICogICAgIGhhbmRsZUNsaWNrOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaGFuZGxlQ2xpY2soKTtcbiAqICAgICB9LFxuICogICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaW5pdGlhbGl6ZSgpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogUmVmcyBzaG91bGQgcmFyZWx5IGJlIHVzZWQuIFdoZW4gcmVmcyBhcmUgdXNlZCwgdGhleSBzaG91bGQgb25seSBiZSBkb25lIHRvXG4gKiBjb250cm9sIGRhdGEgdGhhdCBpcyBub3QgaGFuZGxlZCBieSBSZWFjdCdzIGRhdGEgZmxvdy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RPd25lclxuICovXG52YXIgUmVhY3RPd25lciA9IHtcbiAgLyoqXG4gICAqIEFkZHMgYSBjb21wb25lbnQgYnkgcmVmIHRvIGFuIG93bmVyIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byByZWZlcmVuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSBieSB3aGljaCB0byByZWZlciB0byB0aGUgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge1JlYWN0T3duZXJ9IG93bmVyIENvbXBvbmVudCBvbiB3aGljaCB0byByZWNvcmQgdGhlIHJlZi5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYWRkQ29tcG9uZW50QXNSZWZUbzogZnVuY3Rpb24gKGNvbXBvbmVudCwgcmVmLCBvd25lcikge1xuICAgICFpc1ZhbGlkT3duZXIob3duZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2FkZENvbXBvbmVudEFzUmVmVG8oLi4uKTogT25seSBhIFJlYWN0T3duZXIgY2FuIGhhdmUgcmVmcy4gWW91IG1pZ2h0IGJlIGFkZGluZyBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgY3JlYXRlZCBpbnNpZGUgYSBjb21wb25lbnRcXCdzIGByZW5kZXJgIG1ldGhvZCwgb3IgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZCAoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJykgOiBfcHJvZEludmFyaWFudCgnMTE5JykgOiB2b2lkIDA7XG4gICAgb3duZXIuYXR0YWNoUmVmKHJlZiwgY29tcG9uZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNvbXBvbmVudCBieSByZWYgZnJvbSBhbiBvd25lciBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gZGVyZWZlcmVuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSBvZiB0aGUgcmVmIHRvIHJlbW92ZS5cbiAgICogQHBhcmFtIHtSZWFjdE93bmVyfSBvd25lciBDb21wb25lbnQgb24gd2hpY2ggdGhlIHJlZiBpcyByZWNvcmRlZC5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tOiBmdW5jdGlvbiAoY29tcG9uZW50LCByZWYsIG93bmVyKSB7XG4gICAgIWlzVmFsaWRPd25lcihvd25lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKC4uLik6IE9ubHkgYSBSZWFjdE93bmVyIGNhbiBoYXZlIHJlZnMuIFlvdSBtaWdodCBiZSByZW1vdmluZyBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgY3JlYXRlZCBpbnNpZGUgYSBjb21wb25lbnRcXCdzIGByZW5kZXJgIG1ldGhvZCwgb3IgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZCAoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJykgOiBfcHJvZEludmFyaWFudCgnMTIwJykgOiB2b2lkIDA7XG4gICAgdmFyIG93bmVyUHVibGljSW5zdGFuY2UgPSBvd25lci5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIC8vIENoZWNrIHRoYXQgYGNvbXBvbmVudGAncyBvd25lciBpcyBzdGlsbCBhbGl2ZSBhbmQgdGhhdCBgY29tcG9uZW50YCBpcyBzdGlsbCB0aGUgY3VycmVudCByZWZcbiAgICAvLyBiZWNhdXNlIHdlIGRvIG5vdCB3YW50IHRvIGRldGFjaCB0aGUgcmVmIGlmIGFub3RoZXIgY29tcG9uZW50IHN0b2xlIGl0LlxuICAgIGlmIChvd25lclB1YmxpY0luc3RhbmNlICYmIG93bmVyUHVibGljSW5zdGFuY2UucmVmc1tyZWZdID09PSBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSkge1xuICAgICAgb3duZXIuZGV0YWNoUmVmKHJlZik7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0T3duZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RPd25lci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2sgPSByZXF1aXJlKCcuL1JlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2snKTtcbnZhciBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayA9IHJlcXVpcmUoJy4vUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2snKTtcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBwZXJmb3JtYW5jZU5vdyA9IHJlcXVpcmUoJ2ZianMvbGliL3BlcmZvcm1hbmNlTm93Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGhvb2tzID0gW107XG52YXIgZGlkSG9va1Rocm93Rm9yRXZlbnQgPSB7fTtcblxuZnVuY3Rpb24gY2FsbEhvb2soZXZlbnQsIGZuLCBjb250ZXh0LCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSB7XG4gIHRyeSB7XG4gICAgZm4uY2FsbChjb250ZXh0LCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZEhvb2tUaHJvd0ZvckV2ZW50W2V2ZW50XSwgJ0V4Y2VwdGlvbiB0aHJvd24gYnkgaG9vayB3aGlsZSBoYW5kbGluZyAlczogJXMnLCBldmVudCwgZSArICdcXG4nICsgZS5zdGFjaykgOiB2b2lkIDA7XG4gICAgZGlkSG9va1Rocm93Rm9yRXZlbnRbZXZlbnRdID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXZlbnQoZXZlbnQsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBob29rID0gaG9va3NbaV07XG4gICAgdmFyIGZuID0gaG9va1tldmVudF07XG4gICAgaWYgKGZuKSB7XG4gICAgICBjYWxsSG9vayhldmVudCwgZm4sIGhvb2ssIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgaXNQcm9maWxpbmcgPSBmYWxzZTtcbnZhciBmbHVzaEhpc3RvcnkgPSBbXTtcbnZhciBsaWZlQ3ljbGVUaW1lclN0YWNrID0gW107XG52YXIgY3VycmVudEZsdXNoTmVzdGluZyA9IDA7XG52YXIgY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzID0gW107XG52YXIgY3VycmVudEZsdXNoU3RhcnRUaW1lID0gMDtcbnZhciBjdXJyZW50VGltZXJEZWJ1Z0lEID0gbnVsbDtcbnZhciBjdXJyZW50VGltZXJTdGFydFRpbWUgPSAwO1xudmFyIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24gPSAwO1xudmFyIGN1cnJlbnRUaW1lclR5cGUgPSBudWxsO1xuXG52YXIgbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gY2xlYXJIaXN0b3J5KCkge1xuICBSZWFjdENvbXBvbmVudFRyZWVIb29rLnB1cmdlVW5tb3VudGVkQ29tcG9uZW50cygpO1xuICBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5jbGVhckhpc3RvcnkoKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJlZVNuYXBzaG90KHJlZ2lzdGVyZWRJRHMpIHtcbiAgcmV0dXJuIHJlZ2lzdGVyZWRJRHMucmVkdWNlKGZ1bmN0aW9uICh0cmVlLCBpZCkge1xuICAgIHZhciBvd25lcklEID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRPd25lcklEKGlkKTtcbiAgICB2YXIgcGFyZW50SUQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFBhcmVudElEKGlkKTtcbiAgICB0cmVlW2lkXSA9IHtcbiAgICAgIGRpc3BsYXlOYW1lOiBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKGlkKSxcbiAgICAgIHRleHQ6IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0VGV4dChpZCksXG4gICAgICB1cGRhdGVDb3VudDogUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRVcGRhdGVDb3VudChpZCksXG4gICAgICBjaGlsZElEczogUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDaGlsZElEcyhpZCksXG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUgb3duZXJzIGJ1dCB0aGlzIGlzIGNsb3NlIGVub3VnaC5cbiAgICAgIG93bmVySUQ6IG93bmVySUQgfHwgcGFyZW50SUQgJiYgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRPd25lcklEKHBhcmVudElEKSB8fCAwLFxuICAgICAgcGFyZW50SUQ6IHBhcmVudElEXG4gICAgfTtcbiAgICByZXR1cm4gdHJlZTtcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiByZXNldE1lYXN1cmVtZW50cygpIHtcbiAgdmFyIHByZXZpb3VzU3RhcnRUaW1lID0gY3VycmVudEZsdXNoU3RhcnRUaW1lO1xuICB2YXIgcHJldmlvdXNNZWFzdXJlbWVudHMgPSBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHM7XG4gIHZhciBwcmV2aW91c09wZXJhdGlvbnMgPSBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5nZXRIaXN0b3J5KCk7XG5cbiAgaWYgKGN1cnJlbnRGbHVzaE5lc3RpbmcgPT09IDApIHtcbiAgICBjdXJyZW50Rmx1c2hTdGFydFRpbWUgPSAwO1xuICAgIGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyA9IFtdO1xuICAgIGNsZWFySGlzdG9yeSgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChwcmV2aW91c01lYXN1cmVtZW50cy5sZW5ndGggfHwgcHJldmlvdXNPcGVyYXRpb25zLmxlbmd0aCkge1xuICAgIHZhciByZWdpc3RlcmVkSURzID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRSZWdpc3RlcmVkSURzKCk7XG4gICAgZmx1c2hIaXN0b3J5LnB1c2goe1xuICAgICAgZHVyYXRpb246IHBlcmZvcm1hbmNlTm93KCkgLSBwcmV2aW91c1N0YXJ0VGltZSxcbiAgICAgIG1lYXN1cmVtZW50czogcHJldmlvdXNNZWFzdXJlbWVudHMgfHwgW10sXG4gICAgICBvcGVyYXRpb25zOiBwcmV2aW91c09wZXJhdGlvbnMgfHwgW10sXG4gICAgICB0cmVlU25hcHNob3Q6IGdldFRyZWVTbmFwc2hvdChyZWdpc3RlcmVkSURzKVxuICAgIH0pO1xuICB9XG5cbiAgY2xlYXJIaXN0b3J5KCk7XG4gIGN1cnJlbnRGbHVzaFN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG4gIGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyA9IFtdO1xufVxuXG5mdW5jdGlvbiBjaGVja0RlYnVnSUQoZGVidWdJRCkge1xuICB2YXIgYWxsb3dSb290ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICBpZiAoYWxsb3dSb290ICYmIGRlYnVnSUQgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFkZWJ1Z0lEKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERlYnVnVG9vbDogZGVidWdJRCBtYXkgbm90IGJlIGVtcHR5LicpIDogdm9pZCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJlZ2luTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKSB7XG4gIGlmIChjdXJyZW50Rmx1c2hOZXN0aW5nID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChjdXJyZW50VGltZXJUeXBlICYmICFsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGhlcmUgaXMgYW4gaW50ZXJuYWwgZXJyb3IgaW4gdGhlIFJlYWN0IHBlcmZvcm1hbmNlIG1lYXN1cmVtZW50IGNvZGUuICcgKyAnRGlkIG5vdCBleHBlY3QgJXMgdGltZXIgdG8gc3RhcnQgd2hpbGUgJXMgdGltZXIgaXMgc3RpbGwgaW4gJyArICdwcm9ncmVzcyBmb3IgJXMgaW5zdGFuY2UuJywgdGltZXJUeXBlLCBjdXJyZW50VGltZXJUeXBlIHx8ICdubycsIGRlYnVnSUQgPT09IGN1cnJlbnRUaW1lckRlYnVnSUQgPyAndGhlIHNhbWUnIDogJ2Fub3RoZXInKSA6IHZvaWQgMDtcbiAgICBsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCA9IHRydWU7XG4gIH1cbiAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiA9IDA7XG4gIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBkZWJ1Z0lEO1xuICBjdXJyZW50VGltZXJUeXBlID0gdGltZXJUeXBlO1xufVxuXG5mdW5jdGlvbiBlbmRMaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgaWYgKGN1cnJlbnRGbHVzaE5lc3RpbmcgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGN1cnJlbnRUaW1lclR5cGUgIT09IHRpbWVyVHlwZSAmJiAhbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RoZXJlIGlzIGFuIGludGVybmFsIGVycm9yIGluIHRoZSBSZWFjdCBwZXJmb3JtYW5jZSBtZWFzdXJlbWVudCBjb2RlLiAnICsgJ1dlIGRpZCBub3QgZXhwZWN0ICVzIHRpbWVyIHRvIHN0b3Agd2hpbGUgJXMgdGltZXIgaXMgc3RpbGwgaW4gJyArICdwcm9ncmVzcyBmb3IgJXMgaW5zdGFuY2UuIFBsZWFzZSByZXBvcnQgdGhpcyBhcyBhIGJ1ZyBpbiBSZWFjdC4nLCB0aW1lclR5cGUsIGN1cnJlbnRUaW1lclR5cGUgfHwgJ25vJywgZGVidWdJRCA9PT0gY3VycmVudFRpbWVyRGVidWdJRCA/ICd0aGUgc2FtZScgOiAnYW5vdGhlcicpIDogdm9pZCAwO1xuICAgIGxpZmVDeWNsZVRpbWVySGFzV2FybmVkID0gdHJ1ZTtcbiAgfVxuICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMucHVzaCh7XG4gICAgICB0aW1lclR5cGU6IHRpbWVyVHlwZSxcbiAgICAgIGluc3RhbmNlSUQ6IGRlYnVnSUQsXG4gICAgICBkdXJhdGlvbjogcGVyZm9ybWFuY2VOb3coKSAtIGN1cnJlbnRUaW1lclN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb25cbiAgICB9KTtcbiAgfVxuICBjdXJyZW50VGltZXJTdGFydFRpbWUgPSAwO1xuICBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uID0gMDtcbiAgY3VycmVudFRpbWVyRGVidWdJRCA9IG51bGw7XG4gIGN1cnJlbnRUaW1lclR5cGUgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBwYXVzZUN1cnJlbnRMaWZlQ3ljbGVUaW1lcigpIHtcbiAgdmFyIGN1cnJlbnRUaW1lciA9IHtcbiAgICBzdGFydFRpbWU6IGN1cnJlbnRUaW1lclN0YXJ0VGltZSxcbiAgICBuZXN0ZWRGbHVzaFN0YXJ0VGltZTogcGVyZm9ybWFuY2VOb3coKSxcbiAgICBkZWJ1Z0lEOiBjdXJyZW50VGltZXJEZWJ1Z0lELFxuICAgIHRpbWVyVHlwZTogY3VycmVudFRpbWVyVHlwZVxuICB9O1xuICBsaWZlQ3ljbGVUaW1lclN0YWNrLnB1c2goY3VycmVudFRpbWVyKTtcbiAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gMDtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiA9IDA7XG4gIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBudWxsO1xuICBjdXJyZW50VGltZXJUeXBlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVzdW1lQ3VycmVudExpZmVDeWNsZVRpbWVyKCkge1xuICB2YXIgX2xpZmVDeWNsZVRpbWVyU3RhY2skID0gbGlmZUN5Y2xlVGltZXJTdGFjay5wb3AoKSxcbiAgICAgIHN0YXJ0VGltZSA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC5zdGFydFRpbWUsXG4gICAgICBuZXN0ZWRGbHVzaFN0YXJ0VGltZSA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC5uZXN0ZWRGbHVzaFN0YXJ0VGltZSxcbiAgICAgIGRlYnVnSUQgPSBfbGlmZUN5Y2xlVGltZXJTdGFjayQuZGVidWdJRCxcbiAgICAgIHRpbWVyVHlwZSA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC50aW1lclR5cGU7XG5cbiAgdmFyIG5lc3RlZEZsdXNoRHVyYXRpb24gPSBwZXJmb3JtYW5jZU5vdygpIC0gbmVzdGVkRmx1c2hTdGFydFRpbWU7XG4gIGN1cnJlbnRUaW1lclN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiArPSBuZXN0ZWRGbHVzaER1cmF0aW9uO1xuICBjdXJyZW50VGltZXJEZWJ1Z0lEID0gZGVidWdJRDtcbiAgY3VycmVudFRpbWVyVHlwZSA9IHRpbWVyVHlwZTtcbn1cblxudmFyIGxhc3RNYXJrVGltZVN0YW1wID0gMDtcbnZhciBjYW5Vc2VQZXJmb3JtYW5jZU1lYXN1cmUgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1hcmtzID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tZWFzdXJlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBzaG91bGRNYXJrKGRlYnVnSUQpIHtcbiAgaWYgKCFpc1Byb2ZpbGluZyB8fCAhY2FuVXNlUGVyZm9ybWFuY2VNZWFzdXJlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGRlYnVnSUQpO1xuICBpZiAoZWxlbWVudCA9PSBudWxsIHx8IHR5cGVvZiBlbGVtZW50ICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaXNIb3N0RWxlbWVudCA9IHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnO1xuICBpZiAoaXNIb3N0RWxlbWVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbWFya0JlZ2luKGRlYnVnSUQsIG1hcmtUeXBlKSB7XG4gIGlmICghc2hvdWxkTWFyayhkZWJ1Z0lEKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBtYXJrTmFtZSA9IGRlYnVnSUQgKyAnOjonICsgbWFya1R5cGU7XG4gIGxhc3RNYXJrVGltZVN0YW1wID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgcGVyZm9ybWFuY2UubWFyayhtYXJrTmFtZSk7XG59XG5cbmZ1bmN0aW9uIG1hcmtFbmQoZGVidWdJRCwgbWFya1R5cGUpIHtcbiAgaWYgKCFzaG91bGRNYXJrKGRlYnVnSUQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1hcmtOYW1lID0gZGVidWdJRCArICc6OicgKyBtYXJrVHlwZTtcbiAgdmFyIGRpc3BsYXlOYW1lID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShkZWJ1Z0lEKSB8fCAnVW5rbm93bic7XG5cbiAgLy8gQ2hyb21lIGhhcyBhbiBpc3N1ZSBvZiBkcm9wcGluZyBtYXJrZXJzIHJlY29yZGVkIHRvbyBmYXN0OlxuICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02NDA2NTJcbiAgLy8gVG8gd29yayBhcm91bmQgdGhpcywgd2Ugd2lsbCBub3QgcmVwb3J0IHZlcnkgc21hbGwgbWVhc3VyZW1lbnRzLlxuICAvLyBJIGRldGVybWluZWQgdGhlIG1hZ2ljIG51bWJlciBieSB0d2Vha2luZyBpdCBiYWNrIGFuZCBmb3J0aC5cbiAgLy8gMC4wNW1zIHdhcyBlbm91Z2ggdG8gcHJldmVudCB0aGUgaXNzdWUsIGJ1dCBJIHNldCBpdCB0byAwLjFtcyB0byBiZSBzYWZlLlxuICAvLyBXaGVuIHRoZSBidWcgaXMgZml4ZWQsIHdlIGNhbiBgbWVhc3VyZSgpYCB1bmNvbmRpdGlvbmFsbHkgaWYgd2Ugd2FudCB0by5cbiAgdmFyIHRpbWVTdGFtcCA9IHBlcmZvcm1hbmNlTm93KCk7XG4gIGlmICh0aW1lU3RhbXAgLSBsYXN0TWFya1RpbWVTdGFtcCA+IDAuMSkge1xuICAgIHZhciBtZWFzdXJlbWVudE5hbWUgPSBkaXNwbGF5TmFtZSArICcgWycgKyBtYXJrVHlwZSArICddJztcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKG1lYXN1cmVtZW50TmFtZSwgbWFya05hbWUpO1xuICB9XG5cbiAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhtYXJrTmFtZSk7XG4gIGlmIChtZWFzdXJlbWVudE5hbWUpIHtcbiAgICBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKG1lYXN1cmVtZW50TmFtZSk7XG4gIH1cbn1cblxudmFyIFJlYWN0RGVidWdUb29sID0ge1xuICBhZGRIb29rOiBmdW5jdGlvbiAoaG9vaykge1xuICAgIGhvb2tzLnB1c2goaG9vayk7XG4gIH0sXG4gIHJlbW92ZUhvb2s6IGZ1bmN0aW9uIChob29rKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGhvb2tzW2ldID09PSBob29rKSB7XG4gICAgICAgIGhvb2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgaXNQcm9maWxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNQcm9maWxpbmc7XG4gIH0sXG4gIGJlZ2luUHJvZmlsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaXNQcm9maWxpbmcgPSB0cnVlO1xuICAgIGZsdXNoSGlzdG9yeS5sZW5ndGggPSAwO1xuICAgIHJlc2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgUmVhY3REZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayk7XG4gIH0sXG4gIGVuZFByb2ZpbGluZzogZnVuY3Rpb24gKCkge1xuICAgIGlmICghaXNQcm9maWxpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpc1Byb2ZpbGluZyA9IGZhbHNlO1xuICAgIHJlc2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgUmVhY3REZWJ1Z1Rvb2wucmVtb3ZlSG9vayhSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayk7XG4gIH0sXG4gIGdldEZsdXNoSGlzdG9yeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbHVzaEhpc3Rvcnk7XG4gIH0sXG4gIG9uQmVnaW5GbHVzaDogZnVuY3Rpb24gKCkge1xuICAgIGN1cnJlbnRGbHVzaE5lc3RpbmcrKztcbiAgICByZXNldE1lYXN1cmVtZW50cygpO1xuICAgIHBhdXNlQ3VycmVudExpZmVDeWNsZVRpbWVyKCk7XG4gICAgZW1pdEV2ZW50KCdvbkJlZ2luRmx1c2gnKTtcbiAgfSxcbiAgb25FbmRGbHVzaDogZnVuY3Rpb24gKCkge1xuICAgIHJlc2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgY3VycmVudEZsdXNoTmVzdGluZy0tO1xuICAgIHJlc3VtZUN1cnJlbnRMaWZlQ3ljbGVUaW1lcigpO1xuICAgIGVtaXRFdmVudCgnb25FbmRGbHVzaCcpO1xuICB9LFxuICBvbkJlZ2luTGlmZUN5Y2xlVGltZXI6IGZ1bmN0aW9uIChkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvbkJlZ2luTGlmZUN5Y2xlVGltZXInLCBkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICAgIG1hcmtCZWdpbihkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICAgIGJlZ2luTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgfSxcbiAgb25FbmRMaWZlQ3ljbGVUaW1lcjogZnVuY3Rpb24gKGRlYnVnSUQsIHRpbWVyVHlwZSkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbmRMaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICAgIG1hcmtFbmQoZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgICBlbWl0RXZlbnQoJ29uRW5kTGlmZUN5Y2xlVGltZXInLCBkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICB9LFxuICBvbkJlZ2luUHJvY2Vzc2luZ0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIGVtaXRFdmVudCgnb25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQnKTtcbiAgfSxcbiAgb25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgZW1pdEV2ZW50KCdvbkVuZFByb2Nlc3NpbmdDaGlsZENvbnRleHQnKTtcbiAgfSxcbiAgb25Ib3N0T3BlcmF0aW9uOiBmdW5jdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKG9wZXJhdGlvbi5pbnN0YW5jZUlEKTtcbiAgICBlbWl0RXZlbnQoJ29uSG9zdE9wZXJhdGlvbicsIG9wZXJhdGlvbik7XG4gIH0sXG4gIG9uU2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICBlbWl0RXZlbnQoJ29uU2V0U3RhdGUnKTtcbiAgfSxcbiAgb25TZXRDaGlsZHJlbjogZnVuY3Rpb24gKGRlYnVnSUQsIGNoaWxkRGVidWdJRHMpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgY2hpbGREZWJ1Z0lEcy5mb3JFYWNoKGNoZWNrRGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvblNldENoaWxkcmVuJywgZGVidWdJRCwgY2hpbGREZWJ1Z0lEcyk7XG4gIH0sXG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50LCBwYXJlbnREZWJ1Z0lEKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGNoZWNrRGVidWdJRChwYXJlbnREZWJ1Z0lELCB0cnVlKTtcbiAgICBlbWl0RXZlbnQoJ29uQmVmb3JlTW91bnRDb21wb25lbnQnLCBkZWJ1Z0lELCBlbGVtZW50LCBwYXJlbnREZWJ1Z0lEKTtcbiAgICBtYXJrQmVnaW4oZGVidWdJRCwgJ21vdW50Jyk7XG4gIH0sXG4gIG9uTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIG1hcmtFbmQoZGVidWdJRCwgJ21vdW50Jyk7XG4gICAgZW1pdEV2ZW50KCdvbk1vdW50Q29tcG9uZW50JywgZGVidWdJRCk7XG4gIH0sXG4gIG9uQmVmb3JlVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uQmVmb3JlVXBkYXRlQ29tcG9uZW50JywgZGVidWdJRCwgZWxlbWVudCk7XG4gICAgbWFya0JlZ2luKGRlYnVnSUQsICd1cGRhdGUnKTtcbiAgfSxcbiAgb25VcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIG1hcmtFbmQoZGVidWdJRCwgJ3VwZGF0ZScpO1xuICAgIGVtaXRFdmVudCgnb25VcGRhdGVDb21wb25lbnQnLCBkZWJ1Z0lEKTtcbiAgfSxcbiAgb25CZWZvcmVVbm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uQmVmb3JlVW5tb3VudENvbXBvbmVudCcsIGRlYnVnSUQpO1xuICAgIG1hcmtCZWdpbihkZWJ1Z0lELCAndW5tb3VudCcpO1xuICB9LFxuICBvblVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIG1hcmtFbmQoZGVidWdJRCwgJ3VubW91bnQnKTtcbiAgICBlbWl0RXZlbnQoJ29uVW5tb3VudENvbXBvbmVudCcsIGRlYnVnSUQpO1xuICB9LFxuICBvblRlc3RFdmVudDogZnVuY3Rpb24gKCkge1xuICAgIGVtaXRFdmVudCgnb25UZXN0RXZlbnQnKTtcbiAgfVxufTtcblxuLy8gVE9ETyByZW1vdmUgdGhlc2Ugd2hlbiBSTi93d3cgZ2V0cyB1cGRhdGVkXG5SZWFjdERlYnVnVG9vbC5hZGREZXZ0b29sID0gUmVhY3REZWJ1Z1Rvb2wuYWRkSG9vaztcblJlYWN0RGVidWdUb29sLnJlbW92ZURldnRvb2wgPSBSZWFjdERlYnVnVG9vbC5yZW1vdmVIb29rO1xuXG5SZWFjdERlYnVnVG9vbC5hZGRIb29rKFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2spO1xuUmVhY3REZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdENvbXBvbmVudFRyZWVIb29rKTtcbnZhciB1cmwgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LmxvY2F0aW9uLmhyZWYgfHwgJyc7XG5pZiAoL1s/Jl1yZWFjdF9wZXJmXFxiLy50ZXN0KHVybCkpIHtcbiAgUmVhY3REZWJ1Z1Rvb2wuYmVnaW5Qcm9maWxpbmcoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlYnVnVG9vbDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERlYnVnVG9vbC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwcm9jZXNzaW5nQ2hpbGRDb250ZXh0ID0gZmFsc2U7XG5cbiAgdmFyIHdhcm5JbnZhbGlkU2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIXByb2Nlc3NpbmdDaGlsZENvbnRleHQsICdzZXRTdGF0ZSguLi4pOiBDYW5ub3QgY2FsbCBzZXRTdGF0ZSgpIGluc2lkZSBnZXRDaGlsZENvbnRleHQoKScpIDogdm9pZCAwO1xuICB9O1xufVxuXG52YXIgUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vayA9IHtcbiAgb25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzaW5nQ2hpbGRDb250ZXh0ID0gdHJ1ZTtcbiAgfSxcbiAgb25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzc2luZ0NoaWxkQ29udGV4dCA9IGZhbHNlO1xuICB9LFxuICBvblNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgd2FybkludmFsaWRTZXRTdGF0ZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2s7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vay5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhpc3RvcnkgPSBbXTtcblxudmFyIFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rID0ge1xuICBvbkhvc3RPcGVyYXRpb246IGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcbiAgICBoaXN0b3J5LnB1c2gob3BlcmF0aW9uKTtcbiAgfSxcbiAgY2xlYXJIaXN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rLl9wcmV2ZW50Q2xlYXJpbmcpIHtcbiAgICAgIC8vIFNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIHRlc3RzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhpc3RvcnkgPSBbXTtcbiAgfSxcbiAgZ2V0SGlzdG9yeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBoaXN0b3J5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgcGVyZm9ybWFuY2UgPSByZXF1aXJlKCcuL3BlcmZvcm1hbmNlJyk7XG5cbnZhciBwZXJmb3JtYW5jZU5vdztcblxuLyoqXG4gKiBEZXRlY3QgaWYgd2UgY2FuIHVzZSBgd2luZG93LnBlcmZvcm1hbmNlLm5vdygpYCBhbmQgZ3JhY2VmdWxseSBmYWxsYmFjayB0b1xuICogYERhdGUubm93KClgIGlmIGl0IGRvZXNuJ3QgZXhpc3QuIFdlIG5lZWQgdG8gc3VwcG9ydCBGaXJlZm94IDwgMTUgZm9yIG5vd1xuICogYmVjYXVzZSBvZiBGYWNlYm9vaydzIHRlc3RpbmcgaW5mcmFzdHJ1Y3R1cmUuXG4gKi9cbmlmIChwZXJmb3JtYW5jZS5ub3cpIHtcbiAgcGVyZm9ybWFuY2VOb3cgPSBmdW5jdGlvbiBwZXJmb3JtYW5jZU5vdygpIHtcbiAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gIH07XG59IGVsc2Uge1xuICBwZXJmb3JtYW5jZU5vdyA9IGZ1bmN0aW9uIHBlcmZvcm1hbmNlTm93KCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBlcmZvcm1hbmNlTm93O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9wZXJmb3JtYW5jZU5vdy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgcGVyZm9ybWFuY2U7XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgcGVyZm9ybWFuY2UgPSB3aW5kb3cucGVyZm9ybWFuY2UgfHwgd2luZG93Lm1zUGVyZm9ybWFuY2UgfHwgd2luZG93LndlYmtpdFBlcmZvcm1hbmNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBlcmZvcm1hbmNlIHx8IHt9O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9wZXJmb3JtYW5jZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIHRoYXQgaXMgaW5qZWN0YWJsZSBpbnRvIGBFdmVudFBsdWdpbkh1YmAsIHRoYXQgc3BlY2lmaWVzIGFcbiAqIGRldGVybWluaXN0aWMgb3JkZXJpbmcgb2YgYEV2ZW50UGx1Z2luYHMuIEEgY29udmVuaWVudCB3YXkgdG8gcmVhc29uIGFib3V0XG4gKiBwbHVnaW5zLCB3aXRob3V0IGhhdmluZyB0byBwYWNrYWdlIGV2ZXJ5IG9uZSBvZiB0aGVtLiBUaGlzIGlzIGJldHRlciB0aGFuXG4gKiBoYXZpbmcgcGx1Z2lucyBiZSBvcmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSBhcmUgaW5qZWN0ZWQgYmVjYXVzZVxuICogdGhhdCBvcmRlcmluZyB3b3VsZCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBwYWNrYWdpbmcgb3JkZXIuXG4gKiBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gIG11c3Qgb2NjdXIgYmVmb3JlIGBTaW1wbGVFdmVudFBsdWdpbmAgc28gdGhhdFxuICogcHJldmVudGluZyBkZWZhdWx0IG9uIGV2ZW50cyBpcyBjb252ZW5pZW50IGluIGBTaW1wbGVFdmVudFBsdWdpbmAgaGFuZGxlcnMuXG4gKi9cblxudmFyIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyID0gWydSZXNwb25kZXJFdmVudFBsdWdpbicsICdTaW1wbGVFdmVudFBsdWdpbicsICdUYXBFdmVudFBsdWdpbicsICdFbnRlckxlYXZlRXZlbnRQbHVnaW4nLCAnQ2hhbmdlRXZlbnRQbHVnaW4nLCAnU2VsZWN0RXZlbnRQbHVnaW4nLCAnQmVmb3JlSW5wdXRFdmVudFBsdWdpbiddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlZmF1bHRFdmVudFBsdWdpbk9yZGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0RlZmF1bHRFdmVudFBsdWdpbk9yZGVyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIG1vdXNlRW50ZXI6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiAnb25Nb3VzZUVudGVyJyxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wTW91c2VPdXQnLCAndG9wTW91c2VPdmVyJ11cbiAgfSxcbiAgbW91c2VMZWF2ZToge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvbk1vdXNlTGVhdmUnLFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BNb3VzZU91dCcsICd0b3BNb3VzZU92ZXInXVxuICB9XG59O1xuXG52YXIgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBGb3IgYWxtb3N0IGV2ZXJ5IGludGVyYWN0aW9uIHdlIGNhcmUgYWJvdXQsIHRoZXJlIHdpbGwgYmUgYm90aCBhIHRvcC1sZXZlbFxuICAgKiBgbW91c2VvdmVyYCBhbmQgYG1vdXNlb3V0YCBldmVudCB0aGF0IG9jY3Vycy4gT25seSB1c2UgYG1vdXNlb3V0YCBzbyB0aGF0XG4gICAqIHdlIGRvIG5vdCBleHRyYWN0IGR1cGxpY2F0ZSBldmVudHMuIEhvd2V2ZXIsIG1vdmluZyB0aGUgbW91c2UgaW50byB0aGVcbiAgICogYnJvd3NlciBmcm9tIG91dHNpZGUgd2lsbCBub3QgZmlyZSBhIGBtb3VzZW91dGAgZXZlbnQuIEluIHRoaXMgY2FzZSwgd2UgdXNlXG4gICAqIHRoZSBgbW91c2VvdmVyYCB0b3AtbGV2ZWwgZXZlbnQuXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VPdmVyJyAmJiAobmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodG9wTGV2ZWxUeXBlICE9PSAndG9wTW91c2VPdXQnICYmIHRvcExldmVsVHlwZSAhPT0gJ3RvcE1vdXNlT3ZlcicpIHtcbiAgICAgIC8vIE11c3Qgbm90IGJlIGEgbW91c2UgaW4gb3IgbW91c2Ugb3V0IC0gaWdub3JpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgd2luO1xuICAgIGlmIChuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgICAvLyBgbmF0aXZlRXZlbnRUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cbiAgICAgIHdpbiA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgICB2YXIgZG9jID0gbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW4gPSB3aW5kb3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZyb207XG4gICAgdmFyIHRvO1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZU91dCcpIHtcbiAgICAgIGZyb20gPSB0YXJnZXRJbnN0O1xuICAgICAgdmFyIHJlbGF0ZWQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudDtcbiAgICAgIHRvID0gcmVsYXRlZCA/IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyZWxhdGVkKSA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdmluZyB0byBhIG5vZGUgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cuXG4gICAgICBmcm9tID0gbnVsbDtcbiAgICAgIHRvID0gdGFyZ2V0SW5zdDtcbiAgICB9XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgIC8vIE5vdGhpbmcgcGVydGFpbnMgdG8gb3VyIG1hbmFnZWQgY29tcG9uZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBmcm9tTm9kZSA9IGZyb20gPT0gbnVsbCA/IHdpbiA6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGZyb20pO1xuICAgIHZhciB0b05vZGUgPSB0byA9PSBudWxsID8gd2luIDogUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodG8pO1xuXG4gICAgdmFyIGxlYXZlID0gU3ludGhldGljTW91c2VFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5tb3VzZUxlYXZlLCBmcm9tLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGxlYXZlLnR5cGUgPSAnbW91c2VsZWF2ZSc7XG4gICAgbGVhdmUudGFyZ2V0ID0gZnJvbU5vZGU7XG4gICAgbGVhdmUucmVsYXRlZFRhcmdldCA9IHRvTm9kZTtcblxuICAgIHZhciBlbnRlciA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMubW91c2VFbnRlciwgdG8sIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZW50ZXIudHlwZSA9ICdtb3VzZWVudGVyJztcbiAgICBlbnRlci50YXJnZXQgPSB0b05vZGU7XG4gICAgZW50ZXIucmVsYXRlZFRhcmdldCA9IGZyb21Ob2RlO1xuXG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tLCB0byk7XG5cbiAgICByZXR1cm4gW2xlYXZlLCBlbnRlcl07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRW50ZXJMZWF2ZUV2ZW50UGx1Z2luO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0VudGVyTGVhdmVFdmVudFBsdWdpbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcblxudmFyIE1VU1RfVVNFX1BST1BFUlRZID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZO1xudmFyIEhBU19CT09MRUFOX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFO1xudmFyIEhBU19OVU1FUklDX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTtcblxudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgaXNDdXN0b21BdHRyaWJ1dGU6IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKG5ldyBSZWdFeHAoJ14oZGF0YXxhcmlhKS1bJyArIERPTVByb3BlcnR5LkFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJykpLFxuICBQcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogU3RhbmRhcmQgUHJvcGVydGllc1xuICAgICAqL1xuICAgIGFjY2VwdDogMCxcbiAgICBhY2NlcHRDaGFyc2V0OiAwLFxuICAgIGFjY2Vzc0tleTogMCxcbiAgICBhY3Rpb246IDAsXG4gICAgYWxsb3dGdWxsU2NyZWVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhbGxvd1RyYW5zcGFyZW5jeTogMCxcbiAgICBhbHQ6IDAsXG4gICAgLy8gc3BlY2lmaWVzIHRhcmdldCBjb250ZXh0IGZvciBsaW5rcyB3aXRoIGBwcmVsb2FkYCB0eXBlXG4gICAgYXM6IDAsXG4gICAgYXN5bmM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9Db21wbGV0ZTogMCxcbiAgICAvLyBhdXRvRm9jdXMgaXMgcG9seWZpbGxlZC9ub3JtYWxpemVkIGJ5IEF1dG9Gb2N1c1V0aWxzXG4gICAgLy8gYXV0b0ZvY3VzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhdXRvUGxheTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2FwdHVyZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2VsbFBhZGRpbmc6IDAsXG4gICAgY2VsbFNwYWNpbmc6IDAsXG4gICAgY2hhclNldDogMCxcbiAgICBjaGFsbGVuZ2U6IDAsXG4gICAgY2hlY2tlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjaXRlOiAwLFxuICAgIGNsYXNzSUQ6IDAsXG4gICAgY2xhc3NOYW1lOiAwLFxuICAgIGNvbHM6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIGNvbFNwYW46IDAsXG4gICAgY29udGVudDogMCxcbiAgICBjb250ZW50RWRpdGFibGU6IDAsXG4gICAgY29udGV4dE1lbnU6IDAsXG4gICAgY29udHJvbHM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNvb3JkczogMCxcbiAgICBjcm9zc09yaWdpbjogMCxcbiAgICBkYXRhOiAwLCAvLyBGb3IgYDxvYmplY3QgLz5gIGFjdHMgYXMgYHNyY2AuXG4gICAgZGF0ZVRpbWU6IDAsXG4gICAgJ2RlZmF1bHQnOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkZWZlcjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGlyOiAwLFxuICAgIGRpc2FibGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkb3dubG9hZDogSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxcbiAgICBkcmFnZ2FibGU6IDAsXG4gICAgZW5jVHlwZTogMCxcbiAgICBmb3JtOiAwLFxuICAgIGZvcm1BY3Rpb246IDAsXG4gICAgZm9ybUVuY1R5cGU6IDAsXG4gICAgZm9ybU1ldGhvZDogMCxcbiAgICBmb3JtTm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZm9ybVRhcmdldDogMCxcbiAgICBmcmFtZUJvcmRlcjogMCxcbiAgICBoZWFkZXJzOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBoaWRkZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGhpZ2g6IDAsXG4gICAgaHJlZjogMCxcbiAgICBocmVmTGFuZzogMCxcbiAgICBodG1sRm9yOiAwLFxuICAgIGh0dHBFcXVpdjogMCxcbiAgICBpY29uOiAwLFxuICAgIGlkOiAwLFxuICAgIGlucHV0TW9kZTogMCxcbiAgICBpbnRlZ3JpdHk6IDAsXG4gICAgaXM6IDAsXG4gICAga2V5UGFyYW1zOiAwLFxuICAgIGtleVR5cGU6IDAsXG4gICAga2luZDogMCxcbiAgICBsYWJlbDogMCxcbiAgICBsYW5nOiAwLFxuICAgIGxpc3Q6IDAsXG4gICAgbG9vcDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbG93OiAwLFxuICAgIG1hbmlmZXN0OiAwLFxuICAgIG1hcmdpbkhlaWdodDogMCxcbiAgICBtYXJnaW5XaWR0aDogMCxcbiAgICBtYXg6IDAsXG4gICAgbWF4TGVuZ3RoOiAwLFxuICAgIG1lZGlhOiAwLFxuICAgIG1lZGlhR3JvdXA6IDAsXG4gICAgbWV0aG9kOiAwLFxuICAgIG1pbjogMCxcbiAgICBtaW5MZW5ndGg6IDAsXG4gICAgLy8gQ2F1dGlvbjsgYG9wdGlvbi5zZWxlY3RlZGAgaXMgbm90IHVwZGF0ZWQgaWYgYHNlbGVjdC5tdWx0aXBsZWAgaXNcbiAgICAvLyBkaXNhYmxlZCB3aXRoIGByZW1vdmVBdHRyaWJ1dGVgLlxuICAgIG11bHRpcGxlOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG11dGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG5hbWU6IDAsXG4gICAgbm9uY2U6IDAsXG4gICAgbm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3BlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3B0aW11bTogMCxcbiAgICBwYXR0ZXJuOiAwLFxuICAgIHBsYWNlaG9sZGVyOiAwLFxuICAgIHBsYXlzSW5saW5lOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBwb3N0ZXI6IDAsXG4gICAgcHJlbG9hZDogMCxcbiAgICBwcm9maWxlOiAwLFxuICAgIHJhZGlvR3JvdXA6IDAsXG4gICAgcmVhZE9ubHk6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJlZmVycmVyUG9saWN5OiAwLFxuICAgIHJlbDogMCxcbiAgICByZXF1aXJlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmV2ZXJzZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJvbGU6IDAsXG4gICAgcm93czogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgcm93U3BhbjogSEFTX05VTUVSSUNfVkFMVUUsXG4gICAgc2FuZGJveDogMCxcbiAgICBzY29wZTogMCxcbiAgICBzY29wZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNjcm9sbGluZzogMCxcbiAgICBzZWFtbGVzczogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2VsZWN0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2hhcGU6IDAsXG4gICAgc2l6ZTogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc2l6ZXM6IDAsXG4gICAgc3BhbjogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc3BlbGxDaGVjazogMCxcbiAgICBzcmM6IDAsXG4gICAgc3JjRG9jOiAwLFxuICAgIHNyY0xhbmc6IDAsXG4gICAgc3JjU2V0OiAwLFxuICAgIHN0YXJ0OiBIQVNfTlVNRVJJQ19WQUxVRSxcbiAgICBzdGVwOiAwLFxuICAgIHN0eWxlOiAwLFxuICAgIHN1bW1hcnk6IDAsXG4gICAgdGFiSW5kZXg6IDAsXG4gICAgdGFyZ2V0OiAwLFxuICAgIHRpdGxlOiAwLFxuICAgIC8vIFNldHRpbmcgLnR5cGUgdGhyb3dzIG9uIG5vbi08aW5wdXQ+IHRhZ3NcbiAgICB0eXBlOiAwLFxuICAgIHVzZU1hcDogMCxcbiAgICB2YWx1ZTogMCxcbiAgICB3aWR0aDogMCxcbiAgICB3bW9kZTogMCxcbiAgICB3cmFwOiAwLFxuXG4gICAgLyoqXG4gICAgICogUkRGYSBQcm9wZXJ0aWVzXG4gICAgICovXG4gICAgYWJvdXQ6IDAsXG4gICAgZGF0YXR5cGU6IDAsXG4gICAgaW5saXN0OiAwLFxuICAgIHByZWZpeDogMCxcbiAgICAvLyBwcm9wZXJ0eSBpcyBhbHNvIHN1cHBvcnRlZCBmb3IgT3BlbkdyYXBoIGluIG1ldGEgdGFncy5cbiAgICBwcm9wZXJ0eTogMCxcbiAgICByZXNvdXJjZTogMCxcbiAgICAndHlwZW9mJzogMCxcbiAgICB2b2NhYjogMCxcblxuICAgIC8qKlxuICAgICAqIE5vbi1zdGFuZGFyZCBQcm9wZXJ0aWVzXG4gICAgICovXG4gICAgLy8gYXV0b0NhcGl0YWxpemUgYW5kIGF1dG9Db3JyZWN0IGFyZSBzdXBwb3J0ZWQgaW4gTW9iaWxlIFNhZmFyaSBmb3JcbiAgICAvLyBrZXlib2FyZCBoaW50cy5cbiAgICBhdXRvQ2FwaXRhbGl6ZTogMCxcbiAgICBhdXRvQ29ycmVjdDogMCxcbiAgICAvLyBhdXRvU2F2ZSBhbGxvd3MgV2ViS2l0L0JsaW5rIHRvIHBlcnNpc3QgdmFsdWVzIG9mIGlucHV0IGZpZWxkcyBvbiBwYWdlIHJlbG9hZHNcbiAgICBhdXRvU2F2ZTogMCxcbiAgICAvLyBjb2xvciBpcyBmb3IgU2FmYXJpIG1hc2staWNvbiBsaW5rXG4gICAgY29sb3I6IDAsXG4gICAgLy8gaXRlbVByb3AsIGl0ZW1TY29wZSwgaXRlbVR5cGUgYXJlIGZvclxuICAgIC8vIE1pY3JvZGF0YSBzdXBwb3J0LiBTZWUgaHR0cDovL3NjaGVtYS5vcmcvZG9jcy9ncy5odG1sXG4gICAgaXRlbVByb3A6IDAsXG4gICAgaXRlbVNjb3BlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBpdGVtVHlwZTogMCxcbiAgICAvLyBpdGVtSUQgYW5kIGl0ZW1SZWYgYXJlIGZvciBNaWNyb2RhdGEgc3VwcG9ydCBhcyB3ZWxsIGJ1dFxuICAgIC8vIG9ubHkgc3BlY2lmaWVkIGluIHRoZSBXSEFUV0cgc3BlYyBkb2N1bWVudC4gU2VlXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvbWljcm9kYXRhLmh0bWwjbWljcm9kYXRhLWRvbS1hcGlcbiAgICBpdGVtSUQ6IDAsXG4gICAgaXRlbVJlZjogMCxcbiAgICAvLyByZXN1bHRzIHNob3cgbG9va2luZyBnbGFzcyBpY29uIGFuZCByZWNlbnQgc2VhcmNoZXMgb24gaW5wdXRcbiAgICAvLyBzZWFyY2ggZmllbGRzIGluIFdlYktpdC9CbGlua1xuICAgIHJlc3VsdHM6IDAsXG4gICAgLy8gSUUtb25seSBhdHRyaWJ1dGUgdGhhdCBzcGVjaWZpZXMgc2VjdXJpdHkgcmVzdHJpY3Rpb25zIG9uIGFuIGlmcmFtZVxuICAgIC8vIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBzYW5kYm94IGF0dHJpYnV0ZSBvbiBJRTwxMFxuICAgIHNlY3VyaXR5OiAwLFxuICAgIC8vIElFLW9ubHkgYXR0cmlidXRlIHRoYXQgY29udHJvbHMgZm9jdXMgYmVoYXZpb3JcbiAgICB1bnNlbGVjdGFibGU6IDBcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcbiAgICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgICBodG1sRm9yOiAnZm9yJyxcbiAgICBodHRwRXF1aXY6ICdodHRwLWVxdWl2J1xuICB9LFxuICBET01Qcm9wZXJ0eU5hbWVzOiB7fSxcbiAgRE9NTXV0YXRpb25NZXRob2RzOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlLCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUucmVtb3ZlQXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgfVxuXG4gICAgICAvLyBOdW1iZXIgaW5wdXRzIGdldCBzcGVjaWFsIHRyZWF0bWVudCBkdWUgdG8gc29tZSBlZGdlIGNhc2VzIGluXG4gICAgICAvLyBDaHJvbWUuIExldCBldmVyeXRoaW5nIGVsc2UgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgYXMgbm9ybWFsLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjUzI2lzc3VlY29tbWVudC0yMzYwNzQzMjZcbiAgICAgIGlmIChub2RlLnR5cGUgIT09ICdudW1iZXInIHx8IG5vZGUuaGFzQXR0cmlidXRlKCd2YWx1ZScpID09PSBmYWxzZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCAnJyArIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS52YWxpZGl0eSAmJiAhbm9kZS52YWxpZGl0eS5iYWRJbnB1dCAmJiBub2RlLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gbm9kZSkge1xuICAgICAgICAvLyBEb24ndCBhc3NpZ24gYW4gYXR0cmlidXRlIGlmIHZhbGlkYXRpb24gcmVwb3J0cyBiYWRcbiAgICAgICAgLy8gaW5wdXQuIENocm9tZSB3aWxsIGNsZWFyIHRoZSB2YWx1ZS4gQWRkaXRpb25hbGx5LCBkb24ndFxuICAgICAgICAvLyBvcGVyYXRlIG9uIGlucHV0cyB0aGF0IGhhdmUgZm9jdXMsIG90aGVyd2lzZSBDaHJvbWUgbWlnaHRcbiAgICAgICAgLy8gc3RyaXAgb2ZmIHRyYWlsaW5nIGRlY2ltYWwgcGxhY2VzIGFuZCBjYXVzZSB0aGUgdXNlcidzXG4gICAgICAgIC8vIGN1cnNvciBwb3NpdGlvbiB0byBqdW1wIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGlucHV0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBJbiBSZWFjdERPTUlucHV0LCB3ZSBoYXZlIGFuIG9uQmx1ciBldmVudCB0aGF0IHdpbGwgdHJpZ2dlclxuICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIGFnYWluIHdoZW4gZm9jdXMgaXMgbG9zdC5cbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgJycgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhUTUxET01Qcm9wZXJ0eUNvbmZpZztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9IVE1MRE9NUHJvcGVydHlDb25maWcuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01DaGlsZHJlbk9wZXJhdGlvbnMnKTtcbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RET01JRE9wZXJhdGlvbnMnKTtcblxuLyoqXG4gKiBBYnN0cmFjdHMgYXdheSBhbGwgZnVuY3Rpb25hbGl0eSBvZiB0aGUgcmVjb25jaWxlciB0aGF0IHJlcXVpcmVzIGtub3dsZWRnZSBvZlxuICogdGhlIGJyb3dzZXIgY29udGV4dC4gVE9ETzogVGhlc2UgY2FsbGVycyBzaG91bGQgYmUgcmVmYWN0b3JlZCB0byBhdm9pZCB0aGVcbiAqIG5lZWQgZm9yIHRoaXMgaW5qZWN0aW9uLlxuICovXG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSB7XG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IFJlYWN0RE9NSURPcGVyYXRpb25zLmRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyxcblxuICByZXBsYWNlTm9kZVdpdGhNYXJrdXA6IERPTUNoaWxkcmVuT3BlcmF0aW9ucy5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAgPSByZXF1aXJlKCdmYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAnKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgRGFuZ2VyID0ge1xuICAvKipcbiAgICogUmVwbGFjZXMgYSBub2RlIHdpdGggYSBzdHJpbmcgb2YgbWFya3VwIGF0IGl0cyBjdXJyZW50IHBvc2l0aW9uIHdpdGhpbiBpdHNcbiAgICogcGFyZW50LiBUaGUgbWFya3VwIG11c3QgcmVuZGVyIGludG8gYSBzaW5nbGUgcm9vdCBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG9sZENoaWxkIENoaWxkIG5vZGUgdG8gcmVwbGFjZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdG8gcmVuZGVyIGluIHBsYWNlIG9mIHRoZSBjaGlsZCBub2RlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwOiBmdW5jdGlvbiAob2xkQ2hpbGQsIG1hcmt1cCkge1xuICAgICFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogQ2Fubm90IHJlbmRlciBtYXJrdXAgaW4gYSB3b3JrZXIgdGhyZWFkLiBNYWtlIHN1cmUgYHdpbmRvd2AgYW5kIGBkb2N1bWVudGAgYXJlIGF2YWlsYWJsZSBnbG9iYWxseSBiZWZvcmUgcmVxdWlyaW5nIFJlYWN0IHdoZW4gdW5pdCB0ZXN0aW5nIG9yIHVzZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLicpIDogX3Byb2RJbnZhcmlhbnQoJzU2JykgOiB2b2lkIDA7XG4gICAgIW1hcmt1cCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBNaXNzaW5nIG1hcmt1cC4nKSA6IF9wcm9kSW52YXJpYW50KCc1NycpIDogdm9pZCAwO1xuICAgICEob2xkQ2hpbGQubm9kZU5hbWUgIT09ICdIVE1MJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogQ2Fubm90IHJlcGxhY2UgbWFya3VwIG9mIHRoZSA8aHRtbD4gbm9kZS4gVGhpcyBpcyBiZWNhdXNlIGJyb3dzZXIgcXVpcmtzIG1ha2UgdGhpcyB1bnJlbGlhYmxlIGFuZC9vciBzbG93LiBJZiB5b3Ugd2FudCB0byByZW5kZXIgdG8gdGhlIHJvb3QgeW91IG11c3QgdXNlIHNlcnZlciByZW5kZXJpbmcuIFNlZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpLicpIDogX3Byb2RJbnZhcmlhbnQoJzU4JykgOiB2b2lkIDA7XG5cbiAgICBpZiAodHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBuZXdDaGlsZCA9IGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXAsIGVtcHR5RnVuY3Rpb24pWzBdO1xuICAgICAgb2xkQ2hpbGQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3Q2hpbGQsIG9sZENoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgRE9NTGF6eVRyZWUucmVwbGFjZUNoaWxkV2l0aFRyZWUob2xkQ2hpbGQsIG1hcmt1cCk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhbmdlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9EYW5nZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qZXNsaW50LWRpc2FibGUgZmItd3d3L3Vuc2FmZS1odG1sKi9cblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgY3JlYXRlQXJyYXlGcm9tTWl4ZWQgPSByZXF1aXJlKCcuL2NyZWF0ZUFycmF5RnJvbU1peGVkJyk7XG52YXIgZ2V0TWFya3VwV3JhcCA9IHJlcXVpcmUoJy4vZ2V0TWFya3VwV3JhcCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogRHVtbXkgY29udGFpbmVyIHVzZWQgdG8gcmVuZGVyIGFsbCBtYXJrdXAuXG4gKi9cbnZhciBkdW1teU5vZGUgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSA6IG51bGw7XG5cbi8qKlxuICogUGF0dGVybiB1c2VkIGJ5IGBnZXROb2RlTmFtZWAuXG4gKi9cbnZhciBub2RlTmFtZVBhdHRlcm4gPSAvXlxccyo8KFxcdyspLztcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgYG5vZGVOYW1lYCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiBhIHN0cmluZyBvZiBtYXJrdXAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICogQHJldHVybiB7P3N0cmluZ30gTm9kZSBuYW1lIG9mIHRoZSBzdXBwbGllZCBtYXJrdXAuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVOYW1lKG1hcmt1cCkge1xuICB2YXIgbm9kZU5hbWVNYXRjaCA9IG1hcmt1cC5tYXRjaChub2RlTmFtZVBhdHRlcm4pO1xuICByZXR1cm4gbm9kZU5hbWVNYXRjaCAmJiBub2RlTmFtZU1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBub2RlcyByZW5kZXJlZCBmcm9tIHRoZSBzdXBwbGllZCBtYXJrdXAuIFRoZVxuICogb3B0aW9uYWxseSBzdXBwbGllZCBgaGFuZGxlU2NyaXB0YCBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgb25jZSBmb3IgZWFjaFxuICogPHNjcmlwdD4gZWxlbWVudCB0aGF0IGlzIHJlbmRlcmVkLiBJZiBubyBgaGFuZGxlU2NyaXB0YCBmdW5jdGlvbiBpcyBzdXBwbGllZCxcbiAqIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgYW55IDxzY3JpcHQ+IGVsZW1lbnRzIGFyZSByZW5kZXJlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIEEgc3RyaW5nIG9mIHZhbGlkIEhUTUwgbWFya3VwLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGhhbmRsZVNjcmlwdCBJbnZva2VkIG9uY2UgZm9yIGVhY2ggcmVuZGVyZWQgPHNjcmlwdD4uXG4gKiBAcmV0dXJuIHthcnJheTxET01FbGVtZW50fERPTVRleHROb2RlPn0gQW4gYXJyYXkgb2YgcmVuZGVyZWQgbm9kZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXAsIGhhbmRsZVNjcmlwdCkge1xuICB2YXIgbm9kZSA9IGR1bW15Tm9kZTtcbiAgISEhZHVtbXlOb2RlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCBkdW1teSBub3QgaW5pdGlhbGl6ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHZhciBub2RlTmFtZSA9IGdldE5vZGVOYW1lKG1hcmt1cCk7XG5cbiAgdmFyIHdyYXAgPSBub2RlTmFtZSAmJiBnZXRNYXJrdXBXcmFwKG5vZGVOYW1lKTtcbiAgaWYgKHdyYXApIHtcbiAgICBub2RlLmlubmVySFRNTCA9IHdyYXBbMV0gKyBtYXJrdXAgKyB3cmFwWzJdO1xuXG4gICAgdmFyIHdyYXBEZXB0aCA9IHdyYXBbMF07XG4gICAgd2hpbGUgKHdyYXBEZXB0aC0tKSB7XG4gICAgICBub2RlID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gbWFya3VwO1xuICB9XG5cbiAgdmFyIHNjcmlwdHMgPSBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgaWYgKHNjcmlwdHMubGVuZ3RoKSB7XG4gICAgIWhhbmRsZVNjcmlwdCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVOb2Rlc0Zyb21NYXJrdXAoLi4uKTogVW5leHBlY3RlZCA8c2NyaXB0PiBlbGVtZW50IHJlbmRlcmVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjcmVhdGVBcnJheUZyb21NaXhlZChzY3JpcHRzKS5mb3JFYWNoKGhhbmRsZVNjcmlwdCk7XG4gIH1cblxuICB2YXIgbm9kZXMgPSBBcnJheS5mcm9tKG5vZGUuY2hpbGROb2Rlcyk7XG4gIHdoaWxlIChub2RlLmxhc3RDaGlsZCkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5sYXN0Q2hpbGQpO1xuICB9XG4gIHJldHVybiBub2Rlcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXA7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cC5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQ29udmVydCBhcnJheS1saWtlIG9iamVjdHMgdG8gYXJyYXlzLlxuICpcbiAqIFRoaXMgQVBJIGFzc3VtZXMgdGhlIGNhbGxlciBrbm93cyB0aGUgY29udGVudHMgb2YgdGhlIGRhdGEgdHlwZS4gRm9yIGxlc3NcbiAqIHdlbGwgZGVmaW5lZCBpbnB1dHMgdXNlIGNyZWF0ZUFycmF5RnJvbU1peGVkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufGZpbGVsaXN0fSBvYmpcbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICB2YXIgbGVuZ3RoID0gb2JqLmxlbmd0aDtcblxuICAvLyBTb21lIGJyb3dzZXJzIGJ1aWx0aW4gb2JqZWN0cyBjYW4gcmVwb3J0IHR5cGVvZiAnZnVuY3Rpb24nIChlLmcuIE5vZGVMaXN0XG4gIC8vIGluIG9sZCB2ZXJzaW9ucyBvZiBTYWZhcmkpLlxuICAhKCFBcnJheS5pc0FycmF5KG9iaikgJiYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBBcnJheS1saWtlIG9iamVjdCBleHBlY3RlZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAhKHR5cGVvZiBsZW5ndGggPT09ICdudW1iZXInKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBPYmplY3QgbmVlZHMgYSBsZW5ndGggcHJvcGVydHknKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgIShsZW5ndGggPT09IDAgfHwgbGVuZ3RoIC0gMSBpbiBvYmopID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IE9iamVjdCBzaG91bGQgaGF2ZSBrZXlzIGZvciBpbmRpY2VzJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICEodHlwZW9mIG9iai5jYWxsZWUgIT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IE9iamVjdCBjYW5cXCd0IGJlIGBhcmd1bWVudHNgLiBVc2UgcmVzdCBwYXJhbXMgJyArICcoZnVuY3Rpb24oLi4uYXJncykge30pIG9yIEFycmF5LmZyb20oKSBpbnN0ZWFkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAvLyBPbGQgSUUgZG9lc24ndCBnaXZlIGNvbGxlY3Rpb25zIGFjY2VzcyB0byBoYXNPd25Qcm9wZXJ0eS4gQXNzdW1lIGlucHV0c1xuICAvLyB3aXRob3V0IG1ldGhvZCB3aWxsIHRocm93IGR1cmluZyB0aGUgc2xpY2UgY2FsbCBhbmQgc2tpcCBzdHJhaWdodCB0byB0aGVcbiAgLy8gZmFsbGJhY2suXG4gIGlmIChvYmouaGFzT3duUHJvcGVydHkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSUUgPCA5IGRvZXMgbm90IHN1cHBvcnQgQXJyYXkjc2xpY2Ugb24gY29sbGVjdGlvbnMgb2JqZWN0c1xuICAgIH1cbiAgfVxuXG4gIC8vIEZhbGwgYmFjayB0byBjb3B5aW5nIGtleSBieSBrZXkuIFRoaXMgYXNzdW1lcyBhbGwga2V5cyBoYXZlIGEgdmFsdWUsXG4gIC8vIHNvIHdpbGwgbm90IHByZXNlcnZlIHNwYXJzZWx5IHBvcHVsYXRlZCBpbnB1dHMuXG4gIHZhciByZXQgPSBBcnJheShsZW5ndGgpO1xuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbGVuZ3RoOyBpaSsrKSB7XG4gICAgcmV0W2lpXSA9IG9ialtpaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBQZXJmb3JtIGEgaGV1cmlzdGljIHRlc3QgdG8gZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBcImFycmF5LWxpa2VcIi5cbiAqXG4gKiAgIEEgbW9uayBhc2tlZCBKb3NodSwgYSBaZW4gbWFzdGVyLCBcIkhhcyBhIGRvZyBCdWRkaGEgbmF0dXJlP1wiXG4gKiAgIEpvc2h1IHJlcGxpZWQ6IFwiTXUuXCJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRldGVybWluZXMgaWYgaXRzIGFyZ3VtZW50IGhhcyBcImFycmF5IG5hdHVyZVwiOiBpdCByZXR1cm5zXG4gKiB0cnVlIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhY3R1YWwgYXJyYXksIGFuIGBhcmd1bWVudHMnIG9iamVjdCwgb3IgYW5cbiAqIEhUTUxDb2xsZWN0aW9uIChlLmcuIG5vZGUuY2hpbGROb2RlcyBvciBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCkpLlxuICpcbiAqIEl0IHdpbGwgcmV0dXJuIGZhbHNlIGZvciBvdGhlciBhcnJheS1saWtlIG9iamVjdHMgbGlrZSBGaWxlbGlzdC5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaGFzQXJyYXlOYXR1cmUob2JqKSB7XG4gIHJldHVybiAoXG4gICAgLy8gbm90IG51bGwvZmFsc2VcbiAgICAhIW9iaiAmJiAoXG4gICAgLy8gYXJyYXlzIGFyZSBvYmplY3RzLCBOb2RlTGlzdHMgYXJlIGZ1bmN0aW9ucyBpbiBTYWZhcmlcbiAgICB0eXBlb2Ygb2JqID09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT0gJ2Z1bmN0aW9uJykgJiZcbiAgICAvLyBxdWFja3MgbGlrZSBhbiBhcnJheVxuICAgICdsZW5ndGgnIGluIG9iaiAmJlxuICAgIC8vIG5vdCB3aW5kb3dcbiAgICAhKCdzZXRJbnRlcnZhbCcgaW4gb2JqKSAmJlxuICAgIC8vIG5vIERPTSBub2RlIHNob3VsZCBiZSBjb25zaWRlcmVkIGFuIGFycmF5LWxpa2VcbiAgICAvLyBhICdzZWxlY3QnIGVsZW1lbnQgaGFzICdsZW5ndGgnIGFuZCAnaXRlbScgcHJvcGVydGllcyBvbiBJRThcbiAgICB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9ICdudW1iZXInICYmIChcbiAgICAvLyBhIHJlYWwgYXJyYXlcbiAgICBBcnJheS5pc0FycmF5KG9iaikgfHxcbiAgICAvLyBhcmd1bWVudHNcbiAgICAnY2FsbGVlJyBpbiBvYmogfHxcbiAgICAvLyBIVE1MQ29sbGVjdGlvbi9Ob2RlTGlzdFxuICAgICdpdGVtJyBpbiBvYmopXG4gICk7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5IGJ5IHdyYXBwaW5nIGl0IGluIGFuIGFycmF5IGlmIGl0IGlzIG5vdC5cbiAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoZSBhcmd1bWVudCBpZiBpdCBpcyBhbHJlYWR5IGFuIGFycmF5LlxuICpcbiAqIFRoaXMgaXMgbW9zdGx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5OlxuICpcbiAqICAgdmFyIGNyZWF0ZUFycmF5RnJvbU1peGVkID0gcmVxdWlyZSgnY3JlYXRlQXJyYXlGcm9tTWl4ZWQnKTtcbiAqXG4gKiAgIGZ1bmN0aW9uIHRha2VzT25lT3JNb3JlVGhpbmdzKHRoaW5ncykge1xuICogICAgIHRoaW5ncyA9IGNyZWF0ZUFycmF5RnJvbU1peGVkKHRoaW5ncyk7XG4gKiAgICAgLi4uXG4gKiAgIH1cbiAqXG4gKiBUaGlzIGFsbG93cyB5b3UgdG8gdHJlYXQgYHRoaW5ncycgYXMgYW4gYXJyYXksIGJ1dCBhY2NlcHQgc2NhbGFycyBpbiB0aGUgQVBJLlxuICpcbiAqIElmIHlvdSBuZWVkIHRvIGNvbnZlcnQgYW4gYXJyYXktbGlrZSBvYmplY3QsIGxpa2UgYGFyZ3VtZW50c2AsIGludG8gYW4gYXJyYXlcbiAqIHVzZSB0b0FycmF5IGluc3RlYWQuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiBjcmVhdGVBcnJheUZyb21NaXhlZChvYmopIHtcbiAgaWYgKCFoYXNBcnJheU5hdHVyZShvYmopKSB7XG4gICAgcmV0dXJuIFtvYmpdO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmouc2xpY2UoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdG9BcnJheShvYmopO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQXJyYXlGcm9tTWl4ZWQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NyZWF0ZUFycmF5RnJvbU1peGVkLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgZmItd3d3L3Vuc2FmZS1odG1sICovXG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogRHVtbXkgY29udGFpbmVyIHVzZWQgdG8gZGV0ZWN0IHdoaWNoIHdyYXBzIGFyZSBuZWNlc3NhcnkuXG4gKi9cbnZhciBkdW1teU5vZGUgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSA6IG51bGw7XG5cbi8qKlxuICogU29tZSBicm93c2VycyBjYW5ub3QgdXNlIGBpbm5lckhUTUxgIHRvIHJlbmRlciBjZXJ0YWluIGVsZW1lbnRzIHN0YW5kYWxvbmUsXG4gKiBzbyB3ZSB3cmFwIHRoZW0sIHJlbmRlciB0aGUgd3JhcHBlZCBub2RlcywgdGhlbiBleHRyYWN0IHRoZSBkZXNpcmVkIG5vZGUuXG4gKlxuICogSW4gSUU4LCBjZXJ0YWluIGVsZW1lbnRzIGNhbm5vdCByZW5kZXIgYWxvbmUsIHNvIHdyYXAgYWxsIGVsZW1lbnRzICgnKicpLlxuICovXG5cbnZhciBzaG91bGRXcmFwID0ge307XG5cbnZhciBzZWxlY3RXcmFwID0gWzEsICc8c2VsZWN0IG11bHRpcGxlPVwidHJ1ZVwiPicsICc8L3NlbGVjdD4nXTtcbnZhciB0YWJsZVdyYXAgPSBbMSwgJzx0YWJsZT4nLCAnPC90YWJsZT4nXTtcbnZhciB0cldyYXAgPSBbMywgJzx0YWJsZT48dGJvZHk+PHRyPicsICc8L3RyPjwvdGJvZHk+PC90YWJsZT4nXTtcblxudmFyIHN2Z1dyYXAgPSBbMSwgJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPicsICc8L3N2Zz4nXTtcblxudmFyIG1hcmt1cFdyYXAgPSB7XG4gICcqJzogWzEsICc/PGRpdj4nLCAnPC9kaXY+J10sXG5cbiAgJ2FyZWEnOiBbMSwgJzxtYXA+JywgJzwvbWFwPiddLFxuICAnY29sJzogWzIsICc8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPicsICc8L2NvbGdyb3VwPjwvdGFibGU+J10sXG4gICdsZWdlbmQnOiBbMSwgJzxmaWVsZHNldD4nLCAnPC9maWVsZHNldD4nXSxcbiAgJ3BhcmFtJzogWzEsICc8b2JqZWN0PicsICc8L29iamVjdD4nXSxcbiAgJ3RyJzogWzIsICc8dGFibGU+PHRib2R5PicsICc8L3Rib2R5PjwvdGFibGU+J10sXG5cbiAgJ29wdGdyb3VwJzogc2VsZWN0V3JhcCxcbiAgJ29wdGlvbic6IHNlbGVjdFdyYXAsXG5cbiAgJ2NhcHRpb24nOiB0YWJsZVdyYXAsXG4gICdjb2xncm91cCc6IHRhYmxlV3JhcCxcbiAgJ3Rib2R5JzogdGFibGVXcmFwLFxuICAndGZvb3QnOiB0YWJsZVdyYXAsXG4gICd0aGVhZCc6IHRhYmxlV3JhcCxcblxuICAndGQnOiB0cldyYXAsXG4gICd0aCc6IHRyV3JhcFxufTtcblxuLy8gSW5pdGlhbGl6ZSB0aGUgU1ZHIGVsZW1lbnRzIHNpbmNlIHdlIGtub3cgdGhleSdsbCBhbHdheXMgbmVlZCB0byBiZSB3cmFwcGVkXG4vLyBjb25zaXN0ZW50bHkuIElmIHRoZXkgYXJlIGNyZWF0ZWQgaW5zaWRlIGEgPGRpdj4gdGhleSB3aWxsIGJlIGluaXRpYWxpemVkIGluXG4vLyB0aGUgd3JvbmcgbmFtZXNwYWNlIChhbmQgd2lsbCBub3QgZGlzcGxheSkuXG52YXIgc3ZnRWxlbWVudHMgPSBbJ2NpcmNsZScsICdjbGlwUGF0aCcsICdkZWZzJywgJ2VsbGlwc2UnLCAnZycsICdpbWFnZScsICdsaW5lJywgJ2xpbmVhckdyYWRpZW50JywgJ21hc2snLCAncGF0aCcsICdwYXR0ZXJuJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncmFkaWFsR3JhZGllbnQnLCAncmVjdCcsICdzdG9wJywgJ3RleHQnLCAndHNwYW4nXTtcbnN2Z0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG5vZGVOYW1lKSB7XG4gIG1hcmt1cFdyYXBbbm9kZU5hbWVdID0gc3ZnV3JhcDtcbiAgc2hvdWxkV3JhcFtub2RlTmFtZV0gPSB0cnVlO1xufSk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFya3VwIHdyYXAgY29uZmlndXJhdGlvbiBmb3IgdGhlIHN1cHBsaWVkIGBub2RlTmFtZWAuXG4gKlxuICogTk9URTogVGhpcyBsYXppbHkgZGV0ZWN0cyB3aGljaCB3cmFwcyBhcmUgbmVjZXNzYXJ5IGZvciB0aGUgY3VycmVudCBicm93c2VyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBub2RlTmFtZSBMb3dlcmNhc2UgYG5vZGVOYW1lYC5cbiAqIEByZXR1cm4gez9hcnJheX0gTWFya3VwIHdyYXAgY29uZmlndXJhdGlvbiwgaWYgYXBwbGljYWJsZS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFya3VwV3JhcChub2RlTmFtZSkge1xuICAhISFkdW1teU5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTWFya3VwIHdyYXBwaW5nIG5vZGUgbm90IGluaXRpYWxpemVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBpZiAoIW1hcmt1cFdyYXAuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgbm9kZU5hbWUgPSAnKic7XG4gIH1cbiAgaWYgKCFzaG91bGRXcmFwLmhhc093blByb3BlcnR5KG5vZGVOYW1lKSkge1xuICAgIGlmIChub2RlTmFtZSA9PT0gJyonKSB7XG4gICAgICBkdW1teU5vZGUuaW5uZXJIVE1MID0gJzxsaW5rIC8+JztcbiAgICB9IGVsc2Uge1xuICAgICAgZHVtbXlOb2RlLmlubmVySFRNTCA9ICc8JyArIG5vZGVOYW1lICsgJz48LycgKyBub2RlTmFtZSArICc+JztcbiAgICB9XG4gICAgc2hvdWxkV3JhcFtub2RlTmFtZV0gPSAhZHVtbXlOb2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIHNob3VsZFdyYXBbbm9kZU5hbWVdID8gbWFya3VwV3JhcFtub2RlTmFtZV0gOiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcmt1cFdyYXA7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldE1hcmt1cFdyYXAuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01DaGlsZHJlbk9wZXJhdGlvbnMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgdXNlZCB0byBwcm9jZXNzIHVwZGF0ZXMgdG8gRE9NIG5vZGVzLlxuICovXG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgY29tcG9uZW50J3MgY2hpbGRyZW4gYnkgcHJvY2Vzc2luZyBhIHNlcmllcyBvZiB1cGRhdGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PG9iamVjdD59IHVwZGF0ZXMgTGlzdCBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiBmdW5jdGlvbiAocGFyZW50SW5zdCwgdXBkYXRlcykge1xuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UocGFyZW50SW5zdCk7XG4gICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLnByb2Nlc3NVcGRhdGVzKG5vZGUsIHVwZGF0ZXMpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSURPcGVyYXRpb25zO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NSURPcGVyYXRpb25zLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbi8qIGdsb2JhbCBoYXNPd25Qcm9wZXJ0eTp0cnVlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgQXV0b0ZvY3VzVXRpbHMgPSByZXF1aXJlKCcuL0F1dG9Gb2N1c1V0aWxzJyk7XG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBET01OYW1lc3BhY2VzID0gcmVxdWlyZSgnLi9ET01OYW1lc3BhY2VzJyk7XG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudEZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudEZsYWdzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdERPTUlucHV0ID0gcmVxdWlyZSgnLi9SZWFjdERPTUlucHV0Jyk7XG52YXIgUmVhY3RET01PcHRpb24gPSByZXF1aXJlKCcuL1JlYWN0RE9NT3B0aW9uJyk7XG52YXIgUmVhY3RET01TZWxlY3QgPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0Jyk7XG52YXIgUmVhY3RET01UZXh0YXJlYSA9IHJlcXVpcmUoJy4vUmVhY3RET01UZXh0YXJlYScpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0TXVsdGlDaGlsZCA9IHJlcXVpcmUoJy4vUmVhY3RNdWx0aUNoaWxkJyk7XG52YXIgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbicpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdmYmpzL2xpYi9zaGFsbG93RXF1YWwnKTtcbnZhciBpbnB1dFZhbHVlVHJhY2tpbmcgPSByZXF1aXJlKCcuL2lucHV0VmFsdWVUcmFja2luZycpO1xudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IHJlcXVpcmUoJy4vdmFsaWRhdGVET01OZXN0aW5nJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIEZsYWdzID0gUmVhY3RET01Db21wb25lbnRGbGFncztcbnZhciBkZWxldGVMaXN0ZW5lciA9IEV2ZW50UGx1Z2luSHViLmRlbGV0ZUxpc3RlbmVyO1xudmFyIGdldE5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZTtcbnZhciBsaXN0ZW5UbyA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5saXN0ZW5UbztcbnZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM7XG5cbi8vIEZvciBxdWlja2x5IG1hdGNoaW5nIGNoaWxkcmVuIHR5cGUsIHRvIHRlc3QgaWYgY2FuIGJlIHRyZWF0ZWQgYXMgY29udGVudC5cbnZhciBDT05URU5UX1RZUEVTID0geyBzdHJpbmc6IHRydWUsIG51bWJlcjogdHJ1ZSB9O1xuXG52YXIgU1RZTEUgPSAnc3R5bGUnO1xudmFyIEhUTUwgPSAnX19odG1sJztcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiBudWxsLFxuICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IG51bGxcbn07XG5cbi8vIE5vZGUgdHlwZSBmb3IgZG9jdW1lbnQgZnJhZ21lbnRzIChOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpLlxudmFyIERPQ19GUkFHTUVOVF9UWVBFID0gMTE7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShpbnRlcm5hbEluc3RhbmNlKSB7XG4gIGlmIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgdmFyIG93bmVyID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyIHx8IG51bGw7XG4gICAgaWYgKG93bmVyKSB7XG4gICAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnIFRoaXMgRE9NIG5vZGUgd2FzIHJlbmRlcmVkIGJ5IGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZnJpZW5kbHlTdHJpbmdpZnkob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIHJldHVybiAnWycgKyBvYmoubWFwKGZyaWVuZGx5U3RyaW5naWZ5KS5qb2luKCcsICcpICsgJ10nO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFpcnMgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICB2YXIga2V5RXNjYXBlZCA9IC9eW2EteiRfXVtcXHckX10qJC9pLnRlc3Qoa2V5KSA/IGtleSA6IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgICAgICAgcGFpcnMucHVzaChrZXlFc2NhcGVkICsgJzogJyArIGZyaWVuZGx5U3RyaW5naWZ5KG9ialtrZXldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAneycgKyBwYWlycy5qb2luKCcsICcpICsgJ30nO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gJ1tmdW5jdGlvbiBvYmplY3RdJztcbiAgfVxuICAvLyBEaWZmZXJzIGZyb20gSlNPTi5zdHJpbmdpZnkgaW4gdGhhdCB1bmRlZmluZWQgYmVjYXVzZSB1bmRlZmluZWQgYW5kIHRoYXRcbiAgLy8gaW5mIGFuZCBuYW4gZG9uJ3QgYmVjb21lIG51bGxcbiAgcmV0dXJuIFN0cmluZyhvYmopO1xufVxuXG52YXIgc3R5bGVNdXRhdGlvbldhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlKHN0eWxlMSwgc3R5bGUyLCBjb21wb25lbnQpIHtcbiAgaWYgKHN0eWxlMSA9PSBudWxsIHx8IHN0eWxlMiA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzaGFsbG93RXF1YWwoc3R5bGUxLCBzdHlsZTIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuX3RhZztcbiAgdmFyIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gIHZhciBvd25lck5hbWU7XG4gIGlmIChvd25lcikge1xuICAgIG93bmVyTmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgfVxuXG4gIHZhciBoYXNoID0gb3duZXJOYW1lICsgJ3wnICsgY29tcG9uZW50TmFtZTtcblxuICBpZiAoc3R5bGVNdXRhdGlvbldhcm5pbmcuaGFzT3duUHJvcGVydHkoaGFzaCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdHlsZU11dGF0aW9uV2FybmluZ1toYXNoXSA9IHRydWU7XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgJXNgIHdhcyBwYXNzZWQgYSBzdHlsZSBvYmplY3QgdGhhdCBoYXMgcHJldmlvdXNseSBiZWVuIG11dGF0ZWQuICcgKyAnTXV0YXRpbmcgYHN0eWxlYCBpcyBkZXByZWNhdGVkLiBDb25zaWRlciBjbG9uaW5nIGl0IGJlZm9yZWhhbmQuIENoZWNrICcgKyAndGhlIGByZW5kZXJgICVzLiBQcmV2aW91cyBzdHlsZTogJXMuIE11dGF0ZWQgc3R5bGU6ICVzLicsIGNvbXBvbmVudE5hbWUsIG93bmVyID8gJ29mIGAnICsgb3duZXJOYW1lICsgJ2AnIDogJ3VzaW5nIDwnICsgY29tcG9uZW50TmFtZSArICc+JywgZnJpZW5kbHlTdHJpbmdpZnkoc3R5bGUxKSwgZnJpZW5kbHlTdHJpbmdpZnkoc3R5bGUyKSkgOiB2b2lkIDA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBwcm9wc1xuICovXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFByb3BzKGNvbXBvbmVudCwgcHJvcHMpIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICBpZiAodm9pZEVsZW1lbnRUYWdzW2NvbXBvbmVudC5fdGFnXSkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcyBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLiVzJywgY29tcG9uZW50Ll90YWcsIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyID8gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAnICsgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpICsgJy4nIDogJycpIDogX3Byb2RJbnZhcmlhbnQoJzEzNycsIGNvbXBvbmVudC5fdGFnLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lciA/ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJyArIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyLmdldE5hbWUoKSArICcuJyA6ICcnKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJykgOiBfcHJvZEludmFyaWFudCgnNjAnKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgSFRNTCBpbiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtaW52YXJpYW50LWRhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogX3Byb2RJbnZhcmlhbnQoJzYxJykgOiB2b2lkIDA7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5pbm5lckhUTUwgPT0gbnVsbCwgJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgfHwgIXByb3BzLmNvbnRlbnRFZGl0YWJsZSB8fCBwcm9wcy5jaGlsZHJlbiA9PSBudWxsLCAnQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLicpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLm9uRm9jdXNJbiA9PSBudWxsICYmIHByb3BzLm9uRm9jdXNPdXQgPT0gbnVsbCwgJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJykgOiB2b2lkIDA7XG4gIH1cbiAgIShwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgbm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArIFxcJ2VtXFwnfX0gd2hlbiB1c2luZyBKU1guJXMnLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSkgOiBfcHJvZEludmFyaWFudCgnNjInLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSkgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGVucXVldWVQdXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lciwgdHJhbnNhY3Rpb24pIHtcbiAgaWYgKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIElFOCBoYXMgbm8gQVBJIGZvciBldmVudCBjYXB0dXJpbmcgYW5kIHRoZSBgb25TY3JvbGxgIGV2ZW50IGRvZXNuJ3RcbiAgICAvLyBidWJibGUuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocmVnaXN0cmF0aW9uTmFtZSAhPT0gJ29uU2Nyb2xsJyB8fCBpc0V2ZW50U3VwcG9ydGVkKCdzY3JvbGwnLCB0cnVlKSwgXCJUaGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSBgb25TY3JvbGxgIGV2ZW50XCIpIDogdm9pZCAwO1xuICB9XG4gIHZhciBjb250YWluZXJJbmZvID0gaW5zdC5faG9zdENvbnRhaW5lckluZm87XG4gIHZhciBpc0RvY3VtZW50RnJhZ21lbnQgPSBjb250YWluZXJJbmZvLl9ub2RlICYmIGNvbnRhaW5lckluZm8uX25vZGUubm9kZVR5cGUgPT09IERPQ19GUkFHTUVOVF9UWVBFO1xuICB2YXIgZG9jID0gaXNEb2N1bWVudEZyYWdtZW50ID8gY29udGFpbmVySW5mby5fbm9kZSA6IGNvbnRhaW5lckluZm8uX293bmVyRG9jdW1lbnQ7XG4gIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGRvYyk7XG4gIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUocHV0TGlzdGVuZXIsIHtcbiAgICBpbnN0OiBpbnN0LFxuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IHJlZ2lzdHJhdGlvbk5hbWUsXG4gICAgbGlzdGVuZXI6IGxpc3RlbmVyXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwdXRMaXN0ZW5lcigpIHtcbiAgdmFyIGxpc3RlbmVyVG9QdXQgPSB0aGlzO1xuICBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcihsaXN0ZW5lclRvUHV0Lmluc3QsIGxpc3RlbmVyVG9QdXQucmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXJUb1B1dC5saXN0ZW5lcik7XG59XG5cbmZ1bmN0aW9uIGlucHV0UG9zdE1vdW50KCkge1xuICB2YXIgaW5zdCA9IHRoaXM7XG4gIFJlYWN0RE9NSW5wdXQucG9zdE1vdW50V3JhcHBlcihpbnN0KTtcbn1cblxuZnVuY3Rpb24gdGV4dGFyZWFQb3N0TW91bnQoKSB7XG4gIHZhciBpbnN0ID0gdGhpcztcbiAgUmVhY3RET01UZXh0YXJlYS5wb3N0TW91bnRXcmFwcGVyKGluc3QpO1xufVxuXG5mdW5jdGlvbiBvcHRpb25Qb3N0TW91bnQoKSB7XG4gIHZhciBpbnN0ID0gdGhpcztcbiAgUmVhY3RET01PcHRpb24ucG9zdE1vdW50V3JhcHBlcihpbnN0KTtcbn1cblxudmFyIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2ID0gZW1wdHlGdW5jdGlvbjtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2ID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICB2YXIgaGFzRXhpc3RpbmdDb250ZW50ID0gdGhpcy5fY29udGVudERlYnVnSUQgIT0gbnVsbDtcbiAgICB2YXIgZGVidWdJRCA9IHRoaXMuX2RlYnVnSUQ7XG4gICAgLy8gVGhpcyBJRCByZXByZXNlbnRzIHRoZSBpbmxpbmVkIGNoaWxkIHRoYXQgaGFzIG5vIGJhY2tpbmcgaW5zdGFuY2U6XG4gICAgdmFyIGNvbnRlbnREZWJ1Z0lEID0gLWRlYnVnSUQ7XG5cbiAgICBpZiAoY29udGVudCA9PSBudWxsKSB7XG4gICAgICBpZiAoaGFzRXhpc3RpbmdDb250ZW50KSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVubW91bnRDb21wb25lbnQodGhpcy5fY29udGVudERlYnVnSUQpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29udGVudERlYnVnSUQgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhbGlkYXRlRE9NTmVzdGluZyhudWxsLCBTdHJpbmcoY29udGVudCksIHRoaXMsIHRoaXMuX2FuY2VzdG9ySW5mbyk7XG4gICAgdGhpcy5fY29udGVudERlYnVnSUQgPSBjb250ZW50RGVidWdJRDtcbiAgICBpZiAoaGFzRXhpc3RpbmdDb250ZW50KSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVcGRhdGVDb21wb25lbnQoY29udGVudERlYnVnSUQsIGNvbnRlbnQpO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVXBkYXRlQ29tcG9uZW50KGNvbnRlbnREZWJ1Z0lEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlTW91bnRDb21wb25lbnQoY29udGVudERlYnVnSUQsIGNvbnRlbnQsIGRlYnVnSUQpO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uTW91bnRDb21wb25lbnQoY29udGVudERlYnVnSUQpO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4oZGVidWdJRCwgW2NvbnRlbnREZWJ1Z0lEXSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBUaGVyZSBhcmUgc28gbWFueSBtZWRpYSBldmVudHMsIGl0IG1ha2VzIHNlbnNlIHRvIGp1c3Rcbi8vIG1haW50YWluIGEgbGlzdCByYXRoZXIgdGhhbiBjcmVhdGUgYSBgdHJhcEJ1YmJsZWRFdmVudGAgZm9yIGVhY2hcbnZhciBtZWRpYUV2ZW50cyA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiAnZHVyYXRpb25jaGFuZ2UnLFxuICB0b3BFbXB0aWVkOiAnZW1wdGllZCcsXG4gIHRvcEVuY3J5cHRlZDogJ2VuY3J5cHRlZCcsXG4gIHRvcEVuZGVkOiAnZW5kZWQnLFxuICB0b3BFcnJvcjogJ2Vycm9yJyxcbiAgdG9wTG9hZGVkRGF0YTogJ2xvYWRlZGRhdGEnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wUGF1c2U6ICdwYXVzZScsXG4gIHRvcFBsYXk6ICdwbGF5JyxcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJ1xufTtcblxuZnVuY3Rpb24gdHJhY2tJbnB1dFZhbHVlKCkge1xuICBpbnB1dFZhbHVlVHJhY2tpbmcudHJhY2sodGhpcyk7XG59XG5cbmZ1bmN0aW9uIHRyYXBCdWJibGVkRXZlbnRzTG9jYWwoKSB7XG4gIHZhciBpbnN0ID0gdGhpcztcbiAgLy8gSWYgYSBjb21wb25lbnQgcmVuZGVycyB0byBudWxsIG9yIGlmIGFub3RoZXIgY29tcG9uZW50IGZhdGFscyBhbmQgY2F1c2VzXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgdHJlZSB0byBiZSBjb3JydXB0ZWQsIGBub2RlYCBoZXJlIGNhbiBiZSBudWxsLlxuICAhaW5zdC5fcm9vdE5vZGVJRCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNdXN0IGJlIG1vdW50ZWQgdG8gdHJhcCBldmVudHMnKSA6IF9wcm9kSW52YXJpYW50KCc2MycpIDogdm9pZCAwO1xuICB2YXIgbm9kZSA9IGdldE5vZGUoaW5zdCk7XG4gICFub2RlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RyYXBCdWJibGVkRXZlbnQoLi4uKTogUmVxdWlyZXMgbm9kZSB0byBiZSByZW5kZXJlZC4nKSA6IF9wcm9kSW52YXJpYW50KCc2NCcpIDogdm9pZCAwO1xuXG4gIHN3aXRjaCAoaW5zdC5fdGFnKSB7XG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndmlkZW8nOlxuICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbXTtcbiAgICAgIC8vIENyZWF0ZSBsaXN0ZW5lciBmb3IgZWFjaCBtZWRpYSBldmVudFxuICAgICAgZm9yICh2YXIgZXZlbnQgaW4gbWVkaWFFdmVudHMpIHtcbiAgICAgICAgaWYgKG1lZGlhRXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xuICAgICAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMucHVzaChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChldmVudCwgbWVkaWFFdmVudHNbZXZlbnRdLCBub2RlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIG5vZGUpLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KCd0b3BSZXNldCcsICdyZXNldCcsIG5vZGUpLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wU3VibWl0JywgJ3N1Ym1pdCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyKCkge1xuICBSZWFjdERPTVNlbGVjdC5wb3N0VXBkYXRlV3JhcHBlcih0aGlzKTtcbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cblxudmFyIG9taXR0ZWRDbG9zZVRhZ3MgPSB7XG4gIGFyZWE6IHRydWUsXG4gIGJhc2U6IHRydWUsXG4gIGJyOiB0cnVlLFxuICBjb2w6IHRydWUsXG4gIGVtYmVkOiB0cnVlLFxuICBocjogdHJ1ZSxcbiAgaW1nOiB0cnVlLFxuICBpbnB1dDogdHJ1ZSxcbiAga2V5Z2VuOiB0cnVlLFxuICBsaW5rOiB0cnVlLFxuICBtZXRhOiB0cnVlLFxuICBwYXJhbTogdHJ1ZSxcbiAgc291cmNlOiB0cnVlLFxuICB0cmFjazogdHJ1ZSxcbiAgd2JyOiB0cnVlXG4gIC8vIE5PVEU6IG1lbnVpdGVtJ3MgY2xvc2UgdGFnIHNob3VsZCBiZSBvbWl0dGVkLCBidXQgdGhhdCBjYXVzZXMgcHJvYmxlbXMuXG59O1xuXG52YXIgbmV3bGluZUVhdGluZ1RhZ3MgPSB7XG4gIGxpc3Rpbmc6IHRydWUsXG4gIHByZTogdHJ1ZSxcbiAgdGV4dGFyZWE6IHRydWVcbn07XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3MgY2Fubm90IGhhdmUgY2hpbGRyZW4uIFRoaXMgaGFzIHRoZSBzYW1lIHB1cnBvc2UgYXNcbi8vIGBvbWl0dGVkQ2xvc2VUYWdzYCBleGNlcHQgdGhhdCBgbWVudWl0ZW1gIHNob3VsZCBzdGlsbCBoYXZlIGl0cyBjbG9zaW5nIHRhZy5cblxudmFyIHZvaWRFbGVtZW50VGFncyA9IF9hc3NpZ24oe1xuICBtZW51aXRlbTogdHJ1ZVxufSwgb21pdHRlZENsb3NlVGFncyk7XG5cbi8vIFdlIGFjY2VwdCBhbnkgdGFnIHRvIGJlIHJlbmRlcmVkIGJ1dCBzaW5jZSB0aGlzIGdldHMgaW5qZWN0ZWQgaW50byBhcmJpdHJhcnlcbi8vIEhUTUwsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgaXQncyBhIHNhZmUgdGFnLlxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVxuXG52YXIgVkFMSURfVEFHX1JFR0VYID0gL15bYS16QS1aXVthLXpBLVo6X1xcLlxcLVxcZF0qJC87IC8vIFNpbXBsaWZpZWQgc3Vic2V0XG52YXIgdmFsaWRhdGVkVGFnQ2FjaGUgPSB7fTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpIHtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZFRhZ0NhY2hlLCB0YWcpKSB7XG4gICAgIVZBTElEX1RBR19SRUdFWC50ZXN0KHRhZykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCB0YWc6ICVzJywgdGFnKSA6IF9wcm9kSW52YXJpYW50KCc2NScsIHRhZykgOiB2b2lkIDA7XG4gICAgdmFsaWRhdGVkVGFnQ2FjaGVbdGFnXSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDdXN0b21Db21wb25lbnQodGFnTmFtZSwgcHJvcHMpIHtcbiAgcmV0dXJuIHRhZ05hbWUuaW5kZXhPZignLScpID49IDAgfHwgcHJvcHMuaXMgIT0gbnVsbDtcbn1cblxudmFyIGdsb2JhbElkQ291bnRlciA9IDE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBSZWFjdCBjbGFzcyB0aGF0IGlzIGlkZW1wb3RlbnQgYW5kIGNhcGFibGUgb2YgY29udGFpbmluZyBvdGhlclxuICogUmVhY3QgY29tcG9uZW50cy4gSXQgYWNjZXB0cyBldmVudCBsaXN0ZW5lcnMgYW5kIERPTSBwcm9wZXJ0aWVzIHRoYXQgYXJlXG4gKiB2YWxpZCBhY2NvcmRpbmcgdG8gYERPTVByb3BlcnR5YC5cbiAqXG4gKiAgLSBFdmVudCBsaXN0ZW5lcnM6IGBvbkNsaWNrYCwgYG9uTW91c2VEb3duYCwgZXRjLlxuICogIC0gRE9NIHByb3BlcnRpZXM6IGBjbGFzc05hbWVgLCBgbmFtZWAsIGB0aXRsZWAsIGV0Yy5cbiAqXG4gKiBUaGUgYHN0eWxlYCBwcm9wZXJ0eSBmdW5jdGlvbnMgZGlmZmVyZW50bHkgZnJvbSB0aGUgRE9NIEFQSS4gSXQgYWNjZXB0cyBhblxuICogb2JqZWN0IG1hcHBpbmcgb2Ygc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yIFJlYWN0RE9NQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBSZWFjdE11bHRpQ2hpbGRcbiAqL1xuZnVuY3Rpb24gUmVhY3RET01Db21wb25lbnQoZWxlbWVudCkge1xuICB2YXIgdGFnID0gZWxlbWVudC50eXBlO1xuICB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpO1xuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IGVsZW1lbnQ7XG4gIHRoaXMuX3RhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICB0aGlzLl9uYW1lc3BhY2VVUkkgPSBudWxsO1xuICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbnVsbDtcbiAgdGhpcy5fcHJldmlvdXNTdHlsZSA9IG51bGw7XG4gIHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gbnVsbDtcbiAgdGhpcy5faG9zdE5vZGUgPSBudWxsO1xuICB0aGlzLl9ob3N0UGFyZW50ID0gbnVsbDtcbiAgdGhpcy5fcm9vdE5vZGVJRCA9IDA7XG4gIHRoaXMuX2RvbUlEID0gMDtcbiAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBudWxsO1xuICB0aGlzLl93cmFwcGVyU3RhdGUgPSBudWxsO1xuICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xuICB0aGlzLl9mbGFncyA9IDA7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdGhpcy5fYW5jZXN0b3JJbmZvID0gbnVsbDtcbiAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIG51bGwpO1xuICB9XG59XG5cblJlYWN0RE9NQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ1JlYWN0RE9NQ29tcG9uZW50JztcblxuUmVhY3RET01Db21wb25lbnQuTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgcm9vdCB0YWcgbWFya3VwIHRoZW4gcmVjdXJzZXMuIFRoaXMgbWV0aG9kIGhhcyBzaWRlIGVmZmVjdHMgYW5kXG4gICAqIGlzIG5vdCBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P1JlYWN0RE9NQ29tcG9uZW50fSB0aGUgcGFyZW50IGNvbXBvbmVudCBpbnN0YW5jZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IGluZm8gYWJvdXQgdGhlIGhvc3QgY29udGFpbmVyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNvbXB1dGVkIG1hcmt1cC5cbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IGdsb2JhbElkQ291bnRlcisrO1xuICAgIHRoaXMuX2RvbUlEID0gaG9zdENvbnRhaW5lckluZm8uX2lkQ291bnRlcisrO1xuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gaG9zdENvbnRhaW5lckluZm87XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdhdWRpbyc6XG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBjYXNlICdpbWcnOlxuICAgICAgY2FzZSAnbGluayc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgICAgdGhpcy5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgICAgIGxpc3RlbmVyczogbnVsbFxuICAgICAgICB9O1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgUmVhY3RET01JbnB1dC5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGhvc3RQYXJlbnQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NSW5wdXQuZ2V0SG9zdFByb3BzKHRoaXMsIHByb3BzKTtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0cmFja0lucHV0VmFsdWUsIHRoaXMpO1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIFJlYWN0RE9NT3B0aW9uLm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01PcHRpb24uZ2V0SG9zdFByb3BzKHRoaXMsIHByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBSZWFjdERPTVNlbGVjdC5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGhvc3RQYXJlbnQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldEhvc3RQcm9wcyh0aGlzLCBwcm9wcyk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBSZWFjdERPTVRleHRhcmVhLm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01UZXh0YXJlYS5nZXRIb3N0UHJvcHModGhpcywgcHJvcHMpO1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYWNrSW5wdXRWYWx1ZSwgdGhpcyk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGFzc2VydFZhbGlkUHJvcHModGhpcywgcHJvcHMpO1xuXG4gICAgLy8gV2UgY3JlYXRlIHRhZ3MgaW4gdGhlIG5hbWVzcGFjZSBvZiB0aGVpciBwYXJlbnQgY29udGFpbmVyLCBleGNlcHQgSFRNTFxuICAgIC8vIHRhZ3MgZ2V0IG5vIG5hbWVzcGFjZS5cbiAgICB2YXIgbmFtZXNwYWNlVVJJO1xuICAgIHZhciBwYXJlbnRUYWc7XG4gICAgaWYgKGhvc3RQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgbmFtZXNwYWNlVVJJID0gaG9zdFBhcmVudC5fbmFtZXNwYWNlVVJJO1xuICAgICAgcGFyZW50VGFnID0gaG9zdFBhcmVudC5fdGFnO1xuICAgIH0gZWxzZSBpZiAoaG9zdENvbnRhaW5lckluZm8uX3RhZykge1xuICAgICAgbmFtZXNwYWNlVVJJID0gaG9zdENvbnRhaW5lckluZm8uX25hbWVzcGFjZVVSSTtcbiAgICAgIHBhcmVudFRhZyA9IGhvc3RDb250YWluZXJJbmZvLl90YWc7XG4gICAgfVxuICAgIGlmIChuYW1lc3BhY2VVUkkgPT0gbnVsbCB8fCBuYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuc3ZnICYmIHBhcmVudFRhZyA9PT0gJ2ZvcmVpZ25vYmplY3QnKSB7XG4gICAgICBuYW1lc3BhY2VVUkkgPSBET01OYW1lc3BhY2VzLmh0bWw7XG4gICAgfVxuICAgIGlmIChuYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuaHRtbCkge1xuICAgICAgaWYgKHRoaXMuX3RhZyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgbmFtZXNwYWNlVVJJID0gRE9NTmFtZXNwYWNlcy5zdmc7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3RhZyA9PT0gJ21hdGgnKSB7XG4gICAgICAgIG5hbWVzcGFjZVVSSSA9IERPTU5hbWVzcGFjZXMubWF0aG1sO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9uYW1lc3BhY2VVUkkgPSBuYW1lc3BhY2VVUkk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHBhcmVudEluZm87XG4gICAgICBpZiAoaG9zdFBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudEluZm8gPSBob3N0UGFyZW50Ll9hbmNlc3RvckluZm87XG4gICAgICB9IGVsc2UgaWYgKGhvc3RDb250YWluZXJJbmZvLl90YWcpIHtcbiAgICAgICAgcGFyZW50SW5mbyA9IGhvc3RDb250YWluZXJJbmZvLl9hbmNlc3RvckluZm87XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50SW5mbykge1xuICAgICAgICAvLyBwYXJlbnRJbmZvIHNob3VsZCBhbHdheXMgYmUgcHJlc2VudCBleGNlcHQgZm9yIHRoZSB0b3AtbGV2ZWxcbiAgICAgICAgLy8gY29tcG9uZW50IHdoZW4gc2VydmVyIHJlbmRlcmluZ1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmcodGhpcy5fdGFnLCBudWxsLCB0aGlzLCBwYXJlbnRJbmZvKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FuY2VzdG9ySW5mbyA9IHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvKHBhcmVudEluZm8sIHRoaXMuX3RhZywgdGhpcyk7XG4gICAgfVxuXG4gICAgdmFyIG1vdW50SW1hZ2U7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lckRvY3VtZW50ID0gaG9zdENvbnRhaW5lckluZm8uX293bmVyRG9jdW1lbnQ7XG4gICAgICB2YXIgZWw7XG4gICAgICBpZiAobmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLmh0bWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RhZyA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgICAgICAvLyBDcmVhdGUgdGhlIHNjcmlwdCB2aWEgLmlubmVySFRNTCBzbyBpdHMgXCJwYXJzZXItaW5zZXJ0ZWRcIiBmbGFnIGlzXG4gICAgICAgICAgLy8gc2V0IHRvIHRydWUgYW5kIGl0IGRvZXMgbm90IGV4ZWN1dGVcbiAgICAgICAgICB2YXIgZGl2ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgICAgICAgZGl2LmlubmVySFRNTCA9ICc8JyArIHR5cGUgKyAnPjwvJyArIHR5cGUgKyAnPic7XG4gICAgICAgICAgZWwgPSBkaXYucmVtb3ZlQ2hpbGQoZGl2LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BzLmlzKSB7XG4gICAgICAgICAgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSwgcHJvcHMuaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNlcGFyYXRlIGVsc2UgYnJhbmNoIGluc3RlYWQgb2YgdXNpbmcgYHByb3BzLmlzIHx8IHVuZGVmaW5lZGAgYWJvdmUgYmVjdWFzZSBvZiBhIEZpcmVmb3ggYnVnLlxuICAgICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzY4OTZcbiAgICAgICAgICAvLyBhbmQgZGlzY3Vzc2lvbiBpbiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjc2MjQwXG4gICAgICAgICAgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlKTtcbiAgICAgIH1cbiAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUodGhpcywgZWwpO1xuICAgICAgdGhpcy5fZmxhZ3MgfD0gRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2RlcztcbiAgICAgIGlmICghdGhpcy5faG9zdFBhcmVudCkge1xuICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0QXR0cmlidXRlRm9yUm9vdChlbCk7XG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGVET01Qcm9wZXJ0aWVzKG51bGwsIHByb3BzLCB0cmFuc2FjdGlvbik7XG4gICAgICB2YXIgbGF6eVRyZWUgPSBET01MYXp5VHJlZShlbCk7XG4gICAgICB0aGlzLl9jcmVhdGVJbml0aWFsQ2hpbGRyZW4odHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0LCBsYXp5VHJlZSk7XG4gICAgICBtb3VudEltYWdlID0gbGF6eVRyZWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0YWdPcGVuID0gdGhpcy5fY3JlYXRlT3BlblRhZ01hcmt1cEFuZFB1dExpc3RlbmVycyh0cmFuc2FjdGlvbiwgcHJvcHMpO1xuICAgICAgdmFyIHRhZ0NvbnRlbnQgPSB0aGlzLl9jcmVhdGVDb250ZW50TWFya3VwKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCk7XG4gICAgICBpZiAoIXRhZ0NvbnRlbnQgJiYgb21pdHRlZENsb3NlVGFnc1t0aGlzLl90YWddKSB7XG4gICAgICAgIG1vdW50SW1hZ2UgPSB0YWdPcGVuICsgJy8+JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vdW50SW1hZ2UgPSB0YWdPcGVuICsgJz4nICsgdGFnQ29udGVudCArICc8LycgKyB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlICsgJz4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW5wdXRQb3N0TW91bnQsIHRoaXMpO1xuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodGV4dGFyZWFQb3N0TW91bnQsIHRoaXMpO1xuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKG9wdGlvblBvc3RNb3VudCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBtb3VudEltYWdlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIG9wZW4gdGFnIGFuZCBhbGwgYXR0cmlidXRlcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaGFzIHNpZGUgZWZmZWN0cyBiZWNhdXNlIGV2ZW50cyBnZXQgcmVnaXN0ZXJlZC5cbiAgICpcbiAgICogSXRlcmF0aW5nIG92ZXIgb2JqZWN0IHByb3BlcnRpZXMgaXMgZmFzdGVyIHRoYW4gaXRlcmF0aW5nIG92ZXIgYXJyYXlzLlxuICAgKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL29iai12cy1hcnItaXRlcmF0aW9uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgb2Ygb3BlbmluZyB0YWcuXG4gICAqL1xuICBfY3JlYXRlT3BlblRhZ01hcmt1cEFuZFB1dExpc3RlbmVyczogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcm9wcykge1xuICAgIHZhciByZXQgPSAnPCcgKyB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuXG4gICAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBpZiAocHJvcFZhbHVlKSB7XG4gICAgICAgICAgZW5xdWV1ZVB1dExpc3RlbmVyKHRoaXMsIHByb3BLZXksIHByb3BWYWx1ZSwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgICBpZiAocHJvcFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAvLyBTZWUgYF91cGRhdGVET01Qcm9wZXJ0aWVzYC4gc3R5bGUgYmxvY2tcbiAgICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BWYWx1ZSA9IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gX2Fzc2lnbih7fSwgcHJvcHMuc3R5bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9wVmFsdWUgPSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yU3R5bGVzKHByb3BWYWx1ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcmt1cCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl90YWcgIT0gbnVsbCAmJiBpc0N1c3RvbUNvbXBvbmVudCh0aGlzLl90YWcsIHByb3BzKSkge1xuICAgICAgICAgIGlmICghUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgICAgIG1hcmt1cCA9IERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGUocHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFya3VwID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclByb3BlcnR5KHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmt1cCkge1xuICAgICAgICAgIHJldCArPSAnICcgKyBtYXJrdXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGb3Igc3RhdGljIHBhZ2VzLCBubyBuZWVkIHRvIHB1dCBSZWFjdCBJRCBhbmQgY2hlY2tzdW0uIFNhdmVzIGxvdHMgb2ZcbiAgICAvLyBieXRlcy5cbiAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9ob3N0UGFyZW50KSB7XG4gICAgICByZXQgKz0gJyAnICsgRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclJvb3QoKTtcbiAgICB9XG4gICAgcmV0ICs9ICcgJyArIERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JJRCh0aGlzLl9kb21JRCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBjb250ZW50IGJldHdlZW4gdGhlIHRhZ3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7c3RyaW5nfSBDb250ZW50IG1hcmt1cC5cbiAgICovXG4gIF9jcmVhdGVDb250ZW50TWFya3VwOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIHJldCA9ICcnO1xuXG4gICAgLy8gSW50ZW50aW9uYWwgdXNlIG9mICE9IHRvIGF2b2lkIGNhdGNoaW5nIHplcm8vZmFsc2UuXG4gICAgdmFyIGlubmVySFRNTCA9IHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuICAgIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICAgaWYgKGlubmVySFRNTC5fX2h0bWwgIT0gbnVsbCkge1xuICAgICAgICByZXQgPSBpbm5lckhUTUwuX19odG1sO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGVudFRvVXNlID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgcHJvcHMuY2hpbGRyZW5dID8gcHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgICAgdmFyIGNoaWxkcmVuVG9Vc2UgPSBjb250ZW50VG9Vc2UgIT0gbnVsbCA/IG51bGwgOiBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChjb250ZW50VG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBWYWxpZGF0ZSB0aGF0IHRleHQgaXMgYWxsb3dlZCBhcyBhIGNoaWxkIG9mIHRoaXMgbm9kZVxuICAgICAgICByZXQgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIoY29udGVudFRvVXNlKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIGNvbnRlbnRUb1VzZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5Ub1VzZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBtb3VudEltYWdlcyA9IHRoaXMubW91bnRDaGlsZHJlbihjaGlsZHJlblRvVXNlLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIHJldCA9IG1vdW50SW1hZ2VzLmpvaW4oJycpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3bGluZUVhdGluZ1RhZ3NbdGhpcy5fdGFnXSAmJiByZXQuY2hhckF0KDApID09PSAnXFxuJykge1xuICAgICAgLy8gdGV4dC9odG1sIGlnbm9yZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGVzZSB0YWdzIGlmIGl0J3MgYSBuZXdsaW5lXG4gICAgICAvLyBQcmVmZXIgdG8gYnJlYWsgYXBwbGljYXRpb24veG1sIG92ZXIgdGV4dC9odG1sIChmb3Igbm93KSBieSBhZGRpbmdcbiAgICAgIC8vIGEgbmV3bGluZSBzcGVjaWZpY2FsbHkgdG8gZ2V0IGVhdGVuIGJ5IHRoZSBwYXJzZXIuIChBbHRlcm5hdGVseSBmb3JcbiAgICAgIC8vIHRleHRhcmVhcywgcmVwbGFjaW5nIFwiXlxcblwiIHdpdGggXCJcXHJcXG5cIiBkb2Vzbid0IGdldCBlYXRlbiwgYW5kIHRoZSBmaXJzdFxuICAgICAgLy8gXFxyIGlzIG5vcm1hbGl6ZWQgb3V0IGJ5IEhUTUxUZXh0QXJlYUVsZW1lbnQjdmFsdWUuKVxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbC1wb2x5Z2xvdC8jbmV3bGluZXMtaW4tdGV4dGFyZWEtYW5kLXByZT5cbiAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2VsZW1lbnQtcmVzdHJpY3Rpb25zPlxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjbmV3bGluZXM+XG4gICAgICAvLyBTZWU6IFBhcnNpbmcgb2YgXCJ0ZXh0YXJlYVwiIFwibGlzdGluZ1wiIGFuZCBcInByZVwiIGVsZW1lbnRzXG4gICAgICAvLyAgZnJvbSA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keT5cbiAgICAgIHJldHVybiAnXFxuJyArIHJldDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sXG5cbiAgX2NyZWF0ZUluaXRpYWxDaGlsZHJlbjogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCwgbGF6eVRyZWUpIHtcbiAgICAvLyBJbnRlbnRpb25hbCB1c2Ugb2YgIT0gdG8gYXZvaWQgY2F0Y2hpbmcgemVyby9mYWxzZS5cbiAgICB2YXIgaW5uZXJIVE1MID0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG4gICAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgICBpZiAoaW5uZXJIVE1MLl9faHRtbCAhPSBudWxsKSB7XG4gICAgICAgIERPTUxhenlUcmVlLnF1ZXVlSFRNTChsYXp5VHJlZSwgaW5uZXJIVE1MLl9faHRtbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250ZW50VG9Vc2UgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBwcm9wcy5jaGlsZHJlbl0gPyBwcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgICB2YXIgY2hpbGRyZW5Ub1VzZSA9IGNvbnRlbnRUb1VzZSAhPSBudWxsID8gbnVsbCA6IHByb3BzLmNoaWxkcmVuO1xuICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCB0ZXh0IGlzIGFsbG93ZWQgYXMgYSBjaGlsZCBvZiB0aGlzIG5vZGVcbiAgICAgIGlmIChjb250ZW50VG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICAvLyBBdm9pZCBzZXR0aW5nIHRleHRDb250ZW50IHdoZW4gdGhlIHRleHQgaXMgZW1wdHkuIEluIElFMTEgc2V0dGluZ1xuICAgICAgICAvLyB0ZXh0Q29udGVudCBvbiBhIHRleHQgYXJlYSB3aWxsIGNhdXNlIHRoZSBwbGFjZWhvbGRlciB0byBub3RcbiAgICAgICAgLy8gc2hvdyB3aXRoaW4gdGhlIHRleHRhcmVhIHVudGlsIGl0IGhhcyBiZWVuIGZvY3VzZWQgYW5kIGJsdXJyZWQgYWdhaW4uXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNjczMSNpc3N1ZWNvbW1lbnQtMjU0ODc0NTUzXG4gICAgICAgIGlmIChjb250ZW50VG9Vc2UgIT09ICcnKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2LmNhbGwodGhpcywgY29udGVudFRvVXNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgRE9NTGF6eVRyZWUucXVldWVUZXh0KGxhenlUcmVlLCBjb250ZW50VG9Vc2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkcmVuVG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbW91bnRJbWFnZXMgPSB0aGlzLm1vdW50Q2hpbGRyZW4oY2hpbGRyZW5Ub1VzZSwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vdW50SW1hZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgRE9NTGF6eVRyZWUucXVldWVDaGlsZChsYXp5VHJlZSwgbW91bnRJbWFnZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNlaXZlcyBhIG5leHQgZWxlbWVudCBhbmQgdXBkYXRlcyB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50O1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XG4gICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgY29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBET00gY29tcG9uZW50IGFmdGVyIGl0IGhhcyBhbHJlYWR5IGJlZW4gYWxsb2NhdGVkIGFuZFxuICAgKiBhdHRhY2hlZCB0byB0aGUgRE9NLiBSZWNvbmNpbGVzIHRoZSByb290IERPTSBub2RlLCB0aGVuIHJlY3Vyc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBwcmV2RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnRcbiAgICogQGludGVybmFsXG4gICAqIEBvdmVycmlkYWJsZVxuICAgKi9cbiAgdXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgY29udGV4dCkge1xuICAgIHZhciBsYXN0UHJvcHMgPSBwcmV2RWxlbWVudC5wcm9wcztcbiAgICB2YXIgbmV4dFByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTUlucHV0LmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTUlucHV0LmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NT3B0aW9uLmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXRIb3N0UHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTVNlbGVjdC5nZXRIb3N0UHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01TZWxlY3QuZ2V0SG9zdFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBhc3NlcnRWYWxpZFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgdGhpcy5fdXBkYXRlRE9NUHJvcGVydGllcyhsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24pO1xuICAgIHRoaXMuX3VwZGF0ZURPTUNoaWxkcmVuKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICAvLyBVcGRhdGUgdGhlIHdyYXBwZXIgYXJvdW5kIGlucHV0cyAqYWZ0ZXIqIHVwZGF0aW5nIHByb3BzLiBUaGlzIGhhcyB0b1xuICAgICAgICAvLyBoYXBwZW4gYWZ0ZXIgYF91cGRhdGVET01Qcm9wZXJ0aWVzYC4gT3RoZXJ3aXNlIEhUTUw1IGlucHV0IHZhbGlkYXRpb25zXG4gICAgICAgIC8vIHJhaXNlIHdhcm5pbmdzIGFuZCBwcmV2ZW50IHRoZSBuZXcgdmFsdWUgZnJvbSBiZWluZyBhc3NpZ25lZC5cbiAgICAgICAgUmVhY3RET01JbnB1dC51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgUmVhY3RET01UZXh0YXJlYS51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIC8vIDxzZWxlY3Q+IHZhbHVlIHVwZGF0ZSBuZWVkcyB0byBvY2N1ciBhZnRlciA8b3B0aW9uPiBjaGlsZHJlblxuICAgICAgICAvLyByZWNvbmNpbGlhdGlvblxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNvbmNpbGVzIHRoZSBwcm9wZXJ0aWVzIGJ5IGRldGVjdGluZyBkaWZmZXJlbmNlcyBpbiBwcm9wZXJ0eSB2YWx1ZXMgYW5kXG4gICAqIHVwZGF0aW5nIHRoZSBET00gYXMgbmVjZXNzYXJ5LiBUaGlzIGZ1bmN0aW9uIGlzIHByb2JhYmx5IHRoZSBzaW5nbGUgbW9zdFxuICAgKiBjcml0aWNhbCBwYXRoIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXG4gICAqXG4gICAqIFRPRE86IEJlbmNobWFyayB3aGV0aGVyIGNoZWNraW5nIGZvciBjaGFuZ2VkIHZhbHVlcyBpbiBtZW1vcnkgYWN0dWFsbHlcbiAgICogICAgICAgaW1wcm92ZXMgcGVyZm9ybWFuY2UgKGVzcGVjaWFsbHkgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnRzKS5cbiAgICogVE9ETzogQmVuY2htYXJrIHRoZSBlZmZlY3RzIG9mIHB1dHRpbmcgdGhpcyBhdCB0aGUgdG9wIHNpbmNlIDk5JSBvZiBwcm9wc1xuICAgKiAgICAgICBkbyBub3QgY2hhbmdlIGZvciBhIGdpdmVuIHJlY29uY2lsaWF0aW9uLlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgYXJlYXMgdGhhdCBjYW4gYmUgaW1wcm92ZWQgd2l0aCBjYWNoaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gbGFzdFByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZVxuICAgKi9cbiAgX3VwZGF0ZURPTVByb3BlcnRpZXM6IGZ1bmN0aW9uIChsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24pIHtcbiAgICB2YXIgcHJvcEtleTtcbiAgICB2YXIgc3R5bGVOYW1lO1xuICAgIHZhciBzdHlsZVVwZGF0ZXM7XG4gICAgZm9yIChwcm9wS2V5IGluIGxhc3RQcm9wcykge1xuICAgICAgaWYgKG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCAhbGFzdFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IGxhc3RQcm9wc1twcm9wS2V5XSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgIHZhciBsYXN0U3R5bGUgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weTtcbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFN0eWxlKSB7XG4gICAgICAgICAgaWYgKGxhc3RTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChsYXN0UHJvcHNbcHJvcEtleV0pIHtcbiAgICAgICAgICAvLyBPbmx5IGNhbGwgZGVsZXRlTGlzdGVuZXIgaWYgdGhlcmUgd2FzIGEgbGlzdGVuZXIgcHJldmlvdXNseSBvclxuICAgICAgICAgIC8vIGVsc2Ugd2lsbERlbGV0ZUxpc3RlbmVyIGdldHMgY2FsbGVkIHdoZW4gdGhlcmUgd2Fzbid0IGFjdHVhbGx5IGFcbiAgICAgICAgICAvLyBsaXN0ZW5lciAoZS5nLiwgb25DbGljaz17bnVsbH0pXG4gICAgICAgICAgZGVsZXRlTGlzdGVuZXIodGhpcywgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBsYXN0UHJvcHMpKSB7XG4gICAgICAgIGlmICghUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUoZ2V0Tm9kZSh0aGlzKSwgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkucHJvcGVydGllc1twcm9wS2V5XSB8fCBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShwcm9wS2V5KSkge1xuICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShnZXROb2RlKHRoaXMpLCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuICAgICAgdmFyIGxhc3RQcm9wID0gcHJvcEtleSA9PT0gU1RZTEUgPyB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA6IGxhc3RQcm9wcyAhPSBudWxsID8gbGFzdFByb3BzW3Byb3BLZXldIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbmV4dFByb3AgPT09IGxhc3RQcm9wIHx8IG5leHRQcm9wID09IG51bGwgJiYgbGFzdFByb3AgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlKHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5LCB0aGlzLl9wcmV2aW91c1N0eWxlLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBuZXh0UHJvcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dFByb3AgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IF9hc3NpZ24oe30sIG5leHRQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgLy8gVW5zZXQgc3R5bGVzIG9uIGBsYXN0UHJvcGAgYnV0IG5vdCBvbiBgbmV4dFByb3BgLlxuICAgICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XG4gICAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVwZGF0ZSBzdHlsZXMgdGhhdCBjaGFuZ2VkIHNpbmNlIGBsYXN0UHJvcGAuXG4gICAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbmV4dFByb3ApIHtcbiAgICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9IG5leHRQcm9wW3N0eWxlTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIGVucXVldWVQdXRMaXN0ZW5lcih0aGlzLCBwcm9wS2V5LCBuZXh0UHJvcCwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgZGVsZXRlTGlzdGVuZXIodGhpcywgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBuZXh0UHJvcHMpKSB7XG4gICAgICAgIGlmICghUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZ2V0Tm9kZSh0aGlzKSwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcEtleV0gfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUocHJvcEtleSkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBnZXROb2RlKHRoaXMpO1xuICAgICAgICAvLyBJZiB3ZSdyZSB1cGRhdGluZyB0byBudWxsIG9yIHVuZGVmaW5lZCwgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICAgICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGVudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcbiAgICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAgICBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JTdHlsZXMoZ2V0Tm9kZSh0aGlzKSwgc3R5bGVVcGRhdGVzLCB0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY29uY2lsZXMgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHZhcmlvdXMgcHJvcGVydGllcyB0aGF0IGFmZmVjdCB0aGVcbiAgICogY2hpbGRyZW4gY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGxhc3RQcm9wc1xuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICovXG4gIF91cGRhdGVET01DaGlsZHJlbjogZnVuY3Rpb24gKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBsYXN0Q29udGVudCA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIGxhc3RQcm9wcy5jaGlsZHJlbl0gPyBsYXN0UHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgIHZhciBuZXh0Q29udGVudCA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIG5leHRQcm9wcy5jaGlsZHJlbl0gPyBuZXh0UHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuXG4gICAgdmFyIGxhc3RIdG1sID0gbGFzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICYmIGxhc3RQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWw7XG4gICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICYmIG5leHRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWw7XG5cbiAgICAvLyBOb3RlIHRoZSB1c2Ugb2YgYCE9YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICAgIHZhciBsYXN0Q2hpbGRyZW4gPSBsYXN0Q29udGVudCAhPSBudWxsID8gbnVsbCA6IGxhc3RQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dENvbnRlbnQgIT0gbnVsbCA/IG51bGwgOiBuZXh0UHJvcHMuY2hpbGRyZW47XG5cbiAgICAvLyBJZiB3ZSdyZSBzd2l0Y2hpbmcgZnJvbSBjaGlsZHJlbiB0byBjb250ZW50L2h0bWwgb3IgdmljZSB2ZXJzYSwgcmVtb3ZlXG4gICAgLy8gdGhlIG9sZCBjb250ZW50XG4gICAgdmFyIGxhc3RIYXNDb250ZW50T3JIdG1sID0gbGFzdENvbnRlbnQgIT0gbnVsbCB8fCBsYXN0SHRtbCAhPSBudWxsO1xuICAgIHZhciBuZXh0SGFzQ29udGVudE9ySHRtbCA9IG5leHRDb250ZW50ICE9IG51bGwgfHwgbmV4dEh0bWwgIT0gbnVsbDtcbiAgICBpZiAobGFzdENoaWxkcmVuICE9IG51bGwgJiYgbmV4dENoaWxkcmVuID09IG51bGwpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obnVsbCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAobGFzdEhhc0NvbnRlbnRPckh0bWwgJiYgIW5leHRIYXNDb250ZW50T3JIdG1sKSB7XG4gICAgICB0aGlzLnVwZGF0ZVRleHRDb250ZW50KCcnKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKHRoaXMuX2RlYnVnSUQsIFtdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmV4dENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgaWYgKGxhc3RDb250ZW50ICE9PSBuZXh0Q29udGVudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVRleHRDb250ZW50KCcnICsgbmV4dENvbnRlbnQpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2LmNhbGwodGhpcywgbmV4dENvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICBpZiAobGFzdEh0bWwgIT09IG5leHRIdG1sKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTWFya3VwKCcnICsgbmV4dEh0bWwpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4odGhpcy5fZGVidWdJRCwgW10pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2LmNhbGwodGhpcywgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obmV4dENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldE5vZGUodGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIGFsbCBldmVudCByZWdpc3RyYXRpb25zIGZvciB0aGlzIGluc3RhbmNlLiBEb2VzIG5vdCByZW1vdmUgZnJvbVxuICAgKiB0aGUgRE9NLiBUaGF0IG11c3QgYmUgZG9uZSBieSB0aGUgcGFyZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChzYWZlbHkpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICBjYXNlICdpZnJhbWUnOlxuICAgICAgY2FzZSAnaW1nJzpcbiAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICBjYXNlICd2aWRlbyc6XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl93cmFwcGVyU3RhdGUubGlzdGVuZXJzO1xuICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIGlucHV0VmFsdWVUcmFja2luZy5zdG9wVHJhY2tpbmcodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcG9uZW50cyBsaWtlIDxodG1sPiA8aGVhZD4gYW5kIDxib2R5PiBjYW4ndCBiZSByZW1vdmVkIG9yIGFkZGVkXG4gICAgICAgICAqIGVhc2lseSBpbiBhIGNyb3NzLWJyb3dzZXIgd2F5LCBob3dldmVyIGl0J3MgdmFsdWFibGUgdG8gYmUgYWJsZSB0b1xuICAgICAgICAgKiB0YWtlIGFkdmFudGFnZSBvZiBSZWFjdCdzIHJlY29uY2lsaWF0aW9uIGZvciBzdHlsaW5nIGFuZCA8dGl0bGU+XG4gICAgICAgICAqIG1hbmFnZW1lbnQuIFNvIHdlIGp1c3QgZG9jdW1lbnQgaXQgYW5kIHRocm93IGluIGRhbmdlcm91cyBjYXNlcy5cbiAgICAgICAgICovXG4gICAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICc8JXM+IHRyaWVkIHRvIHVubW91bnQuIEJlY2F1c2Ugb2YgY3Jvc3MtYnJvd3NlciBxdWlya3MgaXQgaXMgaW1wb3NzaWJsZSB0byB1bm1vdW50IHNvbWUgdG9wLWxldmVsIGNvbXBvbmVudHMgKGVnIDxodG1sPiwgPGhlYWQ+LCBhbmQgPGJvZHk+KSByZWxpYWJseSBhbmQgZWZmaWNpZW50bHkuIFRvIGZpeCB0aGlzLCBoYXZlIGEgc2luZ2xlIHRvcC1sZXZlbCBjb21wb25lbnQgdGhhdCBuZXZlciB1bm1vdW50cyByZW5kZXIgdGhlc2UgZWxlbWVudHMuJywgdGhpcy5fdGFnKSA6IF9wcm9kSW52YXJpYW50KCc2NicsIHRoaXMuX3RhZykgOiB2b2lkIDA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMudW5tb3VudENoaWxkcmVuKHNhZmVseSk7XG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlLnVuY2FjaGVOb2RlKHRoaXMpO1xuICAgIEV2ZW50UGx1Z2luSHViLmRlbGV0ZUFsbExpc3RlbmVycyh0aGlzKTtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gMDtcbiAgICB0aGlzLl9kb21JRCA9IDA7XG4gICAgdGhpcy5fd3JhcHBlclN0YXRlID0gbnVsbDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIG51bGwpO1xuICAgIH1cbiAgfSxcblxuICBnZXRQdWJsaWNJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXROb2RlKHRoaXMpO1xuICB9XG59O1xuXG5fYXNzaWduKFJlYWN0RE9NQ29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RET01Db21wb25lbnQuTWl4aW4sIFJlYWN0TXVsdGlDaGlsZC5NaXhpbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db21wb25lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01Db21wb25lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcblxudmFyIGZvY3VzTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2ZvY3VzTm9kZScpO1xuXG52YXIgQXV0b0ZvY3VzVXRpbHMgPSB7XG4gIGZvY3VzRE9NQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgZm9jdXNOb2RlKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRoaXMpKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdXRvRm9jdXNVdGlscztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9BdXRvRm9jdXNVdGlscy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vQ1NTUHJvcGVydHknKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciBjYW1lbGl6ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lJyk7XG52YXIgZGFuZ2Vyb3VzU3R5bGVWYWx1ZSA9IHJlcXVpcmUoJy4vZGFuZ2Vyb3VzU3R5bGVWYWx1ZScpO1xudmFyIGh5cGhlbmF0ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZScpO1xudmFyIG1lbW9pemVTdHJpbmdPbmx5ID0gcmVxdWlyZSgnZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHknKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgcHJvY2Vzc1N0eWxlTmFtZSA9IG1lbW9pemVTdHJpbmdPbmx5KGZ1bmN0aW9uIChzdHlsZU5hbWUpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpO1xufSk7XG5cbnZhciBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyA9IGZhbHNlO1xudmFyIHN0eWxlRmxvYXRBY2Nlc3NvciA9ICdjc3NGbG9hdCc7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHZhciB0ZW1wU3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgdHJ5IHtcbiAgICAvLyBJRTggdGhyb3dzIFwiSW52YWxpZCBhcmd1bWVudC5cIiBpZiByZXNldHRpbmcgc2hvcnRoYW5kIHN0eWxlIHByb3BlcnRpZXMuXG4gICAgdGVtcFN0eWxlLmZvbnQgPSAnJztcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnID0gdHJ1ZTtcbiAgfVxuICAvLyBJRTggb25seSBzdXBwb3J0cyBhY2Nlc3NpbmcgY3NzRmxvYXQgKHN0YW5kYXJkKSBhcyBzdHlsZUZsb2F0XG4gIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuY3NzRmxvYXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0eWxlRmxvYXRBY2Nlc3NvciA9ICdzdHlsZUZsb2F0JztcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG5cbiAgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcblxuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcbiAgdmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUsIG93bmVyKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8lcycsIG5hbWUsIGNhbWVsaXplU3R5bGVOYW1lKG5hbWUpLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpKSA6IHZvaWQgMDtcbiAgfTtcblxuICB2YXIgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUsIG93bmVyKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSwgY2hlY2tSZW5kZXJNZXNzYWdlKG93bmVyKSkgOiB2b2lkIDA7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgb3duZXIpIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsIFwiU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uLiVzIFwiICsgJ1RyeSBcIiVzOiAlc1wiIGluc3RlYWQuJywgY2hlY2tSZW5kZXJNZXNzYWdlKG93bmVyKSwgbmFtZSwgdmFsdWUucmVwbGFjZShiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sICcnKSkgOiB2b2lkIDA7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNOYU4gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIG93bmVyKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYE5hTmAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LiVzJywgbmFtZSwgY2hlY2tSZW5kZXJNZXNzYWdlKG93bmVyKSkgOiB2b2lkIDA7XG4gIH07XG5cbiAgdmFyIGNoZWNrUmVuZGVyTWVzc2FnZSA9IGZ1bmN0aW9uIChvd25lcikge1xuICAgIGlmIChvd25lcikge1xuICAgICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqL1xuICB2YXIgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGNvbXBvbmVudCkge1xuICAgIHZhciBvd25lcjtcbiAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICBvd25lciA9IGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgIH1cbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSwgb3duZXIpO1xuICAgIH0gZWxzZSBpZiAoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lLCBvd25lcik7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSwgb3duZXIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKSkge1xuICAgICAgd2FyblN0eWxlVmFsdWVJc05hTihuYW1lLCB2YWx1ZSwgb3duZXIpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggQ1NTIHByb3BlcnRpZXMuXG4gKi9cbnZhciBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIGEgbWFwcGluZyBvZiBzdHlsZSBwcm9wZXJ0aWVzIGZvciB1c2UgYXMgaW5saW5lIHN0eWxlczpcbiAgICpcbiAgICogICA+IGNyZWF0ZU1hcmt1cEZvclN0eWxlcyh7d2lkdGg6ICcyMDBweCcsIGhlaWdodDogMH0pXG4gICAqICAgXCJ3aWR0aDoyMDBweDtoZWlnaHQ6MDtcIlxuICAgKlxuICAgKiBVbmRlZmluZWQgdmFsdWVzIGFyZSBpZ25vcmVkIHNvIHRoYXQgZGVjbGFyYXRpdmUgcHJvZ3JhbW1pbmcgaXMgZWFzaWVyLlxuICAgKiBUaGUgcmVzdWx0IHNob3VsZCBiZSBIVE1MLWVzY2FwZWQgYmVmb3JlIGluc2VydGlvbiBpbnRvIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAgICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqIEByZXR1cm4gez9zdHJpbmd9XG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JTdHlsZXM6IGZ1bmN0aW9uIChzdHlsZXMsIGNvbXBvbmVudCkge1xuICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKCFpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgICAgd2FyblZhbGlkU3R5bGUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBjb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gcHJvY2Vzc1N0eWxlTmFtZShzdHlsZU5hbWUpICsgJzonO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBjb21wb25lbnQsIGlzQ3VzdG9tUHJvcGVydHkpICsgJzsnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgbXVsdGlwbGUgc3R5bGVzIG9uIGEgbm9kZS4gIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzXG4gICAqICcnIChlbXB0eSBzdHJpbmcpLCB0aGUgY29ycmVzcG9uZGluZyBzdHlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVuc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0eWxlc1xuICAgKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICovXG4gIHNldFZhbHVlRm9yU3R5bGVzOiBmdW5jdGlvbiAobm9kZSwgc3R5bGVzLCBjb21wb25lbnQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgIGluc3RhbmNlSUQ6IGNvbXBvbmVudC5fZGVidWdJRCxcbiAgICAgICAgdHlwZTogJ3VwZGF0ZSBzdHlsZXMnLFxuICAgICAgICBwYXlsb2FkOiBzdHlsZXNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IG5vZGUuc3R5bGU7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoIWlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgICB3YXJuVmFsaWRTdHlsZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdLCBjb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSwgY29tcG9uZW50LCBpc0N1c3RvbVByb3BlcnR5KTtcbiAgICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcgfHwgc3R5bGVOYW1lID09PSAnY3NzRmxvYXQnKSB7XG4gICAgICAgIHN0eWxlTmFtZSA9IHN0eWxlRmxvYXRBY2Nlc3NvcjtcbiAgICAgIH1cbiAgICAgIGlmIChpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgIHN0eWxlLnNldFByb3BlcnR5KHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0eWxlVmFsdWUpIHtcbiAgICAgICAgc3R5bGVbc3R5bGVOYW1lXSA9IHN0eWxlVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXhwYW5zaW9uID0gaGFzU2hvcnRoYW5kUHJvcGVydHlCdWcgJiYgQ1NTUHJvcGVydHkuc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zW3N0eWxlTmFtZV07XG4gICAgICAgIGlmIChleHBhbnNpb24pIHtcbiAgICAgICAgICAvLyBTaG9ydGhhbmQgcHJvcGVydHkgdGhhdCBJRTggd29uJ3QgbGlrZSB1bnNldHRpbmcsIHNvIHVuc2V0IGVhY2hcbiAgICAgICAgICAvLyBjb21wb25lbnQgdG8gcGxhY2F0ZSBpdFxuICAgICAgICAgIGZvciAodmFyIGluZGl2aWR1YWxTdHlsZU5hbWUgaW4gZXhwYW5zaW9uKSB7XG4gICAgICAgICAgICBzdHlsZVtpbmRpdmlkdWFsU3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHlsZVtzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NTUHJvcGVydHlPcGVyYXRpb25zO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0NTU1Byb3BlcnR5T3BlcmF0aW9ucy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbWVsaXplID0gcmVxdWlyZSgnLi9jYW1lbGl6ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL14tbXMtLztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tb3otdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJNb3pUcmFuc2l0aW9uXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1zLXRyYW5zaXRpb24nKVxuICogICA8IFwibXNUcmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gKiAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGNhbWVsaXplKHN0cmluZy5yZXBsYWNlKG1zUGF0dGVybiwgJ21zLScpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZVN0eWxlTmFtZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF9oeXBoZW5QYXR0ZXJuID0gLy0oLikvZztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENTU1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eScpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0gQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcjtcbnZhciBzdHlsZVdhcm5pbmdzID0ge307XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBzdHlsZSB2YWx1ZSB3aXRoIGRpbWVuc2lvbnMgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLCB2YWx1ZSwgY29tcG9uZW50LCBpc0N1c3RvbVByb3BlcnR5KSB7XG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xuICAvLyB0aGUgbWFya3VwLiBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0XG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG5cbiAgdmFyIGlzRW1wdHkgPSB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgaXNOb25OdW1lcmljID0gaXNOYU4odmFsdWUpO1xuICBpZiAoaXNDdXN0b21Qcm9wZXJ0eSB8fCBpc05vbk51bWVyaWMgfHwgdmFsdWUgPT09IDAgfHwgaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSB7XG4gICAgcmV0dXJuICcnICsgdmFsdWU7IC8vIGNhc3QgdG8gc3RyaW5nXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBBbGxvdyAnMCcgdG8gcGFzcyB0aHJvdWdoIHdpdGhvdXQgd2FybmluZy4gMCBpcyBhbHJlYWR5IHNwZWNpYWwgYW5kXG4gICAgICAvLyBkb2Vzbid0IHJlcXVpcmUgdW5pdHMsIHNvIHdlIGRvbid0IG5lZWQgdG8gd2FybiBhYm91dCBpdC5cbiAgICAgIGlmIChjb21wb25lbnQgJiYgdmFsdWUgIT09ICcwJykge1xuICAgICAgICB2YXIgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gb3duZXIuZ2V0TmFtZSgpIDogbnVsbDtcbiAgICAgICAgaWYgKG93bmVyTmFtZSAmJiAhc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdKSB7XG4gICAgICAgICAgc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgICAgdmFyIHdhcm5pbmdzID0gc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdO1xuICAgICAgICAgIHdhcm5lZCA9IHdhcm5pbmdzW25hbWVdO1xuICAgICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgICB3YXJuaW5nc1tuYW1lXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdhIGAlc2AgdGFnIChvd25lcjogYCVzYCkgd2FzIHBhc3NlZCBhIG51bWVyaWMgc3RyaW5nIHZhbHVlICcgKyAnZm9yIENTUyBwcm9wZXJ0eSBgJXNgICh2YWx1ZTogYCVzYCkgd2hpY2ggd2lsbCBiZSB0cmVhdGVkICcgKyAnYXMgYSB1bml0bGVzcyBudW1iZXIgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBSZWFjdC4nLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50LnR5cGUsIG93bmVyTmFtZSB8fCAndW5rbm93bicsIG5hbWUsIHZhbHVlKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfVxuICByZXR1cm4gdmFsdWUgKyAncHgnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRhbmdlcm91c1N0eWxlVmFsdWU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZGFuZ2Vyb3VzU3R5bGVWYWx1ZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGh5cGhlbmF0ZSA9IHJlcXVpcmUoJy4vaHlwaGVuYXRlJyk7XG5cbnZhciBtc1BhdHRlcm4gPSAvXm1zLS87XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ01velRyYW5zaXRpb24nKVxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ21zVHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbXMtdHJhbnNpdGlvblwiXG4gKlxuICogQXMgTW9kZXJuaXpyIHN1Z2dlc3RzIChodHRwOi8vbW9kZXJuaXpyLmNvbS9kb2NzLyNwcmVmaXhlZCksIGFuIGBtc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gYC1tcy1gLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKHN0cmluZykge1xuICByZXR1cm4gaHlwaGVuYXRlKHN0cmluZykucmVwbGFjZShtc1BhdHRlcm4sICctbXMtJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlU3R5bGVOYW1lO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBfdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKlxuICogRm9yIENTUyBzdHlsZSBuYW1lcywgdXNlIGBoeXBoZW5hdGVTdHlsZU5hbWVgIGluc3RlYWQgd2hpY2ggd29ya3MgcHJvcGVybHlcbiAqIHdpdGggYWxsIHZlbmRvciBwcmVmaXhlcywgaW5jbHVkaW5nIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfdXBwZXJjYXNlUGF0dGVybiwgJy0kMScpLnRvTG93ZXJDYXNlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGUuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNZW1vaXplcyB0aGUgcmV0dXJuIHZhbHVlIG9mIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBzdHJpbmcgYXJndW1lbnQuXG4gKi9cblxuZnVuY3Rpb24gbWVtb2l6ZVN0cmluZ09ubHkoY2FsbGJhY2spIHtcbiAgdmFyIGNhY2hlID0ge307XG4gIHJldHVybiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgaWYgKCFjYWNoZS5oYXNPd25Qcm9wZXJ0eShzdHJpbmcpKSB7XG4gICAgICBjYWNoZVtzdHJpbmddID0gY2FsbGJhY2suY2FsbCh0aGlzLCBzdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVbc3RyaW5nXTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplU3RyaW5nT25seTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHkuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcblxuLyoqXG4gKiBFc2NhcGVzIGF0dHJpYnV0ZSB2YWx1ZSB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpIHtcbiAgcmV0dXJuICdcIicgKyBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodmFsdWUpICsgJ1wiJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9xdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcblxuZnVuY3Rpb24gcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKSB7XG4gIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnRzKTtcbiAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xufVxuXG52YXIgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiA9IHtcbiAgLyoqXG4gICAqIFN0cmVhbXMgYSBmaXJlZCB0b3AtbGV2ZWwgZXZlbnQgdG8gYEV2ZW50UGx1Z2luSHViYCB3aGVyZSBwbHVnaW5zIGhhdmUgdGhlXG4gICAqIG9wcG9ydHVuaXR5IHRvIGNyZWF0ZSBgUmVhY3RFdmVudGBzIHRvIGJlIGRpc3BhdGNoZWQuXG4gICAqL1xuICBoYW5kbGVUb3BMZXZlbDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGV2ZW50cyA9IEV2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFdmVudEVtaXR0ZXJNaXhpbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEV2ZW50RW1pdHRlck1peGluLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG1hcHBpbmcgb2Ygc3RhbmRhcmQgdmVuZG9yIHByZWZpeGVzIHVzaW5nIHRoZSBkZWZpbmVkIHN0eWxlIHByb3BlcnR5IGFuZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVByb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG1ha2VQcmVmaXhNYXAoc3R5bGVQcm9wLCBldmVudE5hbWUpIHtcbiAgdmFyIHByZWZpeGVzID0ge307XG5cbiAgcHJlZml4ZXNbc3R5bGVQcm9wLnRvTG93ZXJDYXNlKCldID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHByZWZpeGVzWydXZWJraXQnICsgc3R5bGVQcm9wXSA9ICd3ZWJraXQnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTW96JyArIHN0eWxlUHJvcF0gPSAnbW96JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ21zJyArIHN0eWxlUHJvcF0gPSAnTVMnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTycgKyBzdHlsZVByb3BdID0gJ28nICsgZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIHByZWZpeGVzO1xufVxuXG4vKipcbiAqIEEgbGlzdCBvZiBldmVudCBuYW1lcyB0byBhIGNvbmZpZ3VyYWJsZSBsaXN0IG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHZlbmRvclByZWZpeGVzID0ge1xuICBhbmltYXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25FbmQnKSxcbiAgYW5pbWF0aW9uaXRlcmF0aW9uOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uSXRlcmF0aW9uJyksXG4gIGFuaW1hdGlvbnN0YXJ0OiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uU3RhcnQnKSxcbiAgdHJhbnNpdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnVHJhbnNpdGlvbicsICdUcmFuc2l0aW9uRW5kJylcbn07XG5cbi8qKlxuICogRXZlbnQgbmFtZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXRlY3RlZCBhbmQgcHJlZml4ZWQgKGlmIGFwcGxpY2FibGUpLlxuICovXG52YXIgcHJlZml4ZWRFdmVudE5hbWVzID0ge307XG5cbi8qKlxuICogRWxlbWVudCB0byBjaGVjayBmb3IgcHJlZml4ZXMgb24uXG4gKi9cbnZhciBzdHlsZSA9IHt9O1xuXG4vKipcbiAqIEJvb3RzdHJhcCBpZiBhIERPTSBleGlzdHMuXG4gKi9cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcblxuICAvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuICAvLyB0aGUgdW4tcHJlZml4ZWQgXCJhbmltYXRpb25cIiBhbmQgXCJ0cmFuc2l0aW9uXCIgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBvbiB0aGVcbiAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbSBmcm9tIHRoZSBtYXAuXG4gIGlmICghKCdBbmltYXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25lbmQuYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25pdGVyYXRpb24uYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25zdGFydC5hbmltYXRpb247XG4gIH1cblxuICAvLyBTYW1lIGFzIGFib3ZlXG4gIGlmICghKCdUcmFuc2l0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHZlbmRvciBwcmVmaXhlZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKGV2ZW50TmFtZSkge1xuICBpZiAocHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV07XG4gIH0gZWxzZSBpZiAoIXZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gZXZlbnROYW1lO1xuICB9XG5cbiAgdmFyIHByZWZpeE1hcCA9IHZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV07XG5cbiAgZm9yICh2YXIgc3R5bGVQcm9wIGluIHByZWZpeE1hcCkge1xuICAgIGlmIChwcmVmaXhNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVQcm9wKSAmJiBzdHlsZVByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHByZWZpeE1hcFtzdHlsZVByb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9nZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHlPcGVyYXRpb25zJyk7XG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkaWRXYXJuVmFsdWVMaW5rID0gZmFsc2U7XG52YXIgZGlkV2FybkNoZWNrZWRMaW5rID0gZmFsc2U7XG52YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gZmFsc2U7XG52YXIgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZvcmNlVXBkYXRlSWZNb3VudGVkKCkge1xuICBpZiAodGhpcy5fcm9vdE5vZGVJRCkge1xuICAgIC8vIERPTSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZDsgdXBkYXRlXG4gICAgUmVhY3RET01JbnB1dC51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQ29udHJvbGxlZChwcm9wcykge1xuICB2YXIgdXNlc0NoZWNrZWQgPSBwcm9wcy50eXBlID09PSAnY2hlY2tib3gnIHx8IHByb3BzLnR5cGUgPT09ICdyYWRpbyc7XG4gIHJldHVybiB1c2VzQ2hlY2tlZCA/IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA6IHByb3BzLnZhbHVlICE9IG51bGw7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8aW5wdXQ+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgdGhlc2Ugb3B0aW9uYWxcbiAqIHByb3BzOiBgY2hlY2tlZGAsIGB2YWx1ZWAsIGBkZWZhdWx0Q2hlY2tlZGAsIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqXG4gKiBJZiBgY2hlY2tlZGAgb3IgYHZhbHVlYCBhcmUgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9uc1xuICogdGhhdCBhZmZlY3QgdGhlIGNoZWNrZWQgc3RhdGUgb3IgdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgdGhleSBhcmUgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIG5vdFxuICogdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgcHJvcHMgbXVzdCBjaGFuZ2UgaW4gb3JkZXIgZm9yXG4gKiB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgYXMgdW5jaGVja2VkIChvciBgZGVmYXVsdENoZWNrZWRgKVxuICogd2l0aCBhbiBlbXB0eSB2YWx1ZSAob3IgYGRlZmF1bHRWYWx1ZWApLlxuICpcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMi9XRC1odG1sNS0yMDEyMTAyNS90aGUtaW5wdXQtZWxlbWVudC5odG1sXG4gKi9cbnZhciBSZWFjdERPTUlucHV0ID0ge1xuICBnZXRIb3N0UHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIHZhciBjaGVja2VkID0gTGlua2VkVmFsdWVVdGlscy5nZXRDaGVja2VkKHByb3BzKTtcblxuICAgIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHtcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLnR5cGUgYmVmb3JlIGFueSBvdGhlciBwcm9wZXJ0aWVzIChzZXR0aW5nIC52YWx1ZVxuICAgICAgLy8gYmVmb3JlIC50eXBlIG1lYW5zIC52YWx1ZSBpcyBsb3N0IGluIElFMTEgYW5kIGJlbG93KVxuICAgICAgdHlwZTogdW5kZWZpbmVkLFxuICAgICAgLy8gTWFrZSBzdXJlIHdlIHNldCAuc3RlcCBiZWZvcmUgLnZhbHVlIChzZXR0aW5nIC52YWx1ZSBiZWZvcmUgLnN0ZXBcbiAgICAgIC8vIG1lYW5zIC52YWx1ZSBpcyByb3VuZGVkIG9uIG1vdW50LCBiYXNlZCB1cG9uIHN0ZXAgcHJlY2lzaW9uKVxuICAgICAgc3RlcDogdW5kZWZpbmVkLFxuICAgICAgLy8gTWFrZSBzdXJlIHdlIHNldCAubWluICYgLm1heCBiZWZvcmUgLnZhbHVlICh0byBlbnN1cmUgcHJvcGVyIG9yZGVyXG4gICAgICAvLyBpbiBjb3JuZXIgY2FzZXMgc3VjaCBhcyBtaW4gb3IgbWF4IGRlcml2aW5nIGZyb20gdmFsdWUsIGUuZy4gSXNzdWUgIzcxNzApXG4gICAgICBtaW46IHVuZGVmaW5lZCxcbiAgICAgIG1heDogdW5kZWZpbmVkXG4gICAgfSwgcHJvcHMsIHtcbiAgICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIHZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLFxuICAgICAgY2hlY2tlZDogY2hlY2tlZCAhPSBudWxsID8gY2hlY2tlZCA6IGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZCxcbiAgICAgIG9uQ2hhbmdlOiBpbnN0Ll93cmFwcGVyU3RhdGUub25DaGFuZ2VcbiAgICB9KTtcblxuICAgIHJldHVybiBob3N0UHJvcHM7XG4gIH0sXG5cbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgTGlua2VkVmFsdWVVdGlscy5jaGVja1Byb3BUeXBlcygnaW5wdXQnLCBwcm9wcywgaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcblxuICAgICAgdmFyIG93bmVyID0gaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuXG4gICAgICBpZiAocHJvcHMudmFsdWVMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZUxpbmspIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgdmFsdWVMaW5rYCBwcm9wIG9uIGBpbnB1dGAgaXMgZGVwcmVjYXRlZDsgc2V0IGB2YWx1ZWAgYW5kIGBvbkNoYW5nZWAgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblZhbHVlTGluayA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMuY2hlY2tlZExpbmsgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkNoZWNrZWRMaW5rKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYGNoZWNrZWRMaW5rYCBwcm9wIG9uIGBpbnB1dGAgaXMgZGVwcmVjYXRlZDsgc2V0IGB2YWx1ZWAgYW5kIGBvbkNoYW5nZWAgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FybkNoZWNrZWRMaW5rID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5jaGVja2VkICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIGNoZWNrZWQgYW5kIGRlZmF1bHRDaGVja2VkIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBvd25lciAmJiBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSkgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgaW5pdGlhbENoZWNrZWQ6IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA/IHByb3BzLmNoZWNrZWQgOiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCxcbiAgICAgIGluaXRpYWxWYWx1ZTogcHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlLFxuICAgICAgbGlzdGVuZXJzOiBudWxsLFxuICAgICAgb25DaGFuZ2U6IF9oYW5kbGVDaGFuZ2UuYmluZChpbnN0KSxcbiAgICAgIGNvbnRyb2xsZWQ6IGlzQ29udHJvbGxlZChwcm9wcylcbiAgICB9O1xuICB9LFxuXG4gIHVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGNvbnRyb2xsZWQgPSBpc0NvbnRyb2xsZWQocHJvcHMpO1xuICAgICAgdmFyIG93bmVyID0gaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuXG4gICAgICBpZiAoIWluc3QuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmIGNvbnRyb2xsZWQgJiYgIWRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBpcyBjaGFuZ2luZyBhbiB1bmNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSBjb250cm9sbGVkLiAnICsgJ0lucHV0IGVsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5zdC5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgIWNvbnRyb2xsZWQgJiYgIWRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBpcyBjaGFuZ2luZyBhIGNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSB1bmNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBTaG91bGRuJ3QgdGhpcyBiZSBnZXRDaGVja2VkKHByb3BzKT9cbiAgICB2YXIgY2hlY2tlZCA9IHByb3BzLmNoZWNrZWQ7XG4gICAgaWYgKGNoZWNrZWQgIT0gbnVsbCkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkoUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCksICdjaGVja2VkJywgY2hlY2tlZCB8fCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgaWYgKHZhbHVlID09PSAwICYmIG5vZGUudmFsdWUgPT09ICcnKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSAnMCc7XG4gICAgICAgIC8vIE5vdGU6IElFOSByZXBvcnRzIGEgbnVtYmVyIGlucHV0cyBhcyAndGV4dCcsIHNvIGNoZWNrIHByb3BzIGluc3RlYWQuXG4gICAgICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIFNpbXVsYXRlIGBpbnB1dC52YWx1ZUFzTnVtYmVyYC4gSUU5IGRvZXMgbm90IHN1cHBvcnQgaXRcbiAgICAgICAgdmFyIHZhbHVlQXNOdW1iZXIgPSBwYXJzZUZsb2F0KG5vZGUudmFsdWUsIDEwKSB8fCAwO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHZhbHVlICE9IHZhbHVlQXNOdW1iZXIgfHxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHZhbHVlID09IHZhbHVlQXNOdW1iZXIgJiYgbm9kZS52YWx1ZSAhPSB2YWx1ZSkge1xuICAgICAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgICAgIG5vZGUudmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudmFsdWUgIT09ICcnICsgdmFsdWUpIHtcbiAgICAgICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgICBub2RlLnZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BzLnZhbHVlID09IG51bGwgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgLy8gSW4gQ2hyb21lLCBhc3NpZ25pbmcgZGVmYXVsdFZhbHVlIHRvIGNlcnRhaW4gaW5wdXQgdHlwZXMgdHJpZ2dlcnMgaW5wdXQgdmFsaWRhdGlvbi5cbiAgICAgICAgLy8gRm9yIG51bWJlciBpbnB1dHMsIHRoZSBkaXNwbGF5IHZhbHVlIGxvc2VzIHRyYWlsaW5nIGRlY2ltYWwgcG9pbnRzLiBGb3IgZW1haWwgaW5wdXRzLFxuICAgICAgICAvLyBDaHJvbWUgcmFpc2VzIFwiVGhlIHNwZWNpZmllZCB2YWx1ZSA8eD4gaXMgbm90IGEgdmFsaWQgZW1haWwgYWRkcmVzc1wiLlxuICAgICAgICAvL1xuICAgICAgICAvLyBIZXJlIHdlIGNoZWNrIHRvIHNlZSBpZiB0aGUgZGVmYXVsdFZhbHVlIGhhcyBhY3R1YWxseSBjaGFuZ2VkLCBhdm9pZGluZyB0aGVzZSBwcm9ibGVtc1xuICAgICAgICAvLyB3aGVuIHRoZSB1c2VyIGlzIGlucHV0dGluZyB0ZXh0XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI1M1xuICAgICAgICBpZiAobm9kZS5kZWZhdWx0VmFsdWUgIT09ICcnICsgcHJvcHMuZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSAnJyArIHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhIXByb3BzLmRlZmF1bHRDaGVja2VkO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBwb3N0TW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuICAgIC8vIGF2YWlsYWJsZSB1bnRpbCBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBtb3VudGVkLlxuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG5cbiAgICAvLyBEZXRhY2ggdmFsdWUgZnJvbSBkZWZhdWx0VmFsdWUuIFdlIHdvbid0IGRvIGFueXRoaW5nIGlmIHdlJ3JlIHdvcmtpbmcgb25cbiAgICAvLyBzdWJtaXQgb3IgcmVzZXQgaW5wdXRzIGFzIHRob3NlIHZhbHVlcyAmIGRlZmF1bHRWYWx1ZXMgYXJlIGxpbmtlZC4gVGhleVxuICAgIC8vIGFyZSBub3QgcmVzZXRhYmxlIG5vZGVzIHNvIHRoaXMgb3BlcmF0aW9uIGRvZXNuJ3QgbWF0dGVyIGFuZCBhY3R1YWxseVxuICAgIC8vIHJlbW92ZXMgYnJvd3Nlci1kZWZhdWx0IHZhbHVlcyAoZWcgXCJTdWJtaXQgUXVlcnlcIikgd2hlbiBubyB2YWx1ZSBpc1xuICAgIC8vIHByb3ZpZGVkLlxuXG4gICAgc3dpdGNoIChwcm9wcy50eXBlKSB7XG4gICAgICBjYXNlICdzdWJtaXQnOlxuICAgICAgY2FzZSAncmVzZXQnOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NvbG9yJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgY2FzZSAnZGF0ZXRpbWUtbG9jYWwnOlxuICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgY2FzZSAndGltZSc6XG4gICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgLy8gVGhpcyBmaXhlcyB0aGUgbm8tc2hvdyBpc3N1ZSBvbiBpT1MgU2FmYXJpIGFuZCBBbmRyb2lkIENocm9tZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjMzXG4gICAgICAgIG5vZGUudmFsdWUgPSAnJztcbiAgICAgICAgbm9kZS52YWx1ZSA9IG5vZGUuZGVmYXVsdFZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG5vZGUudmFsdWUgPSBub2RlLnZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxseSwgd2UnZCBqdXN0IGRvIGBub2RlLmNoZWNrZWQgPSBub2RlLmNoZWNrZWRgIHVwb24gaW5pdGlhbCBtb3VudCwgbGVzcyB0aGlzIGJ1Z1xuICAgIC8vIHRoaXMgaXMgbmVlZGVkIHRvIHdvcmsgYXJvdW5kIGEgY2hyb21lIGJ1ZyB3aGVyZSBzZXR0aW5nIGRlZmF1bHRDaGVja2VkXG4gICAgLy8gd2lsbCBzb21ldGltZXMgaW5mbHVlbmNlIHRoZSB2YWx1ZSBvZiBjaGVja2VkIChldmVuIGFmdGVyIGRldGFjaG1lbnQpLlxuICAgIC8vIFJlZmVyZW5jZTogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjA4NDE2XG4gICAgLy8gV2UgbmVlZCB0byB0ZW1wb3JhcmlseSB1bnNldCBuYW1lIHRvIGF2b2lkIGRpc3J1cHRpbmcgcmFkaW8gYnV0dG9uIGdyb3Vwcy5cbiAgICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcbiAgICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICAgIG5vZGUubmFtZSA9ICcnO1xuICAgIH1cbiAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gIW5vZGUuZGVmYXVsdENoZWNrZWQ7XG4gICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICAgIGlmIChuYW1lICE9PSAnJykge1xuICAgICAgbm9kZS5uYW1lID0gbmFtZTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9oYW5kbGVDaGFuZ2UoZXZlbnQpIHtcbiAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgdmFyIHJldHVyblZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5leGVjdXRlT25DaGFuZ2UocHJvcHMsIGV2ZW50KTtcblxuICAvLyBIZXJlIHdlIHVzZSBhc2FwIHRvIHdhaXQgdW50aWwgYWxsIHVwZGF0ZXMgaGF2ZSBwcm9wYWdhdGVkLCB3aGljaFxuICAvLyBpcyBpbXBvcnRhbnQgd2hlbiB1c2luZyBjb250cm9sbGVkIGNvbXBvbmVudHMgd2l0aGluIGxheWVyczpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjk4XG4gIFJlYWN0VXBkYXRlcy5hc2FwKGZvcmNlVXBkYXRlSWZNb3VudGVkLCB0aGlzKTtcblxuICB2YXIgbmFtZSA9IHByb3BzLm5hbWU7XG4gIGlmIChwcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5hbWUgIT0gbnVsbCkge1xuICAgIHZhciByb290Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRoaXMpO1xuICAgIHZhciBxdWVyeVJvb3QgPSByb290Tm9kZTtcblxuICAgIHdoaWxlIChxdWVyeVJvb3QucGFyZW50Tm9kZSkge1xuICAgICAgcXVlcnlSb290ID0gcXVlcnlSb290LnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLy8gSWYgYHJvb3ROb2RlLmZvcm1gIHdhcyBub24tbnVsbCwgdGhlbiB3ZSBjb3VsZCB0cnkgYGZvcm0uZWxlbWVudHNgLFxuICAgIC8vIGJ1dCB0aGF0IHNvbWV0aW1lcyBiZWhhdmVzIHN0cmFuZ2VseSBpbiBJRTguIFdlIGNvdWxkIGFsc28gdHJ5IHVzaW5nXG4gICAgLy8gYGZvcm0uZ2V0RWxlbWVudHNCeU5hbWVgLCBidXQgdGhhdCB3aWxsIG9ubHkgcmV0dXJuIGRpcmVjdCBjaGlsZHJlblxuICAgIC8vIGFuZCB3b24ndCBpbmNsdWRlIGlucHV0cyB0aGF0IHVzZSB0aGUgSFRNTDUgYGZvcm09YCBhdHRyaWJ1dGUuIFNpbmNlXG4gICAgLy8gdGhlIGlucHV0IG1pZ2h0IG5vdCBldmVuIGJlIGluIGEgZm9ybSwgbGV0J3MganVzdCB1c2UgdGhlIGdsb2JhbFxuICAgIC8vIGBxdWVyeVNlbGVjdG9yQWxsYCB0byBlbnN1cmUgd2UgZG9uJ3QgbWlzcyBhbnl0aGluZy5cbiAgICB2YXIgZ3JvdXAgPSBxdWVyeVJvb3QucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbbmFtZT0nICsgSlNPTi5zdHJpbmdpZnkoJycgKyBuYW1lKSArICddW3R5cGU9XCJyYWRpb1wiXScpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG90aGVyTm9kZSA9IGdyb3VwW2ldO1xuICAgICAgaWYgKG90aGVyTm9kZSA9PT0gcm9vdE5vZGUgfHwgb3RoZXJOb2RlLmZvcm0gIT09IHJvb3ROb2RlLmZvcm0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgcmFkaW8gYnV0dG9ucyByZW5kZXJlZCBieSBkaWZmZXJlbnQgY29waWVzIG9mIFJlYWN0XG4gICAgICAvLyBhbmQgdGhlIHNhbWUgbmFtZSBhcmUgcmVuZGVyZWQgaW50byB0aGUgc2FtZSBmb3JtIChzYW1lIGFzICMxOTM5KS5cbiAgICAgIC8vIFRoYXQncyBwcm9iYWJseSBva2F5OyB3ZSBkb24ndCBzdXBwb3J0IGl0IGp1c3QgYXMgd2UgZG9uJ3Qgc3VwcG9ydFxuICAgICAgLy8gbWl4aW5nIFJlYWN0IHJhZGlvIGJ1dHRvbnMgd2l0aCBub24tUmVhY3Qgb25lcy5cbiAgICAgIHZhciBvdGhlckluc3RhbmNlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUob3RoZXJOb2RlKTtcbiAgICAgICFvdGhlckluc3RhbmNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0RE9NSW5wdXQ6IE1peGluZyBSZWFjdCBhbmQgbm9uLVJlYWN0IHJhZGlvIGlucHV0cyB3aXRoIHRoZSBzYW1lIGBuYW1lYCBpcyBub3Qgc3VwcG9ydGVkLicpIDogX3Byb2RJbnZhcmlhbnQoJzkwJykgOiB2b2lkIDA7XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgY29udHJvbGxlZCByYWRpbyBidXR0b24gZ3JvdXAsIGZvcmNpbmcgdGhlIGlucHV0IHRoYXRcbiAgICAgIC8vIHdhcyBwcmV2aW91c2x5IGNoZWNrZWQgdG8gdXBkYXRlIHdpbGwgY2F1c2UgaXQgdG8gYmUgY29tZSByZS1jaGVja2VkXG4gICAgICAvLyBhcyBhcHByb3ByaWF0ZS5cbiAgICAgIFJlYWN0VXBkYXRlcy5hc2FwKGZvcmNlVXBkYXRlSWZNb3VudGVkLCBvdGhlckluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JbnB1dDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTUlucHV0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RET01TZWxlY3QgPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0Jyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSBmYWxzZTtcblxuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBjb250ZW50ID0gJyc7XG5cbiAgLy8gRmxhdHRlbiBjaGlsZHJlbiBhbmQgd2FybiBpZiB0aGV5IGFyZW4ndCBzdHJpbmdzIG9yIG51bWJlcnM7XG4gIC8vIGludmFsaWQgdHlwZXMgYXJlIGlnbm9yZWQuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnRlbnQgKz0gY2hpbGQ7XG4gICAgfSBlbHNlIGlmICghZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbikge1xuICAgICAgZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9IHRydWU7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ09ubHkgc3RyaW5ncyBhbmQgbnVtYmVycyBhcmUgc3VwcG9ydGVkIGFzIDxvcHRpb24+IGNoaWxkcmVuLicpIDogdm9pZCAwO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8b3B0aW9uPiBob3N0IGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXG4gKi9cbnZhciBSZWFjdERPTU9wdGlvbiA9IHtcbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMsIGhvc3RQYXJlbnQpIHtcbiAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuc2VsZWN0ZWQgPT0gbnVsbCwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIC8vIExvb2sgdXAgd2hldGhlciB0aGlzIG9wdGlvbiBpcyAnc2VsZWN0ZWQnXG4gICAgdmFyIHNlbGVjdFZhbHVlID0gbnVsbDtcbiAgICBpZiAoaG9zdFBhcmVudCAhPSBudWxsKSB7XG4gICAgICB2YXIgc2VsZWN0UGFyZW50ID0gaG9zdFBhcmVudDtcblxuICAgICAgaWYgKHNlbGVjdFBhcmVudC5fdGFnID09PSAnb3B0Z3JvdXAnKSB7XG4gICAgICAgIHNlbGVjdFBhcmVudCA9IHNlbGVjdFBhcmVudC5faG9zdFBhcmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdFBhcmVudCAhPSBudWxsICYmIHNlbGVjdFBhcmVudC5fdGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgICBzZWxlY3RWYWx1ZSA9IFJlYWN0RE9NU2VsZWN0LmdldFNlbGVjdFZhbHVlQ29udGV4dChzZWxlY3RQYXJlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBudWxsIChlLmcuLCBubyBzcGVjaWZpZWQgdmFsdWUgb3IgYWZ0ZXIgaW5pdGlhbCBtb3VudClcbiAgICAvLyBvciBtaXNzaW5nIChlLmcuLCBmb3IgPGRhdGFsaXN0PiksIHdlIGRvbid0IGNoYW5nZSBwcm9wcy5zZWxlY3RlZFxuICAgIHZhciBzZWxlY3RlZCA9IG51bGw7XG4gICAgaWYgKHNlbGVjdFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIGlmIChwcm9wcy52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHZhbHVlID0gcHJvcHMudmFsdWUgKyAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gZmxhdHRlbkNoaWxkcmVuKHByb3BzLmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIHNlbGVjdGVkID0gZmFsc2U7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxlY3RWYWx1ZSkpIHtcbiAgICAgICAgLy8gbXVsdGlwbGVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICgnJyArIHNlbGVjdFZhbHVlW2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RlZCA9ICcnICsgc2VsZWN0VmFsdWUgPT09IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHsgc2VsZWN0ZWQ6IHNlbGVjdGVkIH07XG4gIH0sXG5cbiAgcG9zdE1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICAvLyB2YWx1ZT1cIlwiIHNob3VsZCBtYWtlIGEgdmFsdWUgYXR0cmlidXRlICgjNjIxOSlcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHByb3BzLnZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7IHNlbGVjdGVkOiB1bmRlZmluZWQsIGNoaWxkcmVuOiB1bmRlZmluZWQgfSwgcHJvcHMpO1xuXG4gICAgLy8gUmVhZCBzdGF0ZSBvbmx5IGZyb20gaW5pdGlhbCBtb3VudCBiZWNhdXNlIDxzZWxlY3Q+IHVwZGF0ZXMgdmFsdWVcbiAgICAvLyBtYW51YWxseTsgd2UgbmVlZCB0aGUgaW5pdGlhbCBzdGF0ZSBvbmx5IGZvciBzZXJ2ZXIgcmVuZGVyaW5nXG4gICAgaWYgKGluc3QuX3dyYXBwZXJTdGF0ZS5zZWxlY3RlZCAhPSBudWxsKSB7XG4gICAgICBob3N0UHJvcHMuc2VsZWN0ZWQgPSBpbnN0Ll93cmFwcGVyU3RhdGUuc2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRlbnQgPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgIGhvc3RQcm9wcy5jaGlsZHJlbiA9IGNvbnRlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhvc3RQcm9wcztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTU9wdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTU9wdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKCcuL0xpbmtlZFZhbHVlVXRpbHMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FyblZhbHVlTGluayA9IGZhbHNlO1xudmFyIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZvcmNlVXBkYXRlSWZNb3VudGVkKCkge1xuICBpZiAodGhpcy5fcm9vdE5vZGVJRCkge1xuICAgIC8vIERPTSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZDsgdXBkYXRlXG4gICAgUmVhY3RET01UZXh0YXJlYS51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDx0ZXh0YXJlYT4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyBgdmFsdWVgLCBhbmRcbiAqIGBkZWZhdWx0VmFsdWVgLiBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgdHJhZGl0aW9uYWwgRE9NIEFQSSBiZWNhdXNlIHZhbHVlIGlzXG4gKiB1c3VhbGx5IHNldCBhcyBQQ0RBVEEgY2hpbGRyZW4uXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgYWZmZWN0IHRoZVxuICogdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGxcbiAqIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBlbXB0eSB2YWx1ZSwgdGhlIHByb3BcbiAqIGBkZWZhdWx0VmFsdWVgIGlmIHNwZWNpZmllZCwgb3IgdGhlIGNoaWxkcmVuIGNvbnRlbnQgKGRlcHJlY2F0ZWQpLlxuICovXG52YXIgUmVhY3RET01UZXh0YXJlYSA9IHtcbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICAhKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgZG9lcyBub3QgbWFrZSBzZW5zZSBvbiA8dGV4dGFyZWE+LicpIDogX3Byb2RJbnZhcmlhbnQoJzkxJykgOiB2b2lkIDA7XG5cbiAgICAvLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuICAgIC8vIGdldCByZXNldCBpZiBgdGV4dENvbnRlbnRgIGlzIG11dGF0ZWQuICBXZSBjb3VsZCBhZGQgYSBjaGVjayBpbiBzZXRUZXh0Q29udGVudFxuICAgIC8vIHRvIG9ubHkgc2V0IHRoZSB2YWx1ZSBpZi93aGVuIHRoZSB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIG5vZGUgdmFsdWUgKHdoaWNoIHdvdWxkXG4gICAgLy8gY29tcGxldGVseSBzb2x2ZSB0aGlzIElFOSBidWcpLCBidXQgU2ViYXN0aWFuK0JlbiBzZWVtZWQgdG8gbGlrZSB0aGlzIHNvbHV0aW9uLlxuICAgIC8vIFRoZSB2YWx1ZSBjYW4gYmUgYSBib29sZWFuIG9yIG9iamVjdCBzbyB0aGF0J3Mgd2h5IGl0J3MgZm9yY2VkIHRvIGJlIGEgc3RyaW5nLlxuICAgIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgY2hpbGRyZW46ICcnICsgaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxcbiAgICAgIG9uQ2hhbmdlOiBpbnN0Ll93cmFwcGVyU3RhdGUub25DaGFuZ2VcbiAgICB9KTtcblxuICAgIHJldHVybiBob3N0UHJvcHM7XG4gIH0sXG5cbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgTGlua2VkVmFsdWVVdGlscy5jaGVja1Byb3BUeXBlcygndGV4dGFyZWEnLCBwcm9wcywgaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcbiAgICAgIGlmIChwcm9wcy52YWx1ZUxpbmsgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlTGluaykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2B2YWx1ZUxpbmtgIHByb3Agb24gYHRleHRhcmVhYCBpcyBkZXByZWNhdGVkOyBzZXQgYHZhbHVlYCBhbmQgYG9uQ2hhbmdlYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuVmFsdWVMaW5rID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsRGVmYXVsdFZhbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RleHRhcmVhIGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCB0ZXh0YXJlYSAnICsgJ2FuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblZhbERlZmF1bHRWYWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIHZhciBpbml0aWFsVmFsdWUgPSB2YWx1ZTtcblxuICAgIC8vIE9ubHkgYm90aGVyIGZldGNoaW5nIGRlZmF1bHQgdmFsdWUgaWYgd2UncmUgZ29pbmcgdG8gdXNlIGl0XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgY2hpbGRyZW4gY29udGVudCBpbiA8dGV4dGFyZWE+LlxuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gICAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJykgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgIShkZWZhdWx0VmFsdWUgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLicpIDogX3Byb2RJbnZhcmlhbnQoJzkyJykgOiB2b2lkIDA7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICEoY2hpbGRyZW4ubGVuZ3RoIDw9IDEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKSA6IF9wcm9kSW52YXJpYW50KCc5MycpIDogdm9pZCAwO1xuICAgICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW5bMF07XG4gICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0VmFsdWUgPSAnJyArIGNoaWxkcmVuO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgICAgfVxuICAgICAgaW5pdGlhbFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIGluaXRpYWxWYWx1ZTogJycgKyBpbml0aWFsVmFsdWUsXG4gICAgICBsaXN0ZW5lcnM6IG51bGwsXG4gICAgICBvbkNoYW5nZTogX2hhbmRsZUNoYW5nZS5iaW5kKGluc3QpXG4gICAgfTtcbiAgfSxcblxuICB1cGRhdGVXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICAgIHZhciBuZXdWYWx1ZSA9ICcnICsgdmFsdWU7XG5cbiAgICAgIC8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXG4gICAgICBpZiAobmV3VmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgICAgbm9kZS52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIHBvc3RNb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuICAgIC8vIGF2YWlsYWJsZSB1bnRpbCBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBtb3VudGVkLlxuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gICAgdmFyIHRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDtcblxuICAgIC8vIE9ubHkgc2V0IG5vZGUudmFsdWUgaWYgdGV4dENvbnRlbnQgaXMgZXF1YWwgdG8gdGhlIGV4cGVjdGVkXG4gICAgLy8gaW5pdGlhbCB2YWx1ZS4gSW4gSUUxMC9JRTExIHRoZXJlIGlzIGEgYnVnIHdoZXJlIHRoZSBwbGFjZWhvbGRlciBhdHRyaWJ1dGVcbiAgICAvLyB3aWxsIHBvcHVsYXRlIHRleHRDb250ZW50IGFzIHdlbGwuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTAxNTI1L1xuICAgIGlmICh0ZXh0Q29udGVudCA9PT0gaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSkge1xuICAgICAgbm9kZS52YWx1ZSA9IHRleHRDb250ZW50O1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgdmFyIHJldHVyblZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5leGVjdXRlT25DaGFuZ2UocHJvcHMsIGV2ZW50KTtcbiAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIHRoaXMpO1xuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01UZXh0YXJlYTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTVRleHRhcmVhLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RDaGlsZFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRSZWNvbmNpbGVyJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGZsYXR0ZW5DaGlsZHJlbiA9IHJlcXVpcmUoJy4vZmxhdHRlbkNoaWxkcmVuJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIG1hcmt1cCB0byBiZSByZW5kZXJlZCBhbmQgaW5zZXJ0ZWQgYXQgYSBzdXBwbGllZCBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0aGF0IHJlbmRlcnMgaW50byBhbiBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXguXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlSW5zZXJ0TWFya3VwKG1hcmt1cCwgYWZ0ZXJOb2RlLCB0b0luZGV4KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnSU5TRVJUX01BUktVUCcsXG4gICAgY29udGVudDogbWFya3VwLFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICBmcm9tTm9kZTogbnVsbCxcbiAgICB0b0luZGV4OiB0b0luZGV4LFxuICAgIGFmdGVyTm9kZTogYWZ0ZXJOb2RlXG4gIH07XG59XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIG1vdmluZyBhbiBleGlzdGluZyBlbGVtZW50IHRvIGFub3RoZXIgaW5kZXguXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBTb3VyY2UgaW5kZXggb2YgdGhlIGV4aXN0aW5nIGVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleCBvZiB0aGUgZWxlbWVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VNb3ZlKGNoaWxkLCBhZnRlck5vZGUsIHRvSW5kZXgpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdNT1ZFX0VYSVNUSU5HJyxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogY2hpbGQuX21vdW50SW5kZXgsXG4gICAgZnJvbU5vZGU6IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShjaGlsZCksXG4gICAgdG9JbmRleDogdG9JbmRleCxcbiAgICBhZnRlck5vZGU6IGFmdGVyTm9kZVxuICB9O1xufVxuXG4vKipcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciByZW1vdmluZyBhbiBlbGVtZW50IGF0IGFuIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggSW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZVJlbW92ZShjaGlsZCwgbm9kZSkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1JFTU9WRV9OT0RFJyxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogY2hpbGQuX21vdW50SW5kZXgsXG4gICAgZnJvbU5vZGU6IG5vZGUsXG4gICAgdG9JbmRleDogbnVsbCxcbiAgICBhZnRlck5vZGU6IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBNYWtlIGFuIHVwZGF0ZSBmb3Igc2V0dGluZyB0aGUgbWFya3VwIG9mIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0aGF0IHJlbmRlcnMgaW50byBhbiBlbGVtZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZVNldE1hcmt1cChtYXJrdXApIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdTRVRfTUFSS1VQJyxcbiAgICBjb250ZW50OiBtYXJrdXAsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIGZyb21Ob2RlOiBudWxsLFxuICAgIHRvSW5kZXg6IG51bGwsXG4gICAgYWZ0ZXJOb2RlOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIHNldHRpbmcgdGhlIHRleHQgY29udGVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dENvbnRlbnQgVGV4dCBjb250ZW50IHRvIHNldC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VUZXh0Q29udGVudCh0ZXh0Q29udGVudCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1RFWFRfQ09OVEVOVCcsXG4gICAgY29udGVudDogdGV4dENvbnRlbnQsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIGZyb21Ob2RlOiBudWxsLFxuICAgIHRvSW5kZXg6IG51bGwsXG4gICAgYWZ0ZXJOb2RlOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogUHVzaCBhbiB1cGRhdGUsIGlmIGFueSwgb250byB0aGUgcXVldWUuIENyZWF0ZXMgYSBuZXcgcXVldWUgaWYgbm9uZSBpc1xuICogcGFzc2VkIGFuZCBhbHdheXMgcmV0dXJucyB0aGUgcXVldWUuIE11dGF0aXZlLlxuICovXG5mdW5jdGlvbiBlbnF1ZXVlKHF1ZXVlLCB1cGRhdGUpIHtcbiAgaWYgKHVwZGF0ZSkge1xuICAgIHF1ZXVlID0gcXVldWUgfHwgW107XG4gICAgcXVldWUucHVzaCh1cGRhdGUpO1xuICB9XG4gIHJldHVybiBxdWV1ZTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzZXMgYW55IGVucXVldWVkIHVwZGF0ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc1F1ZXVlKGluc3QsIHVwZGF0ZVF1ZXVlKSB7XG4gIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyhpbnN0LCB1cGRhdGVRdWV1ZSk7XG59XG5cbnZhciBzZXRDaGlsZHJlbkZvckluc3RydW1lbnRhdGlvbiA9IGVtcHR5RnVuY3Rpb247XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgZ2V0RGVidWdJRCA9IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgaWYgKCFpbnN0Ll9kZWJ1Z0lEKSB7XG4gICAgICAvLyBDaGVjayBmb3IgQVJULWxpa2UgaW5zdGFuY2VzLiBUT0RPOiBUaGlzIGlzIHNpbGx5L2dyb3NzLlxuICAgICAgdmFyIGludGVybmFsO1xuICAgICAgaWYgKGludGVybmFsID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQoaW5zdCkpIHtcbiAgICAgICAgaW5zdCA9IGludGVybmFsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zdC5fZGVidWdJRDtcbiAgfTtcbiAgc2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24gPSBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcbiAgICB2YXIgZGVidWdJRCA9IGdldERlYnVnSUQodGhpcyk7XG4gICAgLy8gVE9ETzogUmVhY3QgTmF0aXZlIGVtcHR5IGNvbXBvbmVudHMgYXJlIGFsc28gbXVsdGljaGlsZC5cbiAgICAvLyBUaGlzIG1lYW5zIHRoZXkgc3RpbGwgZ2V0IGludG8gdGhpcyBtZXRob2QgYnV0IGRvbid0IGhhdmUgX2RlYnVnSUQuXG4gICAgaWYgKGRlYnVnSUQgIT09IDApIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKGRlYnVnSUQsIGNoaWxkcmVuID8gT2JqZWN0LmtleXMoY2hpbGRyZW4pLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbltrZXldLl9kZWJ1Z0lEO1xuICAgICAgfSkgOiBbXSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFJlYWN0TXVsdGlDaGlsZCBhcmUgY2FwYWJsZSBvZiByZWNvbmNpbGluZyBtdWx0aXBsZSBjaGlsZHJlbi5cbiAqXG4gKiBAY2xhc3MgUmVhY3RNdWx0aUNoaWxkXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0TXVsdGlDaGlsZCA9IHtcbiAgLyoqXG4gICAqIFByb3ZpZGVzIGNvbW1vbiBmdW5jdGlvbmFsaXR5IGZvciBjb21wb25lbnRzIHRoYXQgbXVzdCByZWNvbmNpbGUgbXVsdGlwbGVcbiAgICogY2hpbGRyZW4uIFRoaXMgaXMgdXNlZCBieSBgUmVhY3RET01Db21wb25lbnRgIHRvIG1vdW50LCB1cGRhdGUsIGFuZFxuICAgKiB1bm1vdW50IGNoaWxkIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEBsZW5kcyB7UmVhY3RNdWx0aUNoaWxkLnByb3RvdHlwZX1cbiAgICovXG4gIE1peGluOiB7XG4gICAgX3JlY29uY2lsZXJJbnN0YW50aWF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgc2VsZkRlYnVnSUQgPSBnZXREZWJ1Z0lEKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdENoaWxkUmVjb25jaWxlci5pbnN0YW50aWF0ZUNoaWxkcmVuKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWFjdENoaWxkUmVjb25jaWxlci5pbnN0YW50aWF0ZUNoaWxkcmVuKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIF9yZWNvbmNpbGVyVXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChwcmV2Q2hpbGRyZW4sIG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdmFyIG5leHRDaGlsZHJlbjtcbiAgICAgIHZhciBzZWxmRGVidWdJRCA9IDA7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBzZWxmRGVidWdJRCA9IGdldERlYnVnSUQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgbmV4dENoaWxkcmVuID0gZmxhdHRlbkNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCBzZWxmRGVidWdJRCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51cGRhdGVDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIHRoaXMsIHRoaXMuX2hvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XG4gICAgICAgICAgcmV0dXJuIG5leHRDaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV4dENoaWxkcmVuID0gZmxhdHRlbkNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCBzZWxmRGVidWdJRCk7XG4gICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51cGRhdGVDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIHRoaXMsIHRoaXMuX2hvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XG4gICAgICByZXR1cm4gbmV4dENoaWxkcmVuO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBcIm1vdW50IGltYWdlXCIgZm9yIGVhY2ggb2YgdGhlIHN1cHBsaWVkIGNoaWxkcmVuLiBJbiB0aGUgY2FzZVxuICAgICAqIG9mIGBSZWFjdERPTUNvbXBvbmVudGAsIGEgbW91bnQgaW1hZ2UgaXMgYSBzdHJpbmcgb2YgbWFya3VwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXN0ZWRDaGlsZHJlbiBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gQW4gYXJyYXkgb2YgbW91bnRlZCByZXByZXNlbnRhdGlvbnMuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgbW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fcmVjb25jaWxlckluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBjaGlsZHJlbjtcblxuICAgICAgdmFyIG1vdW50SW1hZ2VzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBjaGlsZHJlbikge1xuICAgICAgICBpZiAoY2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltuYW1lXTtcbiAgICAgICAgICB2YXIgc2VsZkRlYnVnSUQgPSAwO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBzZWxmRGVidWdJRCA9IGdldERlYnVnSUQodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtb3VudEltYWdlID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KGNoaWxkLCB0cmFuc2FjdGlvbiwgdGhpcywgdGhpcy5faG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgICAgICBjaGlsZC5fbW91bnRJbmRleCA9IGluZGV4Kys7XG4gICAgICAgICAgbW91bnRJbWFnZXMucHVzaChtb3VudEltYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBzZXRDaGlsZHJlbkZvckluc3RydW1lbnRhdGlvbi5jYWxsKHRoaXMsIGNoaWxkcmVuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1vdW50SW1hZ2VzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbnkgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIHRleHQgY29udGVudCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV4dENvbnRlbnQgU3RyaW5nIG9mIGNvbnRlbnQuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlVGV4dENvbnRlbnQ6IGZ1bmN0aW9uIChuZXh0Q29udGVudCkge1xuICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICAvLyBSZW1vdmUgYW55IHJlbmRlcmVkIGNoaWxkcmVuLlxuICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHByZXZDaGlsZHJlbiwgZmFsc2UpO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd1cGRhdGVUZXh0Q29udGVudCBjYWxsZWQgb24gbm9uLWVtcHR5IGNvbXBvbmVudC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMTgnKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gU2V0IG5ldyB0ZXh0IGNvbnRlbnQuXG4gICAgICB2YXIgdXBkYXRlcyA9IFttYWtlVGV4dENvbnRlbnQobmV4dENvbnRlbnQpXTtcbiAgICAgIHByb2Nlc3NRdWV1ZSh0aGlzLCB1cGRhdGVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYW55IHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBtYXJrdXAgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5leHRNYXJrdXAgU3RyaW5nIG9mIG1hcmt1cC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVNYXJrdXA6IGZ1bmN0aW9uIChuZXh0TWFya3VwKSB7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIC8vIFJlbW92ZSBhbnkgcmVuZGVyZWQgY2hpbGRyZW4uXG4gICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCBmYWxzZSk7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZVRleHRDb250ZW50IGNhbGxlZCBvbiBub24tZW1wdHkgY29tcG9uZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzExOCcpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgdXBkYXRlcyA9IFttYWtlU2V0TWFya3VwKG5leHRNYXJrdXApXTtcbiAgICAgIHByb2Nlc3NRdWV1ZSh0aGlzLCB1cGRhdGVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBuZXcgY2hpbGRyZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzIE5lc3RlZCBjaGlsZCBlbGVtZW50IG1hcHMuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICAvLyBIb29rIHVzZWQgYnkgUmVhY3QgQVJUXG4gICAgICB0aGlzLl91cGRhdGVDaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzIE5lc3RlZCBjaGlsZCBlbGVtZW50IG1hcHMuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBmaW5hbFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgdmFyIHJlbW92ZWROb2RlcyA9IHt9O1xuICAgICAgdmFyIG1vdW50SW1hZ2VzID0gW107XG4gICAgICB2YXIgbmV4dENoaWxkcmVuID0gdGhpcy5fcmVjb25jaWxlclVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIG1vdW50SW1hZ2VzLCByZW1vdmVkTm9kZXMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgIGlmICghbmV4dENoaWxkcmVuICYmICFwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHVwZGF0ZXMgPSBudWxsO1xuICAgICAgdmFyIG5hbWU7XG4gICAgICAvLyBgbmV4dEluZGV4YCB3aWxsIGluY3JlbWVudCBmb3IgZWFjaCBjaGlsZCBpbiBgbmV4dENoaWxkcmVuYCwgYnV0XG4gICAgICAvLyBgbGFzdEluZGV4YCB3aWxsIGJlIHRoZSBsYXN0IGluZGV4IHZpc2l0ZWQgaW4gYHByZXZDaGlsZHJlbmAuXG4gICAgICB2YXIgbmV4dEluZGV4ID0gMDtcbiAgICAgIHZhciBsYXN0SW5kZXggPSAwO1xuICAgICAgLy8gYG5leHRNb3VudEluZGV4YCB3aWxsIGluY3JlbWVudCBmb3IgZWFjaCBuZXdseSBtb3VudGVkIGNoaWxkLlxuICAgICAgdmFyIG5leHRNb3VudEluZGV4ID0gMDtcbiAgICAgIHZhciBsYXN0UGxhY2VkTm9kZSA9IG51bGw7XG4gICAgICBmb3IgKG5hbWUgaW4gbmV4dENoaWxkcmVuKSB7XG4gICAgICAgIGlmICghbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZDaGlsZCA9IHByZXZDaGlsZHJlbiAmJiBwcmV2Q2hpbGRyZW5bbmFtZV07XG4gICAgICAgIHZhciBuZXh0Q2hpbGQgPSBuZXh0Q2hpbGRyZW5bbmFtZV07XG4gICAgICAgIGlmIChwcmV2Q2hpbGQgPT09IG5leHRDaGlsZCkge1xuICAgICAgICAgIHVwZGF0ZXMgPSBlbnF1ZXVlKHVwZGF0ZXMsIHRoaXMubW92ZUNoaWxkKHByZXZDaGlsZCwgbGFzdFBsYWNlZE5vZGUsIG5leHRJbmRleCwgbGFzdEluZGV4KSk7XG4gICAgICAgICAgbGFzdEluZGV4ID0gTWF0aC5tYXgocHJldkNoaWxkLl9tb3VudEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgICAgIHByZXZDaGlsZC5fbW91bnRJbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocHJldkNoaWxkKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgYGxhc3RJbmRleGAgYmVmb3JlIGBfbW91bnRJbmRleGAgZ2V0cyB1bnNldCBieSB1bm1vdW50aW5nLlxuICAgICAgICAgICAgbGFzdEluZGV4ID0gTWF0aC5tYXgocHJldkNoaWxkLl9tb3VudEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgICAgICAgLy8gVGhlIGByZW1vdmVkTm9kZXNgIGxvb3AgYmVsb3cgd2lsbCBhY3R1YWxseSByZW1vdmUgdGhlIGNoaWxkLlxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUaGUgY2hpbGQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgYmVmb3JlIGl0J3MgbW91bnRlZC5cbiAgICAgICAgICB1cGRhdGVzID0gZW5xdWV1ZSh1cGRhdGVzLCB0aGlzLl9tb3VudENoaWxkQXRJbmRleChuZXh0Q2hpbGQsIG1vdW50SW1hZ2VzW25leHRNb3VudEluZGV4XSwgbGFzdFBsYWNlZE5vZGUsIG5leHRJbmRleCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpKTtcbiAgICAgICAgICBuZXh0TW91bnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIG5leHRJbmRleCsrO1xuICAgICAgICBsYXN0UGxhY2VkTm9kZSA9IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShuZXh0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGNoaWxkcmVuIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LlxuICAgICAgZm9yIChuYW1lIGluIHJlbW92ZWROb2Rlcykge1xuICAgICAgICBpZiAocmVtb3ZlZE5vZGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdXBkYXRlcyA9IGVucXVldWUodXBkYXRlcywgdGhpcy5fdW5tb3VudENoaWxkKHByZXZDaGlsZHJlbltuYW1lXSwgcmVtb3ZlZE5vZGVzW25hbWVdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh1cGRhdGVzKSB7XG4gICAgICAgIHByb2Nlc3NRdWV1ZSh0aGlzLCB1cGRhdGVzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBuZXh0Q2hpbGRyZW47XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgbmV4dENoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5tb3VudHMgYWxsIHJlbmRlcmVkIGNoaWxkcmVuLiBUaGlzIHNob3VsZCBiZSB1c2VkIHRvIGNsZWFuIHVwIGNoaWxkcmVuXG4gICAgICogd2hlbiB0aGlzIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuIEl0IGRvZXMgbm90IGFjdHVhbGx5IHBlcmZvcm0gYW55XG4gICAgICogYmFja2VuZCBvcGVyYXRpb25zLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdW5tb3VudENoaWxkcmVuOiBmdW5jdGlvbiAoc2FmZWx5KSB7XG4gICAgICB2YXIgcmVuZGVyZWRDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51bm1vdW50Q2hpbGRyZW4ocmVuZGVyZWRDaGlsZHJlbiwgc2FmZWx5KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhIGNoaWxkIGNvbXBvbmVudCB0byB0aGUgc3VwcGxpZWQgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gbW92ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleCBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFzdEluZGV4IExhc3QgaW5kZXggdmlzaXRlZCBvZiB0aGUgc2libGluZ3Mgb2YgYGNoaWxkYC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgbW92ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIGFmdGVyTm9kZSwgdG9JbmRleCwgbGFzdEluZGV4KSB7XG4gICAgICAvLyBJZiB0aGUgaW5kZXggb2YgYGNoaWxkYCBpcyBsZXNzIHRoYW4gYGxhc3RJbmRleGAsIHRoZW4gaXQgbmVlZHMgdG9cbiAgICAgIC8vIGJlIG1vdmVkLiBPdGhlcndpc2UsIHdlIGRvIG5vdCBuZWVkIHRvIG1vdmUgaXQgYmVjYXVzZSBhIGNoaWxkIHdpbGwgYmVcbiAgICAgIC8vIGluc2VydGVkIG9yIG1vdmVkIGJlZm9yZSBgY2hpbGRgLlxuICAgICAgaWYgKGNoaWxkLl9tb3VudEluZGV4IDwgbGFzdEluZGV4KSB7XG4gICAgICAgIHJldHVybiBtYWtlTW92ZShjaGlsZCwgYWZ0ZXJOb2RlLCB0b0luZGV4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNoaWxkIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBjcmVhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vdW50SW1hZ2UgTWFya3VwIHRvIGluc2VydC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgYWZ0ZXJOb2RlLCBtb3VudEltYWdlKSB7XG4gICAgICByZXR1cm4gbWFrZUluc2VydE1hcmt1cChtb3VudEltYWdlLCBhZnRlck5vZGUsIGNoaWxkLl9tb3VudEluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNoaWxkIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENoaWxkIHRvIHJlbW92ZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgbm9kZSkge1xuICAgICAgcmV0dXJuIG1ha2VSZW1vdmUoY2hpbGQsIG5vZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3VudHMgYSBjaGlsZCB3aXRoIHRoZSBzdXBwbGllZCBuYW1lLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBpcyBwYXJ0IG9mIGB1cGRhdGVDaGlsZHJlbmAgYW5kIGlzIGhlcmUgZm9yIHJlYWRhYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIG1vdW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGNoaWxkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGNoaWxkLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tb3VudENoaWxkQXRJbmRleDogZnVuY3Rpb24gKGNoaWxkLCBtb3VudEltYWdlLCBhZnRlck5vZGUsIGluZGV4LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBpbmRleDtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUNoaWxkKGNoaWxkLCBhZnRlck5vZGUsIG1vdW50SW1hZ2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbm1vdW50cyBhIHJlbmRlcmVkIGNoaWxkLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBpcyBwYXJ0IG9mIGB1cGRhdGVDaGlsZHJlbmAgYW5kIGlzIGhlcmUgZm9yIHJlYWRhYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIHVubW91bnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdW5tb3VudENoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIG5vZGUpIHtcbiAgICAgIHZhciB1cGRhdGUgPSB0aGlzLnJlbW92ZUNoaWxkKGNoaWxkLCBub2RlKTtcbiAgICAgIGNoaWxkLl9tb3VudEluZGV4ID0gbnVsbDtcbiAgICAgIHJldHVybiB1cGRhdGU7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TXVsdGlDaGlsZDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdE11bHRpQ2hpbGQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcblxudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciBLZXlFc2NhcGVVdGlscyA9IHJlcXVpcmUoJy4vS2V5RXNjYXBlVXRpbHMnKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0Jykge1xuICAvLyBUZW1wb3JhcnkgaGFjay5cbiAgLy8gSW5saW5lIHJlcXVpcmVzIGRvbid0IHdvcmsgd2VsbCB3aXRoIEplc3Q6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI0MFxuICAvLyBSZW1vdmUgdGhlIGlubGluZSByZXF1aXJlcyB3aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBhbnltb3JlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTc4XG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xufVxuXG5mdW5jdGlvbiBpbnN0YW50aWF0ZUNoaWxkKGNoaWxkSW5zdGFuY2VzLCBjaGlsZCwgbmFtZSwgc2VsZkRlYnVnSUQpIHtcbiAgLy8gV2UgZm91bmQgYSBjb21wb25lbnQgaW5zdGFuY2UuXG4gIHZhciBrZXlVbmlxdWUgPSBjaGlsZEluc3RhbmNlc1tuYW1lXSA9PT0gdW5kZWZpbmVkO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICghUmVhY3RDb21wb25lbnRUcmVlSG9vaykge1xuICAgICAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG4gICAgfVxuICAgIGlmICgha2V5VW5pcXVlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2ZsYXR0ZW5DaGlsZHJlbiguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksICcgKyAnYCVzYC4gQ2hpbGQga2V5cyBtdXN0IGJlIHVuaXF1ZTsgd2hlbiB0d28gY2hpbGRyZW4gc2hhcmUgYSBrZXksIG9ubHkgJyArICd0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSB1c2VkLiVzJywgS2V5RXNjYXBlVXRpbHMudW5lc2NhcGUobmFtZSksIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoc2VsZkRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgaWYgKGNoaWxkICE9IG51bGwgJiYga2V5VW5pcXVlKSB7XG4gICAgY2hpbGRJbnN0YW5jZXNbbmFtZV0gPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KGNoaWxkLCB0cnVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlYWN0Q2hpbGRSZWNvbmNpbGVyIHByb3ZpZGVzIGhlbHBlcnMgZm9yIGluaXRpYWxpemluZyBvciB1cGRhdGluZyBhIHNldCBvZlxuICogY2hpbGRyZW4uIEl0cyBvdXRwdXQgaXMgc3VpdGFibGUgZm9yIHBhc3NpbmcgaXQgb250byBSZWFjdE11bHRpQ2hpbGQgd2hpY2hcbiAqIGRvZXMgZGlmZmVkIHJlb3JkZXJpbmcgYW5kIGluc2VydGlvbi5cbiAqL1xudmFyIFJlYWN0Q2hpbGRSZWNvbmNpbGVyID0ge1xuICAvKipcbiAgICogR2VuZXJhdGVzIGEgXCJtb3VudCBpbWFnZVwiIGZvciBlYWNoIG9mIHRoZSBzdXBwbGllZCBjaGlsZHJlbi4gSW4gdGhlIGNhc2VcbiAgICogb2YgYFJlYWN0RE9NQ29tcG9uZW50YCwgYSBtb3VudCBpbWFnZSBpcyBhIHN0cmluZyBvZiBtYXJrdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmVzdGVkQ2hpbGROb2RlcyBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICogQHJldHVybiB7P29iamVjdH0gQSBzZXQgb2YgY2hpbGQgaW5zdGFuY2VzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGluc3RhbnRpYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZE5vZGVzLCB0cmFuc2FjdGlvbiwgY29udGV4dCwgc2VsZkRlYnVnSUQpIC8vIDAgaW4gcHJvZHVjdGlvbiBhbmQgZm9yIHJvb3RzXG4gIHtcbiAgICBpZiAobmVzdGVkQ2hpbGROb2RlcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGNoaWxkSW5zdGFuY2VzID0ge307XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdHJhdmVyc2VBbGxDaGlsZHJlbihuZXN0ZWRDaGlsZE5vZGVzLCBmdW5jdGlvbiAoY2hpbGRJbnN0cywgY2hpbGQsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbnRpYXRlQ2hpbGQoY2hpbGRJbnN0cywgY2hpbGQsIG5hbWUsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgIH0sIGNoaWxkSW5zdGFuY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhdmVyc2VBbGxDaGlsZHJlbihuZXN0ZWRDaGlsZE5vZGVzLCBpbnN0YW50aWF0ZUNoaWxkLCBjaGlsZEluc3RhbmNlcyk7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZEluc3RhbmNlcztcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcmVuZGVyZWQgY2hpbGRyZW4gYW5kIHJldHVybnMgYSBuZXcgc2V0IG9mIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZDaGlsZHJlbiBQcmV2aW91c2x5IGluaXRpYWxpemVkIHNldCBvZiBjaGlsZHJlbi5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q2hpbGRyZW4gRmxhdCBjaGlsZCBlbGVtZW50IG1hcHMuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P29iamVjdH0gQSBuZXcgc2V0IG9mIGNoaWxkIGluc3RhbmNlcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKSAvLyAwIGluIHByb2R1Y3Rpb24gYW5kIGZvciByb290c1xuICB7XG4gICAgLy8gV2UgY3VycmVudGx5IGRvbid0IGhhdmUgYSB3YXkgdG8gdHJhY2sgbW92ZXMgaGVyZSBidXQgaWYgd2UgdXNlIGl0ZXJhdG9yc1xuICAgIC8vIGluc3RlYWQgb2YgZm9yLi5pbiB3ZSBjYW4gemlwIHRoZSBpdGVyYXRvcnMgYW5kIGNoZWNrIGlmIGFuIGl0ZW0gaGFzXG4gICAgLy8gbW92ZWQuXG4gICAgLy8gVE9ETzogSWYgbm90aGluZyBoYXMgY2hhbmdlZCwgcmV0dXJuIHRoZSBwcmV2Q2hpbGRyZW4gb2JqZWN0IHNvIHRoYXQgd2VcbiAgICAvLyBjYW4gcXVpY2tseSBiYWlsb3V0IGlmIG5vdGhpbmcgaGFzIGNoYW5nZWQuXG4gICAgaWYgKCFuZXh0Q2hpbGRyZW4gJiYgIXByZXZDaGlsZHJlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmFtZTtcbiAgICB2YXIgcHJldkNoaWxkO1xuICAgIGZvciAobmFtZSBpbiBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIGlmICghbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcHJldkNoaWxkID0gcHJldkNoaWxkcmVuICYmIHByZXZDaGlsZHJlbltuYW1lXTtcbiAgICAgIHZhciBwcmV2RWxlbWVudCA9IHByZXZDaGlsZCAmJiBwcmV2Q2hpbGQuX2N1cnJlbnRFbGVtZW50O1xuICAgICAgdmFyIG5leHRFbGVtZW50ID0gbmV4dENoaWxkcmVuW25hbWVdO1xuICAgICAgaWYgKHByZXZDaGlsZCAhPSBudWxsICYmIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkpIHtcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQocHJldkNoaWxkLCBuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICBuZXh0Q2hpbGRyZW5bbmFtZV0gPSBwcmV2Q2hpbGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJldkNoaWxkKSB7XG4gICAgICAgICAgcmVtb3ZlZE5vZGVzW25hbWVdID0gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKHByZXZDaGlsZCk7XG4gICAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNoaWxkLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGNoaWxkIG11c3QgYmUgaW5zdGFudGlhdGVkIGJlZm9yZSBpdCdzIG1vdW50ZWQuXG4gICAgICAgIHZhciBuZXh0Q2hpbGRJbnN0YW5jZSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dEVsZW1lbnQsIHRydWUpO1xuICAgICAgICBuZXh0Q2hpbGRyZW5bbmFtZV0gPSBuZXh0Q2hpbGRJbnN0YW5jZTtcbiAgICAgICAgLy8gQ3JlYXRpbmcgbW91bnQgaW1hZ2Ugbm93IGVuc3VyZXMgcmVmcyBhcmUgcmVzb2x2ZWQgaW4gcmlnaHQgb3JkZXJcbiAgICAgICAgLy8gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTAxIGZvciBleHBsYW5hdGlvbikuXG4gICAgICAgIHZhciBuZXh0Q2hpbGRNb3VudEltYWdlID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KG5leHRDaGlsZEluc3RhbmNlLCB0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgICAgbW91bnRJbWFnZXMucHVzaChuZXh0Q2hpbGRNb3VudEltYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gVW5tb3VudCBjaGlsZHJlbiB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudC5cbiAgICBmb3IgKG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpICYmICEobmV4dENoaWxkcmVuICYmIG5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkpIHtcbiAgICAgICAgcHJldkNoaWxkID0gcHJldkNoaWxkcmVuW25hbWVdO1xuICAgICAgICByZW1vdmVkTm9kZXNbbmFtZV0gPSBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUocHJldkNoaWxkKTtcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNoaWxkLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVbm1vdW50cyBhbGwgcmVuZGVyZWQgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIHVzZWQgdG8gY2xlYW4gdXAgY2hpbGRyZW5cbiAgICogd2hlbiB0aGlzIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcmVuZGVyZWRDaGlsZHJlbiBQcmV2aW91c2x5IGluaXRpYWxpemVkIHNldCBvZiBjaGlsZHJlbi5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uIChyZW5kZXJlZENoaWxkcmVuLCBzYWZlbHkpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHJlbmRlcmVkQ2hpbGRyZW4pIHtcbiAgICAgIGlmIChyZW5kZXJlZENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHZhciByZW5kZXJlZENoaWxkID0gcmVuZGVyZWRDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocmVuZGVyZWRDaGlsZCwgc2FmZWx5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDaGlsZFJlY29uY2lsZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RDaGlsZFJlY29uY2lsZXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdCcpO1xudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RXJyb3JVdGlscyA9IHJlcXVpcmUoJy4vUmVhY3RFcnJvclV0aWxzJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0Tm9kZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE5vZGVUeXBlcycpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBjaGVja1JlYWN0VHlwZVNwZWMgPSByZXF1aXJlKCcuL2NoZWNrUmVhY3RUeXBlU3BlYycpO1xufVxuXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBDb21wb3NpdGVUeXBlcyA9IHtcbiAgSW1wdXJlQ2xhc3M6IDAsXG4gIFB1cmVDbGFzczogMSxcbiAgU3RhdGVsZXNzRnVuY3Rpb25hbDogMlxufTtcblxuZnVuY3Rpb24gU3RhdGVsZXNzQ29tcG9uZW50KENvbXBvbmVudCkge31cblN0YXRlbGVzc0NvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgQ29tcG9uZW50ID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQodGhpcykuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gIHZhciBlbGVtZW50ID0gQ29tcG9uZW50KHRoaXMucHJvcHMsIHRoaXMuY29udGV4dCwgdGhpcy51cGRhdGVyKTtcbiAgd2FybklmSW52YWxpZEVsZW1lbnQoQ29tcG9uZW50LCBlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5mdW5jdGlvbiB3YXJuSWZJbnZhbGlkRWxlbWVudChDb21wb25lbnQsIGVsZW1lbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IGZhbHNlIHx8IFJlYWN0LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpLCAnJXMoLi4uKTogQSB2YWxpZCBSZWFjdCBlbGVtZW50IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiBZb3UgbWF5IGhhdmUgJyArICdyZXR1cm5lZCB1bmRlZmluZWQsIGFuIGFycmF5IG9yIHNvbWUgb3RoZXIgaW52YWxpZCBvYmplY3QuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzLCAnJXMoLi4uKTogY2hpbGRDb250ZXh0VHlwZXMgY2Fubm90IGJlIGRlZmluZWQgb24gYSBmdW5jdGlvbmFsIGNvbXBvbmVudC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgcmV0dXJuICEhKENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gaXNQdXJlQ29tcG9uZW50KENvbXBvbmVudCkge1xuICByZXR1cm4gISEoQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KTtcbn1cblxuLy8gU2VwYXJhdGVkIGludG8gYSBmdW5jdGlvbiB0byBjb250YWluIGRlb3B0aW1pemF0aW9ucyBjYXVzZWQgYnkgdHJ5L2ZpbmFsbHkuXG5mdW5jdGlvbiBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmbiwgZGVidWdJRCwgdGltZXJUeXBlKSB7XG4gIGlmIChkZWJ1Z0lEID09PSAwKSB7XG4gICAgLy8gVG9wLWxldmVsIHdyYXBwZXJzIChzZWUgUmVhY3RNb3VudCkgYW5kIGVtcHR5IGNvbXBvbmVudHMgKHNlZVxuICAgIC8vIFJlYWN0RE9NRW1wdHlDb21wb25lbnQpIGFyZSBpbnZpc2libGUgdG8gaG9va3MgYW5kIGRldnRvb2xzLlxuICAgIC8vIEJvdGggYXJlIGltcGxlbWVudGF0aW9uIGRldGFpbHMgdGhhdCBzaG91bGQgZ28gYXdheSBpbiB0aGUgZnV0dXJlLlxuICAgIHJldHVybiBmbigpO1xuICB9XG5cbiAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICB0cnkge1xuICAgIHJldHVybiBmbigpO1xuICB9IGZpbmFsbHkge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0gVGhlIExpZmUtQ3ljbGUgb2YgYSBDb21wb3NpdGUgQ29tcG9uZW50IC0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIC0gY29uc3RydWN0b3I6IEluaXRpYWxpemF0aW9uIG9mIHN0YXRlLiBUaGUgaW5zdGFuY2UgaXMgbm93IHJldGFpbmVkLlxuICogICAtIGNvbXBvbmVudFdpbGxNb3VudFxuICogICAtIHJlbmRlclxuICogICAtIFtjaGlsZHJlbidzIGNvbnN0cnVjdG9yc11cbiAqICAgICAtIFtjaGlsZHJlbidzIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgcmVuZGVyXVxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50RGlkTW91bnRdXG4gKiAgICAgLSBjb21wb25lbnREaWRNb3VudFxuICpcbiAqICAgICAgIFVwZGF0ZSBQaGFzZXM6XG4gKiAgICAgICAtIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgKG9ubHkgY2FsbGVkIGlmIHBhcmVudCB1cGRhdGVkKVxuICogICAgICAgLSBzaG91bGRDb21wb25lbnRVcGRhdGVcbiAqICAgICAgICAgLSBjb21wb25lbnRXaWxsVXBkYXRlXG4gKiAgICAgICAgICAgLSByZW5kZXJcbiAqICAgICAgICAgICAtIFtjaGlsZHJlbidzIGNvbnN0cnVjdG9ycyBvciByZWNlaXZlIHByb3BzIHBoYXNlc11cbiAqICAgICAgICAgLSBjb21wb25lbnREaWRVcGRhdGVcbiAqXG4gKiAgICAgLSBjb21wb25lbnRXaWxsVW5tb3VudFxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50V2lsbFVubW91bnRdXG4gKiAgIC0gW2NoaWxkcmVuIGRlc3Ryb3llZF1cbiAqIC0gKGRlc3Ryb3llZCk6IFRoZSBpbnN0YW5jZSBpcyBub3cgYmxhbmssIHJlbGVhc2VkIGJ5IFJlYWN0IGFuZCByZWFkeSBmb3IgR0MuXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4vKipcbiAqIEFuIGluY3JlbWVudGluZyBJRCBhc3NpZ25lZCB0byBlYWNoIGNvbXBvbmVudCB3aGVuIGl0IGlzIG1vdW50ZWQuIFRoaXMgaXNcbiAqIHVzZWQgdG8gZW5mb3JjZSB0aGUgb3JkZXIgaW4gd2hpY2ggYFJlYWN0VXBkYXRlc2AgdXBkYXRlcyBkaXJ0eSBjb21wb25lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBuZXh0TW91bnRJRCA9IDE7XG5cbi8qKlxuICogQGxlbmRzIHtSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5wcm90b3R5cGV9XG4gKi9cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHtcbiAgLyoqXG4gICAqIEJhc2UgY29uc3RydWN0b3IgZm9yIGFsbCBjb21wb3NpdGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSAwO1xuICAgIHRoaXMuX2NvbXBvc2l0ZVR5cGUgPSBudWxsO1xuICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICB0aGlzLl9ob3N0UGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IG51bGw7XG5cbiAgICAvLyBTZWUgUmVhY3RVcGRhdGVRdWV1ZVxuICAgIHRoaXMuX3VwZGF0ZUJhdGNoTnVtYmVyID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuICAgIHRoaXMuX3JlbmRlcmVkTm9kZVR5cGUgPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gbnVsbDtcbiAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9tb3VudE9yZGVyID0gMDtcbiAgICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xuXG4gICAgLy8gU2VlIFJlYWN0VXBkYXRlcyBhbmQgUmVhY3RVcGRhdGVRdWV1ZS5cbiAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcblxuICAgIC8vIENvbXBvbmVudFdpbGxVbm1vdW50IHNoYWxsIG9ubHkgYmUgY2FsbGVkIG9uY2VcbiAgICB0aGlzLl9jYWxsZWRDb21wb25lbnRXaWxsVW5tb3VudCA9IGZhbHNlO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRoaXMuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY29tcG9uZW50LCByZW5kZXJzIG1hcmt1cCwgYW5kIHJlZ2lzdGVycyBldmVudCBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9vYmplY3R9IGhvc3RQYXJlbnRcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBob3N0Q29udGFpbmVySW5mb1xuICAgKiBAcGFyYW0gez9vYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P3N0cmluZ30gUmVuZGVyZWQgbWFya3VwIHRvIGJlIGluc2VydGVkIGludG8gdGhlIERPTS5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5fbW91bnRPcmRlciA9IG5leHRNb3VudElEKys7XG4gICAgdGhpcy5faG9zdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBob3N0Q29udGFpbmVySW5mbztcblxuICAgIHZhciBwdWJsaWNQcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIHZhciBwdWJsaWNDb250ZXh0ID0gdGhpcy5fcHJvY2Vzc0NvbnRleHQoY29udGV4dCk7XG5cbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcblxuICAgIHZhciB1cGRhdGVRdWV1ZSA9IHRyYW5zYWN0aW9uLmdldFVwZGF0ZVF1ZXVlKCk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBwdWJsaWMgY2xhc3NcbiAgICB2YXIgZG9Db25zdHJ1Y3QgPSBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KTtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2NvbnN0cnVjdENvbXBvbmVudChkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICB2YXIgcmVuZGVyZWRFbGVtZW50O1xuXG4gICAgLy8gU3VwcG9ydCBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgICBpZiAoIWRvQ29uc3RydWN0ICYmIChpbnN0ID09IG51bGwgfHwgaW5zdC5yZW5kZXIgPT0gbnVsbCkpIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IGluc3Q7XG4gICAgICB3YXJuSWZJbnZhbGlkRWxlbWVudChDb21wb25lbnQsIHJlbmRlcmVkRWxlbWVudCk7XG4gICAgICAhKGluc3QgPT09IG51bGwgfHwgaW5zdCA9PT0gZmFsc2UgfHwgUmVhY3QuaXNWYWxpZEVsZW1lbnQoaW5zdCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzKC4uLik6IEEgdmFsaWQgUmVhY3QgZWxlbWVudCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gWW91IG1heSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZCwgYW4gYXJyYXkgb3Igc29tZSBvdGhlciBpbnZhbGlkIG9iamVjdC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEwNScsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBpbnN0ID0gbmV3IFN0YXRlbGVzc0NvbXBvbmVudChDb21wb25lbnQpO1xuICAgICAgdGhpcy5fY29tcG9zaXRlVHlwZSA9IENvbXBvc2l0ZVR5cGVzLlN0YXRlbGVzc0Z1bmN0aW9uYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1B1cmVDb21wb25lbnQoQ29tcG9uZW50KSkge1xuICAgICAgICB0aGlzLl9jb21wb3NpdGVUeXBlID0gQ29tcG9zaXRlVHlwZXMuUHVyZUNsYXNzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY29tcG9zaXRlVHlwZSA9IENvbXBvc2l0ZVR5cGVzLkltcHVyZUNsYXNzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgbGF0ZXIgaW4gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCwgYnV0IGFkZCBhbiBlYXJseVxuICAgICAgLy8gd2FybmluZyBub3cgdG8gaGVscCBkZWJ1Z2dpbmdcbiAgICAgIGlmIChpbnN0LnJlbmRlciA9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3BzTXV0YXRlZCA9IGluc3QucHJvcHMgIT09IHB1YmxpY1Byb3BzO1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGluc3QucHJvcHMgPT09IHVuZGVmaW5lZCB8fCAhcHJvcHNNdXRhdGVkLCAnJXMoLi4uKTogV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgJyArIFwidXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsIGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudE5hbWUpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIC8vIFRoZXNlIHNob3VsZCBiZSBzZXQgdXAgaW4gdGhlIGNvbnN0cnVjdG9yLCBidXQgYXMgYSBjb252ZW5pZW5jZSBmb3JcbiAgICAvLyBzaW1wbGVyIGNsYXNzIGFic3RyYWN0aW9ucywgd2Ugc2V0IHRoZW0gdXAgYWZ0ZXIgdGhlIGZhY3QuXG4gICAgaW5zdC5wcm9wcyA9IHB1YmxpY1Byb3BzO1xuICAgIGluc3QuY29udGV4dCA9IHB1YmxpY0NvbnRleHQ7XG4gICAgaW5zdC5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgaW5zdC51cGRhdGVyID0gdXBkYXRlUXVldWU7XG5cbiAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3Q7XG5cbiAgICAvLyBTdG9yZSBhIHJlZmVyZW5jZSBmcm9tIHRoZSBpbnN0YW5jZSBiYWNrIHRvIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvblxuICAgIFJlYWN0SW5zdGFuY2VNYXAuc2V0KGluc3QsIHRoaXMpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFNpbmNlIHBsYWluIEpTIGNsYXNzZXMgYXJlIGRlZmluZWQgd2l0aG91dCBhbnkgc3BlY2lhbCBpbml0aWFsaXphdGlvblxuICAgICAgLy8gbG9naWMsIHdlIGNhbiBub3QgY2F0Y2ggY29tbW9uIGVycm9ycyBlYXJseS4gVGhlcmVmb3JlLCB3ZSBoYXZlIHRvXG4gICAgICAvLyBjYXRjaCB0aGVtIGhlcmUsIGF0IGluaXRpYWxpemF0aW9uIHRpbWUsIGluc3RlYWQuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5nZXRJbml0aWFsU3RhdGUgfHwgaW5zdC5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgfHwgaW5zdC5zdGF0ZSwgJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmdldERlZmF1bHRQcm9wcyB8fCBpbnN0LmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QucHJvcFR5cGVzLCAncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5jb250ZXh0VHlwZXMsICdjb250ZXh0VHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhICcgKyAnc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZXMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudFNob3VsZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50RGlkVW5tb3VudCAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdC5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCB0aGlzLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gaW5zdC5zdGF0ZTtcbiAgICBpZiAoaW5pdGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGluc3Quc3RhdGUgPSBpbml0aWFsU3RhdGUgPSBudWxsO1xuICAgIH1cbiAgICAhKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGluaXRpYWxTdGF0ZSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEwNicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuICAgIHZhciBtYXJrdXA7XG4gICAgaWYgKGluc3QudW5zdGFibGVfaGFuZGxlRXJyb3IpIHtcbiAgICAgIG1hcmt1cCA9IHRoaXMucGVyZm9ybUluaXRpYWxNb3VudFdpdGhFcnJvckhhbmRsaW5nKHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFya3VwID0gdGhpcy5wZXJmb3JtSW5pdGlhbE1vdW50KHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnREaWRNb3VudCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3QuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgICAgICB9LCBfdGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudERpZE1vdW50Jyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnN0LmNvbXBvbmVudERpZE1vdW50LCBpbnN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIF9jb25zdHJ1Y3RDb21wb25lbnQ6IGZ1bmN0aW9uIChkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdENvbXBvbmVudFdpdGhvdXRPd25lcihkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29uc3RydWN0Q29tcG9uZW50V2l0aG91dE93bmVyKGRvQ29uc3RydWN0LCBwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xuICAgIH1cbiAgfSxcblxuICBfY29uc3RydWN0Q29tcG9uZW50V2l0aG91dE93bmVyOiBmdW5jdGlvbiAoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSkge1xuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuXG4gICAgaWYgKGRvQ29uc3RydWN0KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICByZXR1cm4gbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50KHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgICAgIH0sIHRoaXMuX2RlYnVnSUQsICdjdG9yJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBvbmVudChwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgY2FuIHN0aWxsIGJlIGFuIGluc3RhbmNlIGluIGNhc2Ugb2YgZmFjdG9yeSBjb21wb25lbnRzXG4gICAgLy8gYnV0IHdlJ2xsIGNvdW50IHRoaXMgYXMgdGltZSBzcGVudCByZW5kZXJpbmcgYXMgdGhlIG1vcmUgY29tbW9uIGNhc2UuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHJldHVybiBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICAgIH0sIHRoaXMuX2RlYnVnSUQsICdyZW5kZXInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIENvbXBvbmVudChwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xuICAgIH1cbiAgfSxcblxuICBwZXJmb3JtSW5pdGlhbE1vdW50V2l0aEVycm9ySGFuZGxpbmc6IGZ1bmN0aW9uIChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBtYXJrdXA7XG4gICAgdmFyIGNoZWNrcG9pbnQgPSB0cmFuc2FjdGlvbi5jaGVja3BvaW50KCk7XG4gICAgdHJ5IHtcbiAgICAgIG1hcmt1cCA9IHRoaXMucGVyZm9ybUluaXRpYWxNb3VudChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gUm9sbCBiYWNrIHRvIGNoZWNrcG9pbnQsIGhhbmRsZSBlcnJvciAod2hpY2ggbWF5IGFkZCBpdGVtcyB0byB0aGUgdHJhbnNhY3Rpb24pLCBhbmQgdGFrZSBhIG5ldyBjaGVja3BvaW50XG4gICAgICB0cmFuc2FjdGlvbi5yb2xsYmFjayhjaGVja3BvaW50KTtcbiAgICAgIHRoaXMuX2luc3RhbmNlLnVuc3RhYmxlX2hhbmRsZUVycm9yKGUpO1xuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlKSB7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlLnN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZSh0aGlzLl9pbnN0YW5jZS5wcm9wcywgdGhpcy5faW5zdGFuY2UuY29udGV4dCk7XG4gICAgICB9XG4gICAgICBjaGVja3BvaW50ID0gdHJhbnNhY3Rpb24uY2hlY2twb2ludCgpO1xuXG4gICAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudC51bm1vdW50Q29tcG9uZW50KHRydWUpO1xuICAgICAgdHJhbnNhY3Rpb24ucm9sbGJhY2soY2hlY2twb2ludCk7XG5cbiAgICAgIC8vIFRyeSBhZ2FpbiAtIHdlJ3ZlIGluZm9ybWVkIHRoZSBjb21wb25lbnQgYWJvdXQgdGhlIGVycm9yLCBzbyB0aGV5IGNhbiByZW5kZXIgYW4gZXJyb3IgbWVzc2FnZSB0aGlzIHRpbWUuXG4gICAgICAvLyBJZiB0aGlzIHRocm93cyBhZ2FpbiwgdGhlIGVycm9yIHdpbGwgYnViYmxlIHVwIChhbmQgY2FuIGJlIGNhdWdodCBieSBhIGhpZ2hlciBlcnJvciBib3VuZGFyeSkuXG4gICAgICBtYXJrdXAgPSB0aGlzLnBlcmZvcm1Jbml0aWFsTW91bnQocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIHBlcmZvcm1Jbml0aWFsTW91bnQ6IGZ1bmN0aW9uIChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG5cbiAgICB2YXIgZGVidWdJRCA9IDA7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGRlYnVnSUQgPSB0aGlzLl9kZWJ1Z0lEO1xuICAgIH1cblxuICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxNb3VudCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBpbnN0LmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgICB9LCBkZWJ1Z0lELCAnY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0LmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuICAgICAgLy8gV2hlbiBtb3VudGluZywgY2FsbHMgdG8gYHNldFN0YXRlYCBieSBgY29tcG9uZW50V2lsbE1vdW50YCB3aWxsIHNldFxuICAgICAgLy8gYHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlYCB3aXRob3V0IHRyaWdnZXJpbmcgYSByZS1yZW5kZXIuXG4gICAgICBpZiAodGhpcy5fcGVuZGluZ1N0YXRlUXVldWUpIHtcbiAgICAgICAgaW5zdC5zdGF0ZSA9IHRoaXMuX3Byb2Nlc3NQZW5kaW5nU3RhdGUoaW5zdC5wcm9wcywgaW5zdC5jb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBub3QgYSBzdGF0ZWxlc3MgY29tcG9uZW50LCB3ZSBub3cgcmVuZGVyXG4gICAgaWYgKHJlbmRlcmVkRWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQoKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZVR5cGUgPSBSZWFjdE5vZGVUeXBlcy5nZXRUeXBlKHJlbmRlcmVkRWxlbWVudCk7XG4gICAgdGhpcy5fcmVuZGVyZWROb2RlVHlwZSA9IG5vZGVUeXBlO1xuICAgIHZhciBjaGlsZCA9IHRoaXMuX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQocmVuZGVyZWRFbGVtZW50LCBub2RlVHlwZSAhPT0gUmVhY3ROb2RlVHlwZXMuRU1QVFkgLyogc2hvdWxkSGF2ZURlYnVnSUQgKi9cbiAgICApO1xuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gY2hpbGQ7XG5cbiAgICB2YXIgbWFya3VwID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KGNoaWxkLCB0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRoaXMuX3Byb2Nlc3NDaGlsZENvbnRleHQoY29udGV4dCksIGRlYnVnSUQpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChkZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIHZhciBjaGlsZERlYnVnSURzID0gY2hpbGQuX2RlYnVnSUQgIT09IDAgPyBbY2hpbGQuX2RlYnVnSURdIDogW107XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKGRlYnVnSUQsIGNoaWxkRGVidWdJRHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXJrdXA7XG4gIH0sXG5cbiAgZ2V0SG9zdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVsZWFzZXMgYW55IHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgYG1vdW50Q29tcG9uZW50YC5cbiAgICpcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHNhZmVseSkge1xuICAgIGlmICghdGhpcy5fcmVuZGVyZWRDb21wb25lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgaWYgKGluc3QuY29tcG9uZW50V2lsbFVubW91bnQgJiYgIWluc3QuX2NhbGxlZENvbXBvbmVudFdpbGxVbm1vdW50KSB7XG4gICAgICBpbnN0Ll9jYWxsZWRDb21wb25lbnRXaWxsVW5tb3VudCA9IHRydWU7XG5cbiAgICAgIGlmIChzYWZlbHkpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLmdldE5hbWUoKSArICcuY29tcG9uZW50V2lsbFVubW91bnQoKSc7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sobmFtZSwgaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudC5iaW5kKGluc3QpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3QuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICAgICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbFVubW91bnQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVuZGVyZWRDb21wb25lbnQpIHtcbiAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50LCBzYWZlbHkpO1xuICAgICAgdGhpcy5fcmVuZGVyZWROb2RlVHlwZSA9IG51bGw7XG4gICAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG4gICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgcGVuZGluZyBmaWVsZHNcbiAgICAvLyBFdmVuIGlmIHRoaXMgY29tcG9uZW50IGlzIHNjaGVkdWxlZCBmb3IgYW5vdGhlciB1cGRhdGUgaW4gUmVhY3RVcGRhdGVzLFxuICAgIC8vIGl0IHdvdWxkIHN0aWxsIGJlIGlnbm9yZWQgYmVjYXVzZSB0aGVzZSBmaWVsZHMgYXJlIHJlc2V0LlxuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gICAgLy8gVGhlc2UgZmllbGRzIGRvIG5vdCByZWFsbHkgbmVlZCB0byBiZSByZXNldCBzaW5jZSB0aGlzIG9iamVjdCBpcyBub1xuICAgIC8vIGxvbmdlciBhY2Nlc3NpYmxlLlxuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSAwO1xuICAgIHRoaXMuX3RvcExldmVsV3JhcHBlciA9IG51bGw7XG5cbiAgICAvLyBEZWxldGUgdGhlIHJlZmVyZW5jZSBmcm9tIHRoZSBpbnN0YW5jZSB0byB0aGlzIGludGVybmFsIHJlcHJlc2VudGF0aW9uXG4gICAgLy8gd2hpY2ggYWxsb3cgdGhlIGludGVybmFscyB0byBiZSBwcm9wZXJseSBjbGVhbmVkIHVwIGV2ZW4gaWYgdGhlIHVzZXJcbiAgICAvLyBsZWFrcyBhIHJlZmVyZW5jZSB0byB0aGUgcHVibGljIGluc3RhbmNlLlxuICAgIFJlYWN0SW5zdGFuY2VNYXAucmVtb3ZlKGluc3QpO1xuXG4gICAgLy8gU29tZSBleGlzdGluZyBjb21wb25lbnRzIHJlbHkgb24gaW5zdC5wcm9wcyBldmVuIGFmdGVyIHRoZXkndmUgYmVlblxuICAgIC8vIGRlc3Ryb3llZCAoaW4gZXZlbnQgaGFuZGxlcnMpLlxuICAgIC8vIFRPRE86IGluc3QucHJvcHMgPSBudWxsO1xuICAgIC8vIFRPRE86IGluc3Quc3RhdGUgPSBudWxsO1xuICAgIC8vIFRPRE86IGluc3QuY29udGV4dCA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbHRlcnMgdGhlIGNvbnRleHQgb2JqZWN0IHRvIG9ubHkgY29udGFpbiBrZXlzIHNwZWNpZmllZCBpblxuICAgKiBgY29udGV4dFR5cGVzYFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21hc2tDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgIHZhciBjb250ZXh0VHlwZXMgPSBDb21wb25lbnQuY29udGV4dFR5cGVzO1xuICAgIGlmICghY29udGV4dFR5cGVzKSB7XG4gICAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gICAgfVxuICAgIHZhciBtYXNrZWRDb250ZXh0ID0ge307XG4gICAgZm9yICh2YXIgY29udGV4dE5hbWUgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgICBtYXNrZWRDb250ZXh0W2NvbnRleHROYW1lXSA9IGNvbnRleHRbY29udGV4dE5hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gbWFza2VkQ29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogRmlsdGVycyB0aGUgY29udGV4dCBvYmplY3QgdG8gb25seSBjb250YWluIGtleXMgc3BlY2lmaWVkIGluXG4gICAqIGBjb250ZXh0VHlwZXNgLCBhbmQgYXNzZXJ0cyB0aGF0IHRoZXkgYXJlIHZhbGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBtYXNrZWRDb250ZXh0ID0gdGhpcy5fbWFza0NvbnRleHQoY29udGV4dCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgICAgaWYgKENvbXBvbmVudC5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tDb250ZXh0VHlwZXMoQ29tcG9uZW50LmNvbnRleHRUeXBlcywgbWFza2VkQ29udGV4dCwgJ2NvbnRleHQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hc2tlZENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjdXJyZW50Q29udGV4dFxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKGN1cnJlbnRDb250ZXh0KSB7XG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICB2YXIgY2hpbGRDb250ZXh0O1xuXG4gICAgaWYgKGluc3QuZ2V0Q2hpbGRDb250ZXh0KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjaGlsZENvbnRleHQgPSBpbnN0LmdldENoaWxkQ29udGV4dCgpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZFByb2Nlc3NpbmdDaGlsZENvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGRDb250ZXh0ID0gaW5zdC5nZXRDaGlsZENvbnRleHQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2hpbGRDb250ZXh0KSB7XG4gICAgICAhKHR5cGVvZiBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMgPT09ICdvYmplY3QnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvIHVzZSBnZXRDaGlsZENvbnRleHQoKS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCcxMDcnLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrQ29udGV4dFR5cGVzKENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0LCAnY2hpbGQgY29udGV4dCcpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAgICAgIShuYW1lIGluIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcIiVzXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnMTA4JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JywgbmFtZSkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2Fzc2lnbih7fSwgY3VycmVudENvbnRleHQsIGNoaWxkQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50Q29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogQXNzZXJ0IHRoYXQgdGhlIGNvbnRleHQgdHlwZXMgYXJlIHZhbGlkXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIGNvbnRleHQgZmllbGQgdG8gYSBSZWFjdFByb3BUeXBlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tDb250ZXh0VHlwZXM6IGZ1bmN0aW9uICh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24pIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY2hlY2tSZWFjdFR5cGVTcGVjKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgdGhpcy5nZXROYW1lKCksIG51bGwsIHRoaXMuX2RlYnVnSUQpO1xuICAgIH1cbiAgfSxcblxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBuZXh0Q29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBwcmV2Q29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG5cbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG5cbiAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudCh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBwcmV2Q29udGV4dCwgbmV4dENvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBhbnkgb2YgYF9wZW5kaW5nRWxlbWVudGAsIGBfcGVuZGluZ1N0YXRlUXVldWVgLCBvciBgX3BlbmRpbmdGb3JjZVVwZGF0ZWBcbiAgICogaXMgc2V0LCB1cGRhdGUgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRoaXMuX3BlbmRpbmdFbGVtZW50ICE9IG51bGwpIHtcbiAgICAgIFJlYWN0UmVjb25jaWxlci5yZWNlaXZlQ29tcG9uZW50KHRoaXMsIHRoaXMuX3BlbmRpbmdFbGVtZW50LCB0cmFuc2FjdGlvbiwgdGhpcy5fY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSAhPT0gbnVsbCB8fCB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCB0aGlzLl9jdXJyZW50RWxlbWVudCwgdGhpcy5fY3VycmVudEVsZW1lbnQsIHRoaXMuX2NvbnRleHQsIHRoaXMuX2NvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91cGRhdGVCYXRjaE51bWJlciA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIHVwZGF0ZSB0byBhIG1vdW50ZWQgY29tcG9uZW50LiBUaGUgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBhbmRcbiAgICogc2hvdWxkQ29tcG9uZW50VXBkYXRlIG1ldGhvZHMgYXJlIGNhbGxlZCwgdGhlbiAoYXNzdW1pbmcgdGhlIHVwZGF0ZSBpc24ndFxuICAgKiBza2lwcGVkKSB0aGUgcmVtYWluaW5nIHVwZGF0ZSBsaWZlY3ljbGUgbWV0aG9kcyBhcmUgY2FsbGVkIGFuZCB0aGUgRE9NXG4gICAqIHJlcHJlc2VudGF0aW9uIGlzIHVwZGF0ZWQuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgaW1wbGVtZW50cyBSZWFjdCdzIHJlbmRlcmluZyBhbmQgcmVjb25jaWxpYXRpb24gYWxnb3JpdGhtLlxuICAgKiBTb3BoaXN0aWNhdGVkIGNsaWVudHMgbWF5IHdpc2ggdG8gb3ZlcnJpZGUgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gcHJldlBhcmVudEVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRQYXJlbnRFbGVtZW50XG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcmV2UGFyZW50RWxlbWVudCwgbmV4dFBhcmVudEVsZW1lbnQsIHByZXZVbm1hc2tlZENvbnRleHQsIG5leHRVbm1hc2tlZENvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgICEoaW5zdCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdBdHRlbXB0ZWQgdG8gdXBkYXRlIGNvbXBvbmVudCBgJXNgIHRoYXQgaGFzIGFscmVhZHkgYmVlbiB1bm1vdW50ZWQgKG9yIGZhaWxlZCB0byBtb3VudCkuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTM2JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICB2YXIgd2lsbFJlY2VpdmUgPSBmYWxzZTtcbiAgICB2YXIgbmV4dENvbnRleHQ7XG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIGNvbnRleHQgaGFzIGNoYW5nZWQgb3Igbm90XG4gICAgaWYgKHRoaXMuX2NvbnRleHQgPT09IG5leHRVbm1hc2tlZENvbnRleHQpIHtcbiAgICAgIG5leHRDb250ZXh0ID0gaW5zdC5jb250ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0Q29udGV4dCA9IHRoaXMuX3Byb2Nlc3NDb250ZXh0KG5leHRVbm1hc2tlZENvbnRleHQpO1xuICAgICAgd2lsbFJlY2VpdmUgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBwcmV2UHJvcHMgPSBwcmV2UGFyZW50RWxlbWVudC5wcm9wcztcbiAgICB2YXIgbmV4dFByb3BzID0gbmV4dFBhcmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICAvLyBOb3QgYSBzaW1wbGUgc3RhdGUgdXBkYXRlIGJ1dCBhIHByb3BzIHVwZGF0ZVxuICAgIGlmIChwcmV2UGFyZW50RWxlbWVudCAhPT0gbmV4dFBhcmVudEVsZW1lbnQpIHtcbiAgICAgIHdpbGxSZWNlaXZlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBBbiB1cGRhdGUgaGVyZSB3aWxsIHNjaGVkdWxlIGFuIHVwZGF0ZSBidXQgaW1tZWRpYXRlbHkgc2V0XG4gICAgLy8gX3BlbmRpbmdTdGF0ZVF1ZXVlIHdoaWNoIHdpbGwgZW5zdXJlIHRoYXQgYW55IHN0YXRlIHVwZGF0ZXMgZ2V0c1xuICAgIC8vIGltbWVkaWF0ZWx5IHJlY29uY2lsZWQgaW5zdGVhZCBvZiB3YWl0aW5nIGZvciB0aGUgbmV4dCBiYXRjaC5cbiAgICBpZiAod2lsbFJlY2VpdmUgJiYgaW5zdC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgICAgfSwgdGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV4dFN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZShuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcblxuICAgIGlmICghdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlKSB7XG4gICAgICBpZiAoaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBzaG91bGRVcGRhdGUgPSBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hvdWxkVXBkYXRlID0gaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbXBvc2l0ZVR5cGUgPT09IENvbXBvc2l0ZVR5cGVzLlB1cmVDbGFzcykge1xuICAgICAgICAgIHNob3VsZFVwZGF0ZSA9ICFzaGFsbG93RXF1YWwocHJldlByb3BzLCBuZXh0UHJvcHMpIHx8ICFzaGFsbG93RXF1YWwoaW5zdC5zdGF0ZSwgbmV4dFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhzaG91bGRVcGRhdGUgIT09IHVuZGVmaW5lZCwgJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUJhdGNoTnVtYmVyID0gbnVsbDtcbiAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcbiAgICAgIC8vIFdpbGwgc2V0IGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YC5cbiAgICAgIHRoaXMuX3BlcmZvcm1Db21wb25lbnRVcGRhdGUobmV4dFBhcmVudEVsZW1lbnQsIG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCwgdHJhbnNhY3Rpb24sIG5leHRVbm1hc2tlZENvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBpdCdzIGRldGVybWluZWQgdGhhdCBhIGNvbXBvbmVudCBzaG91bGQgbm90IHVwZGF0ZSwgd2Ugc3RpbGwgd2FudFxuICAgICAgLy8gdG8gc2V0IHByb3BzIGFuZCBzdGF0ZSBidXQgd2Ugc2hvcnRjdXQgdGhlIHJlc3Qgb2YgdGhlIHVwZGF0ZS5cbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dFBhcmVudEVsZW1lbnQ7XG4gICAgICB0aGlzLl9jb250ZXh0ID0gbmV4dFVubWFza2VkQ29udGV4dDtcbiAgICAgIGluc3QucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgaW5zdC5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG4gICAgfVxuICB9LFxuXG4gIF9wcm9jZXNzUGVuZGluZ1N0YXRlOiBmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlO1xuICAgIHZhciByZXBsYWNlID0gdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZTtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuXG4gICAgaWYgKCFxdWV1ZSkge1xuICAgICAgcmV0dXJuIGluc3Quc3RhdGU7XG4gICAgfVxuXG4gICAgaWYgKHJlcGxhY2UgJiYgcXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gcXVldWVbMF07XG4gICAgfVxuXG4gICAgdmFyIG5leHRTdGF0ZSA9IF9hc3NpZ24oe30sIHJlcGxhY2UgPyBxdWV1ZVswXSA6IGluc3Quc3RhdGUpO1xuICAgIGZvciAodmFyIGkgPSByZXBsYWNlID8gMSA6IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhcnRpYWwgPSBxdWV1ZVtpXTtcbiAgICAgIF9hc3NpZ24obmV4dFN0YXRlLCB0eXBlb2YgcGFydGlhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcnRpYWwuY2FsbChpbnN0LCBuZXh0U3RhdGUsIHByb3BzLCBjb250ZXh0KSA6IHBhcnRpYWwpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0U3RhdGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1lcmdlcyBuZXcgcHJvcHMgYW5kIHN0YXRlLCBub3RpZmllcyBkZWxlZ2F0ZSBtZXRob2RzIG9mIHVwZGF0ZSBhbmRcbiAgICogcGVyZm9ybXMgdXBkYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgTmV4dCBlbGVtZW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHMgTmV4dCBwdWJsaWMgb2JqZWN0IHRvIHNldCBhcyBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZSBOZXh0IG9iamVjdCB0byBzZXQgYXMgc3RhdGUuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHQgTmV4dCBwdWJsaWMgb2JqZWN0IHRvIHNldCBhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gdW5tYXNrZWRDb250ZXh0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcGVyZm9ybUNvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQsIHRyYW5zYWN0aW9uLCB1bm1hc2tlZENvbnRleHQpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG5cbiAgICB2YXIgaGFzQ29tcG9uZW50RGlkVXBkYXRlID0gQm9vbGVhbihpbnN0LmNvbXBvbmVudERpZFVwZGF0ZSk7XG4gICAgdmFyIHByZXZQcm9wcztcbiAgICB2YXIgcHJldlN0YXRlO1xuICAgIHZhciBwcmV2Q29udGV4dDtcbiAgICBpZiAoaGFzQ29tcG9uZW50RGlkVXBkYXRlKSB7XG4gICAgICBwcmV2UHJvcHMgPSBpbnN0LnByb3BzO1xuICAgICAgcHJldlN0YXRlID0gaW5zdC5zdGF0ZTtcbiAgICAgIHByZXZDb250ZXh0ID0gaW5zdC5jb250ZXh0O1xuICAgIH1cblxuICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxVcGRhdGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICAgIH0sIHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0LmNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIHRoaXMuX2NvbnRleHQgPSB1bm1hc2tlZENvbnRleHQ7XG4gICAgaW5zdC5wcm9wcyA9IG5leHRQcm9wcztcbiAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgIGluc3QuY29udGV4dCA9IG5leHRDb250ZXh0O1xuXG4gICAgdGhpcy5fdXBkYXRlUmVuZGVyZWRDb21wb25lbnQodHJhbnNhY3Rpb24sIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICBpZiAoaGFzQ29tcG9uZW50RGlkVXBkYXRlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtZWFzdXJlTGlmZUN5Y2xlUGVyZihpbnN0LmNvbXBvbmVudERpZFVwZGF0ZS5iaW5kKGluc3QsIHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCksIF90aGlzMi5fZGVidWdJRCwgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW5zdC5jb21wb25lbnREaWRVcGRhdGUuYmluZChpbnN0LCBwcmV2UHJvcHMsIHByZXZTdGF0ZSwgcHJldkNvbnRleHQpLCBpbnN0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGwgdGhlIGNvbXBvbmVudCdzIGByZW5kZXJgIG1ldGhvZCBhbmQgdXBkYXRlIHRoZSBET00gYWNjb3JkaW5nbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBfdXBkYXRlUmVuZGVyZWRDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2Q29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLl9yZW5kZXJlZENvbXBvbmVudDtcbiAgICB2YXIgcHJldlJlbmRlcmVkRWxlbWVudCA9IHByZXZDb21wb25lbnRJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG4gICAgdmFyIG5leHRSZW5kZXJlZEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQoKTtcblxuICAgIHZhciBkZWJ1Z0lEID0gMDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZGVidWdJRCA9IHRoaXMuX2RlYnVnSUQ7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZSZW5kZXJlZEVsZW1lbnQsIG5leHRSZW5kZXJlZEVsZW1lbnQpKSB7XG4gICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudChwcmV2Q29tcG9uZW50SW5zdGFuY2UsIG5leHRSZW5kZXJlZEVsZW1lbnQsIHRyYW5zYWN0aW9uLCB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9sZEhvc3ROb2RlID0gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKHByZXZDb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q29tcG9uZW50SW5zdGFuY2UsIGZhbHNlKTtcblxuICAgICAgdmFyIG5vZGVUeXBlID0gUmVhY3ROb2RlVHlwZXMuZ2V0VHlwZShuZXh0UmVuZGVyZWRFbGVtZW50KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkTm9kZVR5cGUgPSBub2RlVHlwZTtcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dFJlbmRlcmVkRWxlbWVudCwgbm9kZVR5cGUgIT09IFJlYWN0Tm9kZVR5cGVzLkVNUFRZIC8qIHNob3VsZEhhdmVEZWJ1Z0lEICovXG4gICAgICApO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBjaGlsZDtcblxuICAgICAgdmFyIG5leHRNYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHRyYW5zYWN0aW9uLCB0aGlzLl9ob3N0UGFyZW50LCB0aGlzLl9ob3N0Q29udGFpbmVySW5mbywgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSwgZGVidWdJRCk7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChkZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgdmFyIGNoaWxkRGVidWdJRHMgPSBjaGlsZC5fZGVidWdJRCAhPT0gMCA/IFtjaGlsZC5fZGVidWdJRF0gOiBbXTtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbihkZWJ1Z0lELCBjaGlsZERlYnVnSURzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZXBsYWNlTm9kZVdpdGhNYXJrdXAob2xkSG9zdE5vZGUsIG5leHRNYXJrdXAsIHByZXZDb21wb25lbnRJbnN0YW5jZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZGVuIGluIHNoYWxsb3cgcmVuZGVyaW5nLlxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcmVwbGFjZU5vZGVXaXRoTWFya3VwOiBmdW5jdGlvbiAob2xkSG9zdE5vZGUsIG5leHRNYXJrdXAsIHByZXZJbnN0YW5jZSkge1xuICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwKG9sZEhvc3ROb2RlLCBuZXh0TWFya3VwLCBwcmV2SW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50V2l0aG91dE93bmVyT3JDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICB2YXIgcmVuZGVyZWRFbGVtZW50O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGluc3QucmVuZGVyKCk7XG4gICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAncmVuZGVyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IGluc3QucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgaWYgKHJlbmRlcmVkRWxlbWVudCA9PT0gdW5kZWZpbmVkICYmIGluc3QucmVuZGVyLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICByZW5kZXJlZEVsZW1lbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZW5kZXJlZEVsZW1lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlbmRlcmVkRWxlbWVudDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyB8fCB0aGlzLl9jb21wb3NpdGVUeXBlICE9PSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsKSB7XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dCgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dCgpO1xuICAgIH1cbiAgICAhKFxuICAgIC8vIFRPRE86IEFuIGBpc1ZhbGlkTm9kZWAgZnVuY3Rpb24gd291bGQgcHJvYmFibHkgYmUgbW9yZSBhcHByb3ByaWF0ZVxuICAgIHJlbmRlcmVkRWxlbWVudCA9PT0gbnVsbCB8fCByZW5kZXJlZEVsZW1lbnQgPT09IGZhbHNlIHx8IFJlYWN0LmlzVmFsaWRFbGVtZW50KHJlbmRlcmVkRWxlbWVudCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLnJlbmRlcigpOiBBIHZhbGlkIFJlYWN0IGVsZW1lbnQgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQsIGFuIGFycmF5IG9yIHNvbWUgb3RoZXIgaW52YWxpZCBvYmplY3QuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTA5JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICByZXR1cm4gcmVuZGVyZWRFbGVtZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBMYXppbHkgYWxsb2NhdGVzIHRoZSByZWZzIG9iamVjdCBhbmQgc3RvcmVzIGBjb21wb25lbnRgIGFzIGByZWZgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIFJlZmVyZW5jZSBuYW1lLlxuICAgKiBAcGFyYW0ge2NvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byBzdG9yZSBhcyBgcmVmYC5cbiAgICogQGZpbmFsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhdHRhY2hSZWY6IGZ1bmN0aW9uIChyZWYsIGNvbXBvbmVudCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgICEoaW5zdCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgaGF2ZSByZWZzLicpIDogX3Byb2RJbnZhcmlhbnQoJzExMCcpIDogdm9pZCAwO1xuICAgIHZhciBwdWJsaWNDb21wb25lbnRJbnN0YW5jZSA9IGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudCAmJiBjb21wb25lbnQuZ2V0TmFtZSA/IGNvbXBvbmVudC5nZXROYW1lKCkgOiAnYSBjb21wb25lbnQnO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHVibGljQ29tcG9uZW50SW5zdGFuY2UgIT0gbnVsbCB8fCBjb21wb25lbnQuX2NvbXBvc2l0ZVR5cGUgIT09IENvbXBvc2l0ZVR5cGVzLlN0YXRlbGVzc0Z1bmN0aW9uYWwsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgYmUgZ2l2ZW4gcmVmcyAnICsgJyhTZWUgcmVmIFwiJXNcIiBpbiAlcyBjcmVhdGVkIGJ5ICVzKS4gJyArICdBdHRlbXB0cyB0byBhY2Nlc3MgdGhpcyByZWYgd2lsbCBmYWlsLicsIHJlZiwgY29tcG9uZW50TmFtZSwgdGhpcy5nZXROYW1lKCkpIDogdm9pZCAwO1xuICAgIH1cbiAgICB2YXIgcmVmcyA9IGluc3QucmVmcyA9PT0gZW1wdHlPYmplY3QgPyBpbnN0LnJlZnMgPSB7fSA6IGluc3QucmVmcztcbiAgICByZWZzW3JlZl0gPSBwdWJsaWNDb21wb25lbnRJbnN0YW5jZTtcbiAgfSxcblxuICAvKipcbiAgICogRGV0YWNoZXMgYSByZWZlcmVuY2UgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIHRvIGRlcmVmZXJlbmNlLlxuICAgKiBAZmluYWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRldGFjaFJlZjogZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciByZWZzID0gdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpLnJlZnM7XG4gICAgZGVsZXRlIHJlZnNbcmVmXTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGEgdGV4dCBkZXNjcmlwdGlvbiBvZiB0aGUgY29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgaXRcbiAgICogaW4gZXJyb3IgbWVzc2FnZXMuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG5hbWUgb3IgbnVsbC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXROYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHR5cGUgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHRoaXMuX2luc3RhbmNlICYmIHRoaXMuX2luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBjb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3Rvci5uYW1lIHx8IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHVibGljbHkgYWNjZXNzaWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbXBvbmVudCAtIGkuZS4gd2hhdFxuICAgKiBpcyBleHBvc2VkIGJ5IHJlZnMgYW5kIHJldHVybmVkIGJ5IHJlbmRlci4gQ2FuIGJlIG51bGwgZm9yIHN0YXRlbGVzc1xuICAgKiBjb21wb25lbnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gdGhlIHB1YmxpYyBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIGlmICh0aGlzLl9jb21wb3NpdGVUeXBlID09PSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGluc3Q7XG4gIH0sXG5cbiAgLy8gU3R1YlxuICBfaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDogbnVsbFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIHtcbiAgLy8gVGVtcG9yYXJ5IGhhY2suXG4gIC8vIElubGluZSByZXF1aXJlcyBkb24ndCB3b3JrIHdlbGwgd2l0aCBKZXN0OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNDBcbiAgLy8gUmVtb3ZlIHRoZSBpbmxpbmUgcmVxdWlyZXMgd2hlbiB3ZSBkb24ndCBuZWVkIHRoZW0gYW55bW9yZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzE3OFxuICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9vYmplY3R9IGVsZW1lbnQgVGhlIFJlYWN0IGVsZW1lbnQgdGhhdCBpcyBiZWluZyB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7P251bWJlcn0gZGVidWdJRCBUaGUgUmVhY3QgY29tcG9uZW50IGluc3RhbmNlIHRoYXQgaXMgYmVpbmcgdHlwZS1jaGVja2VkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1JlYWN0VHlwZVNwZWModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50LCBkZWJ1Z0lEKSB7XG4gIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgIHZhciBlcnJvcjtcbiAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAhKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSBSZWFjdC5Qcm9wVHlwZXMuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSkgOiBfcHJvZEludmFyaWFudCgnODQnLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGVycm9yID0gZXg7XG4gICAgICB9XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcikgOiB2b2lkIDA7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICB2YXIgY29tcG9uZW50U3RhY2tJbmZvID0gJyc7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoIVJlYWN0Q29tcG9uZW50VHJlZUhvb2spIHtcbiAgICAgICAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVidWdJRCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29tcG9uZW50U3RhY2tJbmZvID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrSW5mbyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0Q3VycmVudFN0YWNrQWRkZW5kdW0oZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBjb21wb25lbnRTdGFja0luZm8pIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUmVhY3RUeXBlU3BlYztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHtcbiAgICBwcm9wOiAncHJvcCcsXG4gICAgY29udGV4dDogJ2NvbnRleHQnLFxuICAgIGNoaWxkQ29udGV4dDogJ2NoaWxkIGNvbnRleHQnXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBuZXh0RGVidWdJRCA9IDE7XG5cbmZ1bmN0aW9uIGdldE5leHREZWJ1Z0lEKCkge1xuICByZXR1cm4gbmV4dERlYnVnSUQrKztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROZXh0RGVidWdJRDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldE5leHREZWJ1Z0lELmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQgdHlwZS4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddICYmIFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSB8fCAweGVhYzc7XG5cbm1vZHVsZS5leHBvcnRzID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RWxlbWVudFN5bWJvbC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuXG52YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gKlxuICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gKlxuICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICogICAgICAgLi4uXG4gKiAgICAgfVxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRJdGVyYXRvckZuO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2dldEl0ZXJhdG9yRm4uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBLZXlFc2NhcGVVdGlscyA9IHJlcXVpcmUoJy4vS2V5RXNjYXBlVXRpbHMnKTtcbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0Jykge1xuICAvLyBUZW1wb3JhcnkgaGFjay5cbiAgLy8gSW5saW5lIHJlcXVpcmVzIGRvbid0IHdvcmsgd2VsbCB3aXRoIEplc3Q6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI0MFxuICAvLyBSZW1vdmUgdGhlIGlubGluZSByZXF1aXJlcyB3aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBhbnltb3JlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTc4XG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IHBhc3NlZCB0aHJvdWdoIHRyYXZlcnNhbC5cbiAqIEBwYXJhbSB7P1JlYWN0Q29tcG9uZW50fSBjaGlsZCBSZWFjdCBjaGlsZCBjb21wb25lbnQuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWUgU3RyaW5nIG5hbWUgb2Yga2V5IHBhdGggdG8gY2hpbGQuXG4gKiBAcGFyYW0ge251bWJlcj19IHNlbGZEZWJ1Z0lEIE9wdGlvbmFsIGRlYnVnSUQgb2YgdGhlIGN1cnJlbnQgaW50ZXJuYWwgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5TaW5nbGVDaGlsZEludG9Db250ZXh0KHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUsIHNlbGZEZWJ1Z0lEKSB7XG4gIC8vIFdlIGZvdW5kIGEgY29tcG9uZW50IGluc3RhbmNlLlxuICBpZiAodHJhdmVyc2VDb250ZXh0ICYmIHR5cGVvZiB0cmF2ZXJzZUNvbnRleHQgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRyYXZlcnNlQ29udGV4dDtcbiAgICB2YXIga2V5VW5pcXVlID0gcmVzdWx0W25hbWVdID09PSB1bmRlZmluZWQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghUmVhY3RDb21wb25lbnRUcmVlSG9vaykge1xuICAgICAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbiAgICAgIH1cbiAgICAgIGlmICgha2V5VW5pcXVlKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnZmxhdHRlbkNoaWxkcmVuKC4uLik6IEVuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgJyArICdgJXNgLiBDaGlsZCBrZXlzIG11c3QgYmUgdW5pcXVlOyB3aGVuIHR3byBjaGlsZHJlbiBzaGFyZSBhIGtleSwgb25seSAnICsgJ3RoZSBmaXJzdCBjaGlsZCB3aWxsIGJlIHVzZWQuJXMnLCBLZXlFc2NhcGVVdGlscy51bmVzY2FwZShuYW1lKSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChzZWxmRGVidWdJRCkpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5VW5pcXVlICYmIGNoaWxkICE9IG51bGwpIHtcbiAgICAgIHJlc3VsdFtuYW1lXSA9IGNoaWxkO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEZsYXR0ZW5zIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC4gQW55IG51bGxcbiAqIGNoaWxkcmVuIHdpbGwgbm90IGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHRpbmcgb2JqZWN0LlxuICogQHJldHVybiB7IW9iamVjdH0gZmxhdHRlbmVkIGNoaWxkcmVuIGtleWVkIGJ5IG5hbWUuXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbiwgc2VsZkRlYnVnSUQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUpIHtcbiAgICAgIHJldHVybiBmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lLCBzZWxmRGVidWdJRCk7XG4gICAgfSwgcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgcmVzdWx0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW5DaGlsZHJlbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9mbGF0dGVuQ2hpbGRyZW4uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0U2VydmVyVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0U2VydmVyVXBkYXRlUXVldWUnKTtcblxuLyoqXG4gKiBFeGVjdXRlZCB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBDb25zaWRlciB0aGVzZSBhc1xuICogYmVpbmcgbWVtYmVyIG1ldGhvZHMsIGJ1dCB3aXRoIGFuIGltcGxpZWQgb3JkZXJpbmcgd2hpbGUgYmVpbmcgaXNvbGF0ZWQgZnJvbVxuICogZWFjaCBvdGhlci5cbiAqL1xudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW107XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFRSQU5TQUNUSU9OX1dSQVBQRVJTLnB1c2goe1xuICAgIGluaXRpYWxpemU6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luRmx1c2gsXG4gICAgY2xvc2U6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZEZsdXNoXG4gIH0pO1xufVxuXG52YXIgbm9vcENhbGxiYWNrUXVldWUgPSB7XG4gIGVucXVldWU6IGZ1bmN0aW9uICgpIHt9XG59O1xuXG4vKipcbiAqIEBjbGFzcyBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJlbmRlclRvU3RhdGljTWFya3VwXG4gKi9cbmZ1bmN0aW9uIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ocmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICB0aGlzLnJlbmRlclRvU3RhdGljTWFya3VwID0gcmVuZGVyVG9TdGF0aWNNYXJrdXA7XG4gIHRoaXMudXNlQ3JlYXRlRWxlbWVudCA9IGZhbHNlO1xuICB0aGlzLnVwZGF0ZVF1ZXVlID0gbmV3IFJlYWN0U2VydmVyVXBkYXRlUXVldWUodGhpcyk7XG59XG5cbnZhciBNaXhpbiA9IHtcbiAgLyoqXG4gICAqIEBzZWUgVHJhbnNhY3Rpb25cbiAgICogQGFic3RyYWN0XG4gICAqIEBmaW5hbFxuICAgKiBAcmV0dXJuIHthcnJheX0gRW1wdHkgbGlzdCBvZiBvcGVyYXRpb24gd3JhcCBwcm9jZWR1cmVzLlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBgb25ET01SZWFkeWAgY2FsbGJhY2tzIHdpdGguXG4gICAqL1xuICBnZXRSZWFjdE1vdW50UmVhZHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbm9vcENhbGxiYWNrUXVldWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgUmVhY3QgYXN5bmMgZXZlbnRzLlxuICAgKi9cbiAgZ2V0VXBkYXRlUXVldWU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVRdWV1ZTtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcywgYW5kIHdpbGwgaW52b2tlIHRoaXMgYmVmb3JlIGFsbG93aW5nIHRoaXNcbiAgICogaW5zdGFuY2UgdG8gYmUgcmV1c2VkLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge30sXG5cbiAgY2hlY2twb2ludDogZnVuY3Rpb24gKCkge30sXG5cbiAgcm9sbGJhY2s6IGZ1bmN0aW9uICgpIHt9XG59O1xuXG5fYXNzaWduKFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbiwgTWl4aW4pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG91dHNpZGUgY29tcG9uZW50V2lsbE1vdW50KCkgb24gdGhlIHNlcnZlci4gJyArICdUaGlzIGlzIGEgbm8tb3AuIFBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBjb25zdHJ1Y3RvciAmJiAoY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnKSA6IHZvaWQgMDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHVwZGF0ZSBxdWV1ZSB1c2VkIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLlxuICogSXQgZGVsZWdhdGVzIHRvIFJlYWN0VXBkYXRlUXVldWUgd2hpbGUgc2VydmVyIHJlbmRlcmluZyBpcyBpbiBwcm9ncmVzcyBhbmRcbiAqIHN3aXRjaGVzIHRvIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlIGFmdGVyIHRoZSB0cmFuc2FjdGlvbiBoYXMgY29tcGxldGVkLlxuICogQGNsYXNzIFJlYWN0U2VydmVyVXBkYXRlUXVldWVcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKi9cblxudmFyIFJlYWN0U2VydmVyVXBkYXRlUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlYWN0U2VydmVyVXBkYXRlUXVldWUodHJhbnNhY3Rpb24pIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSk7XG5cbiAgICB0aGlzLnRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cblxuXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmlzTW91bnRlZCA9IGZ1bmN0aW9uIGlzTW91bnRlZChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmVucXVldWVDYWxsYmFjayA9IGZ1bmN0aW9uIGVucXVldWVDYWxsYmFjayhwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5pc0luVHJhbnNhY3Rpb24oKSkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlQ2FsbGJhY2socHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmVucXVldWVGb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIGVucXVldWVGb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSkge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmlzSW5UcmFuc2FjdGlvbigpKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVGb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZVJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIGVucXVldWVSZXBsYWNlU3RhdGUocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5pc0luVHJhbnNhY3Rpb24oKSkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlUmVwbGFjZVN0YXRlKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZVNldFN0YXRlID0gZnVuY3Rpb24gZW5xdWV1ZVNldFN0YXRlKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5pc0luVHJhbnNhY3Rpb24oKSkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlU2V0U3RhdGUocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFJlYWN0U2VydmVyVXBkYXRlUXVldWU7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xuXG52YXIgUmVhY3RET01FbXB0eUNvbXBvbmVudCA9IGZ1bmN0aW9uIChpbnN0YW50aWF0ZSkge1xuICAvLyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCB1c2VzIHRoaXM6XG4gIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbnVsbDtcbiAgLy8gUmVhY3RET01Db21wb25lbnRUcmVlIHVzZXMgdGhlc2U6XG4gIHRoaXMuX2hvc3ROb2RlID0gbnVsbDtcbiAgdGhpcy5faG9zdFBhcmVudCA9IG51bGw7XG4gIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gbnVsbDtcbiAgdGhpcy5fZG9tSUQgPSAwO1xufTtcbl9hc3NpZ24oUmVhY3RET01FbXB0eUNvbXBvbmVudC5wcm90b3R5cGUsIHtcbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQpIHtcbiAgICB2YXIgZG9tSUQgPSBob3N0Q29udGFpbmVySW5mby5faWRDb3VudGVyKys7XG4gICAgdGhpcy5fZG9tSUQgPSBkb21JRDtcbiAgICB0aGlzLl9ob3N0UGFyZW50ID0gaG9zdFBhcmVudDtcbiAgICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IGhvc3RDb250YWluZXJJbmZvO1xuXG4gICAgdmFyIG5vZGVWYWx1ZSA9ICcgcmVhY3QtZW1wdHk6ICcgKyB0aGlzLl9kb21JRCArICcgJztcbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBob3N0Q29udGFpbmVySW5mby5fb3duZXJEb2N1bWVudDtcbiAgICAgIHZhciBub2RlID0gb3duZXJEb2N1bWVudC5jcmVhdGVDb21tZW50KG5vZGVWYWx1ZSk7XG4gICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKHRoaXMsIG5vZGUpO1xuICAgICAgcmV0dXJuIERPTUxhenlUcmVlKG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgICAgLy8gTm9ybWFsbHkgd2UnZCBpbnNlcnQgYSBjb21tZW50IG5vZGUsIGJ1dCBzaW5jZSB0aGlzIGlzIGEgc2l0dWF0aW9uXG4gICAgICAgIC8vIHdoZXJlIFJlYWN0IHdvbid0IHRha2Ugb3ZlciAoc3RhdGljIHBhZ2VzKSwgd2UgY2FuIHNpbXBseSByZXR1cm5cbiAgICAgICAgLy8gbm90aGluZy5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuICc8IS0tJyArIG5vZGVWYWx1ZSArICctLT4nO1xuICAgIH1cbiAgfSxcbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKCkge30sXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRoaXMpO1xuICB9LFxuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlLnVuY2FjaGVOb2RlKHRoaXMpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUVtcHR5Q29tcG9uZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NRW1wdHlDb21wb25lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIG9mIEEgYW5kIEIsIG9yIG51bGwgaWYgdGhleSBhcmUgaW5cbiAqIGRpZmZlcmVudCB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoaW5zdEEsIGluc3RCKSB7XG4gICEoJ19ob3N0Tm9kZScgaW4gaW5zdEEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzMnKSA6IHZvaWQgMDtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0QikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczMycpIDogdm9pZCAwO1xuXG4gIHZhciBkZXB0aEEgPSAwO1xuICBmb3IgKHZhciB0ZW1wQSA9IGluc3RBOyB0ZW1wQTsgdGVtcEEgPSB0ZW1wQS5faG9zdFBhcmVudCkge1xuICAgIGRlcHRoQSsrO1xuICB9XG4gIHZhciBkZXB0aEIgPSAwO1xuICBmb3IgKHZhciB0ZW1wQiA9IGluc3RCOyB0ZW1wQjsgdGVtcEIgPSB0ZW1wQi5faG9zdFBhcmVudCkge1xuICAgIGRlcHRoQisrO1xuICB9XG5cbiAgLy8gSWYgQSBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuICB3aGlsZSAoZGVwdGhBIC0gZGVwdGhCID4gMCkge1xuICAgIGluc3RBID0gaW5zdEEuX2hvc3RQYXJlbnQ7XG4gICAgZGVwdGhBLS07XG4gIH1cblxuICAvLyBJZiBCIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEIgLSBkZXB0aEEgPiAwKSB7XG4gICAgaW5zdEIgPSBpbnN0Qi5faG9zdFBhcmVudDtcbiAgICBkZXB0aEItLTtcbiAgfVxuXG4gIC8vIFdhbGsgaW4gbG9ja3N0ZXAgdW50aWwgd2UgZmluZCBhIG1hdGNoLlxuICB2YXIgZGVwdGggPSBkZXB0aEE7XG4gIHdoaWxlIChkZXB0aC0tKSB7XG4gICAgaWYgKGluc3RBID09PSBpbnN0Qikge1xuICAgICAgcmV0dXJuIGluc3RBO1xuICAgIH1cbiAgICBpbnN0QSA9IGluc3RBLl9ob3N0UGFyZW50O1xuICAgIGluc3RCID0gaW5zdEIuX2hvc3RQYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJuIGlmIEEgaXMgYW4gYW5jZXN0b3Igb2YgQi5cbiAqL1xuZnVuY3Rpb24gaXNBbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0QSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnaXNBbmNlc3RvcjogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczNScpIDogdm9pZCAwO1xuICAhKCdfaG9zdE5vZGUnIGluIGluc3RCKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpc0FuY2VzdG9yOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzM1JykgOiB2b2lkIDA7XG5cbiAgd2hpbGUgKGluc3RCKSB7XG4gICAgaWYgKGluc3RCID09PSBpbnN0QSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGluc3RCID0gaW5zdEIuX2hvc3RQYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgcGFyZW50IGluc3RhbmNlIG9mIHRoZSBwYXNzZWQtaW4gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudEluc3RhbmNlKGluc3QpIHtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXRQYXJlbnRJbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczNicpIDogdm9pZCAwO1xuXG4gIHJldHVybiBpbnN0Ll9ob3N0UGFyZW50O1xufVxuXG4vKipcbiAqIFNpbXVsYXRlcyB0aGUgdHJhdmVyc2FsIG9mIGEgdHdvLXBoYXNlLCBjYXB0dXJlL2J1YmJsZSBldmVudCBkaXNwYXRjaC5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VUd29QaGFzZShpbnN0LCBmbiwgYXJnKSB7XG4gIHZhciBwYXRoID0gW107XG4gIHdoaWxlIChpbnN0KSB7XG4gICAgcGF0aC5wdXNoKGluc3QpO1xuICAgIGluc3QgPSBpbnN0Ll9ob3N0UGFyZW50O1xuICB9XG4gIHZhciBpO1xuICBmb3IgKGkgPSBwYXRoLmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICBmbihwYXRoW2ldLCAnY2FwdHVyZWQnLCBhcmcpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aFtpXSwgJ2J1YmJsZWQnLCBhcmcpO1xuICB9XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIHRoZSBJRCBoaWVyYXJjaHkgYW5kIGludm9rZXMgdGhlIHN1cHBsaWVkIGBjYmAgb24gYW55IElEcyB0aGF0XG4gKiBzaG91bGQgd291bGQgcmVjZWl2ZSBhIGBtb3VzZUVudGVyYCBvciBgbW91c2VMZWF2ZWAgZXZlbnQuXG4gKlxuICogRG9lcyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZSBub3RoaW5nXG4gKiBcImVudGVyZWRcIiBvciBcImxlZnRcIiB0aGF0IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKSB7XG4gIHZhciBjb21tb24gPSBmcm9tICYmIHRvID8gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoZnJvbSwgdG8pIDogbnVsbDtcbiAgdmFyIHBhdGhGcm9tID0gW107XG4gIHdoaWxlIChmcm9tICYmIGZyb20gIT09IGNvbW1vbikge1xuICAgIHBhdGhGcm9tLnB1c2goZnJvbSk7XG4gICAgZnJvbSA9IGZyb20uX2hvc3RQYXJlbnQ7XG4gIH1cbiAgdmFyIHBhdGhUbyA9IFtdO1xuICB3aGlsZSAodG8gJiYgdG8gIT09IGNvbW1vbikge1xuICAgIHBhdGhUby5wdXNoKHRvKTtcbiAgICB0byA9IHRvLl9ob3N0UGFyZW50O1xuICB9XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgcGF0aEZyb20ubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoRnJvbVtpXSwgJ2J1YmJsZWQnLCBhcmdGcm9tKTtcbiAgfVxuICBmb3IgKGkgPSBwYXRoVG8ubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgIGZuKHBhdGhUb1tpXSwgJ2NhcHR1cmVkJywgYXJnVG8pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FuY2VzdG9yOiBpc0FuY2VzdG9yLFxuICBnZXRMb3dlc3RDb21tb25BbmNlc3RvcjogZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IsXG4gIGdldFBhcmVudEluc3RhbmNlOiBnZXRQYXJlbnRJbnN0YW5jZSxcbiAgdHJhdmVyc2VUd29QaGFzZTogdHJhdmVyc2VUd29QaGFzZSxcbiAgdHJhdmVyc2VFbnRlckxlYXZlOiB0cmF2ZXJzZUVudGVyTGVhdmVcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01UcmVlVHJhdmVyc2FsLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01DaGlsZHJlbk9wZXJhdGlvbnMnKTtcbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xuXG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xuXG4vKipcbiAqIFRleHQgbm9kZXMgdmlvbGF0ZSBhIGNvdXBsZSBhc3N1bXB0aW9ucyB0aGF0IFJlYWN0IG1ha2VzIGFib3V0IGNvbXBvbmVudHM6XG4gKlxuICogIC0gV2hlbiBtb3VudGluZyB0ZXh0IGludG8gdGhlIERPTSwgYWRqYWNlbnQgdGV4dCBub2RlcyBhcmUgbWVyZ2VkLlxuICogIC0gVGV4dCBub2RlcyBjYW5ub3QgYmUgYXNzaWduZWQgYSBSZWFjdCByb290IElELlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGlzIHVzZWQgdG8gd3JhcCBzdHJpbmdzIGJldHdlZW4gY29tbWVudCBub2RlcyBzbyB0aGF0IHRoZXlcbiAqIGNhbiB1bmRlcmdvIHRoZSBzYW1lIHJlY29uY2lsaWF0aW9uIHRoYXQgaXMgYXBwbGllZCB0byBlbGVtZW50cy5cbiAqXG4gKiBUT0RPOiBJbnZlc3RpZ2F0ZSByZXByZXNlbnRpbmcgUmVhY3QgY29tcG9uZW50cyBpbiB0aGUgRE9NIHdpdGggdGV4dCBub2Rlcy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBAZXh0ZW5kcyBSZWFjdENvbXBvbmVudFxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAvLyBUT0RPOiBUaGlzIGlzIHJlYWxseSBhIFJlYWN0VGV4dCAoUmVhY3ROb2RlKSwgbm90IGEgUmVhY3RFbGVtZW50XG4gIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gdGV4dDtcbiAgdGhpcy5fc3RyaW5nVGV4dCA9ICcnICsgdGV4dDtcbiAgLy8gUmVhY3RET01Db21wb25lbnRUcmVlIHVzZXMgdGhlc2U6XG4gIHRoaXMuX2hvc3ROb2RlID0gbnVsbDtcbiAgdGhpcy5faG9zdFBhcmVudCA9IG51bGw7XG5cbiAgLy8gUHJvcGVydGllc1xuICB0aGlzLl9kb21JRCA9IDA7XG4gIHRoaXMuX21vdW50SW5kZXggPSAwO1xuICB0aGlzLl9jbG9zaW5nQ29tbWVudCA9IG51bGw7XG4gIHRoaXMuX2NvbW1lbnROb2RlcyA9IG51bGw7XG59O1xuXG5fYXNzaWduKFJlYWN0RE9NVGV4dENvbXBvbmVudC5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIG1hcmt1cCBmb3IgdGhpcyB0ZXh0IG5vZGUuIFRoaXMgbm9kZSBpcyBub3QgaW50ZW5kZWQgdG8gaGF2ZVxuICAgKiBhbnkgZmVhdHVyZXMgYmVzaWRlcyBjb250YWluaW5nIHRleHQgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIGZvciB0aGlzIHRleHQgbm9kZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcGFyZW50SW5mbztcbiAgICAgIGlmIChob3N0UGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgcGFyZW50SW5mbyA9IGhvc3RQYXJlbnQuX2FuY2VzdG9ySW5mbztcbiAgICAgIH0gZWxzZSBpZiAoaG9zdENvbnRhaW5lckluZm8gIT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRJbmZvID0gaG9zdENvbnRhaW5lckluZm8uX2FuY2VzdG9ySW5mbztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRJbmZvKSB7XG4gICAgICAgIC8vIHBhcmVudEluZm8gc2hvdWxkIGFsd2F5cyBiZSBwcmVzZW50IGV4Y2VwdCBmb3IgdGhlIHRvcC1sZXZlbFxuICAgICAgICAvLyBjb21wb25lbnQgd2hlbiBzZXJ2ZXIgcmVuZGVyaW5nXG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyhudWxsLCB0aGlzLl9zdHJpbmdUZXh0LCB0aGlzLCBwYXJlbnRJbmZvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZG9tSUQgPSBob3N0Q29udGFpbmVySW5mby5faWRDb3VudGVyKys7XG4gICAgdmFyIG9wZW5pbmdWYWx1ZSA9ICcgcmVhY3QtdGV4dDogJyArIGRvbUlEICsgJyAnO1xuICAgIHZhciBjbG9zaW5nVmFsdWUgPSAnIC9yZWFjdC10ZXh0ICc7XG4gICAgdGhpcy5fZG9tSUQgPSBkb21JRDtcbiAgICB0aGlzLl9ob3N0UGFyZW50ID0gaG9zdFBhcmVudDtcbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBob3N0Q29udGFpbmVySW5mby5fb3duZXJEb2N1bWVudDtcbiAgICAgIHZhciBvcGVuaW5nQ29tbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlQ29tbWVudChvcGVuaW5nVmFsdWUpO1xuICAgICAgdmFyIGNsb3NpbmdDb21tZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVDb21tZW50KGNsb3NpbmdWYWx1ZSk7XG4gICAgICB2YXIgbGF6eVRyZWUgPSBET01MYXp5VHJlZShvd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSk7XG4gICAgICBET01MYXp5VHJlZS5xdWV1ZUNoaWxkKGxhenlUcmVlLCBET01MYXp5VHJlZShvcGVuaW5nQ29tbWVudCkpO1xuICAgICAgaWYgKHRoaXMuX3N0cmluZ1RleHQpIHtcbiAgICAgICAgRE9NTGF6eVRyZWUucXVldWVDaGlsZChsYXp5VHJlZSwgRE9NTGF6eVRyZWUob3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLl9zdHJpbmdUZXh0KSkpO1xuICAgICAgfVxuICAgICAgRE9NTGF6eVRyZWUucXVldWVDaGlsZChsYXp5VHJlZSwgRE9NTGF6eVRyZWUoY2xvc2luZ0NvbW1lbnQpKTtcbiAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUodGhpcywgb3BlbmluZ0NvbW1lbnQpO1xuICAgICAgdGhpcy5fY2xvc2luZ0NvbW1lbnQgPSBjbG9zaW5nQ29tbWVudDtcbiAgICAgIHJldHVybiBsYXp5VHJlZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVzY2FwZWRUZXh0ID0gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRoaXMuX3N0cmluZ1RleHQpO1xuXG4gICAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgICAgLy8gTm9ybWFsbHkgd2UnZCB3cmFwIHRoaXMgYmV0d2VlbiBjb21tZW50IG5vZGVzIGZvciB0aGUgcmVhc29ucyBzdGF0ZWRcbiAgICAgICAgLy8gYWJvdmUsIGJ1dCBzaW5jZSB0aGlzIGlzIGEgc2l0dWF0aW9uIHdoZXJlIFJlYWN0IHdvbid0IHRha2Ugb3ZlclxuICAgICAgICAvLyAoc3RhdGljIHBhZ2VzKSwgd2UgY2FuIHNpbXBseSByZXR1cm4gdGhlIHRleHQgYXMgaXQgaXMuXG4gICAgICAgIHJldHVybiBlc2NhcGVkVGV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICc8IS0tJyArIG9wZW5pbmdWYWx1ZSArICctLT4nICsgZXNjYXBlZFRleHQgKyAnPCEtLScgKyBjbG9zaW5nVmFsdWUgKyAnLS0+JztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBjb21wb25lbnQgYnkgdXBkYXRpbmcgdGhlIHRleHQgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFRleHR9IG5leHRUZXh0IFRoZSBuZXh0IHRleHQgY29udGVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRUZXh0LCB0cmFuc2FjdGlvbikge1xuICAgIGlmIChuZXh0VGV4dCAhPT0gdGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dFRleHQ7XG4gICAgICB2YXIgbmV4dFN0cmluZ1RleHQgPSAnJyArIG5leHRUZXh0O1xuICAgICAgaWYgKG5leHRTdHJpbmdUZXh0ICE9PSB0aGlzLl9zdHJpbmdUZXh0KSB7XG4gICAgICAgIC8vIFRPRE86IFNhdmUgdGhpcyBhcyBwZW5kaW5nIHByb3BzIGFuZCB1c2UgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5XG4gICAgICAgIC8vIGFuZC9vciB1cGRhdGVDb21wb25lbnQgdG8gZG8gdGhlIGFjdHVhbCB1cGRhdGUgZm9yIGNvbnNpc3RlbmN5IHdpdGhcbiAgICAgICAgLy8gb3RoZXIgY29tcG9uZW50IHR5cGVzP1xuICAgICAgICB0aGlzLl9zdHJpbmdUZXh0ID0gbmV4dFN0cmluZ1RleHQ7XG4gICAgICAgIHZhciBjb21tZW50Tm9kZXMgPSB0aGlzLmdldEhvc3ROb2RlKCk7XG4gICAgICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy5yZXBsYWNlRGVsaW1pdGVkVGV4dChjb21tZW50Tm9kZXNbMF0sIGNvbW1lbnROb2Rlc1sxXSwgbmV4dFN0cmluZ1RleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBnZXRIb3N0Tm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBob3N0Tm9kZSA9IHRoaXMuX2NvbW1lbnROb2RlcztcbiAgICBpZiAoaG9zdE5vZGUpIHtcbiAgICAgIHJldHVybiBob3N0Tm9kZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9jbG9zaW5nQ29tbWVudCkge1xuICAgICAgdmFyIG9wZW5pbmdDb21tZW50ID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGhpcyk7XG4gICAgICB2YXIgbm9kZSA9IG9wZW5pbmdDb21tZW50Lm5leHRTaWJsaW5nO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgIShub2RlICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01pc3NpbmcgY2xvc2luZyBjb21tZW50IGZvciB0ZXh0IGNvbXBvbmVudCAlcycsIHRoaXMuX2RvbUlEKSA6IF9wcm9kSW52YXJpYW50KCc2NycsIHRoaXMuX2RvbUlEKSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggJiYgbm9kZS5ub2RlVmFsdWUgPT09ICcgL3JlYWN0LXRleHQgJykge1xuICAgICAgICAgIHRoaXMuX2Nsb3NpbmdDb21tZW50ID0gbm9kZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG4gICAgaG9zdE5vZGUgPSBbdGhpcy5faG9zdE5vZGUsIHRoaXMuX2Nsb3NpbmdDb21tZW50XTtcbiAgICB0aGlzLl9jb21tZW50Tm9kZXMgPSBob3N0Tm9kZTtcbiAgICByZXR1cm4gaG9zdE5vZGU7XG4gIH0sXG5cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2Nsb3NpbmdDb21tZW50ID0gbnVsbDtcbiAgICB0aGlzLl9jb21tZW50Tm9kZXMgPSBudWxsO1xuICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS51bmNhY2hlTm9kZSh0aGlzKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01UZXh0Q29tcG9uZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NVGV4dENvbXBvbmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG5cbnZhciBSRVNFVF9CQVRDSEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGVtcHR5RnVuY3Rpb24sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xuICB9XG59O1xuXG52YXIgRkxVU0hfQkFUQ0hFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBlbXB0eUZ1bmN0aW9uLFxuICBjbG9zZTogUmVhY3RVcGRhdGVzLmZsdXNoQmF0Y2hlZFVwZGF0ZXMuYmluZChSZWFjdFVwZGF0ZXMpXG59O1xuXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbRkxVU0hfQkFUQ0hFRF9VUERBVEVTLCBSRVNFVF9CQVRDSEVEX1VQREFURVNdO1xuXG5mdW5jdGlvbiBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24oKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbn1cblxuX2Fzc2lnbihSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbiwge1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9XG59KTtcblxudmFyIHRyYW5zYWN0aW9uID0gbmV3IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbigpO1xuXG52YXIgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSA9IHtcbiAgaXNCYXRjaGluZ1VwZGF0ZXM6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpbiBhIGNvbnRleHQgd2l0aGluIHdoaWNoIGNhbGxzIHRvIGBzZXRTdGF0ZWBcbiAgICogYW5kIGZyaWVuZHMgYXJlIGJhdGNoZWQgc3VjaCB0aGF0IGNvbXBvbmVudHMgYXJlbid0IHVwZGF0ZWQgdW5uZWNlc3NhcmlseS5cbiAgICovXG4gIGJhdGNoZWRVcGRhdGVzOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpIHtcbiAgICB2YXIgYWxyZWFkeUJhdGNoaW5nVXBkYXRlcyA9IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXM7XG5cbiAgICBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcblxuICAgIC8vIFRoZSBjb2RlIGlzIHdyaXR0ZW4gdGhpcyB3YXkgdG8gYXZvaWQgZXh0cmEgYWxsb2NhdGlvbnNcbiAgICBpZiAoYWxyZWFkeUJhdGNoaW5nVXBkYXRlcykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGEsIGIsIGMsIGQsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb24ucGVyZm9ybShjYWxsYmFjaywgbnVsbCwgYSwgYiwgYywgZCwgZSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3k7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2ZianMvbGliL0V2ZW50TGlzdGVuZXInKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2dldEV2ZW50VGFyZ2V0Jyk7XG52YXIgZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbicpO1xuXG4vKipcbiAqIEZpbmQgdGhlIGRlZXBlc3QgUmVhY3QgY29tcG9uZW50IGNvbXBsZXRlbHkgY29udGFpbmluZyB0aGUgcm9vdCBvZiB0aGVcbiAqIHBhc3NlZC1pbiBpbnN0YW5jZSAoZm9yIHVzZSB3aGVuIGVudGlyZSBSZWFjdCB0cmVlcyBhcmUgbmVzdGVkIHdpdGhpbiBlYWNoXG4gKiBvdGhlcikuIElmIFJlYWN0IHRyZWVzIGFyZSBub3QgbmVzdGVkLCByZXR1cm5zIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGZpbmRQYXJlbnQoaW5zdCkge1xuICAvLyBUT0RPOiBJdCBtYXkgYmUgYSBnb29kIGlkZWEgdG8gY2FjaGUgdGhpcyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IERPTVxuICAvLyB0cmF2ZXJzYWwsIGJ1dCBjYWNoaW5nIGlzIGRpZmZpY3VsdCB0byBkbyBjb3JyZWN0bHkgd2l0aG91dCB1c2luZyBhXG4gIC8vIG11dGF0aW9uIG9ic2VydmVyIHRvIGxpc3RlbiBmb3IgYWxsIERPTSBjaGFuZ2VzLlxuICB3aGlsZSAoaW5zdC5faG9zdFBhcmVudCkge1xuICAgIGluc3QgPSBpbnN0Ll9ob3N0UGFyZW50O1xuICB9XG4gIHZhciByb290Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICB2YXIgY29udGFpbmVyID0gcm9vdE5vZGUucGFyZW50Tm9kZTtcbiAgcmV0dXJuIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShjb250YWluZXIpO1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGFuY2VzdG9yIGhpZXJhcmNoeSBpbiB0b3AgbGV2ZWwgY2FsbGJhY2tcbmZ1bmN0aW9uIFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHRoaXMudG9wTGV2ZWxUeXBlID0gdG9wTGV2ZWxUeXBlO1xuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gIHRoaXMuYW5jZXN0b3JzID0gW107XG59XG5fYXNzaWduKFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5wcm90b3R5cGUsIHtcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmFuY2VzdG9ycy5sZW5ndGggPSAwO1xuICB9XG59KTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcsIFBvb2xlZENsYXNzLnR3b0FyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWxJbXBsKGJvb2tLZWVwaW5nKSB7XG4gIHZhciBuYXRpdmVFdmVudFRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50KTtcbiAgdmFyIHRhcmdldEluc3QgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIC8vIExvb3AgdGhyb3VnaCB0aGUgaGllcmFyY2h5LCBpbiBjYXNlIHRoZXJlJ3MgYW55IG5lc3RlZCBjb21wb25lbnRzLlxuICAvLyBJdCdzIGltcG9ydGFudCB0aGF0IHdlIGJ1aWxkIHRoZSBhcnJheSBvZiBhbmNlc3RvcnMgYmVmb3JlIGNhbGxpbmcgYW55XG4gIC8vIGV2ZW50IGhhbmRsZXJzLCBiZWNhdXNlIGV2ZW50IGhhbmRsZXJzIGNhbiBtb2RpZnkgdGhlIERPTSwgbGVhZGluZyB0b1xuICAvLyBpbmNvbnNpc3RlbmNpZXMgd2l0aCBSZWFjdE1vdW50J3Mgbm9kZSBjYWNoZS4gU2VlICMxMTA1LlxuICB2YXIgYW5jZXN0b3IgPSB0YXJnZXRJbnN0O1xuICBkbyB7XG4gICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgIGFuY2VzdG9yID0gYW5jZXN0b3IgJiYgZmluZFBhcmVudChhbmNlc3Rvcik7XG4gIH0gd2hpbGUgKGFuY2VzdG9yKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIHRhcmdldEluc3QgPSBib29rS2VlcGluZy5hbmNlc3RvcnNbaV07XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbChib29rS2VlcGluZy50b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjcm9sbFZhbHVlTW9uaXRvcihjYikge1xuICB2YXIgc2Nyb2xsUG9zaXRpb24gPSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbih3aW5kb3cpO1xuICBjYihzY3JvbGxQb3NpdGlvbik7XG59XG5cbnZhciBSZWFjdEV2ZW50TGlzdGVuZXIgPSB7XG4gIF9lbmFibGVkOiB0cnVlLFxuICBfaGFuZGxlVG9wTGV2ZWw6IG51bGwsXG5cbiAgV0lORE9XX0hBTkRMRTogRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gd2luZG93IDogbnVsbCxcblxuICBzZXRIYW5kbGVUb3BMZXZlbDogZnVuY3Rpb24gKGhhbmRsZVRvcExldmVsKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbCA9IGhhbmRsZVRvcExldmVsO1xuICB9LFxuXG4gIHNldEVuYWJsZWQ6IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkID0gISFlbmFibGVkO1xuICB9LFxuXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXBzIHRvcC1sZXZlbCBldmVudHMgYnkgdXNpbmcgZXZlbnQgYnViYmxpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAgICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXBCdWJibGVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBFdmVudExpc3RlbmVyLmxpc3RlbihlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIFJlYWN0RXZlbnRMaXN0ZW5lci5kaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXBzIGEgdG9wLWxldmVsIGV2ZW50IGJ5IHVzaW5nIGV2ZW50IGNhcHR1cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnQgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICAgKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhcENhcHR1cmVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBFdmVudExpc3RlbmVyLmNhcHR1cmUoZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBSZWFjdEV2ZW50TGlzdGVuZXIuZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xuICB9LFxuXG4gIG1vbml0b3JTY3JvbGxWYWx1ZTogZnVuY3Rpb24gKHJlZnJlc2gpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBzY3JvbGxWYWx1ZU1vbml0b3IuYmluZChudWxsLCByZWZyZXNoKTtcbiAgICBFdmVudExpc3RlbmVyLmxpc3Rlbih3aW5kb3csICdzY3JvbGwnLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgICBpZiAoIVJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBib29rS2VlcGluZyA9IFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5nZXRQb29sZWQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEV2ZW50IHF1ZXVlIGJlaW5nIHByb2Nlc3NlZCBpbiB0aGUgc2FtZSBjeWNsZSBhbGxvd3NcbiAgICAgIC8vIGBwcmV2ZW50RGVmYXVsdGAuXG4gICAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMoaGFuZGxlVG9wTGV2ZWxJbXBsLCBib29rS2VlcGluZyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5yZWxlYXNlKGJvb2tLZWVwaW5nKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFdmVudExpc3RlbmVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RXZlbnRMaXN0ZW5lci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIHN1cHBsaWVkIGVsZW1lbnQgb3Igd2luZG93LlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWVzIGFyZSB1bmJvdW5kZWQsIHVubGlrZSBgZ2V0U2Nyb2xsUG9zaXRpb25gLiBUaGlzIG1lYW5zIHRoZXlcbiAqIG1heSBiZSBuZWdhdGl2ZSBvciBleGNlZWQgdGhlIGVsZW1lbnQgYm91bmRhcmllcyAod2hpY2ggaXMgcG9zc2libGUgdXNpbmdcbiAqIGluZXJ0aWFsIHNjcm9sbGluZykuXG4gKlxuICogQHBhcmFtIHtET01XaW5kb3d8RE9NRWxlbWVudH0gc2Nyb2xsYWJsZVxuICogQHJldHVybiB7b2JqZWN0fSBNYXAgd2l0aCBgeGAgYW5kIGB5YCBrZXlzLlxuICovXG5cbmZ1bmN0aW9uIGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uKHNjcm9sbGFibGUpIHtcbiAgaWYgKHNjcm9sbGFibGUuV2luZG93ICYmIHNjcm9sbGFibGUgaW5zdGFuY2VvZiBzY3JvbGxhYmxlLldpbmRvdykge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBzY3JvbGxhYmxlLnBhZ2VYT2Zmc2V0IHx8IHNjcm9sbGFibGUuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICB5OiBzY3JvbGxhYmxlLnBhZ2VZT2Zmc2V0IHx8IHNjcm9sbGFibGUuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBzY3JvbGxhYmxlLnNjcm9sbExlZnQsXG4gICAgeTogc2Nyb2xsYWJsZS5zY3JvbGxUb3BcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5VdGlscycpO1xudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVtcHR5Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdEhvc3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0SG9zdENvbXBvbmVudCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBSZWFjdEluamVjdGlvbiA9IHtcbiAgQ29tcG9uZW50OiBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LmluamVjdGlvbixcbiAgRE9NUHJvcGVydHk6IERPTVByb3BlcnR5LmluamVjdGlvbixcbiAgRW1wdHlDb21wb25lbnQ6IFJlYWN0RW1wdHlDb21wb25lbnQuaW5qZWN0aW9uLFxuICBFdmVudFBsdWdpbkh1YjogRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLFxuICBFdmVudFBsdWdpblV0aWxzOiBFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbixcbiAgRXZlbnRFbWl0dGVyOiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaW5qZWN0aW9uLFxuICBIb3N0Q29tcG9uZW50OiBSZWFjdEhvc3RDb21wb25lbnQuaW5qZWN0aW9uLFxuICBVcGRhdGVzOiBSZWFjdFVwZGF0ZXMuaW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5qZWN0aW9uO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0SW5qZWN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZSgnLi9DYWxsYmFja1F1ZXVlJyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdElucHV0U2VsZWN0aW9uJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xuXG4vKipcbiAqIEVuc3VyZXMgdGhhdCwgd2hlbiBwb3NzaWJsZSwgdGhlIHNlbGVjdGlvbiByYW5nZSAoY3VycmVudGx5IHNlbGVjdGVkIHRleHRcbiAqIGlucHV0KSBpcyBub3QgZGlzdHVyYmVkIGJ5IHBlcmZvcm1pbmcgdGhlIHRyYW5zYWN0aW9uLlxuICovXG52YXIgU0VMRUNUSU9OX1JFU1RPUkFUSU9OID0ge1xuICAvKipcbiAgICogQHJldHVybiB7U2VsZWN0aW9ufSBTZWxlY3Rpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICBpbml0aWFsaXplOiBSZWFjdElucHV0U2VsZWN0aW9uLmdldFNlbGVjdGlvbkluZm9ybWF0aW9uLFxuICAvKipcbiAgICogQHBhcmFtIHtTZWxlY3Rpb259IHNlbCBTZWxlY3Rpb24gaW5mb3JtYXRpb24gcmV0dXJuZWQgZnJvbSBgaW5pdGlhbGl6ZWAuXG4gICAqL1xuICBjbG9zZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5yZXN0b3JlU2VsZWN0aW9uXG59O1xuXG4vKipcbiAqIFN1cHByZXNzZXMgZXZlbnRzIChibHVyL2ZvY3VzKSB0aGF0IGNvdWxkIGJlIGluYWR2ZXJ0ZW50bHkgZGlzcGF0Y2hlZCBkdWUgdG9cbiAqIGhpZ2ggbGV2ZWwgRE9NIG1hbmlwdWxhdGlvbnMgKGxpa2UgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgYSB0ZXh0IGlucHV0IGZyb20gdGhlXG4gKiBET00pLlxuICovXG52YXIgRVZFTlRfU1VQUFJFU1NJT04gPSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgZW5hYmxlZCBzdGF0dXMgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgYmVmb3JlXG4gICAqIHRoZSByZWNvbmNpbGlhdGlvbi5cbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3VycmVudGx5RW5hYmxlZCA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5pc0VuYWJsZWQoKTtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuc2V0RW5hYmxlZChmYWxzZSk7XG4gICAgcmV0dXJuIGN1cnJlbnRseUVuYWJsZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJldmlvdXNseUVuYWJsZWQgRW5hYmxlZCBzdGF0dXMgb2ZcbiAgICogICBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBiZWZvcmUgdGhlIHJlY29uY2lsaWF0aW9uIG9jY3VycmVkLiBgY2xvc2VgXG4gICAqICAgcmVzdG9yZXMgdGhlIHByZXZpb3VzIHZhbHVlLlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uIChwcmV2aW91c2x5RW5hYmxlZCkge1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zZXRFbmFibGVkKHByZXZpb3VzbHlFbmFibGVkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcm92aWRlcyBhIHF1ZXVlIGZvciBjb2xsZWN0aW5nIGBjb21wb25lbnREaWRNb3VudGAgYW5kXG4gKiBgY29tcG9uZW50RGlkVXBkYXRlYCBjYWxsYmFja3MgZHVyaW5nIHRoZSB0cmFuc2FjdGlvbi5cbiAqL1xudmFyIE9OX0RPTV9SRUFEWV9RVUVVRUlORyA9IHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBpbnRlcm5hbCBgb25ET01SZWFkeWAgcXVldWUuXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkucmVzZXQoKTtcbiAgfSxcblxuICAvKipcbiAgICogQWZ0ZXIgRE9NIGlzIGZsdXNoZWQsIGludm9rZSBhbGwgcmVnaXN0ZXJlZCBgb25ET01SZWFkeWAgY2FsbGJhY2tzLlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5ub3RpZnlBbGwoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlZCB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBDb25zaWRlciB0aGVzZSBhc1xuICogYmVpbmcgbWVtYmVyIG1ldGhvZHMsIGJ1dCB3aXRoIGFuIGltcGxpZWQgb3JkZXJpbmcgd2hpbGUgYmVpbmcgaXNvbGF0ZWQgZnJvbVxuICogZWFjaCBvdGhlci5cbiAqL1xudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW1NFTEVDVElPTl9SRVNUT1JBVElPTiwgRVZFTlRfU1VQUFJFU1NJT04sIE9OX0RPTV9SRUFEWV9RVUVVRUlOR107XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFRSQU5TQUNUSU9OX1dSQVBQRVJTLnB1c2goe1xuICAgIGluaXRpYWxpemU6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luRmx1c2gsXG4gICAgY2xvc2U6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZEZsdXNoXG4gIH0pO1xufVxuXG4vKipcbiAqIEN1cnJlbnRseTpcbiAqIC0gVGhlIG9yZGVyIHRoYXQgdGhlc2UgYXJlIGxpc3RlZCBpbiB0aGUgdHJhbnNhY3Rpb24gaXMgY3JpdGljYWw6XG4gKiAtIFN1cHByZXNzZXMgZXZlbnRzLlxuICogLSBSZXN0b3JlcyBzZWxlY3Rpb24gcmFuZ2UuXG4gKlxuICogRnV0dXJlOlxuICogLSBSZXN0b3JlIGRvY3VtZW50L292ZXJmbG93IHNjcm9sbCBwb3NpdGlvbnMgdGhhdCB3ZXJlIHVuaW50ZW50aW9uYWxseVxuICogICBtb2RpZmllZCB2aWEgRE9NIGluc2VydGlvbnMgYWJvdmUgdGhlIHRvcCB2aWV3cG9ydCBib3VuZGFyeS5cbiAqIC0gSW1wbGVtZW50L2ludGVncmF0ZSB3aXRoIGN1c3RvbWl6ZWQgY29uc3RyYWludCBiYXNlZCBsYXlvdXQgc3lzdGVtIGFuZCBrZWVwXG4gKiAgIHRyYWNrIG9mIHdoaWNoIGRpbWVuc2lvbnMgbXVzdCBiZSByZW1lYXN1cmVkLlxuICpcbiAqIEBjbGFzcyBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uXG4gKi9cbmZ1bmN0aW9uIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24odXNlQ3JlYXRlRWxlbWVudCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIC8vIE9ubHkgc2VydmVyLXNpZGUgcmVuZGVyaW5nIHJlYWxseSBuZWVkcyB0aGlzIG9wdGlvbiAoc2VlXG4gIC8vIGBSZWFjdFNlcnZlclJlbmRlcmluZ2ApLCBidXQgc2VydmVyLXNpZGUgdXNlc1xuICAvLyBgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbmAgaW5zdGVhZC4gVGhpcyBvcHRpb24gaXMgaGVyZSBzbyB0aGF0IGl0J3NcbiAgLy8gYWNjZXNzaWJsZSBhbmQgZGVmYXVsdHMgdG8gZmFsc2Ugd2hlbiBgUmVhY3RET01Db21wb25lbnRgIGFuZFxuICAvLyBgUmVhY3RET01UZXh0Q29tcG9uZW50YCBjaGVja3MgaXQgaW4gYG1vdW50Q29tcG9uZW50YC5gXG4gIHRoaXMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSBmYWxzZTtcbiAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZChudWxsKTtcbiAgdGhpcy51c2VDcmVhdGVFbGVtZW50ID0gdXNlQ3JlYXRlRWxlbWVudDtcbn1cblxudmFyIE1peGluID0ge1xuICAvKipcbiAgICogQHNlZSBUcmFuc2FjdGlvblxuICAgKiBAYWJzdHJhY3RcbiAgICogQGZpbmFsXG4gICAqIEByZXR1cm4ge2FycmF5PG9iamVjdD59IExpc3Qgb2Ygb3BlcmF0aW9uIHdyYXAgcHJvY2VkdXJlcy5cbiAgICogICBUT0RPOiBjb252ZXJ0IHRvIGFycmF5PFRyYW5zYWN0aW9uV3JhcHBlcj5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcyB3aXRoLlxuICAgKi9cbiAgZ2V0UmVhY3RNb3VudFJlYWR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhY3RNb3VudFJlYWR5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IFJlYWN0IGFzeW5jIGV2ZW50cy5cbiAgICovXG4gIGdldFVwZGF0ZVF1ZXVlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0VXBkYXRlUXVldWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhdmUgY3VycmVudCB0cmFuc2FjdGlvbiBzdGF0ZSAtLSBpZiB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhpcyBtZXRob2QgaXNcbiAgICogcGFzc2VkIHRvIGByb2xsYmFja2AsIHRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIHJlc2V0IHRvIHRoYXQgc3RhdGUuXG4gICAqL1xuICBjaGVja3BvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcmVhY3RNb3VudFJlYWR5IGlzIHRoZSBvdXIgb25seSBzdGF0ZWZ1bCB3cmFwcGVyXG4gICAgcmV0dXJuIHRoaXMucmVhY3RNb3VudFJlYWR5LmNoZWNrcG9pbnQoKTtcbiAgfSxcblxuICByb2xsYmFjazogZnVuY3Rpb24gKGNoZWNrcG9pbnQpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5yb2xsYmFjayhjaGVja3BvaW50KTtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcywgYW5kIHdpbGwgaW52b2tlIHRoaXMgYmVmb3JlIGFsbG93aW5nIHRoaXNcbiAgICogaW5zdGFuY2UgdG8gYmUgcmV1c2VkLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLnJlYWN0TW91bnRSZWFkeSk7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBudWxsO1xuICB9XG59O1xuXG5fYXNzaWduKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbiwgTWl4aW4pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQgPSByZXF1aXJlKCcuL2dldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQnKTtcbnZhciBnZXRUZXh0Q29udGVudEFjY2Vzc29yID0gcmVxdWlyZSgnLi9nZXRUZXh0Q29udGVudEFjY2Vzc29yJyk7XG5cbi8qKlxuICogV2hpbGUgYGlzQ29sbGFwc2VkYCBpcyBhdmFpbGFibGUgb24gdGhlIFNlbGVjdGlvbiBvYmplY3QgYW5kIGBjb2xsYXBzZWRgXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIFJhbmdlIG9iamVjdCwgSUUxMSBzb21ldGltZXMgZ2V0cyB0aGVtIHdyb25nLlxuICogSWYgdGhlIGFuY2hvci9mb2N1cyBub2RlcyBhbmQgb2Zmc2V0cyBhcmUgdGhlIHNhbWUsIHRoZSByYW5nZSBpcyBjb2xsYXBzZWQuXG4gKi9cbmZ1bmN0aW9uIGlzQ29sbGFwc2VkKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xuICByZXR1cm4gYW5jaG9yTm9kZSA9PT0gZm9jdXNOb2RlICYmIGFuY2hvck9mZnNldCA9PT0gZm9jdXNPZmZzZXQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBhcHByb3ByaWF0ZSBhbmNob3IgYW5kIGZvY3VzIG5vZGUvb2Zmc2V0IHBhaXJzIGZvciBJRS5cbiAqXG4gKiBUaGUgY2F0Y2ggaGVyZSBpcyB0aGF0IElFJ3Mgc2VsZWN0aW9uIEFQSSBkb2Vzbid0IHByb3ZpZGUgaW5mb3JtYXRpb25cbiAqIGFib3V0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBmb3J3YXJkIG9yIGJhY2t3YXJkLCBzbyB3ZSBoYXZlIHRvXG4gKiBiZWhhdmUgYXMgdGhvdWdoIGl0J3MgYWx3YXlzIGZvcndhcmQuXG4gKlxuICogSUUgdGV4dCBkaWZmZXJzIGZyb20gbW9kZXJuIHNlbGVjdGlvbiBpbiB0aGF0IGl0IGJlaGF2ZXMgYXMgdGhvdWdoXG4gKiBibG9jayBlbGVtZW50cyBlbmQgd2l0aCBhIG5ldyBsaW5lLiBUaGlzIG1lYW5zIGNoYXJhY3RlciBvZmZzZXRzIHdpbGxcbiAqIGRpZmZlciBiZXR3ZWVuIHRoZSB0d28gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0SUVPZmZzZXRzKG5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGRvY3VtZW50LnNlbGVjdGlvbjtcbiAgdmFyIHNlbGVjdGVkUmFuZ2UgPSBzZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgdmFyIHNlbGVjdGVkTGVuZ3RoID0gc2VsZWN0ZWRSYW5nZS50ZXh0Lmxlbmd0aDtcblxuICAvLyBEdXBsaWNhdGUgc2VsZWN0aW9uIHNvIHdlIGNhbiBtb3ZlIHJhbmdlIHdpdGhvdXQgYnJlYWtpbmcgdXNlciBzZWxlY3Rpb24uXG4gIHZhciBmcm9tU3RhcnQgPSBzZWxlY3RlZFJhbmdlLmR1cGxpY2F0ZSgpO1xuICBmcm9tU3RhcnQubW92ZVRvRWxlbWVudFRleHQobm9kZSk7XG4gIGZyb21TdGFydC5zZXRFbmRQb2ludCgnRW5kVG9TdGFydCcsIHNlbGVjdGVkUmFuZ2UpO1xuXG4gIHZhciBzdGFydE9mZnNldCA9IGZyb21TdGFydC50ZXh0Lmxlbmd0aDtcbiAgdmFyIGVuZE9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgc2VsZWN0ZWRMZW5ndGg7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnRPZmZzZXQsXG4gICAgZW5kOiBlbmRPZmZzZXRcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE1vZGVybk9mZnNldHMobm9kZSkge1xuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbiAmJiB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gIHZhciBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICB2YXIgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgdmFyIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuXG4gIHZhciBjdXJyZW50UmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcblxuICAvLyBJbiBGaXJlZm94LCByYW5nZS5zdGFydENvbnRhaW5lciBhbmQgcmFuZ2UuZW5kQ29udGFpbmVyIGNhbiBiZSBcImFub255bW91c1xuICAvLyBkaXZzXCIsIGUuZy4gdGhlIHVwL2Rvd24gYnV0dG9ucyBvbiBhbiA8aW5wdXQgdHlwZT1cIm51bWJlclwiPi4gQW5vbnltb3VzXG4gIC8vIGRpdnMgZG8gbm90IHNlZW0gdG8gZXhwb3NlIHByb3BlcnRpZXMsIHRyaWdnZXJpbmcgYSBcIlBlcm1pc3Npb24gZGVuaWVkXG4gIC8vIGVycm9yXCIgaWYgYW55IG9mIGl0cyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlXG4gIC8vIHdheSB0byBhdm9pZCBlcnJvcmluZyBpcyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IHR5cGljYWxseSB3b3JrcyBmb3JcbiAgLy8gbm9uLWFub255bW91cyBkaXZzIGFuZCBjYXRjaCBhbnkgZXJyb3IgdGhhdCBtYXkgb3RoZXJ3aXNlIGFyaXNlLiBTZWVcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG4gIHRyeSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gICAgY3VycmVudFJhbmdlLnN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlO1xuICAgIGN1cnJlbnRSYW5nZS5lbmRDb250YWluZXIubm9kZVR5cGU7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gSWYgdGhlIG5vZGUgYW5kIG9mZnNldCB2YWx1ZXMgYXJlIHRoZSBzYW1lLCB0aGUgc2VsZWN0aW9uIGlzIGNvbGxhcHNlZC5cbiAgLy8gYFNlbGVjdGlvbi5pc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG5hdGl2ZWx5LCBidXQgSUUgc29tZXRpbWVzIGdldHNcbiAgLy8gdGhpcyB2YWx1ZSB3cm9uZy5cbiAgdmFyIGlzU2VsZWN0aW9uQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQoc2VsZWN0aW9uLmFuY2hvck5vZGUsIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsIHNlbGVjdGlvbi5mb2N1c05vZGUsIHNlbGVjdGlvbi5mb2N1c09mZnNldCk7XG5cbiAgdmFyIHJhbmdlTGVuZ3RoID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQgPyAwIDogY3VycmVudFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuXG4gIHZhciB0ZW1wUmFuZ2UgPSBjdXJyZW50UmFuZ2UuY2xvbmVSYW5nZSgpO1xuICB0ZW1wUmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICB0ZW1wUmFuZ2Uuc2V0RW5kKGN1cnJlbnRSYW5nZS5zdGFydENvbnRhaW5lciwgY3VycmVudFJhbmdlLnN0YXJ0T2Zmc2V0KTtcblxuICB2YXIgaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPSBpc0NvbGxhcHNlZCh0ZW1wUmFuZ2Uuc3RhcnRDb250YWluZXIsIHRlbXBSYW5nZS5zdGFydE9mZnNldCwgdGVtcFJhbmdlLmVuZENvbnRhaW5lciwgdGVtcFJhbmdlLmVuZE9mZnNldCk7XG5cbiAgdmFyIHN0YXJ0ID0gaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPyAwIDogdGVtcFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuICB2YXIgZW5kID0gc3RhcnQgKyByYW5nZUxlbmd0aDtcblxuICAvLyBEZXRlY3Qgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGJhY2t3YXJkLlxuICB2YXIgZGV0ZWN0aW9uUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICBkZXRlY3Rpb25SYW5nZS5zZXRTdGFydChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpO1xuICBkZXRlY3Rpb25SYW5nZS5zZXRFbmQoZm9jdXNOb2RlLCBmb2N1c09mZnNldCk7XG4gIHZhciBpc0JhY2t3YXJkID0gZGV0ZWN0aW9uUmFuZ2UuY29sbGFwc2VkO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGlzQmFja3dhcmQgPyBlbmQgOiBzdGFydCxcbiAgICBlbmQ6IGlzQmFja3dhcmQgPyBzdGFydCA6IGVuZFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0SUVPZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkuZHVwbGljYXRlKCk7XG4gIHZhciBzdGFydCwgZW5kO1xuXG4gIGlmIChvZmZzZXRzLmVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIGVuZCA9IHN0YXJ0O1xuICB9IGVsc2UgaWYgKG9mZnNldHMuc3RhcnQgPiBvZmZzZXRzLmVuZCkge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5lbmQ7XG4gICAgZW5kID0gb2Zmc2V0cy5zdGFydDtcbiAgfSBlbHNlIHtcbiAgICBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gIH1cblxuICByYW5nZS5tb3ZlVG9FbGVtZW50VGV4dChub2RlKTtcbiAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gIHJhbmdlLnNldEVuZFBvaW50KCdFbmRUb1N0YXJ0JywgcmFuZ2UpO1xuICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQgLSBzdGFydCk7XG4gIHJhbmdlLnNlbGVjdCgpO1xufVxuXG4vKipcbiAqIEluIG1vZGVybiBub24tSUUgYnJvd3NlcnMsIHdlIGNhbiBzdXBwb3J0IGJvdGggZm9yd2FyZCBhbmQgYmFja3dhcmRcbiAqIHNlbGVjdGlvbnMuXG4gKlxuICogTm90ZTogSUUxMCsgc3VwcG9ydHMgdGhlIFNlbGVjdGlvbiBvYmplY3QsIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0XG4gKiB0aGUgYGV4dGVuZGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGV2ZW4gaW4gbW9kZXJuIElFLCBpdCdzIG5vdCBwb3NzaWJsZVxuICogdG8gcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBiYWNrd2FyZCBzZWxlY3Rpb24uIFRodXMsIGZvciBhbGwgSUVcbiAqIHZlcnNpb25zLCB3ZSB1c2UgdGhlIG9sZCBJRSBBUEkgdG8gY3JlYXRlIG91ciBzZWxlY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0TW9kZXJuT2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIGlmICghd2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBsZW5ndGggPSBub2RlW2dldFRleHRDb250ZW50QWNjZXNzb3IoKV0ubGVuZ3RoO1xuICB2YXIgc3RhcnQgPSBNYXRoLm1pbihvZmZzZXRzLnN0YXJ0LCBsZW5ndGgpO1xuICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogTWF0aC5taW4ob2Zmc2V0cy5lbmQsIGxlbmd0aCk7XG5cbiAgLy8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxuICAvLyBGbGlwIGJhY2t3YXJkIHNlbGVjdGlvbnMsIHNvIHdlIGNhbiBzZXQgd2l0aCBhIHNpbmdsZSByYW5nZS5cbiAgaWYgKCFzZWxlY3Rpb24uZXh0ZW5kICYmIHN0YXJ0ID4gZW5kKSB7XG4gICAgdmFyIHRlbXAgPSBlbmQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gICAgc3RhcnQgPSB0ZW1wO1xuICB9XG5cbiAgdmFyIHN0YXJ0TWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBzdGFydCk7XG4gIHZhciBlbmRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIGVuZCk7XG5cbiAgaWYgKHN0YXJ0TWFya2VyICYmIGVuZE1hcmtlcikge1xuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnRNYXJrZXIubm9kZSwgc3RhcnRNYXJrZXIub2Zmc2V0KTtcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICBzZWxlY3Rpb24uZXh0ZW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2Uuc2V0RW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciB1c2VJRU9mZnNldHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ3NlbGVjdGlvbicgaW4gZG9jdW1lbnQgJiYgISgnZ2V0U2VsZWN0aW9uJyBpbiB3aW5kb3cpO1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICovXG4gIGdldE9mZnNldHM6IHVzZUlFT2Zmc2V0cyA/IGdldElFT2Zmc2V0cyA6IGdldE1vZGVybk9mZnNldHMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICAgKi9cbiAgc2V0T2Zmc2V0czogdXNlSUVPZmZzZXRzID8gc2V0SUVPZmZzZXRzIDogc2V0TW9kZXJuT2Zmc2V0c1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlbGVjdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTVNlbGVjdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2l2ZW4gYW55IG5vZGUgcmV0dXJuIHRoZSBmaXJzdCBsZWFmIG5vZGUgd2l0aG91dCBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cblxuZnVuY3Rpb24gZ2V0TGVhZk5vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSAmJiBub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBzaWJsaW5nIHdpdGhpbiBhIGNvbnRhaW5lci4gVGhpcyB3aWxsIHdhbGsgdXAgdGhlXG4gKiBET00gaWYgYSBub2RlJ3Mgc2libGluZ3MgaGF2ZSBiZWVuIGV4aGF1c3RlZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IG9iamVjdCBkZXNjcmliaW5nIHRoZSBub2RlcyB3aGljaCBjb250YWluIGNoYXJhY3RlcnMgYXQgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gcm9vdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChyb290LCBvZmZzZXQpIHtcbiAgdmFyIG5vZGUgPSBnZXRMZWFmTm9kZShyb290KTtcbiAgdmFyIG5vZGVTdGFydCA9IDA7XG4gIHZhciBub2RlRW5kID0gMDtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICBub2RlRW5kID0gbm9kZVN0YXJ0ICsgbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG5cbiAgICAgIGlmIChub2RlU3RhcnQgPD0gb2Zmc2V0ICYmIG5vZGVFbmQgPj0gb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCAtIG5vZGVTdGFydFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBub2RlU3RhcnQgPSBub2RlRW5kO1xuICAgIH1cblxuICAgIG5vZGUgPSBnZXRMZWFmTm9kZShnZXRTaWJsaW5nTm9kZShub2RlKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2dldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG52YXIgaXNUZXh0Tm9kZSA9IHJlcXVpcmUoJy4vaXNUZXh0Tm9kZScpO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBET00gbm9kZSBjb250YWlucyBvciBpcyBhbm90aGVyIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUpIHtcbiAgaWYgKCFvdXRlck5vZGUgfHwgIWlubmVyTm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUgPT09IGlubmVyTm9kZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUob3V0ZXJOb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKGlubmVyTm9kZSkpIHtcbiAgICByZXR1cm4gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlLnBhcmVudE5vZGUpO1xuICB9IGVsc2UgaWYgKCdjb250YWlucycgaW4gb3V0ZXJOb2RlKSB7XG4gICAgcmV0dXJuIG91dGVyTm9kZS5jb250YWlucyhpbm5lck5vZGUpO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICAgIHJldHVybiAhIShvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oaW5uZXJOb2RlKSAmIDE2KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250YWluc05vZGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NvbnRhaW5zTm9kZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vaXNOb2RlJyk7XG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gdGV4dCBub2RlLlxuICovXG5mdW5jdGlvbiBpc1RleHROb2RlKG9iamVjdCkge1xuICByZXR1cm4gaXNOb2RlKG9iamVjdCkgJiYgb2JqZWN0Lm5vZGVUeXBlID09IDM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0Tm9kZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNUZXh0Tm9kZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBpc05vZGUob2JqZWN0KSB7XG4gIHZhciBkb2MgPSBvYmplY3QgPyBvYmplY3Qub3duZXJEb2N1bWVudCB8fCBvYmplY3QgOiBkb2N1bWVudDtcbiAgdmFyIGRlZmF1bHRWaWV3ID0gZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgcmV0dXJuICEhKG9iamVjdCAmJiAodHlwZW9mIGRlZmF1bHRWaWV3Lk5vZGUgPT09ICdmdW5jdGlvbicgPyBvYmplY3QgaW5zdGFuY2VvZiBkZWZhdWx0Vmlldy5Ob2RlIDogdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iamVjdC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZycpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc05vZGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2lzTm9kZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBOUyA9IHtcbiAgeGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgeG1sOiAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJ1xufTtcblxuLy8gV2UgdXNlIGF0dHJpYnV0ZXMgZm9yIGV2ZXJ5dGhpbmcgU1ZHIHNvIGxldCdzIGF2b2lkIHNvbWUgZHVwbGljYXRpb24gYW5kIHJ1blxuLy8gY29kZSBpbnN0ZWFkLlxuLy8gVGhlIGZvbGxvd2luZyBhcmUgYWxsIHNwZWNpZmllZCBpbiB0aGUgSFRNTCBjb25maWcgYWxyZWFkeSBzbyB3ZSBleGNsdWRlIGhlcmUuXG4vLyAtIGNsYXNzIChhcyBjbGFzc05hbWUpXG4vLyAtIGNvbG9yXG4vLyAtIGhlaWdodFxuLy8gLSBpZFxuLy8gLSBsYW5nXG4vLyAtIG1heFxuLy8gLSBtZWRpYVxuLy8gLSBtZXRob2Rcbi8vIC0gbWluXG4vLyAtIG5hbWVcbi8vIC0gc3R5bGVcbi8vIC0gdGFyZ2V0XG4vLyAtIHR5cGVcbi8vIC0gd2lkdGhcbnZhciBBVFRSUyA9IHtcbiAgYWNjZW50SGVpZ2h0OiAnYWNjZW50LWhlaWdodCcsXG4gIGFjY3VtdWxhdGU6IDAsXG4gIGFkZGl0aXZlOiAwLFxuICBhbGlnbm1lbnRCYXNlbGluZTogJ2FsaWdubWVudC1iYXNlbGluZScsXG4gIGFsbG93UmVvcmRlcjogJ2FsbG93UmVvcmRlcicsXG4gIGFscGhhYmV0aWM6IDAsXG4gIGFtcGxpdHVkZTogMCxcbiAgYXJhYmljRm9ybTogJ2FyYWJpYy1mb3JtJyxcbiAgYXNjZW50OiAwLFxuICBhdHRyaWJ1dGVOYW1lOiAnYXR0cmlidXRlTmFtZScsXG4gIGF0dHJpYnV0ZVR5cGU6ICdhdHRyaWJ1dGVUeXBlJyxcbiAgYXV0b1JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gIGF6aW11dGg6IDAsXG4gIGJhc2VGcmVxdWVuY3k6ICdiYXNlRnJlcXVlbmN5JyxcbiAgYmFzZVByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXG4gIGJhc2VsaW5lU2hpZnQ6ICdiYXNlbGluZS1zaGlmdCcsXG4gIGJib3g6IDAsXG4gIGJlZ2luOiAwLFxuICBiaWFzOiAwLFxuICBieTogMCxcbiAgY2FsY01vZGU6ICdjYWxjTW9kZScsXG4gIGNhcEhlaWdodDogJ2NhcC1oZWlnaHQnLFxuICBjbGlwOiAwLFxuICBjbGlwUGF0aDogJ2NsaXAtcGF0aCcsXG4gIGNsaXBSdWxlOiAnY2xpcC1ydWxlJyxcbiAgY2xpcFBhdGhVbml0czogJ2NsaXBQYXRoVW5pdHMnLFxuICBjb2xvckludGVycG9sYXRpb246ICdjb2xvci1pbnRlcnBvbGF0aW9uJyxcbiAgY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVyczogJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsXG4gIGNvbG9yUHJvZmlsZTogJ2NvbG9yLXByb2ZpbGUnLFxuICBjb2xvclJlbmRlcmluZzogJ2NvbG9yLXJlbmRlcmluZycsXG4gIGNvbnRlbnRTY3JpcHRUeXBlOiAnY29udGVudFNjcmlwdFR5cGUnLFxuICBjb250ZW50U3R5bGVUeXBlOiAnY29udGVudFN0eWxlVHlwZScsXG4gIGN1cnNvcjogMCxcbiAgY3g6IDAsXG4gIGN5OiAwLFxuICBkOiAwLFxuICBkZWNlbGVyYXRlOiAwLFxuICBkZXNjZW50OiAwLFxuICBkaWZmdXNlQ29uc3RhbnQ6ICdkaWZmdXNlQ29uc3RhbnQnLFxuICBkaXJlY3Rpb246IDAsXG4gIGRpc3BsYXk6IDAsXG4gIGRpdmlzb3I6IDAsXG4gIGRvbWluYW50QmFzZWxpbmU6ICdkb21pbmFudC1iYXNlbGluZScsXG4gIGR1cjogMCxcbiAgZHg6IDAsXG4gIGR5OiAwLFxuICBlZGdlTW9kZTogJ2VkZ2VNb2RlJyxcbiAgZWxldmF0aW9uOiAwLFxuICBlbmFibGVCYWNrZ3JvdW5kOiAnZW5hYmxlLWJhY2tncm91bmQnLFxuICBlbmQ6IDAsXG4gIGV4cG9uZW50OiAwLFxuICBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gIGZpbGw6IDAsXG4gIGZpbGxPcGFjaXR5OiAnZmlsbC1vcGFjaXR5JyxcbiAgZmlsbFJ1bGU6ICdmaWxsLXJ1bGUnLFxuICBmaWx0ZXI6IDAsXG4gIGZpbHRlclJlczogJ2ZpbHRlclJlcycsXG4gIGZpbHRlclVuaXRzOiAnZmlsdGVyVW5pdHMnLFxuICBmbG9vZENvbG9yOiAnZmxvb2QtY29sb3InLFxuICBmbG9vZE9wYWNpdHk6ICdmbG9vZC1vcGFjaXR5JyxcbiAgZm9jdXNhYmxlOiAwLFxuICBmb250RmFtaWx5OiAnZm9udC1mYW1pbHknLFxuICBmb250U2l6ZTogJ2ZvbnQtc2l6ZScsXG4gIGZvbnRTaXplQWRqdXN0OiAnZm9udC1zaXplLWFkanVzdCcsXG4gIGZvbnRTdHJldGNoOiAnZm9udC1zdHJldGNoJyxcbiAgZm9udFN0eWxlOiAnZm9udC1zdHlsZScsXG4gIGZvbnRWYXJpYW50OiAnZm9udC12YXJpYW50JyxcbiAgZm9udFdlaWdodDogJ2ZvbnQtd2VpZ2h0JyxcbiAgZm9ybWF0OiAwLFxuICBmcm9tOiAwLFxuICBmeDogMCxcbiAgZnk6IDAsXG4gIGcxOiAwLFxuICBnMjogMCxcbiAgZ2x5cGhOYW1lOiAnZ2x5cGgtbmFtZScsXG4gIGdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsOiAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCcsXG4gIGdseXBoT3JpZW50YXRpb25WZXJ0aWNhbDogJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJyxcbiAgZ2x5cGhSZWY6ICdnbHlwaFJlZicsXG4gIGdyYWRpZW50VHJhbnNmb3JtOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICBncmFkaWVudFVuaXRzOiAnZ3JhZGllbnRVbml0cycsXG4gIGhhbmdpbmc6IDAsXG4gIGhvcml6QWR2WDogJ2hvcml6LWFkdi14JyxcbiAgaG9yaXpPcmlnaW5YOiAnaG9yaXotb3JpZ2luLXgnLFxuICBpZGVvZ3JhcGhpYzogMCxcbiAgaW1hZ2VSZW5kZXJpbmc6ICdpbWFnZS1yZW5kZXJpbmcnLFxuICAnaW4nOiAwLFxuICBpbjI6IDAsXG4gIGludGVyY2VwdDogMCxcbiAgazogMCxcbiAgazE6IDAsXG4gIGsyOiAwLFxuICBrMzogMCxcbiAgazQ6IDAsXG4gIGtlcm5lbE1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbFVuaXRMZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogMCxcbiAga2V5UG9pbnRzOiAna2V5UG9pbnRzJyxcbiAga2V5U3BsaW5lczogJ2tleVNwbGluZXMnLFxuICBrZXlUaW1lczogJ2tleVRpbWVzJyxcbiAgbGVuZ3RoQWRqdXN0OiAnbGVuZ3RoQWRqdXN0JyxcbiAgbGV0dGVyU3BhY2luZzogJ2xldHRlci1zcGFjaW5nJyxcbiAgbGlnaHRpbmdDb2xvcjogJ2xpZ2h0aW5nLWNvbG9yJyxcbiAgbGltaXRpbmdDb25lQW5nbGU6ICdsaW1pdGluZ0NvbmVBbmdsZScsXG4gIGxvY2FsOiAwLFxuICBtYXJrZXJFbmQ6ICdtYXJrZXItZW5kJyxcbiAgbWFya2VyTWlkOiAnbWFya2VyLW1pZCcsXG4gIG1hcmtlclN0YXJ0OiAnbWFya2VyLXN0YXJ0JyxcbiAgbWFya2VySGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VyVW5pdHM6ICdtYXJrZXJVbml0cycsXG4gIG1hcmtlcldpZHRoOiAnbWFya2VyV2lkdGgnLFxuICBtYXNrOiAwLFxuICBtYXNrQ29udGVudFVuaXRzOiAnbWFza0NvbnRlbnRVbml0cycsXG4gIG1hc2tVbml0czogJ21hc2tVbml0cycsXG4gIG1hdGhlbWF0aWNhbDogMCxcbiAgbW9kZTogMCxcbiAgbnVtT2N0YXZlczogJ251bU9jdGF2ZXMnLFxuICBvZmZzZXQ6IDAsXG4gIG9wYWNpdHk6IDAsXG4gIG9wZXJhdG9yOiAwLFxuICBvcmRlcjogMCxcbiAgb3JpZW50OiAwLFxuICBvcmllbnRhdGlvbjogMCxcbiAgb3JpZ2luOiAwLFxuICBvdmVyZmxvdzogMCxcbiAgb3ZlcmxpbmVQb3NpdGlvbjogJ292ZXJsaW5lLXBvc2l0aW9uJyxcbiAgb3ZlcmxpbmVUaGlja25lc3M6ICdvdmVybGluZS10aGlja25lc3MnLFxuICBwYWludE9yZGVyOiAncGFpbnQtb3JkZXInLFxuICBwYW5vc2UxOiAncGFub3NlLTEnLFxuICBwYXRoTGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5Db250ZW50VW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVyblRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJuVW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyRXZlbnRzOiAncG9pbnRlci1ldmVudHMnLFxuICBwb2ludHM6IDAsXG4gIHBvaW50c0F0WDogJ3BvaW50c0F0WCcsXG4gIHBvaW50c0F0WTogJ3BvaW50c0F0WScsXG4gIHBvaW50c0F0WjogJ3BvaW50c0F0WicsXG4gIHByZXNlcnZlQWxwaGE6ICdwcmVzZXJ2ZUFscGhhJyxcbiAgcHJlc2VydmVBc3BlY3RSYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICBwcmltaXRpdmVVbml0czogJ3ByaW1pdGl2ZVVuaXRzJyxcbiAgcjogMCxcbiAgcmFkaXVzOiAwLFxuICByZWZYOiAncmVmWCcsXG4gIHJlZlk6ICdyZWZZJyxcbiAgcmVuZGVyaW5nSW50ZW50OiAncmVuZGVyaW5nLWludGVudCcsXG4gIHJlcGVhdENvdW50OiAncmVwZWF0Q291bnQnLFxuICByZXBlYXREdXI6ICdyZXBlYXREdXInLFxuICByZXF1aXJlZEV4dGVuc2lvbnM6ICdyZXF1aXJlZEV4dGVuc2lvbnMnLFxuICByZXF1aXJlZEZlYXR1cmVzOiAncmVxdWlyZWRGZWF0dXJlcycsXG4gIHJlc3RhcnQ6IDAsXG4gIHJlc3VsdDogMCxcbiAgcm90YXRlOiAwLFxuICByeDogMCxcbiAgcnk6IDAsXG4gIHNjYWxlOiAwLFxuICBzZWVkOiAwLFxuICBzaGFwZVJlbmRlcmluZzogJ3NoYXBlLXJlbmRlcmluZycsXG4gIHNsb3BlOiAwLFxuICBzcGFjaW5nOiAwLFxuICBzcGVjdWxhckNvbnN0YW50OiAnc3BlY3VsYXJDb25zdGFudCcsXG4gIHNwZWN1bGFyRXhwb25lbnQ6ICdzcGVjdWxhckV4cG9uZW50JyxcbiAgc3BlZWQ6IDAsXG4gIHNwcmVhZE1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gIHN0YXJ0T2Zmc2V0OiAnc3RhcnRPZmZzZXQnLFxuICBzdGREZXZpYXRpb246ICdzdGREZXZpYXRpb24nLFxuICBzdGVtaDogMCxcbiAgc3RlbXY6IDAsXG4gIHN0aXRjaFRpbGVzOiAnc3RpdGNoVGlsZXMnLFxuICBzdG9wQ29sb3I6ICdzdG9wLWNvbG9yJyxcbiAgc3RvcE9wYWNpdHk6ICdzdG9wLW9wYWNpdHknLFxuICBzdHJpa2V0aHJvdWdoUG9zaXRpb246ICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaFRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJyxcbiAgc3RyaW5nOiAwLFxuICBzdHJva2U6IDAsXG4gIHN0cm9rZURhc2hhcnJheTogJ3N0cm9rZS1kYXNoYXJyYXknLFxuICBzdHJva2VEYXNob2Zmc2V0OiAnc3Ryb2tlLWRhc2hvZmZzZXQnLFxuICBzdHJva2VMaW5lY2FwOiAnc3Ryb2tlLWxpbmVjYXAnLFxuICBzdHJva2VMaW5lam9pbjogJ3N0cm9rZS1saW5lam9pbicsXG4gIHN0cm9rZU1pdGVybGltaXQ6ICdzdHJva2UtbWl0ZXJsaW1pdCcsXG4gIHN0cm9rZU9wYWNpdHk6ICdzdHJva2Utb3BhY2l0eScsXG4gIHN0cm9rZVdpZHRoOiAnc3Ryb2tlLXdpZHRoJyxcbiAgc3VyZmFjZVNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtTGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxlVmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXRYOiAndGFyZ2V0WCcsXG4gIHRhcmdldFk6ICd0YXJnZXRZJyxcbiAgdGV4dEFuY2hvcjogJ3RleHQtYW5jaG9yJyxcbiAgdGV4dERlY29yYXRpb246ICd0ZXh0LWRlY29yYXRpb24nLFxuICB0ZXh0UmVuZGVyaW5nOiAndGV4dC1yZW5kZXJpbmcnLFxuICB0ZXh0TGVuZ3RoOiAndGV4dExlbmd0aCcsXG4gIHRvOiAwLFxuICB0cmFuc2Zvcm06IDAsXG4gIHUxOiAwLFxuICB1MjogMCxcbiAgdW5kZXJsaW5lUG9zaXRpb246ICd1bmRlcmxpbmUtcG9zaXRpb24nLFxuICB1bmRlcmxpbmVUaGlja25lc3M6ICd1bmRlcmxpbmUtdGhpY2tuZXNzJyxcbiAgdW5pY29kZTogMCxcbiAgdW5pY29kZUJpZGk6ICd1bmljb2RlLWJpZGknLFxuICB1bmljb2RlUmFuZ2U6ICd1bmljb2RlLXJhbmdlJyxcbiAgdW5pdHNQZXJFbTogJ3VuaXRzLXBlci1lbScsXG4gIHZBbHBoYWJldGljOiAndi1hbHBoYWJldGljJyxcbiAgdkhhbmdpbmc6ICd2LWhhbmdpbmcnLFxuICB2SWRlb2dyYXBoaWM6ICd2LWlkZW9ncmFwaGljJyxcbiAgdk1hdGhlbWF0aWNhbDogJ3YtbWF0aGVtYXRpY2FsJyxcbiAgdmFsdWVzOiAwLFxuICB2ZWN0b3JFZmZlY3Q6ICd2ZWN0b3ItZWZmZWN0JyxcbiAgdmVyc2lvbjogMCxcbiAgdmVydEFkdlk6ICd2ZXJ0LWFkdi15JyxcbiAgdmVydE9yaWdpblg6ICd2ZXJ0LW9yaWdpbi14JyxcbiAgdmVydE9yaWdpblk6ICd2ZXJ0LW9yaWdpbi15JyxcbiAgdmlld0JveDogJ3ZpZXdCb3gnLFxuICB2aWV3VGFyZ2V0OiAndmlld1RhcmdldCcsXG4gIHZpc2liaWxpdHk6IDAsXG4gIHdpZHRoczogMCxcbiAgd29yZFNwYWNpbmc6ICd3b3JkLXNwYWNpbmcnLFxuICB3cml0aW5nTW9kZTogJ3dyaXRpbmctbW9kZScsXG4gIHg6IDAsXG4gIHhIZWlnaHQ6ICd4LWhlaWdodCcsXG4gIHgxOiAwLFxuICB4MjogMCxcbiAgeENoYW5uZWxTZWxlY3RvcjogJ3hDaGFubmVsU2VsZWN0b3InLFxuICB4bGlua0FjdHVhdGU6ICd4bGluazphY3R1YXRlJyxcbiAgeGxpbmtBcmNyb2xlOiAneGxpbms6YXJjcm9sZScsXG4gIHhsaW5rSHJlZjogJ3hsaW5rOmhyZWYnLFxuICB4bGlua1JvbGU6ICd4bGluazpyb2xlJyxcbiAgeGxpbmtTaG93OiAneGxpbms6c2hvdycsXG4gIHhsaW5rVGl0bGU6ICd4bGluazp0aXRsZScsXG4gIHhsaW5rVHlwZTogJ3hsaW5rOnR5cGUnLFxuICB4bWxCYXNlOiAneG1sOmJhc2UnLFxuICB4bWxuczogMCxcbiAgeG1sbnNYbGluazogJ3htbG5zOnhsaW5rJyxcbiAgeG1sTGFuZzogJ3htbDpsYW5nJyxcbiAgeG1sU3BhY2U6ICd4bWw6c3BhY2UnLFxuICB5OiAwLFxuICB5MTogMCxcbiAgeTI6IDAsXG4gIHlDaGFubmVsU2VsZWN0b3I6ICd5Q2hhbm5lbFNlbGVjdG9yJyxcbiAgejogMCxcbiAgem9vbUFuZFBhbjogJ3pvb21BbmRQYW4nXG59O1xuXG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIFByb3BlcnRpZXM6IHt9LFxuICBET01BdHRyaWJ1dGVOYW1lc3BhY2VzOiB7XG4gICAgeGxpbmtBY3R1YXRlOiBOUy54bGluayxcbiAgICB4bGlua0FyY3JvbGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rSHJlZjogTlMueGxpbmssXG4gICAgeGxpbmtSb2xlOiBOUy54bGluayxcbiAgICB4bGlua1Nob3c6IE5TLnhsaW5rLFxuICAgIHhsaW5rVGl0bGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rVHlwZTogTlMueGxpbmssXG4gICAgeG1sQmFzZTogTlMueG1sLFxuICAgIHhtbExhbmc6IE5TLnhtbCxcbiAgICB4bWxTcGFjZTogTlMueG1sXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7fVxufTtcblxuT2JqZWN0LmtleXMoQVRUUlMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBTVkdET01Qcm9wZXJ0eUNvbmZpZy5Qcm9wZXJ0aWVzW2tleV0gPSAwO1xuICBpZiAoQVRUUlNba2V5XSkge1xuICAgIFNWR0RPTVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzW2tleV0gPSBBVFRSU1trZXldO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTVkdET01Qcm9wZXJ0eUNvbmZpZztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TVkdET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnB1dFNlbGVjdGlvbicpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQnKTtcbnZhciBpc1RleHRJbnB1dEVsZW1lbnQgPSByZXF1aXJlKCcuL2lzVGV4dElucHV0RWxlbWVudCcpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xuXG52YXIgc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8PSAxMTtcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIHNlbGVjdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25TZWxlY3QnLFxuICAgICAgY2FwdHVyZWQ6ICdvblNlbGVjdENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb250ZXh0TWVudScsICd0b3BGb2N1cycsICd0b3BLZXlEb3duJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93bicsICd0b3BNb3VzZVVwJywgJ3RvcFNlbGVjdGlvbkNoYW5nZSddXG4gIH1cbn07XG5cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG52YXIgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG52YXIgbW91c2VEb3duID0gZmFsc2U7XG5cbi8vIFRyYWNrIHdoZXRoZXIgYSBsaXN0ZW5lciBleGlzdHMgZm9yIHRoaXMgcGx1Z2luLiBJZiBub25lIGV4aXN0LCB3ZSBkb1xuLy8gbm90IGV4dHJhY3QgZXZlbnRzLiBTZWUgIzM2MzkuXG52YXIgaGFzTGlzdGVuZXIgPSBmYWxzZTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24obm9kZSkge1xuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBub2RlICYmIFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmVudEVsZW1lbnQ6IHJhbmdlLnBhcmVudEVsZW1lbnQoKSxcbiAgICAgIHRleHQ6IHJhbmdlLnRleHQsXG4gICAgICB0b3A6IHJhbmdlLmJvdW5kaW5nVG9wLFxuICAgICAgbGVmdDogcmFuZ2UuYm91bmRpbmdMZWZ0XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBvbGwgc2VsZWN0aW9uIHRvIHNlZSB3aGV0aGVyIGl0J3MgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9TeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIC8vIEVuc3VyZSB3ZSBoYXZlIHRoZSByaWdodCBlbGVtZW50LCBhbmQgdGhhdCB0aGUgdXNlciBpcyBub3QgZHJhZ2dpbmcgYVxuICAvLyBzZWxlY3Rpb24gKHRoaXMgbWF0Y2hlcyBuYXRpdmUgYHNlbGVjdGAgZXZlbnQgYmVoYXZpb3IpLiBJbiBIVE1MNSwgc2VsZWN0XG4gIC8vIGZpcmVzIG9ubHkgb24gaW5wdXQgYW5kIHRleHRhcmVhIHRodXMgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnQgd2VcbiAgLy8gd29uJ3QgZGlzcGF0Y2guXG4gIGlmIChtb3VzZURvd24gfHwgYWN0aXZlRWxlbWVudCA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQgIT09IGdldEFjdGl2ZUVsZW1lbnQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihhY3RpdmVFbGVtZW50KTtcbiAgaWYgKCFsYXN0U2VsZWN0aW9uIHx8ICFzaGFsbG93RXF1YWwobGFzdFNlbGVjdGlvbiwgY3VycmVudFNlbGVjdGlvbikpIHtcbiAgICBsYXN0U2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbjtcblxuICAgIHZhciBzeW50aGV0aWNFdmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLnNlbGVjdCwgYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgICBzeW50aGV0aWNFdmVudC50eXBlID0gJ3NlbGVjdCc7XG4gICAgc3ludGhldGljRXZlbnQudGFyZ2V0ID0gYWN0aXZlRWxlbWVudDtcblxuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhzeW50aGV0aWNFdmVudCk7XG5cbiAgICByZXR1cm4gc3ludGhldGljRXZlbnQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvblNlbGVjdGAgZXZlbnQgdGhhdCBub3JtYWxpemVzIHNlbGVjdCBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIGNvbnRlbnRFZGl0YWJsZVxuICpcbiAqIFRoaXMgZGlmZmVycyBmcm9tIG5hdGl2ZSBicm93c2VyIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAtIEZpcmVzIG9uIGNvbnRlbnRFZGl0YWJsZSBmaWVsZHMgYXMgd2VsbCBhcyBpbnB1dHMuXG4gKiAtIEZpcmVzIGZvciBjb2xsYXBzZWQgc2VsZWN0aW9uLlxuICogLSBGaXJlcyBhZnRlciB1c2VyIGlucHV0LlxuICovXG52YXIgU2VsZWN0RXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKCFoYXNMaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XG5cbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgLy8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG4gICAgICBjYXNlICd0b3BGb2N1cyc6XG4gICAgICAgIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkgfHwgdGFyZ2V0Tm9kZS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJykge1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXROb2RlO1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xuICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBEb24ndCBmaXJlIHRoZSBldmVudCB3aGlsZSB0aGUgdXNlciBpcyBkcmFnZ2luZy4gVGhpcyBtYXRjaGVzIHRoZVxuICAgICAgLy8gc2VtYW50aWNzIG9mIHRoZSBuYXRpdmUgc2VsZWN0IGV2ZW50LlxuICAgICAgY2FzZSAndG9wTW91c2VEb3duJzpcbiAgICAgICAgbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BDb250ZXh0TWVudSc6XG4gICAgICBjYXNlICd0b3BNb3VzZVVwJzpcbiAgICAgICAgbW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgLy8gQ2hyb21lIGFuZCBJRSBmaXJlIG5vbi1zdGFuZGFyZCBldmVudCB3aGVuIHNlbGVjdGlvbiBpcyBjaGFuZ2VkIChhbmRcbiAgICAgIC8vIHNvbWV0aW1lcyB3aGVuIGl0IGhhc24ndCkuIElFJ3MgZXZlbnQgZmlyZXMgb3V0IG9mIG9yZGVyIHdpdGggcmVzcGVjdFxuICAgICAgLy8gdG8ga2V5IGFuZCBpbnB1dCBldmVudHMgb24gZGVsZXRpb24sIHNvIHdlIGRpc2NhcmQgaXQuXG4gICAgICAvL1xuICAgICAgLy8gRmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgc2VsZWN0aW9uY2hhbmdlLCBzbyBjaGVjayBzZWxlY3Rpb24gc3RhdHVzXG4gICAgICAvLyBhZnRlciBlYWNoIGtleSBlbnRyeS4gVGhlIHNlbGVjdGlvbiBjaGFuZ2VzIGFmdGVyIGtleWRvd24gYW5kIGJlZm9yZVxuICAgICAgLy8ga2V5dXAsIGJ1dCB3ZSBjaGVjayBvbiBrZXlkb3duIGFzIHdlbGwgaW4gdGhlIGNhc2Ugb2YgaG9sZGluZyBkb3duIGFcbiAgICAgIC8vIGtleSwgd2hlbiBtdWx0aXBsZSBrZXlkb3duIGV2ZW50cyBhcmUgZmlyZWQgYnV0IG9ubHkgb25lIGtleXVwIGlzLlxuICAgICAgLy8gVGhpcyBpcyBhbHNvIG91ciBhcHByb2FjaCBmb3IgSUUgaGFuZGxpbmcsIGZvciB0aGUgcmVhc29uIGFib3ZlLlxuICAgICAgY2FzZSAndG9wU2VsZWN0aW9uQ2hhbmdlJzpcbiAgICAgICAgaWYgKHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlICd0b3BLZXlEb3duJzpcbiAgICAgIGNhc2UgJ3RvcEtleVVwJzpcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgZGlkUHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25TZWxlY3QnKSB7XG4gICAgICBoYXNMaXN0ZW5lciA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdEV2ZW50UGx1Z2luO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1NlbGVjdEV2ZW50UGx1Z2luLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2ZianMvbGliL0V2ZW50TGlzdGVuZXInKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBTeW50aGV0aWNBbmltYXRpb25FdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljQW5pbWF0aW9uRXZlbnQnKTtcbnZhciBTeW50aGV0aWNDbGlwYm9hcmRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljQ2xpcGJvYXJkRXZlbnQnKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcbnZhciBTeW50aGV0aWNGb2N1c0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNGb2N1c0V2ZW50Jyk7XG52YXIgU3ludGhldGljS2V5Ym9hcmRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljS2V5Ym9hcmRFdmVudCcpO1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcbnZhciBTeW50aGV0aWNEcmFnRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0RyYWdFdmVudCcpO1xudmFyIFN5bnRoZXRpY1RvdWNoRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1RvdWNoRXZlbnQnKTtcbnZhciBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1RyYW5zaXRpb25FdmVudCcpO1xudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcbnZhciBTeW50aGV0aWNXaGVlbEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNXaGVlbEV2ZW50Jyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKCcuL2dldEV2ZW50Q2hhckNvZGUnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBUdXJuc1xuICogWydhYm9ydCcsIC4uLl1cbiAqIGludG9cbiAqIGV2ZW50VHlwZXMgPSB7XG4gKiAgICdhYm9ydCc6IHtcbiAqICAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICogICAgICAgYnViYmxlZDogJ29uQWJvcnQnLFxuICogICAgICAgY2FwdHVyZWQ6ICdvbkFib3J0Q2FwdHVyZScsXG4gKiAgICAgfSxcbiAqICAgICBkZXBlbmRlbmNpZXM6IFsndG9wQWJvcnQnXSxcbiAqICAgfSxcbiAqICAgLi4uXG4gKiB9O1xuICogdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge1xuICogICAndG9wQWJvcnQnOiB7IHNhbWVDb25maWcgfVxuICogfTtcbiAqL1xudmFyIGV2ZW50VHlwZXMgPSB7fTtcbnZhciB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7fTtcblsnYWJvcnQnLCAnYW5pbWF0aW9uRW5kJywgJ2FuaW1hdGlvbkl0ZXJhdGlvbicsICdhbmltYXRpb25TdGFydCcsICdibHVyJywgJ2NhblBsYXknLCAnY2FuUGxheVRocm91Z2gnLCAnY2xpY2snLCAnY29udGV4dE1lbnUnLCAnY29weScsICdjdXQnLCAnZG91YmxlQ2xpY2snLCAnZHJhZycsICdkcmFnRW5kJywgJ2RyYWdFbnRlcicsICdkcmFnRXhpdCcsICdkcmFnTGVhdmUnLCAnZHJhZ092ZXInLCAnZHJhZ1N0YXJ0JywgJ2Ryb3AnLCAnZHVyYXRpb25DaGFuZ2UnLCAnZW1wdGllZCcsICdlbmNyeXB0ZWQnLCAnZW5kZWQnLCAnZXJyb3InLCAnZm9jdXMnLCAnaW5wdXQnLCAnaW52YWxpZCcsICdrZXlEb3duJywgJ2tleVByZXNzJywgJ2tleVVwJywgJ2xvYWQnLCAnbG9hZGVkRGF0YScsICdsb2FkZWRNZXRhZGF0YScsICdsb2FkU3RhcnQnLCAnbW91c2VEb3duJywgJ21vdXNlTW92ZScsICdtb3VzZU91dCcsICdtb3VzZU92ZXInLCAnbW91c2VVcCcsICdwYXN0ZScsICdwYXVzZScsICdwbGF5JywgJ3BsYXlpbmcnLCAncHJvZ3Jlc3MnLCAncmF0ZUNoYW5nZScsICdyZXNldCcsICdzY3JvbGwnLCAnc2Vla2VkJywgJ3NlZWtpbmcnLCAnc3RhbGxlZCcsICdzdWJtaXQnLCAnc3VzcGVuZCcsICd0aW1lVXBkYXRlJywgJ3RvdWNoQ2FuY2VsJywgJ3RvdWNoRW5kJywgJ3RvdWNoTW92ZScsICd0b3VjaFN0YXJ0JywgJ3RyYW5zaXRpb25FbmQnLCAndm9sdW1lQ2hhbmdlJywgJ3dhaXRpbmcnLCAnd2hlZWwnXS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgY2FwaXRhbGl6ZWRFdmVudCA9IGV2ZW50WzBdLnRvVXBwZXJDYXNlKCkgKyBldmVudC5zbGljZSgxKTtcbiAgdmFyIG9uRXZlbnQgPSAnb24nICsgY2FwaXRhbGl6ZWRFdmVudDtcbiAgdmFyIHRvcEV2ZW50ID0gJ3RvcCcgKyBjYXBpdGFsaXplZEV2ZW50O1xuXG4gIHZhciB0eXBlID0ge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBvbkV2ZW50LFxuICAgICAgY2FwdHVyZWQ6IG9uRXZlbnQgKyAnQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcEV2ZW50XVxuICB9O1xuICBldmVudFR5cGVzW2V2ZW50XSA9IHR5cGU7XG4gIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BFdmVudF0gPSB0eXBlO1xufSk7XG5cbnZhciBvbkNsaWNrTGlzdGVuZXJzID0ge307XG5cbmZ1bmN0aW9uIGdldERpY3Rpb25hcnlLZXkoaW5zdCkge1xuICAvLyBQcmV2ZW50cyBWOCBwZXJmb3JtYW5jZSBpc3N1ZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzIzMlxuICByZXR1cm4gJy4nICsgaW5zdC5fcm9vdE5vZGVJRDtcbn1cblxuZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZSh0YWcpIHtcbiAgcmV0dXJuIHRhZyA9PT0gJ2J1dHRvbicgfHwgdGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3NlbGVjdCcgfHwgdGFnID09PSAndGV4dGFyZWEnO1xufVxuXG52YXIgU2ltcGxlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGRpc3BhdGNoQ29uZmlnID0gdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3RvcExldmVsVHlwZV07XG4gICAgaWYgKCFkaXNwYXRjaENvbmZpZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBFdmVudENvbnN0cnVjdG9yO1xuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICBjYXNlICd0b3BBYm9ydCc6XG4gICAgICBjYXNlICd0b3BDYW5QbGF5JzpcbiAgICAgIGNhc2UgJ3RvcENhblBsYXlUaHJvdWdoJzpcbiAgICAgIGNhc2UgJ3RvcER1cmF0aW9uQ2hhbmdlJzpcbiAgICAgIGNhc2UgJ3RvcEVtcHRpZWQnOlxuICAgICAgY2FzZSAndG9wRW5jcnlwdGVkJzpcbiAgICAgIGNhc2UgJ3RvcEVuZGVkJzpcbiAgICAgIGNhc2UgJ3RvcEVycm9yJzpcbiAgICAgIGNhc2UgJ3RvcElucHV0JzpcbiAgICAgIGNhc2UgJ3RvcEludmFsaWQnOlxuICAgICAgY2FzZSAndG9wTG9hZCc6XG4gICAgICBjYXNlICd0b3BMb2FkZWREYXRhJzpcbiAgICAgIGNhc2UgJ3RvcExvYWRlZE1ldGFkYXRhJzpcbiAgICAgIGNhc2UgJ3RvcExvYWRTdGFydCc6XG4gICAgICBjYXNlICd0b3BQYXVzZSc6XG4gICAgICBjYXNlICd0b3BQbGF5JzpcbiAgICAgIGNhc2UgJ3RvcFBsYXlpbmcnOlxuICAgICAgY2FzZSAndG9wUHJvZ3Jlc3MnOlxuICAgICAgY2FzZSAndG9wUmF0ZUNoYW5nZSc6XG4gICAgICBjYXNlICd0b3BSZXNldCc6XG4gICAgICBjYXNlICd0b3BTZWVrZWQnOlxuICAgICAgY2FzZSAndG9wU2Vla2luZyc6XG4gICAgICBjYXNlICd0b3BTdGFsbGVkJzpcbiAgICAgIGNhc2UgJ3RvcFN1Ym1pdCc6XG4gICAgICBjYXNlICd0b3BTdXNwZW5kJzpcbiAgICAgIGNhc2UgJ3RvcFRpbWVVcGRhdGUnOlxuICAgICAgY2FzZSAndG9wVm9sdW1lQ2hhbmdlJzpcbiAgICAgIGNhc2UgJ3RvcFdhaXRpbmcnOlxuICAgICAgICAvLyBIVE1MIEV2ZW50c1xuICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZGV4Lmh0bWwjZXZlbnRzLTBcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEga2V5cHJlc3MgZXZlbnQgZm9yIGZ1bmN0aW9uIGtleXMgdG9vLiBUaGlzIHJlbW92ZXNcbiAgICAgICAgLy8gdGhlIHVud2FudGVkIGtleXByZXNzIGV2ZW50cy4gRW50ZXIgaXMgaG93ZXZlciBib3RoIHByaW50YWJsZSBhbmRcbiAgICAgICAgLy8gbm9uLXByaW50YWJsZS4gT25lIHdvdWxkIGV4cGVjdCBUYWIgdG8gYmUgYXMgd2VsbCAoYnV0IGl0IGlzbid0KS5cbiAgICAgICAgaWYgKGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcEtleURvd24nOlxuICAgICAgY2FzZSAndG9wS2V5VXAnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BCbHVyJzpcbiAgICAgIGNhc2UgJ3RvcEZvY3VzJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ2xpY2snOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBjbGljayBldmVudCBvbiByaWdodCBtb3VzZSBjbGlja3MuIFRoaXMgcmVtb3ZlcyB0aGVcbiAgICAgICAgLy8gdW53YW50ZWQgY2xpY2sgZXZlbnRzLlxuICAgICAgICBpZiAobmF0aXZlRXZlbnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcERvdWJsZUNsaWNrJzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgICBjYXNlICd0b3BNb3VzZU1vdmUnOlxuICAgICAgY2FzZSAndG9wTW91c2VVcCc6XG4gICAgICAvLyBUT0RPOiBEaXNhYmxlZCBlbGVtZW50cyBzaG91bGQgbm90IHJlc3BvbmQgdG8gbW91c2UgZXZlbnRzXG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlICd0b3BNb3VzZU91dCc6XG4gICAgICBjYXNlICd0b3BNb3VzZU92ZXInOlxuICAgICAgY2FzZSAndG9wQ29udGV4dE1lbnUnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljTW91c2VFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BEcmFnJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdFbmQnOlxuICAgICAgY2FzZSAndG9wRHJhZ0VudGVyJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdFeGl0JzpcbiAgICAgIGNhc2UgJ3RvcERyYWdMZWF2ZSc6XG4gICAgICBjYXNlICd0b3BEcmFnT3Zlcic6XG4gICAgICBjYXNlICd0b3BEcmFnU3RhcnQnOlxuICAgICAgY2FzZSAndG9wRHJvcCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wVG91Y2hDYW5jZWwnOlxuICAgICAgY2FzZSAndG9wVG91Y2hFbmQnOlxuICAgICAgY2FzZSAndG9wVG91Y2hNb3ZlJzpcbiAgICAgIGNhc2UgJ3RvcFRvdWNoU3RhcnQnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVG91Y2hFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BBbmltYXRpb25FbmQnOlxuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uSXRlcmF0aW9uJzpcbiAgICAgIGNhc2UgJ3RvcEFuaW1hdGlvblN0YXJ0JzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFRyYW5zaXRpb25FbmQnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFNjcm9sbCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNVSUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFdoZWVsJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ29weSc6XG4gICAgICBjYXNlICd0b3BDdXQnOlxuICAgICAgY2FzZSAndG9wUGFzdGUnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAhRXZlbnRDb25zdHJ1Y3RvciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdTaW1wbGVFdmVudFBsdWdpbjogVW5oYW5kbGVkIGV2ZW50IHR5cGUsIGAlc2AuJywgdG9wTGV2ZWxUeXBlKSA6IF9wcm9kSW52YXJpYW50KCc4NicsIHRvcExldmVsVHlwZSkgOiB2b2lkIDA7XG4gICAgdmFyIGV2ZW50ID0gRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH0sXG5cbiAgZGlkUHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIC8vIE1vYmlsZSBTYWZhcmkgZG9lcyBub3QgZmlyZSBwcm9wZXJseSBidWJibGUgY2xpY2sgZXZlbnRzIG9uXG4gICAgLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxuICAgIC8vIGZpcmUuIFRoZSB3b3JrYXJvdW5kIGZvciB0aGlzIGJ1ZyBpbnZvbHZlcyBhdHRhY2hpbmcgYW4gZW1wdHkgY2xpY2tcbiAgICAvLyBsaXN0ZW5lciBvbiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAgLy8gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uQ2xpY2snICYmICFpc0ludGVyYWN0aXZlKGluc3QuX3RhZykpIHtcbiAgICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICAgIGlmICghb25DbGlja0xpc3RlbmVyc1trZXldKSB7XG4gICAgICAgIG9uQ2xpY2tMaXN0ZW5lcnNba2V5XSA9IEV2ZW50TGlzdGVuZXIubGlzdGVuKG5vZGUsICdjbGljaycsIGVtcHR5RnVuY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB3aWxsRGVsZXRlTGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09ICdvbkNsaWNrJyAmJiAhaXNJbnRlcmFjdGl2ZShpbnN0Ll90YWcpKSB7XG4gICAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICAgIG9uQ2xpY2tMaXN0ZW5lcnNba2V5XS5yZW1vdmUoKTtcbiAgICAgIGRlbGV0ZSBvbkNsaWNrTGlzdGVuZXJzW2tleV07XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpbXBsZUV2ZW50UGx1Z2luO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1NpbXBsZUV2ZW50UGx1Z2luLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1hbmltYXRpb25zLyNBbmltYXRpb25FdmVudC1pbnRlcmZhY2VcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvbkV2ZW50XG4gKi9cbnZhciBBbmltYXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgYW5pbWF0aW9uTmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNBbmltYXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNBbmltYXRpb25FdmVudCwgQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY2xpcGJvYXJkLWFwaXMvXG4gKi9cbnZhciBDbGlwYm9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAgY2xpcGJvYXJkRGF0YTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdjbGlwYm9hcmREYXRhJyBpbiBldmVudCA/IGV2ZW50LmNsaXBib2FyZERhdGEgOiB3aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljQ2xpcGJvYXJkRXZlbnQsIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNDbGlwYm9hcmRFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBGb2N1c0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEZvY3VzRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHJlbGF0ZWRUYXJnZXQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0ZvY3VzRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0ZvY3VzRXZlbnQsIEZvY3VzRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvU3ludGhldGljRm9jdXNFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG5cbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG52YXIgZ2V0RXZlbnRLZXkgPSByZXF1aXJlKCcuL2dldEV2ZW50S2V5Jyk7XG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZSgnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgbG9jYXRpb246IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIHJlcGVhdDogbnVsbCxcbiAgbG9jYWxlOiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cblxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNLZXlib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNLZXlib2FyZEV2ZW50LCBLZXlib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0RXZlbnRDaGFyQ29kZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRDaGFyQ29kZScpO1xuXG4vKipcbiAqIE5vcm1hbGl6YXRpb24gb2YgZGVwcmVjYXRlZCBIVE1MNSBga2V5YCB2YWx1ZXNcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciBub3JtYWxpemVLZXkgPSB7XG4gIEVzYzogJ0VzY2FwZScsXG4gIFNwYWNlYmFyOiAnICcsXG4gIExlZnQ6ICdBcnJvd0xlZnQnLFxuICBVcDogJ0Fycm93VXAnLFxuICBSaWdodDogJ0Fycm93UmlnaHQnLFxuICBEb3duOiAnQXJyb3dEb3duJyxcbiAgRGVsOiAnRGVsZXRlJyxcbiAgV2luOiAnT1MnLFxuICBNZW51OiAnQ29udGV4dE1lbnUnLFxuICBBcHBzOiAnQ29udGV4dE1lbnUnLFxuICBTY3JvbGw6ICdTY3JvbGxMb2NrJyxcbiAgTW96UHJpbnRhYmxlS2V5OiAnVW5pZGVudGlmaWVkJ1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIGxlZ2FjeSBga2V5Q29kZWAgdG8gSFRNTDUgYGtleWBcbiAqIE9ubHkgc3BlY2lhbCBrZXlzIHN1cHBvcnRlZCwgYWxsIG90aGVycyBkZXBlbmQgb24ga2V5Ym9hcmQgbGF5b3V0IG9yIGJyb3dzZXJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciB0cmFuc2xhdGVUb0tleSA9IHtcbiAgODogJ0JhY2tzcGFjZScsXG4gIDk6ICdUYWInLFxuICAxMjogJ0NsZWFyJyxcbiAgMTM6ICdFbnRlcicsXG4gIDE2OiAnU2hpZnQnLFxuICAxNzogJ0NvbnRyb2wnLFxuICAxODogJ0FsdCcsXG4gIDE5OiAnUGF1c2UnLFxuICAyMDogJ0NhcHNMb2NrJyxcbiAgMjc6ICdFc2NhcGUnLFxuICAzMjogJyAnLFxuICAzMzogJ1BhZ2VVcCcsXG4gIDM0OiAnUGFnZURvd24nLFxuICAzNTogJ0VuZCcsXG4gIDM2OiAnSG9tZScsXG4gIDM3OiAnQXJyb3dMZWZ0JyxcbiAgMzg6ICdBcnJvd1VwJyxcbiAgMzk6ICdBcnJvd1JpZ2h0JyxcbiAgNDA6ICdBcnJvd0Rvd24nLFxuICA0NTogJ0luc2VydCcsXG4gIDQ2OiAnRGVsZXRlJyxcbiAgMTEyOiAnRjEnLFxuICAxMTM6ICdGMicsXG4gIDExNDogJ0YzJyxcbiAgMTE1OiAnRjQnLFxuICAxMTY6ICdGNScsXG4gIDExNzogJ0Y2JyxcbiAgMTE4OiAnRjcnLFxuICAxMTk6ICdGOCcsXG4gIDEyMDogJ0Y5JyxcbiAgMTIxOiAnRjEwJyxcbiAgMTIyOiAnRjExJyxcbiAgMTIzOiAnRjEyJyxcbiAgMTQ0OiAnTnVtTG9jaycsXG4gIDE0NTogJ1Njcm9sbExvY2snLFxuICAyMjQ6ICdNZXRhJ1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgYGtleWAgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50S2V5KG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5rZXkpIHtcbiAgICAvLyBOb3JtYWxpemUgaW5jb25zaXN0ZW50IHZhbHVlcyByZXBvcnRlZCBieSBicm93c2VycyBkdWUgdG9cbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgb2YgYSB3b3JraW5nIGRyYWZ0IHNwZWNpZmljYXRpb24uXG5cbiAgICAvLyBGaXJlRm94IGltcGxlbWVudHMgYGtleWAgYnV0IHJldHVybnMgYE1velByaW50YWJsZUtleWAgZm9yIGFsbFxuICAgIC8vIHByaW50YWJsZSBjaGFyYWN0ZXJzIChub3JtYWxpemVkIHRvIGBVbmlkZW50aWZpZWRgKSwgaWdub3JlIGl0LlxuICAgIHZhciBrZXkgPSBub3JtYWxpemVLZXlbbmF0aXZlRXZlbnQua2V5XSB8fCBuYXRpdmVFdmVudC5rZXk7XG4gICAgaWYgKGtleSAhPT0gJ1VuaWRlbnRpZmllZCcpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9XG5cbiAgLy8gQnJvd3NlciBkb2VzIG5vdCBpbXBsZW1lbnQgYGtleWAsIHBvbHlmaWxsIGFzIG11Y2ggb2YgaXQgYXMgd2UgY2FuLlxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgIHZhciBjaGFyQ29kZSA9IGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpO1xuXG4gICAgLy8gVGhlIGVudGVyLWtleSBpcyB0ZWNobmljYWxseSBib3RoIHByaW50YWJsZSBhbmQgbm9uLXByaW50YWJsZSBhbmQgY2FuXG4gICAgLy8gdGh1cyBiZSBjYXB0dXJlZCBieSBga2V5cHJlc3NgLCBubyBvdGhlciBub24tcHJpbnRhYmxlIGtleSBzaG91bGQuXG4gICAgcmV0dXJuIGNoYXJDb2RlID09PSAxMyA/ICdFbnRlcicgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgfVxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAvLyBXaGlsZSB1c2VyIGtleWJvYXJkIGxheW91dCBkZXRlcm1pbmVzIHRoZSBhY3R1YWwgbWVhbmluZyBvZiBlYWNoXG4gICAgLy8gYGtleUNvZGVgIHZhbHVlLCBhbG1vc3QgYWxsIGZ1bmN0aW9uIGtleXMgaGF2ZSBhIHVuaXZlcnNhbCB2YWx1ZS5cbiAgICByZXR1cm4gdHJhbnNsYXRlVG9LZXlbbmF0aXZlRXZlbnQua2V5Q29kZV0gfHwgJ1VuaWRlbnRpZmllZCc7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50S2V5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2dldEV2ZW50S2V5LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIERyYWdFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBEcmFnRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGFUcmFuc2ZlcjogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRHJhZ0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNEcmFnRXZlbnQsIERyYWdFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRHJhZ0V2ZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0RyYWdFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG5cbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKCcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZScpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVG91Y2hFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvXG4gKi9cbnZhciBUb3VjaEV2ZW50SW50ZXJmYWNlID0ge1xuICB0b3VjaGVzOiBudWxsLFxuICB0YXJnZXRUb3VjaGVzOiBudWxsLFxuICBjaGFuZ2VkVG91Y2hlczogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNUb3VjaEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNUb3VjaEV2ZW50LCBUb3VjaEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1RvdWNoRXZlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA5L1dELWNzczMtdHJhbnNpdGlvbnMtMjAwOTAzMjAvI3RyYW5zaXRpb24tZXZlbnRzLVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVHJhbnNpdGlvbkV2ZW50XG4gKi9cbnZhciBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHByb3BlcnR5TmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVHJhbnNpdGlvbkV2ZW50LCBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgV2hlZWxFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBXaGVlbEV2ZW50SW50ZXJmYWNlID0ge1xuICBkZWx0YVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFYJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWCA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWGAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChyaWdodCBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFYJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWCA6IDA7XG4gIH0sXG4gIGRlbHRhWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFZYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YWAgZm9yIElFPDkgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGEnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGEgOiAwO1xuICB9LFxuICBkZWx0YVo6IG51bGwsXG5cbiAgLy8gQnJvd3NlcnMgd2l0aG91dCBcImRlbHRhTW9kZVwiIGlzIHJlcG9ydGluZyBpbiByYXcgd2hlZWwgZGVsdGEgd2hlcmUgb25lXG4gIC8vIG5vdGNoIG9uIHRoZSBzY3JvbGwgaXMgYWx3YXlzICsvLSAxMjAsIHJvdWdobHkgZXF1aXZhbGVudCB0byBwaXhlbHMuXG4gIC8vIEEgZ29vZCBhcHByb3hpbWF0aW9uIG9mIERPTV9ERUxUQV9MSU5FICgxKSBpcyA1JSBvZiB2aWV3cG9ydCBzaXplIG9yXG4gIC8vIH40MCBwaXhlbHMsIGZvciBET01fREVMVEFfU0NSRUVOICgyKSBpdCBpcyA4Ny41JSBvZiB2aWV3cG9ydCBzaXplLlxuICBkZWx0YU1vZGU6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY01vdXNlRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1doZWVsRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1doZWVsRXZlbnQsIFdoZWVsRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvU3ludGhldGljV2hlZWxFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xuXG52YXIgRE9DX05PREVfVFlQRSA9IDk7XG5cbmZ1bmN0aW9uIFJlYWN0RE9NQ29udGFpbmVySW5mbyh0b3BMZXZlbFdyYXBwZXIsIG5vZGUpIHtcbiAgdmFyIGluZm8gPSB7XG4gICAgX3RvcExldmVsV3JhcHBlcjogdG9wTGV2ZWxXcmFwcGVyLFxuICAgIF9pZENvdW50ZXI6IDEsXG4gICAgX293bmVyRG9jdW1lbnQ6IG5vZGUgPyBub2RlLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFID8gbm9kZSA6IG5vZGUub3duZXJEb2N1bWVudCA6IG51bGwsXG4gICAgX25vZGU6IG5vZGUsXG4gICAgX3RhZzogbm9kZSA/IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA6IG51bGwsXG4gICAgX25hbWVzcGFjZVVSSTogbm9kZSA/IG5vZGUubmFtZXNwYWNlVVJJIDogbnVsbFxuICB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGluZm8uX2FuY2VzdG9ySW5mbyA9IG5vZGUgPyB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyhudWxsLCBpbmZvLl90YWcsIG51bGwpIDogbnVsbDtcbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUNvbnRhaW5lckluZm87XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01Db250YWluZXJJbmZvLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NRmVhdHVyZUZsYWdzID0ge1xuICB1c2VDcmVhdGVFbGVtZW50OiB0cnVlLFxuICB1c2VGaWJlcjogZmFsc2Vcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01GZWF0dXJlRmxhZ3M7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01GZWF0dXJlRmxhZ3MuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWRsZXIzMiA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xuXG52YXIgVEFHX0VORCA9IC9cXC8/Pi87XG52YXIgQ09NTUVOVF9TVEFSVCA9IC9ePFxcIVxcLVxcLS87XG5cbnZhciBSZWFjdE1hcmt1cENoZWNrc3VtID0ge1xuICBDSEVDS1NVTV9BVFRSX05BTUU6ICdkYXRhLXJlYWN0LWNoZWNrc3VtJyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgc3RyaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZyB3aXRoIGNoZWNrc3VtIGF0dHJpYnV0ZSBhdHRhY2hlZFxuICAgKi9cbiAgYWRkQ2hlY2tzdW1Ub01hcmt1cDogZnVuY3Rpb24gKG1hcmt1cCkge1xuICAgIHZhciBjaGVja3N1bSA9IGFkbGVyMzIobWFya3VwKTtcblxuICAgIC8vIEFkZCBjaGVja3N1bSAoaGFuZGxlIGJvdGggcGFyZW50IHRhZ3MsIGNvbW1lbnRzIGFuZCBzZWxmLWNsb3NpbmcgdGFncylcbiAgICBpZiAoQ09NTUVOVF9TVEFSVC50ZXN0KG1hcmt1cCkpIHtcbiAgICAgIHJldHVybiBtYXJrdXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtYXJrdXAucmVwbGFjZShUQUdfRU5ELCAnICcgKyBSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSArICc9XCInICsgY2hlY2tzdW0gKyAnXCIkJicpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCB0byB1c2VcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IHJvb3QgUmVhY3QgZWxlbWVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBvciBub3QgdGhlIG1hcmt1cCBpcyB0aGUgc2FtZVxuICAgKi9cbiAgY2FuUmV1c2VNYXJrdXA6IGZ1bmN0aW9uIChtYXJrdXAsIGVsZW1lbnQpIHtcbiAgICB2YXIgZXhpc3RpbmdDaGVja3N1bSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcbiAgICBleGlzdGluZ0NoZWNrc3VtID0gZXhpc3RpbmdDaGVja3N1bSAmJiBwYXJzZUludChleGlzdGluZ0NoZWNrc3VtLCAxMCk7XG4gICAgdmFyIG1hcmt1cENoZWNrc3VtID0gYWRsZXIzMihtYXJrdXApO1xuICAgIHJldHVybiBtYXJrdXBDaGVja3N1bSA9PT0gZXhpc3RpbmdDaGVja3N1bTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1hcmt1cENoZWNrc3VtO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0TWFya3VwQ2hlY2tzdW0uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBNT0QgPSA2NTUyMTtcblxuLy8gYWRsZXIzMiBpcyBub3QgY3J5cHRvZ3JhcGhpY2FsbHkgc3Ryb25nLCBhbmQgaXMgb25seSB1c2VkIHRvIHNhbml0eSBjaGVjayB0aGF0XG4vLyBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSBzZXJ2ZXIgbWF0Y2hlcyB0aGUgbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgY2xpZW50LlxuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiAoYSBtb2RpZmllZCB2ZXJzaW9uIG9mIHRoZSBTaGVldEpTIHZlcnNpb24pIGhhcyBiZWVuIG9wdGltaXplZFxuLy8gZm9yIG91ciB1c2UgY2FzZSwgYXQgdGhlIGV4cGVuc2Ugb2YgY29uZm9ybWluZyB0byB0aGUgYWRsZXIzMiBzcGVjaWZpY2F0aW9uXG4vLyBmb3Igbm9uLWFzY2lpIGlucHV0cy5cbmZ1bmN0aW9uIGFkbGVyMzIoZGF0YSkge1xuICB2YXIgYSA9IDE7XG4gIHZhciBiID0gMDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGRhdGEubGVuZ3RoO1xuICB2YXIgbSA9IGwgJiB+MHgzO1xuICB3aGlsZSAoaSA8IG0pIHtcbiAgICB2YXIgbiA9IE1hdGgubWluKGkgKyA0MDk2LCBtKTtcbiAgICBmb3IgKDsgaSA8IG47IGkgKz0gNCkge1xuICAgICAgYiArPSAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSkpICsgKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkgKyAxKSkgKyAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSArIDIpKSArIChhICs9IGRhdGEuY2hhckNvZGVBdChpICsgMykpO1xuICAgIH1cbiAgICBhICU9IE1PRDtcbiAgICBiICU9IE1PRDtcbiAgfVxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGIgKz0gYSArPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgYSAlPSBNT0Q7XG4gIGIgJT0gTU9EO1xuICByZXR1cm4gYSB8IGIgPDwgMTY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9hZGxlcjMyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAnMTUuNi4xJztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdFZlcnNpb24uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcblxudmFyIGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlID0gcmVxdWlyZSgnLi9nZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZScpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgRE9NIG5vZGUgcmVuZGVyZWQgYnkgdGhpcyBlbGVtZW50LlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdGRvbS5maW5kZG9tbm9kZVxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR8RE9NRWxlbWVudH0gY29tcG9uZW50T3JFbGVtZW50XG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudH0gVGhlIHJvb3Qgbm9kZSBvZiB0aGlzIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRET01Ob2RlKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgaWYgKG93bmVyICE9PSBudWxsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIsICclcyBpcyBhY2Nlc3NpbmcgZmluZERPTU5vZGUgaW5zaWRlIGl0cyByZW5kZXIoKS4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQubm9kZVR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gY29tcG9uZW50T3JFbGVtZW50O1xuICB9XG5cbiAgdmFyIGluc3QgPSBSZWFjdEluc3RhbmNlTWFwLmdldChjb21wb25lbnRPckVsZW1lbnQpO1xuICBpZiAoaW5zdCkge1xuICAgIGluc3QgPSBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZShpbnN0KTtcbiAgICByZXR1cm4gaW5zdCA/IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpIDogbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29tcG9uZW50T3JFbGVtZW50LnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdmaW5kRE9NTm9kZSB3YXMgY2FsbGVkIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiBfcHJvZEludmFyaWFudCgnNDQnKSA6IHZvaWQgMDtcbiAgfSBlbHNlIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCBhcHBlYXJzIHRvIGJlIG5laXRoZXIgUmVhY3RDb21wb25lbnQgbm9yIERPTU5vZGUgKGtleXM6ICVzKScsIE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkpIDogX3Byb2RJbnZhcmlhbnQoJzQ1JywgT2JqZWN0LmtleXMoY29tcG9uZW50T3JFbGVtZW50KSkgOiB2b2lkIDA7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kRE9NTm9kZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9maW5kRE9NTm9kZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNb3VudC5yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcmVhY3RQcm9wcyA9IHtcbiAgICBjaGlsZHJlbjogdHJ1ZSxcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogdHJ1ZSxcbiAgICBrZXk6IHRydWUsXG4gICAgcmVmOiB0cnVlLFxuXG4gICAgYXV0b0ZvY3VzOiB0cnVlLFxuICAgIGRlZmF1bHRWYWx1ZTogdHJ1ZSxcbiAgICB2YWx1ZUxpbms6IHRydWUsXG4gICAgZGVmYXVsdENoZWNrZWQ6IHRydWUsXG4gICAgY2hlY2tlZExpbms6IHRydWUsXG4gICAgaW5uZXJIVE1MOiB0cnVlLFxuICAgIHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzogdHJ1ZSxcbiAgICBvbkZvY3VzSW46IHRydWUsXG4gICAgb25Gb2N1c091dDogdHJ1ZVxuICB9O1xuICB2YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xuXG4gIHZhciB2YWxpZGF0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKHRhZ05hbWUsIG5hbWUsIGRlYnVnSUQpIHtcbiAgICBpZiAoRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChyZWFjdFByb3BzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHJlYWN0UHJvcHNbbmFtZV0gfHwgd2FybmVkUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAvLyBkYXRhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuICAgIHZhciBzdGFuZGFyZE5hbWUgPSBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgIGlmIChzdGFuZGFyZE5hbWUgIT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIERPTSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgc3RhbmRhcmROYW1lLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCByZWdpc3RyYXRpb25OYW1lLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSB3ZXJlIHVuYWJsZSB0byBndWVzcyB3aGljaCBwcm9wIHRoZSB1c2VyIGludGVuZGVkLlxuICAgICAgLy8gSXQgaXMgbGlrZWx5IHRoYXQgdGhlIHVzZXIgd2FzIGp1c3QgYmxpbmRseSBzcHJlYWRpbmcvZm9yd2FyZGluZyBwcm9wc1xuICAgICAgLy8gQ29tcG9uZW50cyBzaG91bGQgYmUgY2FyZWZ1bCB0byBvbmx5IHJlbmRlciB2YWxpZCBwcm9wcy9hdHRyaWJ1dGVzLlxuICAgICAgLy8gV2FybmluZyB3aWxsIGJlIGludm9rZWQgaW4gd2FyblVua25vd25Qcm9wZXJ0aWVzIHRvIGFsbG93IGdyb3VwaW5nLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHdhcm5Vbmtub3duUHJvcGVydGllcyA9IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gIHZhciB1bmtub3duUHJvcHMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIGVsZW1lbnQucHJvcHMpIHtcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkoZWxlbWVudC50eXBlLCBrZXksIGRlYnVnSUQpO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG5cbiAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vua25vd24gcHJvcCAlcyBvbiA8JXM+IHRhZy4gUmVtb3ZlIHRoaXMgcHJvcCBmcm9tIHRoZSBlbGVtZW50LiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC11bmtub3duLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICB9IGVsc2UgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIHByb3BzICVzIG9uIDwlcz4gdGFnLiBSZW1vdmUgdGhlc2UgcHJvcHMgZnJvbSB0aGUgZWxlbWVudC4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtdW5rbm93bi1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgZWxlbWVudC50eXBlLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgfVxufTtcblxuZnVuY3Rpb24gaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09IG51bGwgfHwgdHlwZW9mIGVsZW1lbnQudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW1lbnQudHlwZS5pbmRleE9mKCctJykgPj0gMCB8fCBlbGVtZW50LnByb3BzLmlzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5Vbmtub3duUHJvcGVydGllcyhkZWJ1Z0lELCBlbGVtZW50KTtcbn1cblxudmFyIFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vayA9IHtcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vaztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2suanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC50eXBlICE9PSAnaW5wdXQnICYmIGVsZW1lbnQudHlwZSAhPT0gJ3RleHRhcmVhJyAmJiBlbGVtZW50LnR5cGUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGVtZW50LnByb3BzICE9IG51bGwgJiYgZWxlbWVudC5wcm9wcy52YWx1ZSA9PT0gbnVsbCAmJiAhZGlkV2FyblZhbHVlTnVsbCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIHRoZSBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCAnICsgJ2ZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4lcycsIGVsZW1lbnQudHlwZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG5cbiAgICBkaWRXYXJuVmFsdWVOdWxsID0gdHJ1ZTtcbiAgfVxufVxuXG52YXIgUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rID0ge1xuICBvbkJlZm9yZU1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCk7XG4gIH0sXG4gIG9uQmVmb3JlVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vay5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG52YXIgckFSSUEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgRE9NUHJvcGVydHkuQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSh0YWdOYW1lLCBuYW1lLCBkZWJ1Z0lEKSB7XG4gIGlmICh3YXJuZWRQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChyQVJJQS50ZXN0KG5hbWUpKSB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBzdGFuZGFyZE5hbWUgPSBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZS5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuICAgIGlmIChzdGFuZGFyZE5hbWUgPT0gbnVsbCkge1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuICAgIGlmIChuYW1lICE9PSBzdGFuZGFyZE5hbWUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBBUklBIGF0dHJpYnV0ZSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgc3RhbmRhcmROYW1lLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JbnZhbGlkQVJJQVByb3BzKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgdmFyIGludmFsaWRQcm9wcyA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBlbGVtZW50LnByb3BzKSB7XG4gICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KGVsZW1lbnQudHlwZSwga2V5LCBkZWJ1Z0lEKTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIGludmFsaWRQcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gaW52YWxpZFByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICB9KS5qb2luKCcsICcpO1xuXG4gIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICB9IGVsc2UgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcHMgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL2ludmFsaWQtYXJpYS1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgZWxlbWVudC50eXBlLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCB8fCB0eXBlb2YgZWxlbWVudC50eXBlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC50eXBlLmluZGV4T2YoJy0nKSA+PSAwIHx8IGVsZW1lbnQucHJvcHMuaXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3YXJuSW52YWxpZEFSSUFQcm9wcyhkZWJ1Z0lELCBlbGVtZW50KTtcbn1cblxudmFyIFJlYWN0RE9NSW52YWxpZEFSSUFIb29rID0ge1xuICBvbkJlZm9yZU1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICAgIH1cbiAgfSxcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSW52YWxpZEFSSUFIb29rO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NSW52YWxpZEFSSUFIb29rLmpzIiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgeyBDb21wb25lbnQsIENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IHN0b3JlU2hhcGUsIHN1YnNjcmlwdGlvblNoYXBlIH0gZnJvbSAnLi4vdXRpbHMvUHJvcFR5cGVzJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJy4uL3V0aWxzL3dhcm5pbmcnO1xuXG52YXIgZGlkV2FybkFib3V0UmVjZWl2aW5nU3RvcmUgPSBmYWxzZTtcbmZ1bmN0aW9uIHdhcm5BYm91dFJlY2VpdmluZ1N0b3JlKCkge1xuICBpZiAoZGlkV2FybkFib3V0UmVjZWl2aW5nU3RvcmUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZGlkV2FybkFib3V0UmVjZWl2aW5nU3RvcmUgPSB0cnVlO1xuXG4gIHdhcm5pbmcoJzxQcm92aWRlcj4gZG9lcyBub3Qgc3VwcG9ydCBjaGFuZ2luZyBgc3RvcmVgIG9uIHRoZSBmbHkuICcgKyAnSXQgaXMgbW9zdCBsaWtlbHkgdGhhdCB5b3Ugc2VlIHRoaXMgZXJyb3IgYmVjYXVzZSB5b3UgdXBkYXRlZCB0byAnICsgJ1JlZHV4IDIueCBhbmQgUmVhY3QgUmVkdXggMi54IHdoaWNoIG5vIGxvbmdlciBob3QgcmVsb2FkIHJlZHVjZXJzICcgKyAnYXV0b21hdGljYWxseS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JlYWN0LXJlZHV4L3JlbGVhc2VzLycgKyAndGFnL3YyLjAuMCBmb3IgdGhlIG1pZ3JhdGlvbiBpbnN0cnVjdGlvbnMuJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm92aWRlcigpIHtcbiAgdmFyIF9Qcm92aWRlciRjaGlsZENvbnRleDtcblxuICB2YXIgc3RvcmVLZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdzdG9yZSc7XG4gIHZhciBzdWJLZXkgPSBhcmd1bWVudHNbMV07XG5cbiAgdmFyIHN1YnNjcmlwdGlvbktleSA9IHN1YktleSB8fCBzdG9yZUtleSArICdTdWJzY3JpcHRpb24nO1xuXG4gIHZhciBQcm92aWRlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKFByb3ZpZGVyLCBfQ29tcG9uZW50KTtcblxuICAgIFByb3ZpZGVyLnByb3RvdHlwZS5nZXRDaGlsZENvbnRleHQgPSBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZltzdG9yZUtleV0gPSB0aGlzW3N0b3JlS2V5XSwgX3JlZltzdWJzY3JpcHRpb25LZXldID0gbnVsbCwgX3JlZjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gUHJvdmlkZXIocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm92aWRlcik7XG5cbiAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCkpO1xuXG4gICAgICBfdGhpc1tzdG9yZUtleV0gPSBwcm9wcy5zdG9yZTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBQcm92aWRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIENoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gICAgfTtcblxuICAgIHJldHVybiBQcm92aWRlcjtcbiAgfShDb21wb25lbnQpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgUHJvdmlkZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiAobmV4dFByb3BzKSB7XG4gICAgICBpZiAodGhpc1tzdG9yZUtleV0gIT09IG5leHRQcm9wcy5zdG9yZSkge1xuICAgICAgICB3YXJuQWJvdXRSZWNlaXZpbmdTdG9yZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBQcm92aWRlci5wcm9wVHlwZXMgPSB7XG4gICAgc3RvcmU6IHN0b3JlU2hhcGUuaXNSZXF1aXJlZCxcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLmVsZW1lbnQuaXNSZXF1aXJlZFxuICB9O1xuICBQcm92aWRlci5jaGlsZENvbnRleHRUeXBlcyA9IChfUHJvdmlkZXIkY2hpbGRDb250ZXggPSB7fSwgX1Byb3ZpZGVyJGNoaWxkQ29udGV4W3N0b3JlS2V5XSA9IHN0b3JlU2hhcGUuaXNSZXF1aXJlZCwgX1Byb3ZpZGVyJGNoaWxkQ29udGV4W3N1YnNjcmlwdGlvbktleV0gPSBzdWJzY3JpcHRpb25TaGFwZSwgX1Byb3ZpZGVyJGNoaWxkQ29udGV4KTtcblxuICByZXR1cm4gUHJvdmlkZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVByb3ZpZGVyKCk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2NvbXBvbmVudHMvUHJvdmlkZXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gc2hpbShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIGlmIChzZWNyZXQgPT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAvLyBJdCBpcyBzdGlsbCBzYWZlIHdoZW4gY2FsbGVkIGZyb20gUmVhY3QuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGludmFyaWFudChcbiAgICAgIGZhbHNlLFxuICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgJ1VzZSBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKSB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgKTtcbiAgfTtcbiAgc2hpbS5pc1JlcXVpcmVkID0gc2hpbTtcbiAgZnVuY3Rpb24gZ2V0U2hpbSgpIHtcbiAgICByZXR1cm4gc2hpbTtcbiAgfTtcbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBzaGltLFxuICAgIGJvb2w6IHNoaW0sXG4gICAgZnVuYzogc2hpbSxcbiAgICBudW1iZXI6IHNoaW0sXG4gICAgb2JqZWN0OiBzaGltLFxuICAgIHN0cmluZzogc2hpbSxcbiAgICBzeW1ib2w6IHNoaW0sXG5cbiAgICBhbnk6IHNoaW0sXG4gICAgYXJyYXlPZjogZ2V0U2hpbSxcbiAgICBlbGVtZW50OiBzaGltLFxuICAgIGluc3RhbmNlT2Y6IGdldFNoaW0sXG4gICAgbm9kZTogc2hpbSxcbiAgICBvYmplY3RPZjogZ2V0U2hpbSxcbiAgICBvbmVPZjogZ2V0U2hpbSxcbiAgICBvbmVPZlR5cGU6IGdldFNoaW0sXG4gICAgc2hhcGU6IGdldFNoaW1cbiAgfTtcblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGVtcHR5RnVuY3Rpb247XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICAgIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgZGlzcGxheU5hbWU6IHRydWUsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIG1peGluczogdHJ1ZSxcbiAgICBwcm9wVHlwZXM6IHRydWUsXG4gICAgdHlwZTogdHJ1ZVxufTtcblxudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gIG5hbWU6IHRydWUsXG4gIGxlbmd0aDogdHJ1ZSxcbiAgcHJvdG90eXBlOiB0cnVlLFxuICBjYWxsZXI6IHRydWUsXG4gIGNhbGxlZTogdHJ1ZSxcbiAgYXJndW1lbnRzOiB0cnVlLFxuICBhcml0eTogdHJ1ZVxufTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgb2JqZWN0UHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YgJiYgZ2V0UHJvdG90eXBlT2YoT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIHNvdXJjZUNvbXBvbmVudCwgYmxhY2tsaXN0KSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7IC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG5cbiAgICAgICAgaWYgKG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICAgICAgdmFyIGluaGVyaXRlZENvbXBvbmVudCA9IGdldFByb3RvdHlwZU9mKHNvdXJjZUNvbXBvbmVudCk7XG4gICAgICAgICAgICBpZiAoaW5oZXJpdGVkQ29tcG9uZW50ICYmIGluaGVyaXRlZENvbXBvbmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBpbmhlcml0ZWRDb21wb25lbnQsIGJsYWNrbGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcblxuICAgICAgICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmICghUkVBQ1RfU1RBVElDU1trZXldICYmICFLTk9XTl9TVEFUSUNTW2tleV0gJiYgKCFibGFja2xpc3QgfHwgIWJsYWNrbGlzdFtrZXldKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZUNvbXBvbmVudCwga2V5KTtcbiAgICAgICAgICAgICAgICB0cnkgeyAvLyBBdm9pZCBmYWlsdXJlcyBmcm9tIHJlYWQtb25seSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldENvbXBvbmVudCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgK1xuICAgICAgICAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaW52YXJpYW50L2Jyb3dzZXIuanMiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vLyBlbmNhcHN1bGF0ZXMgdGhlIHN1YnNjcmlwdGlvbiBsb2dpYyBmb3IgY29ubmVjdGluZyBhIGNvbXBvbmVudCB0byB0aGUgcmVkdXggc3RvcmUsIGFzXG4vLyB3ZWxsIGFzIG5lc3Rpbmcgc3Vic2NyaXB0aW9ucyBvZiBkZXNjZW5kYW50IGNvbXBvbmVudHMsIHNvIHRoYXQgd2UgY2FuIGVuc3VyZSB0aGVcbi8vIGFuY2VzdG9yIGNvbXBvbmVudHMgcmUtcmVuZGVyIGJlZm9yZSBkZXNjZW5kYW50c1xuXG52YXIgQ0xFQVJFRCA9IG51bGw7XG52YXIgbnVsbExpc3RlbmVycyA9IHtcbiAgbm90aWZ5OiBmdW5jdGlvbiBub3RpZnkoKSB7fVxufTtcblxuZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uKCkge1xuICAvLyB0aGUgY3VycmVudC9uZXh0IHBhdHRlcm4gaXMgY29waWVkIGZyb20gcmVkdXgncyBjcmVhdGVTdG9yZSBjb2RlLlxuICAvLyBUT0RPOiByZWZhY3RvcitleHBvc2UgdGhhdCBjb2RlIHRvIGJlIHJldXNhYmxlIGhlcmU/XG4gIHZhciBjdXJyZW50ID0gW107XG4gIHZhciBuZXh0ID0gW107XG5cbiAgcmV0dXJuIHtcbiAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICBuZXh0ID0gQ0xFQVJFRDtcbiAgICAgIGN1cnJlbnQgPSBDTEVBUkVEO1xuICAgIH0sXG4gICAgbm90aWZ5OiBmdW5jdGlvbiBub3RpZnkoKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gY3VycmVudCA9IG5leHQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsaXN0ZW5lcnNbaV0oKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfSxcbiAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgICAgdmFyIGlzU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICBpZiAobmV4dCA9PT0gY3VycmVudCkgbmV4dCA9IGN1cnJlbnQuc2xpY2UoKTtcbiAgICAgIG5leHQucHVzaChsaXN0ZW5lcik7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKCFpc1N1YnNjcmliZWQgfHwgY3VycmVudCA9PT0gQ0xFQVJFRCkgcmV0dXJuO1xuICAgICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAobmV4dCA9PT0gY3VycmVudCkgbmV4dCA9IGN1cnJlbnQuc2xpY2UoKTtcbiAgICAgICAgbmV4dC5zcGxpY2UobmV4dC5pbmRleE9mKGxpc3RlbmVyKSwgMSk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxudmFyIFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uKHN0b3JlLCBwYXJlbnRTdWIsIG9uU3RhdGVDaGFuZ2UpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3Vic2NyaXB0aW9uKTtcblxuICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB0aGlzLnBhcmVudFN1YiA9IHBhcmVudFN1YjtcbiAgICB0aGlzLm9uU3RhdGVDaGFuZ2UgPSBvblN0YXRlQ2hhbmdlO1xuICAgIHRoaXMudW5zdWJzY3JpYmUgPSBudWxsO1xuICAgIHRoaXMubGlzdGVuZXJzID0gbnVsbExpc3RlbmVycztcbiAgfVxuXG4gIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuYWRkTmVzdGVkU3ViID0gZnVuY3Rpb24gYWRkTmVzdGVkU3ViKGxpc3RlbmVyKSB7XG4gICAgdGhpcy50cnlTdWJzY3JpYmUoKTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnMuc3Vic2NyaWJlKGxpc3RlbmVyKTtcbiAgfTtcblxuICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLm5vdGlmeU5lc3RlZFN1YnMgPSBmdW5jdGlvbiBub3RpZnlOZXN0ZWRTdWJzKCkge1xuICAgIHRoaXMubGlzdGVuZXJzLm5vdGlmeSgpO1xuICB9O1xuXG4gIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuaXNTdWJzY3JpYmVkID0gZnVuY3Rpb24gaXNTdWJzY3JpYmVkKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMudW5zdWJzY3JpYmUpO1xuICB9O1xuXG4gIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUudHJ5U3Vic2NyaWJlID0gZnVuY3Rpb24gdHJ5U3Vic2NyaWJlKCkge1xuICAgIGlmICghdGhpcy51bnN1YnNjcmliZSkge1xuICAgICAgdGhpcy51bnN1YnNjcmliZSA9IHRoaXMucGFyZW50U3ViID8gdGhpcy5wYXJlbnRTdWIuYWRkTmVzdGVkU3ViKHRoaXMub25TdGF0ZUNoYW5nZSkgOiB0aGlzLnN0b3JlLnN1YnNjcmliZSh0aGlzLm9uU3RhdGVDaGFuZ2UpO1xuXG4gICAgICB0aGlzLmxpc3RlbmVycyA9IGNyZWF0ZUxpc3RlbmVyQ29sbGVjdGlvbigpO1xuICAgIH1cbiAgfTtcblxuICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnRyeVVuc3Vic2NyaWJlID0gZnVuY3Rpb24gdHJ5VW5zdWJzY3JpYmUoKSB7XG4gICAgaWYgKHRoaXMudW5zdWJzY3JpYmUpIHtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUgPSBudWxsO1xuICAgICAgdGhpcy5saXN0ZW5lcnMuY2xlYXIoKTtcbiAgICAgIHRoaXMubGlzdGVuZXJzID0gbnVsbExpc3RlbmVycztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcbn0oKTtcblxuZXhwb3J0IHsgU3Vic2NyaXB0aW9uIGFzIGRlZmF1bHQgfTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvU3Vic2NyaXB0aW9uLmpzIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5pbXBvcnQgY29ubmVjdEFkdmFuY2VkIGZyb20gJy4uL2NvbXBvbmVudHMvY29ubmVjdEFkdmFuY2VkJztcbmltcG9ydCBzaGFsbG93RXF1YWwgZnJvbSAnLi4vdXRpbHMvc2hhbGxvd0VxdWFsJztcbmltcG9ydCBkZWZhdWx0TWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzIGZyb20gJy4vbWFwRGlzcGF0Y2hUb1Byb3BzJztcbmltcG9ydCBkZWZhdWx0TWFwU3RhdGVUb1Byb3BzRmFjdG9yaWVzIGZyb20gJy4vbWFwU3RhdGVUb1Byb3BzJztcbmltcG9ydCBkZWZhdWx0TWVyZ2VQcm9wc0ZhY3RvcmllcyBmcm9tICcuL21lcmdlUHJvcHMnO1xuaW1wb3J0IGRlZmF1bHRTZWxlY3RvckZhY3RvcnkgZnJvbSAnLi9zZWxlY3RvckZhY3RvcnknO1xuXG4vKlxuICBjb25uZWN0IGlzIGEgZmFjYWRlIG92ZXIgY29ubmVjdEFkdmFuY2VkLiBJdCB0dXJucyBpdHMgYXJncyBpbnRvIGEgY29tcGF0aWJsZVxuICBzZWxlY3RvckZhY3RvcnksIHdoaWNoIGhhcyB0aGUgc2lnbmF0dXJlOlxuXG4gICAgKGRpc3BhdGNoLCBvcHRpb25zKSA9PiAobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpID0+IG5leHRGaW5hbFByb3BzXG4gIFxuICBjb25uZWN0IHBhc3NlcyBpdHMgYXJncyB0byBjb25uZWN0QWR2YW5jZWQgYXMgb3B0aW9ucywgd2hpY2ggd2lsbCBpbiB0dXJuIHBhc3MgdGhlbSB0b1xuICBzZWxlY3RvckZhY3RvcnkgZWFjaCB0aW1lIGEgQ29ubmVjdCBjb21wb25lbnQgaW5zdGFuY2UgaXMgaW5zdGFudGlhdGVkIG9yIGhvdCByZWxvYWRlZC5cblxuICBzZWxlY3RvckZhY3RvcnkgcmV0dXJucyBhIGZpbmFsIHByb3BzIHNlbGVjdG9yIGZyb20gaXRzIG1hcFN0YXRlVG9Qcm9wcyxcbiAgbWFwU3RhdGVUb1Byb3BzRmFjdG9yaWVzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcmllcywgbWVyZ2VQcm9wcyxcbiAgbWVyZ2VQcm9wc0ZhY3RvcmllcywgYW5kIHB1cmUgYXJncy5cblxuICBUaGUgcmVzdWx0aW5nIGZpbmFsIHByb3BzIHNlbGVjdG9yIGlzIGNhbGxlZCBieSB0aGUgQ29ubmVjdCBjb21wb25lbnQgaW5zdGFuY2Ugd2hlbmV2ZXJcbiAgaXQgcmVjZWl2ZXMgbmV3IHByb3BzIG9yIHN0b3JlIHN0YXRlLlxuICovXG5cbmZ1bmN0aW9uIG1hdGNoKGFyZywgZmFjdG9yaWVzLCBuYW1lKSB7XG4gIGZvciAodmFyIGkgPSBmYWN0b3JpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgcmVzdWx0ID0gZmFjdG9yaWVzW2ldKGFyZyk7XG4gICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2gsIG9wdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUgb2YgdHlwZSAnICsgdHlwZW9mIGFyZyArICcgZm9yICcgKyBuYW1lICsgJyBhcmd1bWVudCB3aGVuIGNvbm5lY3RpbmcgY29tcG9uZW50ICcgKyBvcHRpb25zLndyYXBwZWRDb21wb25lbnROYW1lICsgJy4nKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3RyaWN0RXF1YWwoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn1cblxuLy8gY3JlYXRlQ29ubmVjdCB3aXRoIGRlZmF1bHQgYXJncyBidWlsZHMgdGhlICdvZmZpY2lhbCcgY29ubmVjdCBiZWhhdmlvci4gQ2FsbGluZyBpdCB3aXRoXG4vLyBkaWZmZXJlbnQgb3B0aW9ucyBvcGVucyB1cCBzb21lIHRlc3RpbmcgYW5kIGV4dGVuc2liaWxpdHkgc2NlbmFyaW9zXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29ubmVjdCgpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgX3JlZiRjb25uZWN0SE9DID0gX3JlZi5jb25uZWN0SE9DLFxuICAgICAgY29ubmVjdEhPQyA9IF9yZWYkY29ubmVjdEhPQyA9PT0gdW5kZWZpbmVkID8gY29ubmVjdEFkdmFuY2VkIDogX3JlZiRjb25uZWN0SE9DLFxuICAgICAgX3JlZiRtYXBTdGF0ZVRvUHJvcHNGID0gX3JlZi5tYXBTdGF0ZVRvUHJvcHNGYWN0b3JpZXMsXG4gICAgICBtYXBTdGF0ZVRvUHJvcHNGYWN0b3JpZXMgPSBfcmVmJG1hcFN0YXRlVG9Qcm9wc0YgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRNYXBTdGF0ZVRvUHJvcHNGYWN0b3JpZXMgOiBfcmVmJG1hcFN0YXRlVG9Qcm9wc0YsXG4gICAgICBfcmVmJG1hcERpc3BhdGNoVG9Qcm8gPSBfcmVmLm1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcmllcyxcbiAgICAgIG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcmllcyA9IF9yZWYkbWFwRGlzcGF0Y2hUb1BybyA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdE1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcmllcyA6IF9yZWYkbWFwRGlzcGF0Y2hUb1BybyxcbiAgICAgIF9yZWYkbWVyZ2VQcm9wc0ZhY3RvciA9IF9yZWYubWVyZ2VQcm9wc0ZhY3RvcmllcyxcbiAgICAgIG1lcmdlUHJvcHNGYWN0b3JpZXMgPSBfcmVmJG1lcmdlUHJvcHNGYWN0b3IgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRNZXJnZVByb3BzRmFjdG9yaWVzIDogX3JlZiRtZXJnZVByb3BzRmFjdG9yLFxuICAgICAgX3JlZiRzZWxlY3RvckZhY3RvcnkgPSBfcmVmLnNlbGVjdG9yRmFjdG9yeSxcbiAgICAgIHNlbGVjdG9yRmFjdG9yeSA9IF9yZWYkc2VsZWN0b3JGYWN0b3J5ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0U2VsZWN0b3JGYWN0b3J5IDogX3JlZiRzZWxlY3RvckZhY3Rvcnk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMpIHtcbiAgICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9LFxuICAgICAgICBfcmVmMiRwdXJlID0gX3JlZjIucHVyZSxcbiAgICAgICAgcHVyZSA9IF9yZWYyJHB1cmUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfcmVmMiRwdXJlLFxuICAgICAgICBfcmVmMiRhcmVTdGF0ZXNFcXVhbCA9IF9yZWYyLmFyZVN0YXRlc0VxdWFsLFxuICAgICAgICBhcmVTdGF0ZXNFcXVhbCA9IF9yZWYyJGFyZVN0YXRlc0VxdWFsID09PSB1bmRlZmluZWQgPyBzdHJpY3RFcXVhbCA6IF9yZWYyJGFyZVN0YXRlc0VxdWFsLFxuICAgICAgICBfcmVmMiRhcmVPd25Qcm9wc0VxdWEgPSBfcmVmMi5hcmVPd25Qcm9wc0VxdWFsLFxuICAgICAgICBhcmVPd25Qcm9wc0VxdWFsID0gX3JlZjIkYXJlT3duUHJvcHNFcXVhID09PSB1bmRlZmluZWQgPyBzaGFsbG93RXF1YWwgOiBfcmVmMiRhcmVPd25Qcm9wc0VxdWEsXG4gICAgICAgIF9yZWYyJGFyZVN0YXRlUHJvcHNFcSA9IF9yZWYyLmFyZVN0YXRlUHJvcHNFcXVhbCxcbiAgICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsID0gX3JlZjIkYXJlU3RhdGVQcm9wc0VxID09PSB1bmRlZmluZWQgPyBzaGFsbG93RXF1YWwgOiBfcmVmMiRhcmVTdGF0ZVByb3BzRXEsXG4gICAgICAgIF9yZWYyJGFyZU1lcmdlZFByb3BzRSA9IF9yZWYyLmFyZU1lcmdlZFByb3BzRXF1YWwsXG4gICAgICAgIGFyZU1lcmdlZFByb3BzRXF1YWwgPSBfcmVmMiRhcmVNZXJnZWRQcm9wc0UgPT09IHVuZGVmaW5lZCA/IHNoYWxsb3dFcXVhbCA6IF9yZWYyJGFyZU1lcmdlZFByb3BzRSxcbiAgICAgICAgZXh0cmFPcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBbJ3B1cmUnLCAnYXJlU3RhdGVzRXF1YWwnLCAnYXJlT3duUHJvcHNFcXVhbCcsICdhcmVTdGF0ZVByb3BzRXF1YWwnLCAnYXJlTWVyZ2VkUHJvcHNFcXVhbCddKTtcblxuICAgIHZhciBpbml0TWFwU3RhdGVUb1Byb3BzID0gbWF0Y2gobWFwU3RhdGVUb1Byb3BzLCBtYXBTdGF0ZVRvUHJvcHNGYWN0b3JpZXMsICdtYXBTdGF0ZVRvUHJvcHMnKTtcbiAgICB2YXIgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyA9IG1hdGNoKG1hcERpc3BhdGNoVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJyk7XG4gICAgdmFyIGluaXRNZXJnZVByb3BzID0gbWF0Y2gobWVyZ2VQcm9wcywgbWVyZ2VQcm9wc0ZhY3RvcmllcywgJ21lcmdlUHJvcHMnKTtcblxuICAgIHJldHVybiBjb25uZWN0SE9DKHNlbGVjdG9yRmFjdG9yeSwgX2V4dGVuZHMoe1xuICAgICAgLy8gdXNlZCBpbiBlcnJvciBtZXNzYWdlc1xuICAgICAgbWV0aG9kTmFtZTogJ2Nvbm5lY3QnLFxuXG4gICAgICAvLyB1c2VkIHRvIGNvbXB1dGUgQ29ubmVjdCdzIGRpc3BsYXlOYW1lIGZyb20gdGhlIHdyYXBwZWQgY29tcG9uZW50J3MgZGlzcGxheU5hbWUuXG4gICAgICBnZXREaXNwbGF5TmFtZTogZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gJ0Nvbm5lY3QoJyArIG5hbWUgKyAnKSc7XG4gICAgICB9LFxuXG4gICAgICAvLyBpZiBtYXBTdGF0ZVRvUHJvcHMgaXMgZmFsc3ksIHRoZSBDb25uZWN0IGNvbXBvbmVudCBkb2Vzbid0IHN1YnNjcmliZSB0byBzdG9yZSBzdGF0ZSBjaGFuZ2VzXG4gICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXM6IEJvb2xlYW4obWFwU3RhdGVUb1Byb3BzKSxcblxuICAgICAgLy8gcGFzc2VkIHRocm91Z2ggdG8gc2VsZWN0b3JGYWN0b3J5XG4gICAgICBpbml0TWFwU3RhdGVUb1Byb3BzOiBpbml0TWFwU3RhdGVUb1Byb3BzLFxuICAgICAgaW5pdE1hcERpc3BhdGNoVG9Qcm9wczogaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyxcbiAgICAgIGluaXRNZXJnZVByb3BzOiBpbml0TWVyZ2VQcm9wcyxcbiAgICAgIHB1cmU6IHB1cmUsXG4gICAgICBhcmVTdGF0ZXNFcXVhbDogYXJlU3RhdGVzRXF1YWwsXG4gICAgICBhcmVPd25Qcm9wc0VxdWFsOiBhcmVPd25Qcm9wc0VxdWFsLFxuICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsOiBhcmVTdGF0ZVByb3BzRXF1YWwsXG4gICAgICBhcmVNZXJnZWRQcm9wc0VxdWFsOiBhcmVNZXJnZWRQcm9wc0VxdWFsXG5cbiAgICB9LCBleHRyYU9wdGlvbnMpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQ29ubmVjdCgpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L2Nvbm5lY3QuanMiLCJ2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gaXMoeCwgeSkge1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiB4ICE9PSAwIHx8IHkgIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKGlzKG9iakEsIG9iakIpKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duLmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL3NoYWxsb3dFcXVhbC5qcyIsImltcG9ydCB7IGJpbmRBY3Rpb25DcmVhdG9ycyB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQsIHdyYXBNYXBUb1Byb3BzRnVuYyB9IGZyb20gJy4vd3JhcE1hcFRvUHJvcHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzRnVuY3Rpb24obWFwRGlzcGF0Y2hUb1Byb3BzKSB7XG4gIHJldHVybiB0eXBlb2YgbWFwRGlzcGF0Y2hUb1Byb3BzID09PSAnZnVuY3Rpb24nID8gd3JhcE1hcFRvUHJvcHNGdW5jKG1hcERpc3BhdGNoVG9Qcm9wcywgJ21hcERpc3BhdGNoVG9Qcm9wcycpIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzTWlzc2luZyhtYXBEaXNwYXRjaFRvUHJvcHMpIHtcbiAgcmV0dXJuICFtYXBEaXNwYXRjaFRvUHJvcHMgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KGZ1bmN0aW9uIChkaXNwYXRjaCkge1xuICAgIHJldHVybiB7IGRpc3BhdGNoOiBkaXNwYXRjaCB9O1xuICB9KSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc09iamVjdChtYXBEaXNwYXRjaFRvUHJvcHMpIHtcbiAgcmV0dXJuIG1hcERpc3BhdGNoVG9Qcm9wcyAmJiB0eXBlb2YgbWFwRGlzcGF0Y2hUb1Byb3BzID09PSAnb2JqZWN0JyA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoZnVuY3Rpb24gKGRpc3BhdGNoKSB7XG4gICAgcmV0dXJuIGJpbmRBY3Rpb25DcmVhdG9ycyhtYXBEaXNwYXRjaFRvUHJvcHMsIGRpc3BhdGNoKTtcbiAgfSkgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFt3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNGdW5jdGlvbiwgd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzTWlzc2luZywgd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzT2JqZWN0XTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9tYXBEaXNwYXRjaFRvUHJvcHMuanMiLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgZ2V0UmF3VGFnIGZyb20gJy4vX2dldFJhd1RhZy5qcyc7XG5pbXBvcnQgb2JqZWN0VG9TdHJpbmcgZnJvbSAnLi9fb2JqZWN0VG9TdHJpbmcuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldFRhZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXRUYWcuanMiLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5leHBvcnQgZGVmYXVsdCByb290O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcm9vdC5qcyIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbmV4cG9ydCBkZWZhdWx0IGZyZWVHbG9iYWw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19mcmVlR2xvYmFsLmpzIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFJhd1RhZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qcyIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBvYmplY3RUb1N0cmluZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX29iamVjdFRvU3RyaW5nLmpzIiwiaW1wb3J0IG92ZXJBcmcgZnJvbSAnLi9fb3ZlckFyZy5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5leHBvcnQgZGVmYXVsdCBnZXRQcm90b3R5cGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRQcm90b3R5cGUuanMiLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3ZlckFyZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJBcmcuanMiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3RMaWtlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2luZGV4Jyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvc3ltYm9sLW9ic2VydmFibGUvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcG9ueWZpbGwgPSByZXF1aXJlKCcuL3BvbnlmaWxsJyk7XG5cbnZhciBfcG9ueWZpbGwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9ueWZpbGwpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciByb290OyAvKiBnbG9iYWwgd2luZG93ICovXG5cblxuaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gc2VsZjtcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IGdsb2JhbDtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IG1vZHVsZTtcbn0gZWxzZSB7XG4gIHJvb3QgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xufVxuXG52YXIgcmVzdWx0ID0gKDAsIF9wb255ZmlsbDJbJ2RlZmF1bHQnXSkocm9vdCk7XG5leHBvcnRzWydkZWZhdWx0J10gPSByZXN1bHQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3N5bWJvbC1vYnNlcnZhYmxlL2xpYi9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHN5bWJvbE9ic2VydmFibGVQb255ZmlsbDtcbmZ1bmN0aW9uIHN5bWJvbE9ic2VydmFibGVQb255ZmlsbChyb290KSB7XG5cdHZhciByZXN1bHQ7XG5cdHZhciBfU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cblx0aWYgKHR5cGVvZiBfU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0aWYgKF9TeW1ib2wub2JzZXJ2YWJsZSkge1xuXHRcdFx0cmVzdWx0ID0gX1N5bWJvbC5vYnNlcnZhYmxlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHQgPSBfU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG5cdFx0XHRfU3ltYm9sLm9ic2VydmFibGUgPSByZXN1bHQ7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHJlc3VsdCA9ICdAQG9ic2VydmFibGUnO1xuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3N5bWJvbC1vYnNlcnZhYmxlL2xpYi9wb255ZmlsbC5qcyIsImltcG9ydCB7IEFjdGlvblR5cGVzIH0gZnJvbSAnLi9jcmVhdGVTdG9yZSc7XG5pbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICdsb2Rhc2gtZXMvaXNQbGFpbk9iamVjdCc7XG5pbXBvcnQgd2FybmluZyBmcm9tICcuL3V0aWxzL3dhcm5pbmcnO1xuXG5mdW5jdGlvbiBnZXRVbmRlZmluZWRTdGF0ZUVycm9yTWVzc2FnZShrZXksIGFjdGlvbikge1xuICB2YXIgYWN0aW9uVHlwZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZTtcbiAgdmFyIGFjdGlvbk5hbWUgPSBhY3Rpb25UeXBlICYmICdcIicgKyBhY3Rpb25UeXBlLnRvU3RyaW5nKCkgKyAnXCInIHx8ICdhbiBhY3Rpb24nO1xuXG4gIHJldHVybiAnR2l2ZW4gYWN0aW9uICcgKyBhY3Rpb25OYW1lICsgJywgcmVkdWNlciBcIicgKyBrZXkgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkLiAnICsgJ1RvIGlnbm9yZSBhbiBhY3Rpb24sIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBwcmV2aW91cyBzdGF0ZS4gJyArICdJZiB5b3Ugd2FudCB0aGlzIHJlZHVjZXIgdG8gaG9sZCBubyB2YWx1ZSwgeW91IGNhbiByZXR1cm4gbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC4nO1xufVxuXG5mdW5jdGlvbiBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKGlucHV0U3RhdGUsIHJlZHVjZXJzLCBhY3Rpb24sIHVuZXhwZWN0ZWRLZXlDYWNoZSkge1xuICB2YXIgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIHZhciBhcmd1bWVudE5hbWUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGUgPT09IEFjdGlvblR5cGVzLklOSVQgPyAncHJlbG9hZGVkU3RhdGUgYXJndW1lbnQgcGFzc2VkIHRvIGNyZWF0ZVN0b3JlJyA6ICdwcmV2aW91cyBzdGF0ZSByZWNlaXZlZCBieSB0aGUgcmVkdWNlcic7XG5cbiAgaWYgKHJlZHVjZXJLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnU3RvcmUgZG9lcyBub3QgaGF2ZSBhIHZhbGlkIHJlZHVjZXIuIE1ha2Ugc3VyZSB0aGUgYXJndW1lbnQgcGFzc2VkICcgKyAndG8gY29tYmluZVJlZHVjZXJzIGlzIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIHJlZHVjZXJzLic7XG4gIH1cblxuICBpZiAoIWlzUGxhaW5PYmplY3QoaW5wdXRTdGF0ZSkpIHtcbiAgICByZXR1cm4gJ1RoZSAnICsgYXJndW1lbnROYW1lICsgJyBoYXMgdW5leHBlY3RlZCB0eXBlIG9mIFwiJyArIHt9LnRvU3RyaW5nLmNhbGwoaW5wdXRTdGF0ZSkubWF0Y2goL1xccyhbYS16fEEtWl0rKS8pWzFdICsgJ1wiLiBFeHBlY3RlZCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nICcgKyAoJ2tleXM6IFwiJyArIHJlZHVjZXJLZXlzLmpvaW4oJ1wiLCBcIicpICsgJ1wiJyk7XG4gIH1cblxuICB2YXIgdW5leHBlY3RlZEtleXMgPSBPYmplY3Qua2V5cyhpbnB1dFN0YXRlKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhcmVkdWNlcnMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhdW5leHBlY3RlZEtleUNhY2hlW2tleV07XG4gIH0pO1xuXG4gIHVuZXhwZWN0ZWRLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHVuZXhwZWN0ZWRLZXlDYWNoZVtrZXldID0gdHJ1ZTtcbiAgfSk7XG5cbiAgaWYgKHVuZXhwZWN0ZWRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gJ1VuZXhwZWN0ZWQgJyArICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAxID8gJ2tleXMnIDogJ2tleScpICsgJyAnICsgKCdcIicgKyB1bmV4cGVjdGVkS2V5cy5qb2luKCdcIiwgXCInKSArICdcIiBmb3VuZCBpbiAnICsgYXJndW1lbnROYW1lICsgJy4gJykgKyAnRXhwZWN0ZWQgdG8gZmluZCBvbmUgb2YgdGhlIGtub3duIHJlZHVjZXIga2V5cyBpbnN0ZWFkOiAnICsgKCdcIicgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArICdcIi4gVW5leHBlY3RlZCBrZXlzIHdpbGwgYmUgaWdub3JlZC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRSZWR1Y2VyU2hhcGUocmVkdWNlcnMpIHtcbiAgT2JqZWN0LmtleXMocmVkdWNlcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciByZWR1Y2VyID0gcmVkdWNlcnNba2V5XTtcbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gcmVkdWNlcih1bmRlZmluZWQsIHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcblxuICAgIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQgZHVyaW5nIGluaXRpYWxpemF0aW9uLiAnICsgJ0lmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlIHJlZHVjZXIgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCAnICsgJ2V4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgJyArICdub3QgYmUgdW5kZWZpbmVkLiBJZiB5b3UgZG9uXFwndCB3YW50IHRvIHNldCBhIHZhbHVlIGZvciB0aGlzIHJlZHVjZXIsICcgKyAneW91IGNhbiB1c2UgbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9ICdAQHJlZHV4L1BST0JFX1VOS05PV05fQUNUSU9OXycgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNykuc3BsaXQoJycpLmpvaW4oJy4nKTtcbiAgICBpZiAodHlwZW9mIHJlZHVjZXIodW5kZWZpbmVkLCB7IHR5cGU6IHR5cGUgfSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIHByb2JlZCB3aXRoIGEgcmFuZG9tIHR5cGUuICcgKyAoJ0RvblxcJ3QgdHJ5IHRvIGhhbmRsZSAnICsgQWN0aW9uVHlwZXMuSU5JVCArICcgb3Igb3RoZXIgYWN0aW9ucyBpbiBcInJlZHV4LypcIiAnKSArICduYW1lc3BhY2UuIFRoZXkgYXJlIGNvbnNpZGVyZWQgcHJpdmF0ZS4gSW5zdGVhZCwgeW91IG11c3QgcmV0dXJuIHRoZSAnICsgJ2N1cnJlbnQgc3RhdGUgZm9yIGFueSB1bmtub3duIGFjdGlvbnMsIHVubGVzcyBpdCBpcyB1bmRlZmluZWQsICcgKyAnaW4gd2hpY2ggY2FzZSB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUsIHJlZ2FyZGxlc3Mgb2YgdGhlICcgKyAnYWN0aW9uIHR5cGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBub3QgYmUgdW5kZWZpbmVkLCBidXQgY2FuIGJlIG51bGwuJyk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBkaWZmZXJlbnQgcmVkdWNlciBmdW5jdGlvbnMsIGludG8gYSBzaW5nbGVcbiAqIHJlZHVjZXIgZnVuY3Rpb24uIEl0IHdpbGwgY2FsbCBldmVyeSBjaGlsZCByZWR1Y2VyLCBhbmQgZ2F0aGVyIHRoZWlyIHJlc3VsdHNcbiAqIGludG8gYSBzaW5nbGUgc3RhdGUgb2JqZWN0LCB3aG9zZSBrZXlzIGNvcnJlc3BvbmQgdG8gdGhlIGtleXMgb2YgdGhlIHBhc3NlZFxuICogcmVkdWNlciBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlZHVjZXJzIEFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgY29ycmVzcG9uZCB0byBkaWZmZXJlbnRcbiAqIHJlZHVjZXIgZnVuY3Rpb25zIHRoYXQgbmVlZCB0byBiZSBjb21iaW5lZCBpbnRvIG9uZS4gT25lIGhhbmR5IHdheSB0byBvYnRhaW5cbiAqIGl0IGlzIHRvIHVzZSBFUzYgYGltcG9ydCAqIGFzIHJlZHVjZXJzYCBzeW50YXguIFRoZSByZWR1Y2VycyBtYXkgbmV2ZXIgcmV0dXJuXG4gKiB1bmRlZmluZWQgZm9yIGFueSBhY3Rpb24uIEluc3RlYWQsIHRoZXkgc2hvdWxkIHJldHVybiB0aGVpciBpbml0aWFsIHN0YXRlXG4gKiBpZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZW0gd2FzIHVuZGVmaW5lZCwgYW5kIHRoZSBjdXJyZW50IHN0YXRlIGZvciBhbnlcbiAqIHVucmVjb2duaXplZCBhY3Rpb24uXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHJlZHVjZXIgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGV2ZXJ5IHJlZHVjZXIgaW5zaWRlIHRoZVxuICogcGFzc2VkIG9iamVjdCwgYW5kIGJ1aWxkcyBhIHN0YXRlIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21iaW5lUmVkdWNlcnMocmVkdWNlcnMpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgZmluYWxSZWR1Y2VycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IHJlZHVjZXJLZXlzW2ldO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2FybmluZygnTm8gcmVkdWNlciBwcm92aWRlZCBmb3Iga2V5IFwiJyArIGtleSArICdcIicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmluYWxSZWR1Y2Vyc1trZXldID0gcmVkdWNlcnNba2V5XTtcbiAgICB9XG4gIH1cbiAgdmFyIGZpbmFsUmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhmaW5hbFJlZHVjZXJzKTtcblxuICB2YXIgdW5leHBlY3RlZEtleUNhY2hlID0gdm9pZCAwO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHVuZXhwZWN0ZWRLZXlDYWNoZSA9IHt9O1xuICB9XG5cbiAgdmFyIHNoYXBlQXNzZXJ0aW9uRXJyb3IgPSB2b2lkIDA7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UmVkdWNlclNoYXBlKGZpbmFsUmVkdWNlcnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2hhcGVBc3NlcnRpb25FcnJvciA9IGU7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gY29tYmluYXRpb24oKSB7XG4gICAgdmFyIHN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgYWN0aW9uID0gYXJndW1lbnRzWzFdO1xuXG4gICAgaWYgKHNoYXBlQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICAgIHRocm93IHNoYXBlQXNzZXJ0aW9uRXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciB3YXJuaW5nTWVzc2FnZSA9IGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2Uoc3RhdGUsIGZpbmFsUmVkdWNlcnMsIGFjdGlvbiwgdW5leHBlY3RlZEtleUNhY2hlKTtcbiAgICAgIGlmICh3YXJuaW5nTWVzc2FnZSkge1xuICAgICAgICB3YXJuaW5nKHdhcm5pbmdNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBuZXh0U3RhdGUgPSB7fTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZmluYWxSZWR1Y2VyS2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfa2V5ID0gZmluYWxSZWR1Y2VyS2V5c1tfaV07XG4gICAgICB2YXIgcmVkdWNlciA9IGZpbmFsUmVkdWNlcnNbX2tleV07XG4gICAgICB2YXIgcHJldmlvdXNTdGF0ZUZvcktleSA9IHN0YXRlW19rZXldO1xuICAgICAgdmFyIG5leHRTdGF0ZUZvcktleSA9IHJlZHVjZXIocHJldmlvdXNTdGF0ZUZvcktleSwgYWN0aW9uKTtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFN0YXRlRm9yS2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2UoX2tleSwgYWN0aW9uKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBuZXh0U3RhdGVbX2tleV0gPSBuZXh0U3RhdGVGb3JLZXk7XG4gICAgICBoYXNDaGFuZ2VkID0gaGFzQ2hhbmdlZCB8fCBuZXh0U3RhdGVGb3JLZXkgIT09IHByZXZpb3VzU3RhdGVGb3JLZXk7XG4gICAgfVxuICAgIHJldHVybiBoYXNDaGFuZ2VkID8gbmV4dFN0YXRlIDogc3RhdGU7XG4gIH07XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2NvbWJpbmVSZWR1Y2Vycy5qcyIsImZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKGFjdGlvbkNyZWF0b3IuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb24gY3JlYXRvcnMsIGludG8gYW4gb2JqZWN0IHdpdGggdGhlXG4gKiBzYW1lIGtleXMsIGJ1dCB3aXRoIGV2ZXJ5IGZ1bmN0aW9uIHdyYXBwZWQgaW50byBhIGBkaXNwYXRjaGAgY2FsbCBzbyB0aGV5XG4gKiBtYXkgYmUgaW52b2tlZCBkaXJlY3RseS4gVGhpcyBpcyBqdXN0IGEgY29udmVuaWVuY2UgbWV0aG9kLCBhcyB5b3UgY2FuIGNhbGxcbiAqIGBzdG9yZS5kaXNwYXRjaChNeUFjdGlvbkNyZWF0b3JzLmRvU29tZXRoaW5nKCkpYCB5b3Vyc2VsZiBqdXN0IGZpbmUuXG4gKlxuICogRm9yIGNvbnZlbmllbmNlLCB5b3UgY2FuIGFsc28gcGFzcyBhIHNpbmdsZSBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQsXG4gKiBhbmQgZ2V0IGEgZnVuY3Rpb24gaW4gcmV0dXJuLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBhY3Rpb25DcmVhdG9ycyBBbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb25cbiAqIGNyZWF0b3IgZnVuY3Rpb25zLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpbiBpdCBpcyB0byB1c2UgRVM2IGBpbXBvcnQgKiBhc2BcbiAqIHN5bnRheC4gWW91IG1heSBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzcGF0Y2ggVGhlIGBkaXNwYXRjaGAgZnVuY3Rpb24gYXZhaWxhYmxlIG9uIHlvdXIgUmVkdXhcbiAqIHN0b3JlLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFRoZSBvYmplY3QgbWltaWNraW5nIHRoZSBvcmlnaW5hbCBvYmplY3QsIGJ1dCB3aXRoXG4gKiBldmVyeSBhY3Rpb24gY3JlYXRvciB3cmFwcGVkIGludG8gdGhlIGBkaXNwYXRjaGAgY2FsbC4gSWYgeW91IHBhc3NlZCBhXG4gKiBmdW5jdGlvbiBhcyBgYWN0aW9uQ3JlYXRvcnNgLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYWxzbyBiZSBhIHNpbmdsZVxuICogZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyAhPT0gJ29iamVjdCcgfHwgYWN0aW9uQ3JlYXRvcnMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBY3Rpb25DcmVhdG9ycyBleHBlY3RlZCBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiwgaW5zdGVhZCByZWNlaXZlZCAnICsgKGFjdGlvbkNyZWF0b3JzID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIGFjdGlvbkNyZWF0b3JzKSArICcuICcgKyAnRGlkIHlvdSB3cml0ZSBcImltcG9ydCBBY3Rpb25DcmVhdG9ycyBmcm9tXCIgaW5zdGVhZCBvZiBcImltcG9ydCAqIGFzIEFjdGlvbkNyZWF0b3JzIGZyb21cIj8nKTtcbiAgfVxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWN0aW9uQ3JlYXRvcnMpO1xuICB2YXIgYm91bmRBY3Rpb25DcmVhdG9ycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICB2YXIgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG4gICAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBib3VuZEFjdGlvbkNyZWF0b3JzW2tleV0gPSBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWR1eC9lcy9iaW5kQWN0aW9uQ3JlYXRvcnMuanMiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5pbXBvcnQgY29tcG9zZSBmcm9tICcuL2NvbXBvc2UnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdG9yZSBlbmhhbmNlciB0aGF0IGFwcGxpZXMgbWlkZGxld2FyZSB0byB0aGUgZGlzcGF0Y2ggbWV0aG9kXG4gKiBvZiB0aGUgUmVkdXggc3RvcmUuIFRoaXMgaXMgaGFuZHkgZm9yIGEgdmFyaWV0eSBvZiB0YXNrcywgc3VjaCBhcyBleHByZXNzaW5nXG4gKiBhc3luY2hyb25vdXMgYWN0aW9ucyBpbiBhIGNvbmNpc2UgbWFubmVyLCBvciBsb2dnaW5nIGV2ZXJ5IGFjdGlvbiBwYXlsb2FkLlxuICpcbiAqIFNlZSBgcmVkdXgtdGh1bmtgIHBhY2thZ2UgYXMgYW4gZXhhbXBsZSBvZiB0aGUgUmVkdXggbWlkZGxld2FyZS5cbiAqXG4gKiBCZWNhdXNlIG1pZGRsZXdhcmUgaXMgcG90ZW50aWFsbHkgYXN5bmNocm9ub3VzLCB0aGlzIHNob3VsZCBiZSB0aGUgZmlyc3RcbiAqIHN0b3JlIGVuaGFuY2VyIGluIHRoZSBjb21wb3NpdGlvbiBjaGFpbi5cbiAqXG4gKiBOb3RlIHRoYXQgZWFjaCBtaWRkbGV3YXJlIHdpbGwgYmUgZ2l2ZW4gdGhlIGBkaXNwYXRjaGAgYW5kIGBnZXRTdGF0ZWAgZnVuY3Rpb25zXG4gKiBhcyBuYW1lZCBhcmd1bWVudHMuXG4gKlxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gbWlkZGxld2FyZXMgVGhlIG1pZGRsZXdhcmUgY2hhaW4gdG8gYmUgYXBwbGllZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBzdG9yZSBlbmhhbmNlciBhcHBseWluZyB0aGUgbWlkZGxld2FyZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWlkZGxld2FyZXMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBtaWRkbGV3YXJlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoY3JlYXRlU3RvcmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcikge1xuICAgICAgdmFyIHN0b3JlID0gY3JlYXRlU3RvcmUocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGVuaGFuY2VyKTtcbiAgICAgIHZhciBfZGlzcGF0Y2ggPSBzdG9yZS5kaXNwYXRjaDtcbiAgICAgIHZhciBjaGFpbiA9IFtdO1xuXG4gICAgICB2YXIgbWlkZGxld2FyZUFQSSA9IHtcbiAgICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgICBkaXNwYXRjaDogZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIF9kaXNwYXRjaChhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2hhaW4gPSBtaWRkbGV3YXJlcy5tYXAoZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmUobWlkZGxld2FyZUFQSSk7XG4gICAgICB9KTtcbiAgICAgIF9kaXNwYXRjaCA9IGNvbXBvc2UuYXBwbHkodW5kZWZpbmVkLCBjaGFpbikoc3RvcmUuZGlzcGF0Y2gpO1xuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0b3JlLCB7XG4gICAgICAgIGRpc3BhdGNoOiBfZGlzcGF0Y2hcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2FwcGx5TWlkZGxld2FyZS5qcyIsImltcG9ydCB7IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQsIHdyYXBNYXBUb1Byb3BzRnVuYyB9IGZyb20gJy4vd3JhcE1hcFRvUHJvcHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gd2hlbk1hcFN0YXRlVG9Qcm9wc0lzRnVuY3Rpb24obWFwU3RhdGVUb1Byb3BzKSB7XG4gIHJldHVybiB0eXBlb2YgbWFwU3RhdGVUb1Byb3BzID09PSAnZnVuY3Rpb24nID8gd3JhcE1hcFRvUHJvcHNGdW5jKG1hcFN0YXRlVG9Qcm9wcywgJ21hcFN0YXRlVG9Qcm9wcycpIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2hlbk1hcFN0YXRlVG9Qcm9wc0lzTWlzc2luZyhtYXBTdGF0ZVRvUHJvcHMpIHtcbiAgcmV0dXJuICFtYXBTdGF0ZVRvUHJvcHMgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge307XG4gIH0pIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBbd2hlbk1hcFN0YXRlVG9Qcm9wc0lzRnVuY3Rpb24sIHdoZW5NYXBTdGF0ZVRvUHJvcHNJc01pc3NpbmddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L21hcFN0YXRlVG9Qcm9wcy5qcyIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCB2ZXJpZnlQbGFpbk9iamVjdCBmcm9tICcuLi91dGlscy92ZXJpZnlQbGFpbk9iamVjdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0TWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIG93blByb3BzLCBzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBNZXJnZVByb3BzRnVuYyhtZXJnZVByb3BzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0TWVyZ2VQcm9wc1Byb3h5KGRpc3BhdGNoLCBfcmVmKSB7XG4gICAgdmFyIGRpc3BsYXlOYW1lID0gX3JlZi5kaXNwbGF5TmFtZSxcbiAgICAgICAgcHVyZSA9IF9yZWYucHVyZSxcbiAgICAgICAgYXJlTWVyZ2VkUHJvcHNFcXVhbCA9IF9yZWYuYXJlTWVyZ2VkUHJvcHNFcXVhbDtcblxuICAgIHZhciBoYXNSdW5PbmNlID0gZmFsc2U7XG4gICAgdmFyIG1lcmdlZFByb3BzID0gdm9pZCAwO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlUHJvcHNQcm94eShzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcykge1xuICAgICAgdmFyIG5leHRNZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuXG4gICAgICBpZiAoaGFzUnVuT25jZSkge1xuICAgICAgICBpZiAoIXB1cmUgfHwgIWFyZU1lcmdlZFByb3BzRXF1YWwobmV4dE1lcmdlZFByb3BzLCBtZXJnZWRQcm9wcykpIG1lcmdlZFByb3BzID0gbmV4dE1lcmdlZFByb3BzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFzUnVuT25jZSA9IHRydWU7XG4gICAgICAgIG1lcmdlZFByb3BzID0gbmV4dE1lcmdlZFByb3BzO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB2ZXJpZnlQbGFpbk9iamVjdChtZXJnZWRQcm9wcywgZGlzcGxheU5hbWUsICdtZXJnZVByb3BzJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgICB9O1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2hlbk1lcmdlUHJvcHNJc0Z1bmN0aW9uKG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBtZXJnZVByb3BzID09PSAnZnVuY3Rpb24nID8gd3JhcE1lcmdlUHJvcHNGdW5jKG1lcmdlUHJvcHMpIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2hlbk1lcmdlUHJvcHNJc09taXR0ZWQobWVyZ2VQcm9wcykge1xuICByZXR1cm4gIW1lcmdlUHJvcHMgPyBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNZXJnZVByb3BzO1xuICB9IDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBbd2hlbk1lcmdlUHJvcHNJc0Z1bmN0aW9uLCB3aGVuTWVyZ2VQcm9wc0lzT21pdHRlZF07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvbWVyZ2VQcm9wcy5qcyIsImZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuaW1wb3J0IHZlcmlmeVN1YnNlbGVjdG9ycyBmcm9tICcuL3ZlcmlmeVN1YnNlbGVjdG9ycyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbXB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBkaXNwYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24gaW1wdXJlRmluYWxQcm9wc1NlbGVjdG9yKHN0YXRlLCBvd25Qcm9wcykge1xuICAgIHJldHVybiBtZXJnZVByb3BzKG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpLCBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKSwgb3duUHJvcHMpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCBfcmVmKSB7XG4gIHZhciBhcmVTdGF0ZXNFcXVhbCA9IF9yZWYuYXJlU3RhdGVzRXF1YWwsXG4gICAgICBhcmVPd25Qcm9wc0VxdWFsID0gX3JlZi5hcmVPd25Qcm9wc0VxdWFsLFxuICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsID0gX3JlZi5hcmVTdGF0ZVByb3BzRXF1YWw7XG5cbiAgdmFyIGhhc1J1bkF0TGVhc3RPbmNlID0gZmFsc2U7XG4gIHZhciBzdGF0ZSA9IHZvaWQgMDtcbiAgdmFyIG93blByb3BzID0gdm9pZCAwO1xuICB2YXIgc3RhdGVQcm9wcyA9IHZvaWQgMDtcbiAgdmFyIGRpc3BhdGNoUHJvcHMgPSB2b2lkIDA7XG4gIHZhciBtZXJnZWRQcm9wcyA9IHZvaWQgMDtcblxuICBmdW5jdGlvbiBoYW5kbGVGaXJzdENhbGwoZmlyc3RTdGF0ZSwgZmlyc3RPd25Qcm9wcykge1xuICAgIHN0YXRlID0gZmlyc3RTdGF0ZTtcbiAgICBvd25Qcm9wcyA9IGZpcnN0T3duUHJvcHM7XG4gICAgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIGhhc1J1bkF0TGVhc3RPbmNlID0gdHJ1ZTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCkge1xuICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcblxuICAgIGlmIChtYXBEaXNwYXRjaFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcblxuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTmV3UHJvcHMoKSB7XG4gICAgaWYgKG1hcFN0YXRlVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuXG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuXG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVOZXdTdGF0ZSgpIHtcbiAgICB2YXIgbmV4dFN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICB2YXIgc3RhdGVQcm9wc0NoYW5nZWQgPSAhYXJlU3RhdGVQcm9wc0VxdWFsKG5leHRTdGF0ZVByb3BzLCBzdGF0ZVByb3BzKTtcbiAgICBzdGF0ZVByb3BzID0gbmV4dFN0YXRlUHJvcHM7XG5cbiAgICBpZiAoc3RhdGVQcm9wc0NoYW5nZWQpIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG5cbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIHtcbiAgICB2YXIgcHJvcHNDaGFuZ2VkID0gIWFyZU93blByb3BzRXF1YWwobmV4dE93blByb3BzLCBvd25Qcm9wcyk7XG4gICAgdmFyIHN0YXRlQ2hhbmdlZCA9ICFhcmVTdGF0ZXNFcXVhbChuZXh0U3RhdGUsIHN0YXRlKTtcbiAgICBzdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICBvd25Qcm9wcyA9IG5leHRPd25Qcm9wcztcblxuICAgIGlmIChwcm9wc0NoYW5nZWQgJiYgc3RhdGVDaGFuZ2VkKSByZXR1cm4gaGFuZGxlTmV3UHJvcHNBbmROZXdTdGF0ZSgpO1xuICAgIGlmIChwcm9wc0NoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdQcm9wcygpO1xuICAgIGlmIChzdGF0ZUNoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdTdGF0ZSgpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSB7XG4gICAgcmV0dXJuIGhhc1J1bkF0TGVhc3RPbmNlID8gaGFuZGxlU3Vic2VxdWVudENhbGxzKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSA6IGhhbmRsZUZpcnN0Q2FsbChuZXh0U3RhdGUsIG5leHRPd25Qcm9wcyk7XG4gIH07XG59XG5cbi8vIFRPRE86IEFkZCBtb3JlIGNvbW1lbnRzXG5cbi8vIElmIHB1cmUgaXMgdHJ1ZSwgdGhlIHNlbGVjdG9yIHJldHVybmVkIGJ5IHNlbGVjdG9yRmFjdG9yeSB3aWxsIG1lbW9pemUgaXRzIHJlc3VsdHMsXG4vLyBhbGxvd2luZyBjb25uZWN0QWR2YW5jZWQncyBzaG91bGRDb21wb25lbnRVcGRhdGUgdG8gcmV0dXJuIGZhbHNlIGlmIGZpbmFsXG4vLyBwcm9wcyBoYXZlIG5vdCBjaGFuZ2VkLiBJZiBmYWxzZSwgdGhlIHNlbGVjdG9yIHdpbGwgYWx3YXlzIHJldHVybiBhIG5ld1xuLy8gb2JqZWN0IGFuZCBzaG91bGRDb21wb25lbnRVcGRhdGUgd2lsbCBhbHdheXMgcmV0dXJuIHRydWUuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkoZGlzcGF0Y2gsIF9yZWYyKSB7XG4gIHZhciBpbml0TWFwU3RhdGVUb1Byb3BzID0gX3JlZjIuaW5pdE1hcFN0YXRlVG9Qcm9wcyxcbiAgICAgIGluaXRNYXBEaXNwYXRjaFRvUHJvcHMgPSBfcmVmMi5pbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxuICAgICAgaW5pdE1lcmdlUHJvcHMgPSBfcmVmMi5pbml0TWVyZ2VQcm9wcyxcbiAgICAgIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsnaW5pdE1hcFN0YXRlVG9Qcm9wcycsICdpbml0TWFwRGlzcGF0Y2hUb1Byb3BzJywgJ2luaXRNZXJnZVByb3BzJ10pO1xuXG4gIHZhciBtYXBTdGF0ZVRvUHJvcHMgPSBpbml0TWFwU3RhdGVUb1Byb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcbiAgdmFyIG1hcERpc3BhdGNoVG9Qcm9wcyA9IGluaXRNYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICB2YXIgbWVyZ2VQcm9wcyA9IGluaXRNZXJnZVByb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZlcmlmeVN1YnNlbGVjdG9ycyhtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgb3B0aW9ucy5kaXNwbGF5TmFtZSk7XG4gIH1cblxuICB2YXIgc2VsZWN0b3JGYWN0b3J5ID0gb3B0aW9ucy5wdXJlID8gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkgOiBpbXB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5O1xuXG4gIHJldHVybiBzZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCBvcHRpb25zKTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9zZWxlY3RvckZhY3RvcnkuanMiLCJpbXBvcnQgd2FybmluZyBmcm9tICcuLi91dGlscy93YXJuaW5nJztcblxuZnVuY3Rpb24gdmVyaWZ5KHNlbGVjdG9yLCBtZXRob2ROYW1lLCBkaXNwbGF5TmFtZSkge1xuICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHZhbHVlIGZvciAnICsgbWV0aG9kTmFtZSArICcgaW4gJyArIGRpc3BsYXlOYW1lICsgJy4nKTtcbiAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAnbWFwU3RhdGVUb1Byb3BzJyB8fCBtZXRob2ROYW1lID09PSAnbWFwRGlzcGF0Y2hUb1Byb3BzJykge1xuICAgIGlmICghc2VsZWN0b3IuaGFzT3duUHJvcGVydHkoJ2RlcGVuZHNPbk93blByb3BzJykpIHtcbiAgICAgIHdhcm5pbmcoJ1RoZSBzZWxlY3RvciBmb3IgJyArIG1ldGhvZE5hbWUgKyAnIG9mICcgKyBkaXNwbGF5TmFtZSArICcgZGlkIG5vdCBzcGVjaWZ5IGEgdmFsdWUgZm9yIGRlcGVuZHNPbk93blByb3BzLicpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2ZXJpZnlTdWJzZWxlY3RvcnMobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZlcmlmeShtYXBTdGF0ZVRvUHJvcHMsICdtYXBTdGF0ZVRvUHJvcHMnLCBkaXNwbGF5TmFtZSk7XG4gIHZlcmlmeShtYXBEaXNwYXRjaFRvUHJvcHMsICdtYXBEaXNwYXRjaFRvUHJvcHMnLCBkaXNwbGF5TmFtZSk7XG4gIHZlcmlmeShtZXJnZVByb3BzLCAnbWVyZ2VQcm9wcycsIGRpc3BsYXlOYW1lKTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC92ZXJpZnlTdWJzZWxlY3RvcnMuanMiLCJpbXBvcnQgeyBjcmVhdGVTdG9yZSwgYXBwbHlNaWRkbGV3YXJlIH0gZnJvbSAncmVkdXgnXG5pbXBvcnQgdGh1bmsgZnJvbSAncmVkdXgtdGh1bmsnXG5pbXBvcnQgcm9vdFJlZHVjZXIgZnJvbSAnLi4vcmVkdWNlcnMnXG5cbmNvbnN0IGNvbmZpZ3VyZVN0b3JlID0gKHByZWxvYWRlZFN0YXRlKSA9PiB7XG4gIGNvbnN0IHN0b3JlID0gY3JlYXRlU3RvcmUoXG4gICAgcm9vdFJlZHVjZXIsXG4gICAgcHJlbG9hZGVkU3RhdGUsXG4gICAgYXBwbHlNaWRkbGV3YXJlKHRodW5rKVxuICApXG5cbiAgaWYgKG1vZHVsZS5ob3QpIHtcbiAgICAvLyBFbmFibGUgV2VicGFjayBob3QgbW9kdWxlIHJlcGxhY2VtZW50IGZvciByZWR1Y2Vyc1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KCcuLi9yZWR1Y2VycycsICgpID0+IHtcbiAgICAgIGNvbnN0IG5leHRSb290UmVkdWNlciA9IHJlcXVpcmUoJy4uL3JlZHVjZXJzJykuZGVmYXVsdFxuICAgICAgc3RvcmUucmVwbGFjZVJlZHVjZXIobmV4dFJvb3RSZWR1Y2VyKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gc3RvcmVcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29uZmlndXJlU3RvcmVcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbW1vbi9zdG9yZS9jb25maWd1cmVTdG9yZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmZ1bmN0aW9uIGNyZWF0ZVRodW5rTWlkZGxld2FyZShleHRyYUFyZ3VtZW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBkaXNwYXRjaCA9IF9yZWYuZGlzcGF0Y2gsXG4gICAgICAgIGdldFN0YXRlID0gX3JlZi5nZXRTdGF0ZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGFjdGlvbihkaXNwYXRjaCwgZ2V0U3RhdGUsIGV4dHJhQXJndW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbn1cblxudmFyIHRodW5rID0gY3JlYXRlVGh1bmtNaWRkbGV3YXJlKCk7XG50aHVuay53aXRoRXh0cmFBcmd1bWVudCA9IGNyZWF0ZVRodW5rTWlkZGxld2FyZTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gdGh1bms7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlZHV4LXRodW5rL2xpYi9pbmRleC5qcyIsImltcG9ydCB7IFNFVF9DT1VOVEVSLCBJTkNSRU1FTlRfQ09VTlRFUiwgREVDUkVNRU5UX0NPVU5URVIgfSBmcm9tICcuLi9hY3Rpb25zJ1xuXG5jb25zdCBjb3VudGVyID0gKHN0YXRlID0gMCwgYWN0aW9uKSA9PiB7XG4gIHN3aXRjaChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgU0VUX0NPVU5URVI6XG4gICAgICByZXR1cm4gYWN0aW9uLnBsYXlsb2FkXG4gICAgY2FzZSBJTkNSRU1FTlRfQ09VTlRFUjpcbiAgICAgIHJldHVybiBzdGF0ZSArIDFcbiAgICBjYXNlIERFQ1JFTUVOVF9DT1VOVEVSOlxuICAgICAgcmV0dXJuIHN0YXRlIC0gMVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGVcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjb3VudGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21tb24vcmVkdWNlcnMvY291bnRlci5qcyIsImltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCdcbmltcG9ydCBDb3VudGVyIGZyb20gJy4uL2NvbXBvbmVudHMvY291bnRlcidcbmltcG9ydCAqIGFzIENvdW50ZXJBY3Rpb25zIGZyb20gJy4uL2FjdGlvbnMnXG5pbXBvcnQgeyBiaW5kQWN0aW9uQ3JlYXRvcnMgfSBmcm9tICdyZWR1eCdcblxuY29uc3QgbWFwU3RhdGVUb1Byb3BzID0gKHN0YXRlKSA9PiAoe1xuICBjb3VudGVyOiBzdGF0ZS5jb3VudGVyXG59KVxuXG5jb25zdCBtYXBEaXNwYXRjaFRvUHJvcHMgPSAoZGlzcGF0Y2gpID0+IHtcbiAgcmV0dXJuIGJpbmRBY3Rpb25DcmVhdG9ycyhDb3VudGVyQWN0aW9ucywgZGlzcGF0Y2gpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMpKENvdW50ZXIpXG5cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tbW9uL2NvbnRhaW5lcnMvQXBwLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJ1xuXG5jb25zdCBDb3VudGVyID0gKHtpbmNyZW1lbnQsIGRlY3JlbWVudCwgaW5jcmVtZW50SWZPZGQsIGluY3JlbWVudEFzeW5jLCBjb3VudGVyfSkgPT4gKFxuICA8cD5cbiAgICBDbGlja2VkOiB7IGNvdW50ZXIgfSB0aW1lc1xuICAgIHsnICd9XG4gICAgPGJ1dHRvbiBvbkNsaWNrPXtpbmNyZW1lbnR9Pis8L2J1dHRvbj5cbiAgICB7JyAnfVxuICAgIDxidXR0b24gb25DbGljaz17ZGVjcmVtZW50fT4tPC9idXR0b24+XG4gICAgeycgJ31cbiAgICA8YnV0dG9uIG9uQ2xpY2s9e2luY3JlbWVudElmT2RkfT5JbmNyZW1lbnQgSWYgT2RkPC9idXR0b24+XG4gICAgeycgJ31cbiAgICA8YnV0dG9uIG9uQ2xpY2s9e2luY3JlbWVudEFzeW5jfT5JbmNyZW1lbnQgYXN5bmM8L2J1dHRvbj5cbiAgPC9wPlxuKVxuXG5Db3VudGVyLnByb3BUeXBlcyA9IHtcbiAgaW5jcmVtZW50OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBkZWNyZW1lbnQ6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIGluY3JlbWVudElmT2RkOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBpbmNyZW1lbnRBc3luYzogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgY291bnRlcjogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG59XG5cbmV4cG9ydCBkZWZhdWx0IENvdW50ZXJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbW1vbi9jb21wb25lbnRzL2NvdW50ZXIuanMiXSwic291cmNlUm9vdCI6IiJ9